import {
  bG,
  bM,
  bT,
  bh,
  bl,
  bq,
  bu
} from "./chunk-QOBHKNUZ.js";
import "./chunk-5WRI5ZAA.js";

// node_modules/@geenee/bodyrenderers-common/dist/bodyrenderers-common.js
var n = class extends bG {
  constructor(Xc, XG, W0 = 1) {
    super(Xc, XG, ["image"], {}, g("max", W0), void 0, true, true);
  }
};
var s = class extends bG {
  constructor(Xc, XG, W0 = 1) {
    super(Xc, XG, ["image"], {}, g("min", W0), void 0, true, true);
  }
};
var g = (Xc, XG = 1) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform sampler2D image;\nfloat readImage(vec2 dxy) {\n    vec2 xy1 = xy + dxy / wh;\n    return min(xy1.x, xy1.y) < 0.0 ||\n           max(xy1.x, xy1.y) >= 1.0 ?\n           0.0 : texture2D(image, xy1).r;\n}\nvoid main() {\n    float res = texture2D(image, xy).r;\n    for (int y = -" + XG + "; y <= " + XG + "; y++)\n        for (int x = -" + XG + "; x <= " + XG + "; x++)\n            res = " + Xc + "(res, readImage(vec2(x, y)));\n    gl_FragColor = vec4(res, res, res, 1.0);\n}";
var h = Object["defineProperty"];
var q0 = Object["getOwnPropertySymbols"];
var q1 = Object["prototype"]["hasOwnProperty"];
var q2 = Object["prototype"]["propertyIsEnumerable"];
var q3 = (Xc, XG, W0) => XG in Xc ? h(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var q4 = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) q1["call"](XG, W0) && q3(Xc, W0, XG[W0]);
  if (q0) {
    for (var W0 of q0(XG)) q2["call"](XG, W0) && q3(Xc, W0, XG[W0]);
  }
  return Xc;
};
var q5 = class extends bT {
  constructor(Xc = { "width": 256, "height": 256 }) {
    super(), this["size"] = Xc, this["ordinal"] = bu["PreProcess"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["maskTexture"] = new bh(XG, this["size"], true, true), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["maskTexture"]) == null || Xc["dispose"](), delete this["maskTexture"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const { maskTexture: W0 } = this;
    if (!this["loaded"] || !W0) return;
    const W1 = q7(Xc);
    if (!W1 || !W1["mask"]) return;
    this["size"] = q4({}, W1["mask"]["size"]), W0["resize"](W1["mask"]["size"]), W0["update"](W1["mask"]["buffer"]);
    const W2 = W0["texture"]();
    W2 && (W1["maskTex"] = { "texture": W2, "size": W1["mask"]["size"], "box": W1["mask"]["box"] });
  }
};
function q6(Xc) {
  return [Xc[0][0], Xc[0][1], Xc[1][0] - Xc[0][0], Xc[1][1] - Xc[0][1]];
}
function q7(Xc) {
  return "poses" in Xc && Xc["poses"][0] || "faces" in Xc && Xc["faces"][0] || "masks" in Xc && Xc["masks"][0] || void 0;
}
function q8(Xc) {
  var XG;
  return (XG = q7(Xc)) == null ? void 0 : XG["mask"];
}
function q9(Xc) {
  var XG;
  return (XG = q7(Xc)) == null ? void 0 : XG["maskTex"];
}
var qq = Object["defineProperty"];
var qX = Object["getOwnPropertySymbols"];
var qW = Object["prototype"]["hasOwnProperty"];
var qt = Object["prototype"]["propertyIsEnumerable"];
var qF = (Xc, XG, W0) => XG in Xc ? qq(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var qy = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) qW["call"](XG, W0) && qF(Xc, W0, XG[W0]);
  if (qX) {
    for (var W0 of qX(XG)) qt["call"](XG, W0) && qF(Xc, W0, XG[W0]);
  }
  return Xc;
};
var qi = class {
  constructor() {
    this["upscalers"] = [], this["upscaleSize"] = { "width": 1024, "height": 1024 };
  }
  ["load"](Xc, XG, W0 = 0.55, W1 = 2) {
    const W2 = qy({}, XG);
    for (let W3 = 0; W3 < W1; W3++) {
      W2["width"] *= 2, W2["height"] *= 2;
      const W4 = new bG(Xc, W2, ["image", "mask"], { "rect": "4f" }, qQ(W0), void 0, true, true), W5 = new bG(Xc, W2, ["mask"], {}, qv(W0), void 0, true, true);
      this["upscalers"]["push"]({ "edge": W4, "fill": W5 });
    }
    this["upscaleSize"] = W2;
  }
  ["unload"]() {
    this["upscalers"]["forEach"]((Xc) => {
      Xc["edge"]["dispose"](), Xc["fill"]["dispose"]();
    }), this["upscalers"] = [];
  }
  ["upscale"](Xc, XG) {
    const { upscalers: W0 } = this;
    if (W0["length"] < 1) return false;
    const W1 = q6(Xc["box"]);
    let W2 = Xc["texture"];
    for (let W3 = 0; W3 < W0["length"]; W3++) {
      const W4 = W0[W3];
      W4["edge"]["process"]([XG, W2], { "rect": W1 }), W4["fill"]["process"]([W4["edge"]["output"]()]), W2 = W4["fill"]["output"]();
    }
    return true;
  }
  ["mask"]() {
    var Xc;
    return ((Xc = this["upscalers"][this["upscalers"]["length"] - 1]) == null ? void 0 : Xc["fill"]["output"]()) || null;
  }
  ["size"]() {
    return this["upscaleSize"];
  }
  ["resize"](Xc) {
    const { upscalers: XG } = this, W0 = qy({}, Xc);
    for (let W1 = 0; W1 < XG["length"]; W1++) W0["width"] *= 2, W0["height"] *= 2, XG[W1]["edge"]["resize"](W0), XG[W1]["fill"]["resize"](W0);
    this["upscaleSize"] = W0;
  }
};
var qQ = (Xc = 0.55) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform vec4 rect;\nuniform sampler2D image;\nuniform sampler2D mask;\n\nvec4 avgColor(vec2 xyMask, vec2 whPix) {\n    vec2 xy = xyMask * rect.zw + rect.xy;\n    vec2 dxy = whPix * rect.zw / 3.0;\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            color += texture2D(image, xy + vec2(i, j) * dxy);\n    return color / 9.0;\n}\n\nfloat minDiff(vec2 xyI, vec4 color) {\n    // vec4 c = avgColor(xyI / wh, 1.0 / wh);\n    // vec3 diff = color.rgb - c.rgb;\n    // float ra = 0.5 * (color.r + c.r);\n    // diff = diff * diff;\n    // return (2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b;\n    vec2 xyMask = xyI / wh;\n    vec2 whPix = 1.0 / (2.0 * wh);\n    float dist = 100.0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            vec4 c = avgColor(xyMask + vec2(i, j) * whPix, whPix);\n            vec3 diff = color.rgb - c.rgb;\n            float ra = 0.5 * (color.r + c.r);\n            diff = diff * diff;\n            dist = min((2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b, dist);\n        }\n    }\n    return dist;\n}\n\nfloat minDist(vec2 xyI, vec2 dxy, vec4 color) {\n    vec2 dxyI = 0.25 * dxy;\n    float dist = 100.0;\n    for (int i = 0; i < 8; i++) {\n        vec4 c = texture2D(image, (xyI + float(i) * dxyI) / wh * rect.zw + rect.xy);\n        vec3 diff = color.rgb - c.rgb;\n        float ra = 0.5 * (color.r + c.r);\n        diff = diff * diff;\n        dist = min((2.0 + ra) * diff.r + 4.0 * diff.g + (3.0 - ra) * diff.b, dist);\n    }\n    return dist;\n}\n\nvoid main() {\n    vec2 xyI = floor(xy * wh);\n    float val[9];\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            val[j * 3 + i] = texture2D(mask,\n                (xyI + vec2(i, j) - 1.0) / wh).r;\n    bool fg[9];\n    int fgCount = 0;\n    for (int i = 0; i < 9; i++) {\n        fg[i] = val[i] >= " + Xc + ";\n        fgCount += int(fg[i]);\n    }\n    if (fgCount <= 0) {\n        float valMin = min(val[0], min(\n            min(min(val[1], val[2]), min(val[3], val[4])),\n            min(min(val[5], val[6]), min(val[7], val[8]))));\n        gl_FragColor = vec4(valMin, 0, 0, 1);\n        return;\n    }\n    if (fgCount >= 9) {\n        float valMax = max(val[0], max(\n            max(max(val[1], val[2]), max(val[3], val[4])),\n            max(max(val[5], val[6]), max(val[7], val[8]))));\n        gl_FragColor = vec4(valMax, 0, 0, 1);\n        return;\n    }\n    vec2 dxy = normalize(vec2(\n        val[2] + 2.0 * val[5] + val[8] - val[0] - 2.0 * val[3] - val[6],\n        val[6] + 2.0 * val[7] + val[8] - val[0] - 2.0 * val[1] - val[2]));\n    vec4 color = avgColor(xyI / wh, 1.0 / wh);\n    vec2 xyFg = xyI + (fg[4] ? 2.0 : 3.0) * dxy;\n    vec2 xyBg = xyI - (fg[4] ? 3.0 : 2.0) * dxy;\n    vec2 diffFgBg = sqrt(vec2(\n        minDist(xyFg,  dxy, color),\n        minDist(xyBg, -dxy, color)));\n    diffFgBg /= diffFgBg.x + diffFgBg.y;\n    vec2 valBgFg = vec2(texture2D(mask, xyBg / wh).r,\n                        texture2D(mask, xyFg / wh).r);\n    float valInter = dot(valBgFg, diffFgBg);\n    gl_FragColor = vec4(valInter, 1, 0, 1);\n}";
var qv = (Xc = 0.55) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform sampler2D mask;\n\nvoid main() {\n    vec2 xyI = floor(xy * wh);\n    vec4 val0 = texture2D(mask, xyI / wh);\n    if (val0.r >= " + Xc + ") {\n        gl_FragColor = val0;\n        return;\n    }\n    float val[9];\n    for (int i = 0; i < 3; i++)\n        for (int j = 0; j < 3; j++)\n            val[j * 3 + i] = texture2D(mask,\n                (xyI + vec2(i, j) - 1.0) / wh).r;\n    bool fg[9];\n    int fgCount = 0;\n    for (int i = 0; i < 9; i++) {\n        fg[i] = val[i] >= " + Xc + ";\n        fgCount += int(fg[i]);\n    }\n    float valMax = max(val[0], max(\n        max(max(val[1], val[2]), max(val[3], val[4])),\n        max(max(val[5], val[6]), max(val[7], val[8]))));\n    if (fg[0] && fg[8] || fg[1] && fg[7] ||\n        fg[2] && fg[6] || fg[3] && fg[5] || fgCount >= 4) {\n        gl_FragColor = vec4(valMax, 1, 0, 1);\n        return;\n    }\n    gl_FragColor = val0;\n}";
var qT = Object["defineProperty"];
var qJ = Object["getOwnPropertySymbols"];
var qz = Object["prototype"]["hasOwnProperty"];
var qA = Object["prototype"]["propertyIsEnumerable"];
var qd = (Xc, XG, W0) => XG in Xc ? qT(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var qk = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) qz["call"](XG, W0) && qd(Xc, W0, XG[W0]);
  if (qJ) {
    for (var W0 of qJ(XG)) qA["call"](XG, W0) && qd(Xc, W0, XG[W0]);
  }
  return Xc;
};
var qr = class extends bT {
  constructor(Xc = 0.55, XG = 2, W0 = { "width": 256, "height": 256 }) {
    super(), this["thresh"] = Xc, this["steps"] = XG, this["size"] = W0, this["upscaler"] = new qi(), this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["upscaler"]["load"](XG, this["size"], this["thresh"], this["steps"]), super["load"](Xc);
  }
  ["unload"]() {
    this["loaded"] && (this["upscaler"]["unload"](), super["unload"]());
  }
  async ["update"](Xc, XG) {
    var W0;
    const { renderer: W1 } = this;
    if (!this["loaded"] || !(W1 instanceof bM)) return;
    const W2 = (W0 = W1["input"]) == null ? void 0 : W0["texture"](), W3 = q7(Xc);
    if (!W3 || !W3["maskTex"] || !W2) return;
    this["size"] = qk({}, W3["maskTex"]["size"]), this["upscaler"]["resize"](W3["maskTex"]["size"]);
    const W4 = this["upscaler"]["upscale"](W3["maskTex"], W2) && this["upscaler"]["mask"]();
    W4 && (W3["maskTex"]["texture"] = W4, W3["maskTex"] = { "texture": W4, "size": qk({}, this["upscaler"]["size"]()), "box": W3["maskTex"]["box"] });
  }
};
var qm = Object["defineProperty"];
var qZ = Object["getOwnPropertySymbols"];
var qj = Object["prototype"]["hasOwnProperty"];
var qx = Object["prototype"]["propertyIsEnumerable"];
var qR = (Xc, XG, W0) => XG in Xc ? qm(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var qf = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) qj["call"](XG, W0) && qR(Xc, W0, XG[W0]);
  if (qZ) {
    for (var W0 of qZ(XG)) qx["call"](XG, W0) && qR(Xc, W0, XG[W0]);
  }
  return Xc;
};
var qU = class extends bT {
  constructor(Xc = 2, XG = { "width": 256, "height": 256 }, W0 = Math["floor"](2 * Xc)) {
    super(), this["smooth"] = Xc, this["size"] = XG, this["radius"] = W0, this["gaussian"] = [], this["ordinal"] = bu["Process"];
    const W1 = -0.5 / Xc ** 2;
    this["gaussian"]["push"](1);
    let W2 = 1;
    for (let W3 = 1; W3 <= W0; W3++) {
      const W4 = Math["exp"](W1 * W3 ** 2);
      this["gaussian"]["push"](W4), this["gaussian"]["unshift"](W4), W2 += 2 * W4;
    }
    for (let W5 = 0; W5 < this["gaussian"]["length"]; W5++) this["gaussian"][W5] /= W2;
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["xpass"] = new bG(XG, this["size"], ["image"], { "kernel": "1fv" }, qa("x", this["radius"]), void 0, true, true), this["xpass"]["setUniform"]("kernel", this["gaussian"]), this["ypass"] = new bG(XG, this["size"], ["image"], { "kernel": "1fv" }, qa("y", this["radius"]), void 0, true, true), this["ypass"]["setUniform"]("kernel", this["gaussian"]), super["load"](Xc);
  }
  ["unload"]() {
    var Xc, XG;
    this["loaded"] && ((Xc = this["xpass"]) == null || Xc["dispose"](), delete this["xpass"], (XG = this["ypass"]) == null || XG["dispose"](), delete this["ypass"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const W0 = q9(Xc);
    if (!W0) return;
    const { xpass: W1, ypass: W2 } = this;
    if (!W1 || !W2) return;
    this["size"] = qf({}, W0["size"]), W1["resize"](W0["size"]), W2["resize"](W0["size"]);
    const W3 = W1["process"]([W0["texture"]]), W4 = W3 && W2["process"]([W3]);
    W4 && (W0["texture"] = W4);
  }
};
var qa = (Xc, XG) => {
  const W0 = Xc === "x" ? ["x", "x", "0"] : ["y", "0", "y"];
  return "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform float kernel[" + (2 * XG + 1) + "];\nuniform sampler2D image;\n\nvoid main() {\n    float result = 0.0;\n    for (int " + W0[0] + " = " + -XG + "; " + W0[0] + " <= " + XG + "; " + W0[0] + "++)\n        result += kernel[" + W0[0] + " + " + XG + "] *\n            texture2D(image, xy + vec2(" + W0[1] + ", " + W0[2] + ") / wh).r;\n    gl_FragColor = vec4(result, result, result, 1.0);\n}";
};
var qD = Object["defineProperty"];
var qE = Object["getOwnPropertySymbols"];
var qL = Object["prototype"]["hasOwnProperty"];
var qw = Object["prototype"]["propertyIsEnumerable"];
var qS = (Xc, XG, W0) => XG in Xc ? qD(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var qo = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) qL["call"](XG, W0) && qS(Xc, W0, XG[W0]);
  if (qE) {
    for (var W0 of qE(XG)) qw["call"](XG, W0) && qS(Xc, W0, XG[W0]);
  }
  return Xc;
};
var qn = class extends bT {
  constructor(Xc = 0.9, XG = { "width": 256, "height": 256 }) {
    super(), this["alpha"] = Xc, this["size"] = XG, this["filterTurn"] = false, this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["filters"] = [0, 1]["map"](() => new bG(XG, this["size"], ["image", "smooth"], {}, qO(this["alpha"]), void 0, true, true)), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["filters"]) == null || Xc["forEach"]((XG) => XG["dispose"]()), delete this["filters"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const W0 = q9(Xc);
    if (!W0) return;
    const { filters: W1 } = this;
    if (!W1) return;
    this["size"] = qo({}, W0["size"]), this["filterTurn"] = !this["filterTurn"];
    let [W2, W3] = W1;
    [W2, W3] = this["filterTurn"] ? [W3, W2] : [W2, W3], W3["resize"](W0["size"]);
    const W4 = W3["process"]([W0["texture"], W2["output"]()]);
    W4 && (W0["texture"] = W4);
  }
};
var qO = (Xc = 0.9) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform sampler2D image;\nuniform sampler2D smooth;\n\nvoid main() {\n    float mask = texture2D(image, xy).r;\n    float t = mask - 0.5;\n    float x = t * t;\n    float alpha = 1.0 - min(\n        x * (5.74062006 + x * (-2.90180189 + x * (-30.34594285 +\n        x * (153.83657925 + x * (-387.53530186))))), 1.0);\n    float prev = texture2D(smooth, xy).r;\n    float smoothed = mask + (prev - mask) * (alpha * " + Xc["toFixed"](3) + ");\n    gl_FragColor = vec4(smoothed);\n}";
var ql = Object["defineProperty"];
var qu = Object["getOwnPropertySymbols"];
var qH = Object["prototype"]["hasOwnProperty"];
var qK = Object["prototype"]["propertyIsEnumerable"];
var qp = (Xc, XG, W0) => XG in Xc ? ql(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var qY = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) qH["call"](XG, W0) && qp(Xc, W0, XG[W0]);
  if (qu) {
    for (var W0 of qu(XG)) qK["call"](XG, W0) && qp(Xc, W0, XG[W0]);
  }
  return Xc;
};
var qB = class extends bT {
  constructor(Xc = 8, XG = { "width": 256, "height": 256 }) {
    super(), this["radius"] = Xc, this["size"] = XG, this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["ypass"] = new bG(XG, this["size"], ["mask", "image"], { "rect": "4f" }, qs(this["radius"]), void 0, false, true), this["xpass"] = new bG(XG, this["size"], ["mask", "image"], { "rect": "4f" }, qP(this["radius"]), void 0, true, true), super["load"](Xc);
  }
  ["unload"]() {
    var Xc, XG;
    this["loaded"] && ((Xc = this["ypass"]) == null || Xc["dispose"](), delete this["ypass"], (XG = this["xpass"]) == null || XG["dispose"](), delete this["xpass"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const { renderer: W0, ypass: W1, xpass: W2 } = this;
    if (!this["loaded"] || !W1 || !W2 || !(W0 instanceof bM)) return;
    const W3 = q9(Xc);
    if (!W3) return;
    this["size"] = qY({}, W3["size"]), W1["resize"](W3["size"]);
    const W4 = W1["process"]([W3["texture"], W0["current"]], { "rect": q6(W3["box"]) });
    W2["resize"](W3["size"]);
    const W5 = W2["process"]([W4, W0["current"]], { "rect": q6(W3["box"]) });
    W3["texture"] = W5 || W3["texture"];
  }
};
var qs = (Xc = 8) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform vec4 rect;\nuniform sampler2D mask;\nuniform sampler2D image;\n\nvoid main() {\n    vec2 whPix = 1.0 / wh;\n    vec4 stats = vec4(0.0);\n    for (int y = -" + Xc + "; y <= " + Xc + "; y++) {\n        vec2 xyMask = xy + vec2(0, y) * whPix;\n        vec2 xyImg = xyMask * rect.zw + rect.xy;\n        vec3 rgb = texture2D(image, xyImg).rgb;\n        float i = dot(rgb, vec3(0.299, 0.587, 0.114));\n        float m = texture2D(mask, xyMask).r;\n        stats += vec4(i, m, i * i, i * m);\n    }\n    stats /= " + (2 * Xc + 1)["toFixed"](1) + ";\n    gl_FragColor = stats;\n}";
var qP = (Xc = 8) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform vec4 rect;\nuniform sampler2D mask;\nuniform sampler2D image;\n\nvoid main() {\n    vec2 whPix = 1.0 / wh;\n    vec4 stats = vec4(0.0);\n    for (int x = -" + Xc + "; x <= " + Xc + "; x++) {\n        vec2 xyMask = xy + vec2(x, 0) * whPix;\n        stats += texture2D(mask, xyMask);\n    }\n    stats /= " + (2 * Xc + 1)["toFixed"](1) + ";\n    vec2 xyImg = xy * rect.zw + rect.xy;\n    vec3 rgb = texture2D(image, xyImg).rgb;\n    float i = dot(rgb, vec3(0.299, 0.587, 0.114));\n    float varII = stats.z - stats.x * stats.x;\n    float varIM = stats.w - stats.x * stats.y;\n    float a = varIM / (varII + 0.001);\n    float b = stats.y - a * stats.x;\n    gl_FragColor = vec4(a * i + b);\n}";
var qg = Object["defineProperty"];
var qN = Object["getOwnPropertySymbols"];
var qI = Object["prototype"]["hasOwnProperty"];
var qC = Object["prototype"]["propertyIsEnumerable"];
var qb = (Xc, XG, W0) => XG in Xc ? qg(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var qV = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) qI["call"](XG, W0) && qb(Xc, W0, XG[W0]);
  if (qN) {
    for (var W0 of qN(XG)) qC["call"](XG, W0) && qb(Xc, W0, XG[W0]);
  }
  return Xc;
};
var qM = class extends bT {
  constructor(Xc = 1, XG = { "width": 256, "height": 256 }) {
    super(), this["radius"] = Xc, this["size"] = XG, this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["shader"] = new n(XG, this["size"], this["radius"]), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["shader"]) == null || Xc["dispose"](), delete this["shader"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const { shader: W0 } = this;
    if (!this["loaded"] || !W0) return;
    const W1 = q9(Xc);
    if (!W1) return;
    this["size"] = qV({}, W1["size"]), W0["resize"](W1["size"]);
    const W2 = W0["process"]([W1["texture"]]);
    W2 && (W1["texture"] = W2);
  }
};
var qh = Object["defineProperty"];
var qc = Object["getOwnPropertySymbols"];
var qG = Object["prototype"]["hasOwnProperty"];
var X0 = Object["prototype"]["propertyIsEnumerable"];
var X1 = (Xc, XG, W0) => XG in Xc ? qh(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var X2 = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) qG["call"](XG, W0) && X1(Xc, W0, XG[W0]);
  if (qc) {
    for (var W0 of qc(XG)) X0["call"](XG, W0) && X1(Xc, W0, XG[W0]);
  }
  return Xc;
};
var X3 = class extends bT {
  constructor(Xc = 1, XG = { "width": 256, "height": 256 }) {
    super(), this["radius"] = Xc, this["size"] = XG, this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["shader"] = new s(XG, this["size"], this["radius"]), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["shader"]) == null || Xc["dispose"](), delete this["shader"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const { shader: W0 } = this;
    if (!this["loaded"] || !W0) return;
    const W1 = q9(Xc);
    if (!W1) return;
    this["size"] = X2({}, W1["size"]), W0["resize"](W1["size"]);
    const W2 = W0["process"]([W1["texture"]]);
    W2 && (W1["texture"] = W2);
  }
};
var X4 = Object["defineProperty"];
var X5 = Object["getOwnPropertySymbols"];
var X6 = Object["prototype"]["hasOwnProperty"];
var X7 = Object["prototype"]["propertyIsEnumerable"];
var X8 = (Xc, XG, W0) => XG in Xc ? X4(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var X9 = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) X6["call"](XG, W0) && X8(Xc, W0, XG[W0]);
  if (X5) {
    for (var W0 of X5(XG)) X7["call"](XG, W0) && X8(Xc, W0, XG[W0]);
  }
  return Xc;
};
var Xq = class extends bT {
  constructor(Xc = 1, XG = { "width": 256, "height": 256 }) {
    super(), this["radius"] = Xc, this["size"] = XG, this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["shader"] = this["radius"] > 0 ? new n(XG, this["size"], this["radius"]) : new s(XG, this["size"], -this["radius"]), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["shader"]) == null || Xc["dispose"](), delete this["shader"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const { shader: W0 } = this;
    if (!this["loaded"] || !W0) return;
    const W1 = q9(Xc);
    if (!W1) return;
    this["size"] = X9({}, W1["size"]), W0["resize"](W1["size"]);
    const W2 = W0["process"]([W1["texture"]]);
    W2 && (W1["texture"] = W2);
  }
};
var XX = Object["defineProperty"];
var XW = Object["getOwnPropertySymbols"];
var Xt = Object["prototype"]["hasOwnProperty"];
var XF = Object["prototype"]["propertyIsEnumerable"];
var Xy = (Xc, XG, W0) => XG in Xc ? XX(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var Xi = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) Xt["call"](XG, W0) && Xy(Xc, W0, XG[W0]);
  if (XW) {
    for (var W0 of XW(XG)) XF["call"](XG, W0) && Xy(Xc, W0, XG[W0]);
  }
  return Xc;
};
var XQ = class extends bT {
  constructor(Xc = 0.55, XG = { "width": 256, "height": 256 }) {
    super(), this["thresh"] = Xc, this["size"] = XG, this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["shader"] = new bG(XG, this["size"], ["image"], {}, Xv(this["thresh"]), void 0, true, true), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["shader"]) == null || Xc["dispose"](), delete this["shader"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const { renderer: W0, shader: W1 } = this;
    if (!this["loaded"] || !W1 || !(W0 instanceof bM)) return;
    const W2 = q9(Xc);
    if (!W2) return;
    this["size"] = Xi({}, W2["size"]), W1["resize"](W2["size"]);
    const W3 = W1["process"]([W2["texture"]]);
    W2["texture"] = W3 || W2["texture"];
  }
};
var Xv = (Xc = 0.55) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform sampler2D image;\n\nvoid main() {\n    float v = texture2D(image, xy).r < " + Xc + " ? 0.0 : 1.0;\n    gl_FragColor = vec4(v, v, v, 1.0);\n}";
var XT = Object["defineProperty"];
var XJ = Object["getOwnPropertySymbols"];
var Xz = Object["prototype"]["hasOwnProperty"];
var XA = Object["prototype"]["propertyIsEnumerable"];
var Xd = (Xc, XG, W0) => XG in Xc ? XT(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var Xk = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) Xz["call"](XG, W0) && Xd(Xc, W0, XG[W0]);
  if (XJ) {
    for (var W0 of XJ(XG)) XA["call"](XG, W0) && Xd(Xc, W0, XG[W0]);
  }
  return Xc;
};
var Xr = class extends bT {
  constructor(Xc = 0.25, XG = 0.75, W0 = { "width": 256, "height": 256 }) {
    super(), this["edge0"] = Xc, this["edge1"] = XG, this["size"] = W0, this["ordinal"] = bu["Process"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["shader"] = new bG(XG, this["size"], ["image"], {}, Xm(this["edge0"], this["edge1"]), void 0, true, true), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["shader"]) == null || Xc["dispose"](), delete this["shader"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    const { renderer: W0, shader: W1 } = this;
    if (!this["loaded"] || !W1 || !(W0 instanceof bM)) return;
    const W2 = q9(Xc);
    if (!W2) return;
    this["size"] = Xk({}, W2["size"]), W1["resize"](W2["size"]);
    const W3 = W1["process"]([W2["texture"]]);
    W2["texture"] = W3 || W2["texture"];
  }
};
var Xm = (Xc = 0.25, XG = 0.75) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform sampler2D image;\n\nvoid main() {\n    float v = texture2D(image, xy).r;\n    v = smoothstep(" + Xc["toFixed"](3) + ", " + XG["toFixed"](3) + ", v);\n    gl_FragColor = vec4(v, v, v, 1.0);\n}";
var XZ = class extends bl {
  constructor(Xc = 11, XG = 0.55, W0 = Math["floor"](2 * Xc)) {
    super(["image", "smooth", "mask"], { "rect": "4f", "kernel": "1fv" }, Xx(W0, XG)), this["smooth"] = Xc, this["radius"] = W0, this["gaussian"] = [];
    const W1 = -0.5 / Xc ** 2;
    this["gaussian"]["push"](1);
    let W2 = 1;
    for (let W3 = 1; W3 <= W0; W3++) {
      const W4 = Math["exp"](W1 * W3 ** 2);
      this["gaussian"]["push"](W4), this["gaussian"]["unshift"](W4), W2 += 2 * W4;
    }
    for (let W5 = 0; W5 < this["gaussian"]["length"]; W5++) this["gaussian"][W5] /= W2;
  }
  async ["load"](Xc) {
    var XG;
    const W0 = Xc instanceof bM && Xc["shaderCtx"];
    this["loaded"] || !W0 || (this["xpass"] = new bG(W0, this["size"], ["image"], { "kernel": "1fv" }, Xj(this["radius"])), await super["load"](Xc), this["xpass"]["setUniform"]("kernel", this["gaussian"]), (XG = this["shader"]) == null || XG["setUniform"]("kernel", this["gaussian"]));
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["xpass"]) == null || Xc["dispose"](), delete this["xpass"], super["unload"]());
  }
  async ["process"](Xc, XG) {
    const W0 = q9(Xc);
    if (!W0) return false;
    const { xpass: W1, shader: W2 } = this;
    if (!W1 || !W2) return false;
    const W3 = q6(W0["box"]);
    return W1["process"]([XG]), W2["process"]([XG, W1["output"](), W0["texture"]], { "rect": W3 }), true;
  }
  ["setupVideo"](Xc) {
    var XG;
    super["setupVideo"](Xc), (XG = this["xpass"]) == null || XG["resize"](Xc);
  }
};
var Xj = (Xc) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform float kernel[" + (2 * Xc + 1) + "];\nuniform sampler2D image;\n\nvoid main() {\n    vec3 result = vec3(0.0);\n    for (int x = " + -Xc + "; x <= " + Xc + "; x++)\n        result += kernel[x + " + Xc + "] *\n            texture2D(image, xy + vec2(x, 0) / wh).rgb;\n    gl_FragColor = vec4(result, 1.0);\n}";
var Xx = (Xc, XG = 0.55) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform vec4 rect;\nuniform float kernel[" + (2 * Xc + 1) + "];\nuniform sampler2D image;\nuniform sampler2D smooth;\nuniform sampler2D mask;\n\nvoid main() {\n    vec2 xyMask = (xy - rect.xy) / rect.zw;\n    bool fg = min(xyMask.x, xyMask.y) >= 0.0 &&\n              max(xyMask.x, xyMask.y) <= 1.0 &&\n              texture2D(mask, xyMask).r >= " + XG + ";\n    if (fg) {\n        gl_FragColor = texture2D(image, xy);\n        return;\n    }\n    vec3 result = vec3(0.0);\n    for (int y = " + -Xc + "; y <= " + Xc + "; y++)\n        result += kernel[y + " + Xc + "] *\n            texture2D(smooth, xy + vec2(0, y) / wh).rgb;\n    gl_FragColor = vec4(result, 1.0);\n}";
var XR = class extends bl {
  constructor(Xc = 0.4, XG = 0.6, W0 = false) {
    super(["image", "bg", "mask"], { "rect": "4f", "flipX": "1i" }, Xf(Xc, XG)), this["mirror"] = W0;
  }
  async ["load"](Xc) {
    var XG;
    const W0 = Xc instanceof bM && Xc["shaderCtx"];
    this["loaded"] || !W0 || (this["bgTexture"] = new bh(W0, this["size"]), await super["load"](Xc), (XG = this["shader"]) == null || XG["setUniform"]("flipX", [this["mirror"] ? 1 : 0]));
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["bgTexture"]) == null || Xc["dispose"](), delete this["bgTexture"], super["unload"]());
  }
  async ["process"](Xc, XG) {
    const W0 = q9(Xc);
    if (!W0) return false;
    const { shader: W1, bgTexture: W2 } = this;
    if (!W1 || !W2) return false;
    const W3 = q6(W0["box"]);
    return W1["process"]([XG, W2["texture"](), W0["texture"]], { "rect": W3 }), true;
  }
  ["background"]() {
    return this["bgTexture"];
  }
  ["setMirror"](Xc) {
    var XG;
    this["mirror"] = Xc, (XG = this["shader"]) == null || XG["setUniform"]("flipX", [Xc ? 1 : 0]);
  }
  ["setupVideo"](Xc) {
    var XG;
    super["setupVideo"](Xc), (XG = this["bgTexture"]) == null || XG["resize"](this["size"]);
  }
};
var Xf = (Xc = 0.4, XG = 0.6) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform vec4 rect;\nuniform int flipX;\nuniform sampler2D image;\nuniform sampler2D bg;\nuniform sampler2D mask;\n\nvoid main() {\n    vec2 xyMask = (xy - rect.xy) / rect.zw;\n    vec2 xyBg = vec2(bool(flipX) ? 1.0 - xy.x : xy.x, xy.y);\n    float prob = texture2D(mask, xyMask).r;\n    bool flag = prob < " + Xc["toFixed"](3) + " ||\n                min(xyMask.x, xyMask.y) < 0.0 ||\n                max(xyMask.x, xyMask.y) > 1.0;\n    if (flag) {\n        gl_FragColor = texture2D(bg, xyBg);\n        return;\n    }\n    float alpha = min(1.0, (prob - " + Xc["toFixed"](5) + ") /\n        " + (XG - Xc)["toFixed"](3) + ");\n    gl_FragColor = mix(texture2D(bg, xyBg), texture2D(image, xy), alpha);\n}";
var XU = class extends bl {
  constructor(Xc = 0.5, XG = false) {
    super(["image", "bg"], { "alpha": "1f", "flipX": "1i" }, Xa), this["alpha"] = Xc, this["mirror"] = XG;
  }
  async ["load"](Xc) {
    var XG;
    const W0 = Xc instanceof bM && Xc["shaderCtx"];
    this["loaded"] || !W0 || (this["bgTexture"] = new bh(W0, this["size"]), await super["load"](Xc), (XG = this["shader"]) == null || XG["setUniform"]("flipX", [this["mirror"] ? 1 : 0]));
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["bgTexture"]) == null || Xc["dispose"](), delete this["bgTexture"], super["unload"]());
  }
  async ["process"](Xc, XG) {
    const { shader: W0, bgTexture: W1 } = this;
    return !W0 || !W1 ? false : (W0["process"]([XG, W1["texture"]()], { "alpha": [this["alpha"]] }), true);
  }
  ["background"]() {
    return this["bgTexture"];
  }
  ["setAlpha"](Xc) {
    this["alpha"] = Xc;
  }
  ["setMirror"](Xc) {
    var XG;
    this["mirror"] = Xc, (XG = this["shader"]) == null || XG["setUniform"]("flipX", [Xc ? 1 : 0]);
  }
  ["setupVideo"](Xc) {
    var XG;
    super["setupVideo"](Xc), (XG = this["bgTexture"]) == null || XG["resize"](this["size"]);
  }
};
var Xa = "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform float alpha;\nuniform int flipX;\nuniform sampler2D image;\nuniform sampler2D bg;\n\nvoid main() {\n    vec2 xyBg = vec2(bool(flipX) ? 1.0 - xy.x : xy.x, xy.y);\n    gl_FragColor = mix(texture2D(image, xy), texture2D(bg, xyBg), alpha);\n}";
var XD = class extends bl {
  constructor(Xc = 7, XG = 0.05, W0 = Math["floor"](2 * Xc)) {
    super(["image"], { "kernel": "1fv" }, XE("y", W0, XG)), this["smooth"] = Xc, this["sense"] = XG, this["radius"] = W0, this["gaussian"] = [];
    const W1 = -0.5 / Xc ** 2;
    this["gaussian"]["push"](1);
    let W2 = 1;
    for (let W3 = 1; W3 <= W0; W3++) {
      const W4 = Math["exp"](W1 * W3 ** 2);
      this["gaussian"]["push"](W4), this["gaussian"]["unshift"](W4), W2 += 2 * W4;
    }
    for (let W5 = 0; W5 < 2 * W0 + 1; W5++) this["gaussian"][W5] /= W2;
  }
  async ["load"](Xc) {
    var XG;
    const W0 = Xc instanceof bM && Xc["shaderCtx"];
    this["loaded"] || !W0 || (this["xpass"] = new bG(W0, this["size"], ["image"], { "kernel": "1fv" }, XE("x", this["radius"], this["sense"])), await super["load"](Xc), this["xpass"]["setUniform"]("kernel", this["gaussian"]), (XG = this["shader"]) == null || XG["setUniform"]("kernel", this["gaussian"]));
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["xpass"]) == null || Xc["dispose"](), delete this["xpass"], super["unload"]());
  }
  async ["process"](Xc, XG) {
    const { xpass: W0, shader: W1 } = this;
    return !W0 || !W1 ? false : (W0["process"]([XG]), W1["process"]([W0["output"]()]), true);
  }
  ["setupVideo"](Xc) {
    var XG;
    super["setupVideo"](Xc), (XG = this["xpass"]) == null || XG["resize"](Xc);
  }
};
function XE(Xc, XG, W0) {
  const W1 = Xc === "x" ? ["x", "x", "0"] : ["y", "0", "y"];
  return "\nprecision mediump float;\nvarying vec2 xy;\nuniform sampler2D image;\nuniform vec2 wh;\nuniform float kernel[" + (2 * XG + 1) + "];\n\nvoid main() {\n    vec3 center = texture2D(image, xy).rgb;\n    vec3 result = vec3(0.0);\n    float norm = 0.0;\n    for (int " + W1[0] + " = " + -XG + "; " + W1[0] + " <= " + XG + "; " + W1[0] + "++) {\n        vec3 pixel = texture2D(image, xy + vec2(" + W1[1] + ", " + W1[2] + ") / wh).rgb;\n        vec3 diff = center - pixel;\n        float kc = " + 1 / (W0 * Math["sqrt"](2 * Math["PI"])) + " *\n            exp(-0.5 * dot(diff, diff) / " + W0 * W0 + ");\n        float k = kernel[" + W1[0] + " + " + XG + "] * kc;\n        result += k * pixel;\n        norm += k;\n    }\n    gl_FragColor = vec4(result / norm, 1.0);\n}";
}
var XL = Object["defineProperty"];
var Xw = Object["getOwnPropertySymbols"];
var XS = Object["prototype"]["hasOwnProperty"];
var Xo = Object["prototype"]["propertyIsEnumerable"];
var Xn = (Xc, XG, W0) => XG in Xc ? XL(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var XO = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) XS["call"](XG, W0) && Xn(Xc, W0, XG[W0]);
  if (Xw) {
    for (var W0 of Xw(XG)) Xo["call"](XG, W0) && Xn(Xc, W0, XG[W0]);
  }
  return Xc;
};
var Xl = class extends bl {
  constructor(Xc = 0.55, XG = 512, W0 = { "width": 256, "height": 256 }) {
    super(["image", "mask", "maskDist"], { "rect": "4f" }, Xu(Xc)), this["thresh"] = Xc, this["radius"] = XG, this["maskSize"] = W0, this["ordinal"] = bu["PostRender"];
  }
  async ["load"](Xc) {
    const XG = Xc instanceof bM && Xc["shaderCtx"];
    if (!(this["loaded"] || !XG)) return this["distShader"] = new bG(XG, this["maskSize"], ["image"], {}, XH(this["thresh"], this["radius"]), void 0, false, false), super["load"](Xc);
  }
  ["unload"]() {
    var Xc;
    this["loaded"] && ((Xc = this["distShader"]) == null || Xc["dispose"](), delete this["distShader"], super["unload"]());
  }
  async ["process"](Xc, XG) {
    const W0 = q9(Xc), { shader: W1, distShader: W2 } = this;
    if (!W0 || !W1 || !W2) return false;
    const W3 = q6(W0["box"]);
    return this["maskSize"] = XO({}, W0["size"]), W2["resize"](W0["size"]), W2["process"]([W0["texture"]]), W1["process"]([XG, W0["texture"], W2["output"]()], { "rect": W3 }), true;
  }
};
var Xu = (Xc = 0.55, XG = 0.02) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform vec4 rect;\nuniform sampler2D image;\nuniform sampler2D mask;\nuniform sampler2D maskDist;\n\nfloat readMask(vec2 dxy) {\n    return texture2D(mask, (xy + dxy - rect.xy) / rect.zw).r;\n}\n\nvec4 readProp(vec2 dxyX1, vec2 dxyX2) {\n    vec2 dxy = abs(dxyX1.x) + abs(dxyX1.y) < " + XG["toFixed"](4) + " &&\n        readMask(dxyX2) < " + Xc + " ? dxyX2 : dxyX1;\n    return texture2D(image, xy + dxy);\n}\n\nfloat refineMask(vec2 dxyI, float s, float d) {\n    for (int i = -4; i <= 4; i++) {\n        float di = max(d + float(i) * s, 0.0);\n        if (readMask(dxyI * di) < " + Xc + ") {\n            d = di;\n            break;\n        }\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 xyMask = (xy - rect.xy) / rect.zw;\n    vec4 dist = texture2D(maskDist, xyMask) * rect.zwzw;\n    vec4 color = texture2D(image, xy);\n    bool bg = texture2D(mask, xyMask).r < " + Xc + " ||\n              all(lessThanEqual(dist, vec4(0.0)));\n    if (bg) {\n        gl_FragColor = color;\n        return;\n    }\n    vec2 whPix = 1.0 / wh;\n    dist = vec4(refineMask(vec2(-1.0,  0.0), whPix.x, dist.x),\n                refineMask(vec2( 0.0, -1.0), whPix.y, dist.y),\n                refineMask(vec2( 1.0,  0.0), whPix.x, dist.z),\n                refineMask(vec2( 0.0,  1.0), whPix.y, dist.w));\n\n    float x0 = dist.x;\n    bg = x0 > 0.0;\n    vec4 cx0 = bg ? readProp(vec2(-x0, 0.0),\n        vec2(-2.0 * x0 + whPix.x, 0.0)) : color;\n    x0 = bg ? 1.0 / x0 : 0.0;\n\n    float y0 = dist.y;\n    bg = y0 > 0.0;\n    vec4 cy0 = bg ? readProp(vec2(0.0, -y0),\n        vec2(0.0, -2.0 * y0 + whPix.y)) : color;\n    y0 = bg ? 1.0 / y0 : 0.0;\n\n    float x1 = dist.z;\n    bg = x1 > 0.0;\n    vec4 cx1 = bg ? readProp(vec2(x1, 0.0),\n        vec2(2.0 * x1 - whPix.x, 0.0)) : color;\n    x1 = bg ? 1.0 / x1 : 0.0;\n\n    float y1 = dist.w;\n    bg = y1 > 0.0;\n    vec4 cy1 = bg ? readProp(vec2(0.0, y1),\n        vec2(0.0, 2.0 * y1 - whPix.y)) : color;\n    y1 = bg ? 1.0 / y1 : 0.0;\n\n    float s = 1.0 / (x0 + x1 + y0 + y1);\n    color = cx0 * x0 * s + cx1 * x1 * s + cy0 * y0 * s + cy1 * y1 * s;\n    gl_FragColor = color;\n}";
var XH = (Xc = 0.55, XG = 512, W0 = 8) => "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform sampler2D image;\n\nbool background(vec2 dxy) {\n    return texture2D(image, xy + dxy).r < " + Xc + ";\n}\n\nfloat traverse(vec2 dxy) {\n    bool bg = false;\n    float d = 1.0;\n    for (int di = 1; di < " + Math["ceil"](XG / W0) + "; di++) {\n        d = bg ? d : float(di * " + W0 + ");\n        bg = bg || background(d * dxy);\n    }\n    bool bg1 = bg;\n    for (int di = 1; di < " + W0 + "; di++) {\n        float d1 = d - 1.0;\n        bg1 = bg1 && background(d1 * dxy);\n        d = bg1 ? d1 : d;\n    }\n    return bg ? d : 0.0;\n}\n\nvoid main() {\n    if (background(vec2(0.0))) {\n        gl_FragColor = vec4(0.0);\n        return;\n    }\n    vec2 whPix = 1.0 / wh;\n    gl_FragColor = vec4(\n        traverse(vec2(-whPix.x, 0.0)),\n        traverse(vec2(0.0, -whPix.y)),\n        traverse(vec2(whPix.x, 0.0)),\n        traverse(vec2(0.0, whPix.y))) / wh.xyxy;\n}";
var XK = Object["defineProperty"];
var Xp = Object["getOwnPropertySymbols"];
var XY = Object["prototype"]["hasOwnProperty"];
var XB = Object["prototype"]["propertyIsEnumerable"];
var Xs = (Xc, XG, W0) => XG in Xc ? XK(Xc, XG, { "enumerable": true, "configurable": true, "writable": true, "value": W0 }) : Xc[XG] = W0;
var XP = (Xc, XG) => {
  for (var W0 in XG || (XG = {})) XY["call"](XG, W0) && Xs(Xc, W0, XG[W0]);
  if (Xp) {
    for (var W0 of Xp(XG)) XB["call"](XG, W0) && Xs(Xc, W0, XG[W0]);
  }
  return Xc;
};
var Xg = class extends bT {
  constructor(Xc, XG = 0.5, W0 = 0.1, W1 = { "minCutOff": 0.05, "minCutOffD": 0.05, "beta": 5 }) {
    super(), this["callback"] = Xc, this["rangeMax"] = XG, this["rangeMin"] = W0, this["filterParams"] = W1, this["size"] = { "width": 0, "height": 0 }, this["ordinal"] = bu["PreRender"], this["rangeRatio"] = (1 - W0) / (XG - W0);
  }
  async ["load"](Xc) {
    if (this["loaded"] || !(Xc instanceof bM) || !Xc["shaderCtx"]) return;
    const { shaderCtx: XG } = Xc;
    return this["image"] = new bh(XG, this["size"], false, true, true), this["reader"] = new bq(XG), this["setupVideo"](this["size"]), super["load"](Xc);
  }
  ["unload"]() {
    var Xc, XG;
    this["loaded"] && ((Xc = this["image"]) == null || Xc["dispose"](), delete this["image"], (XG = this["reader"]) == null || XG["dispose"](), delete this["reader"], super["unload"]());
  }
  async ["update"](Xc, XG) {
    var W0;
    const { image: W1, reader: W2 } = this;
    if (!this["loaded"] || !W1 || !W2) return;
    const W3 = (W6) => Promise["race"]([W6, false]), W4 = this["pending"] && await W3(this["pending"]);
    if (W4 === false || (W1["update"](XG), this["pending"] = W2["readAsync"](W1, W1["levelCount"]() - 1), !W4)) return;
    let W5 = (0.299 * W4[0] + 0.587 * W4[1] + 0.114 * W4[2]) / 255;
    W5 = this["filter"](W5), W5 = Math["min"](Math["max"](W5, this["rangeMin"]), this["rangeMax"]), W5 = (W5 - this["rangeMin"]) * this["rangeRatio"] + this["rangeMin"], (W0 = this["callback"]) == null || W0["call"](this, W5);
  }
  ["setupVideo"](Xc) {
    var XG;
    return this["size"] = XP({}, Xc), (XG = this["image"]) == null || XG["resize"](Xc), true;
  }
  ["setCallback"](Xc) {
    this["callback"] = Xc;
  }
  ["filter"](Xc) {
    if (!this["smooth"]) return this["smooth"] = { "val": Xc, "der": 0, "time": Date["now"]() / 1e3 }, Xc;
    const { smooth: XG, filterParams: W0 } = this, W1 = Date["now"]() / 1e3;
    if (W1 <= XG["time"]) return Xc;
    const W2 = 1 / (W1 - XG["time"]);
    XG["time"] = W1;
    const W3 = (Xc - XG["val"]) * W2, W4 = (W7) => 1 / (1 + W2 / (2 * Math["PI"] * W7)), W5 = W4(W0["minCutOffD"]);
    XG["der"] = XG["der"] + W5 * (W3 - XG["der"]);
    const W6 = W4(W0["minCutOff"] + W0["beta"] * Math["abs"](XG["der"]));
    return XG["val"] = XG["val"] + W6 * (Xc - XG["val"]), XG["val"];
  }
};
var XN = class extends bT {
  constructor(Xc) {
    super(), this["callback"] = Xc, this["ordinal"] = bu["PostProcess"];
  }
  async ["update"](Xc, XG) {
    if (this["loaded"]) return this["callback"](Xc), super["update"](Xc, XG);
  }
};
var XI = class extends XN {
};
var XC = class extends XN {
};
var Xb = class extends bT {
  constructor(Xc) {
    super(), this["predicate"] = Xc, this["ordinal"] = bu["PreProcess"];
  }
  async ["update"](Xc, XG) {
    this["loaded"] && (Xc["poses"] = Xc["poses"]["filter"](this["predicate"]));
  }
};
var XV = class extends bT {
  constructor(Xc) {
    super(), this["predicate"] = Xc, this["ordinal"] = bu["PreProcess"];
  }
  async ["update"](Xc, XG) {
    if (this["loaded"]) return Xc["faces"] = Xc["faces"]["filter"](this["predicate"]), super["update"](Xc, XG);
  }
};
function XM(Xc, XG = 0) {
  const W0 = Xc;
  W0["results"] = [], W0["delay"] = XG;
  const W1 = W0["update"];
  return W0["update"] = async function(W2, W3) {
    for (this["results"]["push"](W2); this["results"]["length"] > this["delay"]; ) this["results"]["shift"]();
    return W1["call"](this, this["results"][0] || W2, W3);
  }, W0;
}
var Xh = class extends bT {
  constructor(Xc) {
    super(), this["callback"] = Xc, this["fpsStart"] = Date["now"](), this["fpsCount"] = 0, this["ordinal"] = bu["PostRender"];
  }
  async ["load"](Xc) {
    return this["fpsStart"] = Date["now"](), this["fpsCount"] = 0, super["load"](Xc);
  }
  async ["update"](Xc, XG) {
    if (this["loaded"]) {
      if (this["fpsCount"]++, this["fpsCount"] >= 30) {
        const W0 = Date["now"](), W1 = this["fpsCount"] * 1e3 / (W0 - this["fpsStart"]);
        this["fpsCount"] = 0, this["fpsStart"] = W0, this["callback"](W1);
      }
      return super["update"](Xc, XG);
    }
  }
};
export {
  XZ as BgBlurPlugin,
  XR as BgReplacePlugin,
  XD as BilateralPlugin,
  Xl as BodyPatchPlugin,
  Xg as BrightnessPlugin,
  XN as CallbackPlugin,
  XM as DelayPlugin,
  n as DilationShader,
  s as ErosionShader,
  XC as FaceCallbackPlugin,
  XV as FaceFilterPlugin,
  XQ as MaskBinaryPlugin,
  qM as MaskDilationPlugin,
  X3 as MaskErosionPlugin,
  qn as MaskFilterPlugin,
  Xq as MaskMorphPlugin,
  qB as MaskSharpPlugin,
  qU as MaskSmoothPlugin,
  Xr as MaskStepPlugin,
  q5 as MaskUploadPlugin,
  qr as MaskUpscalePlugin,
  Xh as PerfDevPlugin,
  XI as PoseCallbackPlugin,
  Xb as PoseFilterPlugin,
  XU as VideoMergePlugin,
  q8 as getMaskBuf,
  q7 as getMaskObj,
  q9 as getMaskTex,
  q6 as maskRectUniform
};
//# sourceMappingURL=@geenee_bodyrenderers-common.js.map
