(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function n(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();function w5(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x.default:x}var s_={exports:{}},m0={};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var YN;function A5(){if(YN)return m0;YN=1;var x=Symbol.for("react.transitional.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),n=Symbol.for("react.strict_mode"),i=Symbol.for("react.profiler"),r=Symbol.for("react.consumer"),a=Symbol.for("react.context"),s=Symbol.for("react.forward_ref"),l=Symbol.for("react.suspense"),c=Symbol.for("react.memo"),h=Symbol.for("react.lazy"),d=Symbol.iterator;function p(K){return K===null||typeof K!="object"?null:(K=d&&K[d]||K["@@iterator"],typeof K=="function"?K:null)}var m={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,_={};function v(K,se,ge){this.props=K,this.context=se,this.refs=_,this.updater=ge||m}v.prototype.isReactComponent={},v.prototype.setState=function(K,se){if(typeof K!="object"&&typeof K!="function"&&K!=null)throw Error("takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,K,se,"setState")},v.prototype.forceUpdate=function(K){this.updater.enqueueForceUpdate(this,K,"forceUpdate")};function b(){}b.prototype=v.prototype;function T(K,se,ge){this.props=K,this.context=se,this.refs=_,this.updater=ge||m}var E=T.prototype=new b;E.constructor=T,g(E,v.prototype),E.isPureReactComponent=!0;var A=Array.isArray,M={H:null,A:null,T:null,S:null,V:null},R=Object.prototype.hasOwnProperty;function C(K,se,ge,Me,le,Se){return ge=Se.ref,{$$typeof:x,type:K,key:se,ref:ge!==void 0?ge:null,props:Se}}function k(K,se){return C(K.type,se,void 0,void 0,void 0,K.props)}function P(K){return typeof K=="object"&&K!==null&&K.$$typeof===x}function N(K){var se={"=":"=0",":":"=2"};return"$"+K.replace(/[=:]/g,function(ge){return se[ge]})}var G=/\/+/g;function te(K,se){return typeof K=="object"&&K!==null&&K.key!=null?N(""+K.key):se.toString(36)}function j(){}function xe(K){switch(K.status){case"fulfilled":return K.value;case"rejected":throw K.reason;default:switch(typeof K.status=="string"?K.then(j,j):(K.status="pending",K.then(function(se){K.status==="pending"&&(K.status="fulfilled",K.value=se)},function(se){K.status==="pending"&&(K.status="rejected",K.reason=se)})),K.status){case"fulfilled":return K.value;case"rejected":throw K.reason}}throw K}function ae(K,se,ge,Me,le){var Se=typeof K;(Se==="undefined"||Se==="boolean")&&(K=null);var Fe=!1;if(K===null)Fe=!0;else switch(Se){case"bigint":case"string":case"number":Fe=!0;break;case"object":switch(K.$$typeof){case x:case e:Fe=!0;break;case h:return Fe=K._init,ae(Fe(K._payload),se,ge,Me,le)}}if(Fe)return le=le(K),Fe=Me===""?"."+te(K,0):Me,A(le)?(ge="",Fe!=null&&(ge=Fe.replace(G,"$&/")+"/"),ae(le,se,ge,"",function(Et){return Et})):le!=null&&(P(le)&&(le=k(le,ge+(le.key==null||K&&K.key===le.key?"":(""+le.key).replace(G,"$&/")+"/")+Fe)),se.push(le)),1;Fe=0;var Qe=Me===""?".":Me+":";if(A(K))for(var qe=0;qe<K.length;qe++)Me=K[qe],Se=Qe+te(Me,qe),Fe+=ae(Me,se,ge,Se,le);else if(qe=p(K),typeof qe=="function")for(K=qe.call(K),qe=0;!(Me=K.next()).done;)Me=Me.value,Se=Qe+te(Me,qe++),Fe+=ae(Me,se,ge,Se,le);else if(Se==="object"){if(typeof K.then=="function")return ae(xe(K),se,ge,Me,le);throw se=String(K),Error("Objects are not valid as a React child (found: "+(se==="[object Object]"?"object with keys {"+Object.keys(K).join(", ")+"}":se)+"). If you meant to render a collection of children, use an array instead.")}return Fe}function H(K,se,ge){if(K==null)return K;var Me=[],le=0;return ae(K,Me,"","",function(Se){return se.call(ge,Se,le++)}),Me}function re(K){if(K._status===-1){var se=K._result;se=se(),se.then(function(ge){(K._status===0||K._status===-1)&&(K._status=1,K._result=ge)},function(ge){(K._status===0||K._status===-1)&&(K._status=2,K._result=ge)}),K._status===-1&&(K._status=0,K._result=se)}if(K._status===1)return K._result.default;throw K._result}var q=typeof reportError=="function"?reportError:function(K){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var se=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof K=="object"&&K!==null&&typeof K.message=="string"?String(K.message):String(K),error:K});if(!window.dispatchEvent(se))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",K);return}console.error(K)};function be(){}return m0.Children={map:H,forEach:function(K,se,ge){H(K,function(){se.apply(this,arguments)},ge)},count:function(K){var se=0;return H(K,function(){se++}),se},toArray:function(K){return H(K,function(se){return se})||[]},only:function(K){if(!P(K))throw Error("React.Children.only expected to receive a single React element child.");return K}},m0.Component=v,m0.Fragment=t,m0.Profiler=i,m0.PureComponent=T,m0.StrictMode=n,m0.Suspense=l,m0.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=M,m0.__COMPILER_RUNTIME={__proto__:null,c:function(K){return M.H.useMemoCache(K)}},m0.cache=function(K){return function(){return K.apply(null,arguments)}},m0.cloneElement=function(K,se,ge){if(K==null)throw Error("The argument must be a React element, but you passed "+K+".");var Me=g({},K.props),le=K.key,Se=void 0;if(se!=null)for(Fe in se.ref!==void 0&&(Se=void 0),se.key!==void 0&&(le=""+se.key),se)!R.call(se,Fe)||Fe==="key"||Fe==="__self"||Fe==="__source"||Fe==="ref"&&se.ref===void 0||(Me[Fe]=se[Fe]);var Fe=arguments.length-2;if(Fe===1)Me.children=ge;else if(1<Fe){for(var Qe=Array(Fe),qe=0;qe<Fe;qe++)Qe[qe]=arguments[qe+2];Me.children=Qe}return C(K.type,le,void 0,void 0,Se,Me)},m0.createContext=function(K){return K={$$typeof:a,_currentValue:K,_currentValue2:K,_threadCount:0,Provider:null,Consumer:null},K.Provider=K,K.Consumer={$$typeof:r,_context:K},K},m0.createElement=function(K,se,ge){var Me,le={},Se=null;if(se!=null)for(Me in se.key!==void 0&&(Se=""+se.key),se)R.call(se,Me)&&Me!=="key"&&Me!=="__self"&&Me!=="__source"&&(le[Me]=se[Me]);var Fe=arguments.length-2;if(Fe===1)le.children=ge;else if(1<Fe){for(var Qe=Array(Fe),qe=0;qe<Fe;qe++)Qe[qe]=arguments[qe+2];le.children=Qe}if(K&&K.defaultProps)for(Me in Fe=K.defaultProps,Fe)le[Me]===void 0&&(le[Me]=Fe[Me]);return C(K,Se,void 0,void 0,null,le)},m0.createRef=function(){return{current:null}},m0.forwardRef=function(K){return{$$typeof:s,render:K}},m0.isValidElement=P,m0.lazy=function(K){return{$$typeof:h,_payload:{_status:-1,_result:K},_init:re}},m0.memo=function(K,se){return{$$typeof:c,type:K,compare:se===void 0?null:se}},m0.startTransition=function(K){var se=M.T,ge={};M.T=ge;try{var Me=K(),le=M.S;le!==null&&le(ge,Me),typeof Me=="object"&&Me!==null&&typeof Me.then=="function"&&Me.then(be,q)}catch(Se){q(Se)}finally{M.T=se}},m0.unstable_useCacheRefresh=function(){return M.H.useCacheRefresh()},m0.use=function(K){return M.H.use(K)},m0.useActionState=function(K,se,ge){return M.H.useActionState(K,se,ge)},m0.useCallback=function(K,se){return M.H.useCallback(K,se)},m0.useContext=function(K){return M.H.useContext(K)},m0.useDebugValue=function(){},m0.useDeferredValue=function(K,se){return M.H.useDeferredValue(K,se)},m0.useEffect=function(K,se,ge){var Me=M.H;if(typeof ge=="function")throw Error("useEffect CRUD overload is not enabled in this build of React.");return Me.useEffect(K,se)},m0.useId=function(){return M.H.useId()},m0.useImperativeHandle=function(K,se,ge){return M.H.useImperativeHandle(K,se,ge)},m0.useInsertionEffect=function(K,se){return M.H.useInsertionEffect(K,se)},m0.useLayoutEffect=function(K,se){return M.H.useLayoutEffect(K,se)},m0.useMemo=function(K,se){return M.H.useMemo(K,se)},m0.useOptimistic=function(K,se){return M.H.useOptimistic(K,se)},m0.useReducer=function(K,se,ge){return M.H.useReducer(K,se,ge)},m0.useRef=function(K){return M.H.useRef(K)},m0.useState=function(K){return M.H.useState(K)},m0.useSyncExternalStore=function(K,se,ge){return M.H.useSyncExternalStore(K,se,ge)},m0.useTransition=function(){return M.H.useTransition()},m0.version="19.1.0",m0}var KN;function Zw(){return KN||(KN=1,s_.exports=A5()),s_.exports}var Jn=Zw();const hx=w5(Jn);var o_={exports:{}},xf={},l_={exports:{}},c_={};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var $N;function E5(){return $N||($N=1,function(x){function e(H,re){var q=H.length;H.push(re);e:for(;0<q;){var be=q-1>>>1,K=H[be];if(0<i(K,re))H[be]=re,H[q]=K,q=be;else break e}}function t(H){return H.length===0?null:H[0]}function n(H){if(H.length===0)return null;var re=H[0],q=H.pop();if(q!==re){H[0]=q;e:for(var be=0,K=H.length,se=K>>>1;be<se;){var ge=2*(be+1)-1,Me=H[ge],le=ge+1,Se=H[le];if(0>i(Me,q))le<K&&0>i(Se,Me)?(H[be]=Se,H[le]=q,be=le):(H[be]=Me,H[ge]=q,be=ge);else if(le<K&&0>i(Se,q))H[be]=Se,H[le]=q,be=le;else break e}}return re}function i(H,re){var q=H.sortIndex-re.sortIndex;return q!==0?q:H.id-re.id}if(x.unstable_now=void 0,typeof performance=="object"&&typeof performance.now=="function"){var r=performance;x.unstable_now=function(){return r.now()}}else{var a=Date,s=a.now();x.unstable_now=function(){return a.now()-s}}var l=[],c=[],h=1,d=null,p=3,m=!1,g=!1,_=!1,v=!1,b=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,E=typeof setImmediate<"u"?setImmediate:null;function A(H){for(var re=t(c);re!==null;){if(re.callback===null)n(c);else if(re.startTime<=H)n(c),re.sortIndex=re.expirationTime,e(l,re);else break;re=t(c)}}function M(H){if(_=!1,A(H),!g)if(t(l)!==null)g=!0,R||(R=!0,te());else{var re=t(c);re!==null&&ae(M,re.startTime-H)}}var R=!1,C=-1,k=5,P=-1;function N(){return v?!0:!(x.unstable_now()-P<k)}function G(){if(v=!1,R){var H=x.unstable_now();P=H;var re=!0;try{e:{g=!1,_&&(_=!1,T(C),C=-1),m=!0;var q=p;try{t:{for(A(H),d=t(l);d!==null&&!(d.expirationTime>H&&N());){var be=d.callback;if(typeof be=="function"){d.callback=null,p=d.priorityLevel;var K=be(d.expirationTime<=H);if(H=x.unstable_now(),typeof K=="function"){d.callback=K,A(H),re=!0;break t}d===t(l)&&n(l),A(H)}else n(l);d=t(l)}if(d!==null)re=!0;else{var se=t(c);se!==null&&ae(M,se.startTime-H),re=!1}}break e}finally{d=null,p=q,m=!1}re=void 0}}finally{re?te():R=!1}}}var te;if(typeof E=="function")te=function(){E(G)};else if(typeof MessageChannel<"u"){var j=new MessageChannel,xe=j.port2;j.port1.onmessage=G,te=function(){xe.postMessage(null)}}else te=function(){b(G,0)};function ae(H,re){C=b(function(){H(x.unstable_now())},re)}x.unstable_IdlePriority=5,x.unstable_ImmediatePriority=1,x.unstable_LowPriority=4,x.unstable_NormalPriority=3,x.unstable_Profiling=null,x.unstable_UserBlockingPriority=2,x.unstable_cancelCallback=function(H){H.callback=null},x.unstable_forceFrameRate=function(H){0>H||125<H?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<H?Math.floor(1e3/H):5},x.unstable_getCurrentPriorityLevel=function(){return p},x.unstable_next=function(H){switch(p){case 1:case 2:case 3:var re=3;break;default:re=p}var q=p;p=re;try{return H()}finally{p=q}},x.unstable_requestPaint=function(){v=!0},x.unstable_runWithPriority=function(H,re){switch(H){case 1:case 2:case 3:case 4:case 5:break;default:H=3}var q=p;p=H;try{return re()}finally{p=q}},x.unstable_scheduleCallback=function(H,re,q){var be=x.unstable_now();switch(typeof q=="object"&&q!==null?(q=q.delay,q=typeof q=="number"&&0<q?be+q:be):q=be,H){case 1:var K=-1;break;case 2:K=250;break;case 5:K=1073741823;break;case 4:K=1e4;break;default:K=5e3}return K=q+K,H={id:h++,callback:re,priorityLevel:H,startTime:q,expirationTime:K,sortIndex:-1},q>be?(H.sortIndex=q,e(c,H),t(l)===null&&H===t(c)&&(_?(T(C),C=-1):_=!0,ae(M,q-be))):(H.sortIndex=K,e(l,H),g||m||(g=!0,R||(R=!0,te()))),H},x.unstable_shouldYield=N,x.unstable_wrapCallback=function(H){var re=p;return function(){var q=p;p=re;try{return H.apply(this,arguments)}finally{p=q}}}}(c_)),c_}var QN;function M5(){return QN||(QN=1,l_.exports=E5()),l_.exports}var u_={exports:{}},ni={};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ZN;function R5(){if(ZN)return ni;ZN=1;var x=Zw();function e(l){var c="https://react.dev/errors/"+l;if(1<arguments.length){c+="?args[]="+encodeURIComponent(arguments[1]);for(var h=2;h<arguments.length;h++)c+="&args[]="+encodeURIComponent(arguments[h])}return"Minified React error #"+l+"; visit "+c+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function t(){}var n={d:{f:t,r:function(){throw Error(e(522))},D:t,C:t,L:t,m:t,X:t,S:t,M:t},p:0,findDOMNode:null},i=Symbol.for("react.portal");function r(l,c,h){var d=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:i,key:d==null?null:""+d,children:l,containerInfo:c,implementation:h}}var a=x.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;function s(l,c){if(l==="font")return"";if(typeof c=="string")return c==="use-credentials"?c:""}return ni.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE=n,ni.createPortal=function(l,c){var h=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!c||c.nodeType!==1&&c.nodeType!==9&&c.nodeType!==11)throw Error(e(299));return r(l,c,null,h)},ni.flushSync=function(l){var c=a.T,h=n.p;try{if(a.T=null,n.p=2,l)return l()}finally{a.T=c,n.p=h,n.d.f()}},ni.preconnect=function(l,c){typeof l=="string"&&(c?(c=c.crossOrigin,c=typeof c=="string"?c==="use-credentials"?c:"":void 0):c=null,n.d.C(l,c))},ni.prefetchDNS=function(l){typeof l=="string"&&n.d.D(l)},ni.preinit=function(l,c){if(typeof l=="string"&&c&&typeof c.as=="string"){var h=c.as,d=s(h,c.crossOrigin),p=typeof c.integrity=="string"?c.integrity:void 0,m=typeof c.fetchPriority=="string"?c.fetchPriority:void 0;h==="style"?n.d.S(l,typeof c.precedence=="string"?c.precedence:void 0,{crossOrigin:d,integrity:p,fetchPriority:m}):h==="script"&&n.d.X(l,{crossOrigin:d,integrity:p,fetchPriority:m,nonce:typeof c.nonce=="string"?c.nonce:void 0})}},ni.preinitModule=function(l,c){if(typeof l=="string")if(typeof c=="object"&&c!==null){if(c.as==null||c.as==="script"){var h=s(c.as,c.crossOrigin);n.d.M(l,{crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0})}}else c==null&&n.d.M(l)},ni.preload=function(l,c){if(typeof l=="string"&&typeof c=="object"&&c!==null&&typeof c.as=="string"){var h=c.as,d=s(h,c.crossOrigin);n.d.L(l,h,{crossOrigin:d,integrity:typeof c.integrity=="string"?c.integrity:void 0,nonce:typeof c.nonce=="string"?c.nonce:void 0,type:typeof c.type=="string"?c.type:void 0,fetchPriority:typeof c.fetchPriority=="string"?c.fetchPriority:void 0,referrerPolicy:typeof c.referrerPolicy=="string"?c.referrerPolicy:void 0,imageSrcSet:typeof c.imageSrcSet=="string"?c.imageSrcSet:void 0,imageSizes:typeof c.imageSizes=="string"?c.imageSizes:void 0,media:typeof c.media=="string"?c.media:void 0})}},ni.preloadModule=function(l,c){if(typeof l=="string")if(c){var h=s(c.as,c.crossOrigin);n.d.m(l,{as:typeof c.as=="string"&&c.as!=="script"?c.as:void 0,crossOrigin:h,integrity:typeof c.integrity=="string"?c.integrity:void 0})}else n.d.m(l)},ni.requestFormReset=function(l){n.d.r(l)},ni.unstable_batchedUpdates=function(l,c){return l(c)},ni.useFormState=function(l,c,h){return a.H.useFormState(l,c,h)},ni.useFormStatus=function(){return a.H.useHostTransitionStatus()},ni.version="19.1.0",ni}var JN;function C5(){if(JN)return u_.exports;JN=1;function x(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(x)}catch(e){console.error(e)}}return x(),u_.exports=R5(),u_.exports}/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jN;function N5(){if(jN)return xf;jN=1;var x=M5(),e=Zw(),t=C5();function n(o){var u="https://react.dev/errors/"+o;if(1<arguments.length){u+="?args[]="+encodeURIComponent(arguments[1]);for(var f=2;f<arguments.length;f++)u+="&args[]="+encodeURIComponent(arguments[f])}return"Minified React error #"+o+"; visit "+u+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}function i(o){return!(!o||o.nodeType!==1&&o.nodeType!==9&&o.nodeType!==11)}function r(o){var u=o,f=o;if(o.alternate)for(;u.return;)u=u.return;else{o=u;do u=o,(u.flags&4098)!==0&&(f=u.return),o=u.return;while(o)}return u.tag===3?f:null}function a(o){if(o.tag===13){var u=o.memoizedState;if(u===null&&(o=o.alternate,o!==null&&(u=o.memoizedState)),u!==null)return u.dehydrated}return null}function s(o){if(r(o)!==o)throw Error(n(188))}function l(o){var u=o.alternate;if(!u){if(u=r(o),u===null)throw Error(n(188));return u!==o?null:o}for(var f=o,y=u;;){var S=f.return;if(S===null)break;var w=S.alternate;if(w===null){if(y=S.return,y!==null){f=y;continue}break}if(S.child===w.child){for(w=S.child;w;){if(w===f)return s(S),o;if(w===y)return s(S),u;w=w.sibling}throw Error(n(188))}if(f.return!==y.return)f=S,y=w;else{for(var B=!1,W=S.child;W;){if(W===f){B=!0,f=S,y=w;break}if(W===y){B=!0,y=S,f=w;break}W=W.sibling}if(!B){for(W=w.child;W;){if(W===f){B=!0,f=w,y=S;break}if(W===y){B=!0,y=w,f=S;break}W=W.sibling}if(!B)throw Error(n(189))}}if(f.alternate!==y)throw Error(n(190))}if(f.tag!==3)throw Error(n(188));return f.stateNode.current===f?o:u}function c(o){var u=o.tag;if(u===5||u===26||u===27||u===6)return o;for(o=o.child;o!==null;){if(u=c(o),u!==null)return u;o=o.sibling}return null}var h=Object.assign,d=Symbol.for("react.element"),p=Symbol.for("react.transitional.element"),m=Symbol.for("react.portal"),g=Symbol.for("react.fragment"),_=Symbol.for("react.strict_mode"),v=Symbol.for("react.profiler"),b=Symbol.for("react.provider"),T=Symbol.for("react.consumer"),E=Symbol.for("react.context"),A=Symbol.for("react.forward_ref"),M=Symbol.for("react.suspense"),R=Symbol.for("react.suspense_list"),C=Symbol.for("react.memo"),k=Symbol.for("react.lazy"),P=Symbol.for("react.activity"),N=Symbol.for("react.memo_cache_sentinel"),G=Symbol.iterator;function te(o){return o===null||typeof o!="object"?null:(o=G&&o[G]||o["@@iterator"],typeof o=="function"?o:null)}var j=Symbol.for("react.client.reference");function xe(o){if(o==null)return null;if(typeof o=="function")return o.$$typeof===j?null:o.displayName||o.name||null;if(typeof o=="string")return o;switch(o){case g:return"Fragment";case v:return"Profiler";case _:return"StrictMode";case M:return"Suspense";case R:return"SuspenseList";case P:return"Activity"}if(typeof o=="object")switch(o.$$typeof){case m:return"Portal";case E:return(o.displayName||"Context")+".Provider";case T:return(o._context.displayName||"Context")+".Consumer";case A:var u=o.render;return o=o.displayName,o||(o=u.displayName||u.name||"",o=o!==""?"ForwardRef("+o+")":"ForwardRef"),o;case C:return u=o.displayName||null,u!==null?u:xe(o.type)||"Memo";case k:u=o._payload,o=o._init;try{return xe(o(u))}catch{}}return null}var ae=Array.isArray,H=e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,re=t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,q={pending:!1,data:null,method:null,action:null},be=[],K=-1;function se(o){return{current:o}}function ge(o){0>K||(o.current=be[K],be[K]=null,K--)}function Me(o,u){K++,be[K]=o.current,o.current=u}var le=se(null),Se=se(null),Fe=se(null),Qe=se(null);function qe(o,u){switch(Me(Fe,u),Me(Se,o),Me(le,null),u.nodeType){case 9:case 11:o=(o=u.documentElement)&&(o=o.namespaceURI)?bN(o):0;break;default:if(o=u.tagName,u=u.namespaceURI)u=bN(u),o=_N(u,o);else switch(o){case"svg":o=1;break;case"math":o=2;break;default:o=0}}ge(le),Me(le,o)}function Et(){ge(le),ge(Se),ge(Fe)}function Tt(o){o.memoizedState!==null&&Me(Qe,o);var u=le.current,f=_N(u,o.type);u!==f&&(Me(Se,o),Me(le,f))}function Bt(o){Se.current===o&&(ge(le),ge(Se)),Qe.current===o&&(ge(Qe),Jd._currentValue=q)}var Q=Object.prototype.hasOwnProperty,rt=x.unstable_scheduleCallback,He=x.unstable_cancelCallback,at=x.unstable_shouldYield,Ue=x.unstable_requestPaint,bt=x.unstable_now,ht=x.unstable_getCurrentPriorityLevel,dt=x.unstable_ImmediatePriority,Z=x.unstable_UserBlockingPriority,V=x.unstable_NormalPriority,_e=x.unstable_LowPriority,Ge=x.unstable_IdlePriority,Re=x.log,Ve=x.unstable_setDisableYieldValue,_t=null,Ce=null;function pt(o){if(typeof Re=="function"&&Ve(o),Ce&&typeof Ce.setStrictMode=="function")try{Ce.setStrictMode(_t,o)}catch{}}var et=Math.clz32?Math.clz32:i0,tt=Math.log,gt=Math.LN2;function i0(o){return o>>>=0,o===0?32:31-(tt(o)/gt|0)|0}var Ht=256,St=4194304;function Ut(o){var u=o&42;if(u!==0)return u;switch(o&-o){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:return 64;case 128:return 128;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return o&4194048;case 4194304:case 8388608:case 16777216:case 33554432:return o&62914560;case 67108864:return 67108864;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 0;default:return o}}function t0(o,u,f){var y=o.pendingLanes;if(y===0)return 0;var S=0,w=o.suspendedLanes,B=o.pingedLanes;o=o.warmLanes;var W=y&134217727;return W!==0?(y=W&~w,y!==0?S=Ut(y):(B&=W,B!==0?S=Ut(B):f||(f=W&~o,f!==0&&(S=Ut(f))))):(W=y&~w,W!==0?S=Ut(W):B!==0?S=Ut(B):f||(f=y&~o,f!==0&&(S=Ut(f)))),S===0?0:u!==0&&u!==S&&(u&w)===0&&(w=S&-S,f=u&-u,w>=f||w===32&&(f&4194048)!==0)?u:S}function p0(o,u){return(o.pendingLanes&~(o.suspendedLanes&~o.pingedLanes)&u)===0}function de(o,u){switch(o){case 1:case 2:case 4:case 8:case 64:return u+250;case 16:case 32:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return u+5e3;case 4194304:case 8388608:case 16777216:case 33554432:return-1;case 67108864:case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function ft(){var o=Ht;return Ht<<=1,(Ht&4194048)===0&&(Ht=256),o}function Xe(){var o=St;return St<<=1,(St&62914560)===0&&(St=4194304),o}function Ze(o){for(var u=[],f=0;31>f;f++)u.push(o);return u}function lt(o,u){o.pendingLanes|=u,u!==268435456&&(o.suspendedLanes=0,o.pingedLanes=0,o.warmLanes=0)}function Wt(o,u,f,y,S,w){var B=o.pendingLanes;o.pendingLanes=f,o.suspendedLanes=0,o.pingedLanes=0,o.warmLanes=0,o.expiredLanes&=f,o.entangledLanes&=f,o.errorRecoveryDisabledLanes&=f,o.shellSuspendCounter=0;var W=o.entanglements,ie=o.expirationTimes,Ee=o.hiddenUpdates;for(f=B&~f;0<f;){var Ke=31-et(f),nt=1<<Ke;W[Ke]=0,ie[Ke]=-1;var De=Ee[Ke];if(De!==null)for(Ee[Ke]=null,Ke=0;Ke<De.length;Ke++){var ke=De[Ke];ke!==null&&(ke.lane&=-536870913)}f&=~nt}y!==0&&Qt(o,y,0),w!==0&&S===0&&o.tag!==0&&(o.suspendedLanes|=w&~(B&~u))}function Qt(o,u,f){o.pendingLanes|=u,o.suspendedLanes&=~u;var y=31-et(u);o.entangledLanes|=u,o.entanglements[y]=o.entanglements[y]|1073741824|f&4194090}function D0(o,u){var f=o.entangledLanes|=u;for(o=o.entanglements;f;){var y=31-et(f),S=1<<y;S&u|o[y]&u&&(o[y]|=u),f&=~S}}function P0(o){switch(o){case 2:o=1;break;case 8:o=4;break;case 32:o=16;break;case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:o=128;break;case 268435456:o=134217728;break;default:o=0}return o}function s0(o){return o&=-o,2<o?8<o?(o&134217727)!==0?32:268435456:8:2}function rn(){var o=re.p;return o!==0?o:(o=window.event,o===void 0?32:zN(o.type))}function Cx(o,u){var f=re.p;try{return re.p=o,u()}finally{re.p=f}}var ax=Math.random().toString(36).slice(2),L0="__reactFiber$"+ax,R0="__reactProps$"+ax,Wn="__reactContainer$"+ax,q0="__reactEvents$"+ax,Fx="__reactListeners$"+ax,gn="__reactHandles$"+ax,mi="__reactResources$"+ax,yi="__reactMarker$"+ax;function Gr(o){delete o[L0],delete o[R0],delete o[q0],delete o[Fx],delete o[gn]}function Ii(o){var u=o[L0];if(u)return u;for(var f=o.parentNode;f;){if(u=f[Wn]||f[L0]){if(f=u.alternate,u.child!==null||f!==null&&f.child!==null)for(o=AN(o);o!==null;){if(f=o[L0])return f;o=AN(o)}return u}o=f,f=o.parentNode}return null}function Oi(o){if(o=o[L0]||o[Wn]){var u=o.tag;if(u===5||u===6||u===13||u===26||u===27||u===3)return o}return null}function vn(o){var u=o.tag;if(u===5||u===26||u===27||u===6)return o.stateNode;throw Error(n(33))}function Y(o){var u=o[mi];return u||(u=o[mi]={hoistableStyles:new Map,hoistableScripts:new Map}),u}function ce(o){o[yi]=!0}var Ne=new Set,Ie={};function fe(o,u){ct(o,u),ct(o+"Capture",u)}function ct(o,u){for(Ie[o]=u,o=0;o<u.length;o++)Ne.add(u[o])}var wt=RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),It={},Ct={};function Kt(o){return Q.call(Ct,o)?!0:Q.call(It,o)?!1:wt.test(o)?Ct[o]=!0:(It[o]=!0,!1)}function Ft(o,u,f){if(Kt(u))if(f===null)o.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":o.removeAttribute(u);return;case"boolean":var y=u.toLowerCase().slice(0,5);if(y!=="data-"&&y!=="aria-"){o.removeAttribute(u);return}}o.setAttribute(u,""+f)}}function Dt(o,u,f){if(f===null)o.removeAttribute(u);else{switch(typeof f){case"undefined":case"function":case"symbol":case"boolean":o.removeAttribute(u);return}o.setAttribute(u,""+f)}}function Zt(o,u,f,y){if(y===null)o.removeAttribute(f);else{switch(typeof y){case"undefined":case"function":case"symbol":case"boolean":o.removeAttribute(f);return}o.setAttributeNS(u,f,""+y)}}var v0,h0;function sx(o){if(v0===void 0)try{throw Error()}catch(f){var u=f.stack.trim().match(/\n( *(at )?)/);v0=u&&u[1]||"",h0=-1<f.stack.indexOf(`
    at`)?" (<anonymous>)":-1<f.stack.indexOf("@")?"@unknown:0:0":""}return`
`+v0+o+h0}var d0=!1;function Ot(o,u){if(!o||d0)return"";d0=!0;var f=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{var y={DetermineComponentFrameRoot:function(){try{if(u){var nt=function(){throw Error()};if(Object.defineProperty(nt.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(nt,[])}catch(ke){var De=ke}Reflect.construct(o,[],nt)}else{try{nt.call()}catch(ke){De=ke}o.call(nt.prototype)}}else{try{throw Error()}catch(ke){De=ke}(nt=o())&&typeof nt.catch=="function"&&nt.catch(function(){})}}catch(ke){if(ke&&De&&typeof ke.stack=="string")return[ke.stack,De.stack]}return[null,null]}};y.DetermineComponentFrameRoot.displayName="DetermineComponentFrameRoot";var S=Object.getOwnPropertyDescriptor(y.DetermineComponentFrameRoot,"name");S&&S.configurable&&Object.defineProperty(y.DetermineComponentFrameRoot,"name",{value:"DetermineComponentFrameRoot"});var w=y.DetermineComponentFrameRoot(),B=w[0],W=w[1];if(B&&W){var ie=B.split(`
`),Ee=W.split(`
`);for(S=y=0;y<ie.length&&!ie[y].includes("DetermineComponentFrameRoot");)y++;for(;S<Ee.length&&!Ee[S].includes("DetermineComponentFrameRoot");)S++;if(y===ie.length||S===Ee.length)for(y=ie.length-1,S=Ee.length-1;1<=y&&0<=S&&ie[y]!==Ee[S];)S--;for(;1<=y&&0<=S;y--,S--)if(ie[y]!==Ee[S]){if(y!==1||S!==1)do if(y--,S--,0>S||ie[y]!==Ee[S]){var Ke=`
`+ie[y].replace(" at new "," at ");return o.displayName&&Ke.includes("<anonymous>")&&(Ke=Ke.replace("<anonymous>",o.displayName)),Ke}while(1<=y&&0<=S);break}}}finally{d0=!1,Error.prepareStackTrace=f}return(f=o?o.displayName||o.name:"")?sx(f):""}function $0(o){switch(o.tag){case 26:case 27:case 5:return sx(o.type);case 16:return sx("Lazy");case 13:return sx("Suspense");case 19:return sx("SuspenseList");case 0:case 15:return Ot(o.type,!1);case 11:return Ot(o.type.render,!1);case 1:return Ot(o.type,!0);case 31:return sx("Activity");default:return""}}function y0(o){try{var u="";do u+=$0(o),o=o.return;while(o);return u}catch(f){return`
Error generating stack: `+f.message+`
`+f.stack}}function U0(o){switch(typeof o){case"bigint":case"boolean":case"number":case"string":case"undefined":return o;case"object":return o;default:return""}}function gi(o){var u=o.type;return(o=o.nodeName)&&o.toLowerCase()==="input"&&(u==="checkbox"||u==="radio")}function Bx(o){var u=gi(o)?"checked":"value",f=Object.getOwnPropertyDescriptor(o.constructor.prototype,u),y=""+o[u];if(!o.hasOwnProperty(u)&&typeof f<"u"&&typeof f.get=="function"&&typeof f.set=="function"){var S=f.get,w=f.set;return Object.defineProperty(o,u,{configurable:!0,get:function(){return S.call(this)},set:function(B){y=""+B,w.call(this,B)}}),Object.defineProperty(o,u,{enumerable:f.enumerable}),{getValue:function(){return y},setValue:function(B){y=""+B},stopTracking:function(){o._valueTracker=null,delete o[u]}}}}function Di(o){o._valueTracker||(o._valueTracker=Bx(o))}function Q0(o){if(!o)return!1;var u=o._valueTracker;if(!u)return!0;var f=u.getValue(),y="";return o&&(y=gi(o)?o.checked?"true":"false":o.value),o=y,o!==f?(u.setValue(o),!0):!1}function bn(o){if(o=o||(typeof document<"u"?document:void 0),typeof o>"u")return null;try{return o.activeElement||o.body}catch{return o.body}}var vi=/[\n"\\]/g;function T0(o){return o.replace(vi,function(u){return"\\"+u.charCodeAt(0).toString(16)+" "})}function Xn(o,u,f,y,S,w,B,W){o.name="",B!=null&&typeof B!="function"&&typeof B!="symbol"&&typeof B!="boolean"?o.type=B:o.removeAttribute("type"),u!=null?B==="number"?(u===0&&o.value===""||o.value!=u)&&(o.value=""+U0(u)):o.value!==""+U0(u)&&(o.value=""+U0(u)):B!=="submit"&&B!=="reset"||o.removeAttribute("value"),u!=null?Pi(o,B,U0(u)):f!=null?Pi(o,B,U0(f)):y!=null&&o.removeAttribute("value"),S==null&&w!=null&&(o.defaultChecked=!!w),S!=null&&(o.checked=S&&typeof S!="function"&&typeof S!="symbol"),W!=null&&typeof W!="function"&&typeof W!="symbol"&&typeof W!="boolean"?o.name=""+U0(W):o.removeAttribute("name")}function Nx(o,u,f,y,S,w,B,W){if(w!=null&&typeof w!="function"&&typeof w!="symbol"&&typeof w!="boolean"&&(o.type=w),u!=null||f!=null){if(!(w!=="submit"&&w!=="reset"||u!=null))return;f=f!=null?""+U0(f):"",u=u!=null?""+U0(u):f,W||u===o.value||(o.value=u),o.defaultValue=u}y=y??S,y=typeof y!="function"&&typeof y!="symbol"&&!!y,o.checked=W?o.checked:!!y,o.defaultChecked=!!y,B!=null&&typeof B!="function"&&typeof B!="symbol"&&typeof B!="boolean"&&(o.name=B)}function Pi(o,u,f){u==="number"&&bn(o.ownerDocument)===o||o.defaultValue===""+f||(o.defaultValue=""+f)}function bi(o,u,f,y){if(o=o.options,u){u={};for(var S=0;S<f.length;S++)u["$"+f[S]]=!0;for(f=0;f<o.length;f++)S=u.hasOwnProperty("$"+o[f].value),o[f].selected!==S&&(o[f].selected=S),S&&y&&(o[f].defaultSelected=!0)}else{for(f=""+U0(f),u=null,S=0;S<o.length;S++){if(o[S].value===f){o[S].selected=!0,y&&(o[S].defaultSelected=!0);return}u!==null||o[S].disabled||(u=o[S])}u!==null&&(u.selected=!0)}}function Ko(o,u,f){if(u!=null&&(u=""+U0(u),u!==o.value&&(o.value=u),f==null)){o.defaultValue!==u&&(o.defaultValue=u);return}o.defaultValue=f!=null?""+U0(f):""}function Lx(o,u,f,y){if(u==null){if(y!=null){if(f!=null)throw Error(n(92));if(ae(y)){if(1<y.length)throw Error(n(93));y=y[0]}f=y}f==null&&(f=""),u=f}f=U0(u),o.defaultValue=f,y=o.textContent,y===f&&y!==""&&y!==null&&(o.value=y)}function ki(o,u){if(u){var f=o.firstChild;if(f&&f===o.lastChild&&f.nodeType===3){f.nodeValue=u;return}}o.textContent=u}var yl=new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));function Wr(o,u,f){var y=u.indexOf("--")===0;f==null||typeof f=="boolean"||f===""?y?o.setProperty(u,""):u==="float"?o.cssFloat="":o[u]="":y?o.setProperty(u,f):typeof f!="number"||f===0||yl.has(u)?u==="float"?o.cssFloat=f:o[u]=(""+f).trim():o[u]=f+"px"}function $o(o,u,f){if(u!=null&&typeof u!="object")throw Error(n(62));if(o=o.style,f!=null){for(var y in f)!f.hasOwnProperty(y)||u!=null&&u.hasOwnProperty(y)||(y.indexOf("--")===0?o.setProperty(y,""):y==="float"?o.cssFloat="":o[y]="");for(var S in u)y=u[S],u.hasOwnProperty(S)&&f[S]!==y&&Wr(o,S,y)}else for(var w in u)u.hasOwnProperty(w)&&Wr(o,w,u[w])}function Fs(o){if(o.indexOf("-")===-1)return!1;switch(o){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var gl=new Map([["acceptCharset","accept-charset"],["htmlFor","for"],["httpEquiv","http-equiv"],["crossOrigin","crossorigin"],["accentHeight","accent-height"],["alignmentBaseline","alignment-baseline"],["arabicForm","arabic-form"],["baselineShift","baseline-shift"],["capHeight","cap-height"],["clipPath","clip-path"],["clipRule","clip-rule"],["colorInterpolation","color-interpolation"],["colorInterpolationFilters","color-interpolation-filters"],["colorProfile","color-profile"],["colorRendering","color-rendering"],["dominantBaseline","dominant-baseline"],["enableBackground","enable-background"],["fillOpacity","fill-opacity"],["fillRule","fill-rule"],["floodColor","flood-color"],["floodOpacity","flood-opacity"],["fontFamily","font-family"],["fontSize","font-size"],["fontSizeAdjust","font-size-adjust"],["fontStretch","font-stretch"],["fontStyle","font-style"],["fontVariant","font-variant"],["fontWeight","font-weight"],["glyphName","glyph-name"],["glyphOrientationHorizontal","glyph-orientation-horizontal"],["glyphOrientationVertical","glyph-orientation-vertical"],["horizAdvX","horiz-adv-x"],["horizOriginX","horiz-origin-x"],["imageRendering","image-rendering"],["letterSpacing","letter-spacing"],["lightingColor","lighting-color"],["markerEnd","marker-end"],["markerMid","marker-mid"],["markerStart","marker-start"],["overlinePosition","overline-position"],["overlineThickness","overline-thickness"],["paintOrder","paint-order"],["panose-1","panose-1"],["pointerEvents","pointer-events"],["renderingIntent","rendering-intent"],["shapeRendering","shape-rendering"],["stopColor","stop-color"],["stopOpacity","stop-opacity"],["strikethroughPosition","strikethrough-position"],["strikethroughThickness","strikethrough-thickness"],["strokeDasharray","stroke-dasharray"],["strokeDashoffset","stroke-dashoffset"],["strokeLinecap","stroke-linecap"],["strokeLinejoin","stroke-linejoin"],["strokeMiterlimit","stroke-miterlimit"],["strokeOpacity","stroke-opacity"],["strokeWidth","stroke-width"],["textAnchor","text-anchor"],["textDecoration","text-decoration"],["textRendering","text-rendering"],["transformOrigin","transform-origin"],["underlinePosition","underline-position"],["underlineThickness","underline-thickness"],["unicodeBidi","unicode-bidi"],["unicodeRange","unicode-range"],["unitsPerEm","units-per-em"],["vAlphabetic","v-alphabetic"],["vHanging","v-hanging"],["vIdeographic","v-ideographic"],["vMathematical","v-mathematical"],["vectorEffect","vector-effect"],["vertAdvY","vert-adv-y"],["vertOriginX","vert-origin-x"],["vertOriginY","vert-origin-y"],["wordSpacing","word-spacing"],["writingMode","writing-mode"],["xmlnsXlink","xmlns:xlink"],["xHeight","x-height"]]),vl=/^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;function rs(o){return vl.test(""+o)?"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')":o}var as=null;function _n(o){return o=o.target||o.srcElement||window,o.correspondingUseElement&&(o=o.correspondingUseElement),o.nodeType===3?o.parentNode:o}var nr=null,Ui=null;function Qo(o){var u=Oi(o);if(u&&(o=u.stateNode)){var f=o[R0]||null;e:switch(o=u.stateNode,u.type){case"input":if(Xn(o,f.value,f.defaultValue,f.defaultValue,f.checked,f.defaultChecked,f.type,f.name),u=f.name,f.type==="radio"&&u!=null){for(f=o;f.parentNode;)f=f.parentNode;for(f=f.querySelectorAll('input[name="'+T0(""+u)+'"][type="radio"]'),u=0;u<f.length;u++){var y=f[u];if(y!==o&&y.form===o.form){var S=y[R0]||null;if(!S)throw Error(n(90));Xn(y,S.value,S.defaultValue,S.defaultValue,S.checked,S.defaultChecked,S.type,S.name)}}for(u=0;u<f.length;u++)y=f[u],y.form===o.form&&Q0(y)}break e;case"textarea":Ko(o,f.value,f.defaultValue);break e;case"select":u=f.value,u!=null&&bi(o,!!f.multiple,u,!1)}}}var zx=!1;function Zo(o,u,f){if(zx)return o(u,f);zx=!0;try{var y=o(u);return y}finally{if(zx=!1,(nr!==null||Ui!==null)&&(pm(),nr&&(u=nr,o=Ui,Ui=nr=null,Qo(u),o)))for(u=0;u<o.length;u++)Qo(o[u])}}function ir(o,u){var f=o.stateNode;if(f===null)return null;var y=f[R0]||null;if(y===null)return null;f=y[u];e:switch(u){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(y=!y.disabled)||(o=o.type,y=!(o==="button"||o==="input"||o==="select"||o==="textarea")),o=!y;break e;default:o=!1}if(o)return null;if(f&&typeof f!="function")throw Error(n(231,u,typeof f));return f}var _i=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),Bs=!1;if(_i)try{var Ma={};Object.defineProperty(Ma,"passive",{get:function(){Bs=!0}}),window.addEventListener("test",Ma,Ma),window.removeEventListener("test",Ma,Ma)}catch{Bs=!1}var Fi=null,Ls=null,ss=null;function Jo(){if(ss)return ss;var o,u=Ls,f=u.length,y,S="value"in Fi?Fi.value:Fi.textContent,w=S.length;for(o=0;o<f&&u[o]===S[o];o++);var B=f-o;for(y=1;y<=B&&u[f-y]===S[w-y];y++);return ss=S.slice(o,1<y?1-y:void 0)}function os(o){var u=o.keyCode;return"charCode"in o?(o=o.charCode,o===0&&u===13&&(o=13)):o=u,o===10&&(o=13),32<=o||o===13?o:0}function ls(){return!0}function zs(){return!1}function an(o){function u(f,y,S,w,B){this._reactName=f,this._targetInst=S,this.type=y,this.nativeEvent=w,this.target=B,this.currentTarget=null;for(var W in o)o.hasOwnProperty(W)&&(f=o[W],this[W]=f?f(w):w[W]);return this.isDefaultPrevented=(w.defaultPrevented!=null?w.defaultPrevented:w.returnValue===!1)?ls:zs,this.isPropagationStopped=zs,this}return h(u.prototype,{preventDefault:function(){this.defaultPrevented=!0;var f=this.nativeEvent;f&&(f.preventDefault?f.preventDefault():typeof f.returnValue!="unknown"&&(f.returnValue=!1),this.isDefaultPrevented=ls)},stopPropagation:function(){var f=this.nativeEvent;f&&(f.stopPropagation?f.stopPropagation():typeof f.cancelBubble!="unknown"&&(f.cancelBubble=!0),this.isPropagationStopped=ls)},persist:function(){},isPersistent:ls}),u}var rr={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(o){return o.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cs=an(rr),Xr=h({},rr,{view:0,detail:0}),jo=an(Xr),Vs,Yn,Sn,Yr=h({},Xr,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:we,button:0,buttons:0,relatedTarget:function(o){return o.relatedTarget===void 0?o.fromElement===o.srcElement?o.toElement:o.fromElement:o.relatedTarget},movementX:function(o){return"movementX"in o?o.movementX:(o!==Sn&&(Sn&&o.type==="mousemove"?(Vs=o.screenX-Sn.screenX,Yn=o.screenY-Sn.screenY):Yn=Vs=0,Sn=o),Vs)},movementY:function(o){return"movementY"in o?o.movementY:Yn}}),Hs=an(Yr),ei=h({},Yr,{dataTransfer:0}),In=an(ei),us=h({},Xr,{relatedTarget:0}),z=an(us),L=h({},rr,{animationName:0,elapsedTime:0,pseudoElement:0}),ne=an(L),Te=h({},rr,{clipboardData:function(o){return"clipboardData"in o?o.clipboardData:window.clipboardData}}),D=an(Te),U=h({},rr,{data:0}),X=an(U),J={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},ue={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},pe={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function ve(o){var u=this.nativeEvent;return u.getModifierState?u.getModifierState(o):(o=pe[o])?!!u[o]:!1}function we(){return ve}var $e=h({},Xr,{key:function(o){if(o.key){var u=J[o.key]||o.key;if(u!=="Unidentified")return u}return o.type==="keypress"?(o=os(o),o===13?"Enter":String.fromCharCode(o)):o.type==="keydown"||o.type==="keyup"?ue[o.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:we,charCode:function(o){return o.type==="keypress"?os(o):0},keyCode:function(o){return o.type==="keydown"||o.type==="keyup"?o.keyCode:0},which:function(o){return o.type==="keypress"?os(o):o.type==="keydown"||o.type==="keyup"?o.keyCode:0}}),st=an($e),ot=h({},Yr,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Gt=an(ot),r0=h({},Xr,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:we}),c0=an(r0),F0=h({},rr,{propertyName:0,elapsedTime:0,pseudoElement:0}),Y0=an(F0),b0=h({},Yr,{deltaX:function(o){return"deltaX"in o?o.deltaX:"wheelDeltaX"in o?-o.wheelDeltaX:0},deltaY:function(o){return"deltaY"in o?o.deltaY:"wheelDeltaY"in o?-o.wheelDeltaY:"wheelDelta"in o?-o.wheelDelta:0},deltaZ:0,deltaMode:0}),z0=an(b0),Vx=h({},rr,{newState:0,oldState:0}),Tn=an(Vx),sn=[9,13,27,32],Kn=_i&&"CompositionEvent"in window,Kr=null;_i&&"documentMode"in document&&(Kr=document.documentMode);var zc=_i&&"TextEvent"in window&&!Kr,qo=_i&&(!Kn||Kr&&8<Kr&&11>=Kr),bl=" ",ti=!1;function Gs(o,u){switch(o){case"keyup":return sn.indexOf(u.keyCode)!==-1;case"keydown":return u.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function ar(o){return o=o.detail,typeof o=="object"&&"data"in o?o.data:null}var Ws=!1;function kp(o,u){switch(o){case"compositionend":return ar(u);case"keypress":return u.which!==32?null:(ti=!0,bl);case"textInput":return o=u.data,o===bl&&ti?null:o;default:return null}}function Vc(o,u){if(Ws)return o==="compositionend"||!Kn&&Gs(o,u)?(o=Jo(),ss=Ls=Fi=null,Ws=!1,o):null;switch(o){case"paste":return null;case"keypress":if(!(u.ctrlKey||u.altKey||u.metaKey)||u.ctrlKey&&u.altKey){if(u.char&&1<u.char.length)return u.char;if(u.which)return String.fromCharCode(u.which)}return null;case"compositionend":return qo&&u.locale!=="ko"?null:u.data;default:return null}}var Up={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function F(o){var u=o&&o.nodeName&&o.nodeName.toLowerCase();return u==="input"?!!Up[o.type]:u==="textarea"}function O(o,u,f,y){nr?Ui?Ui.push(y):Ui=[y]:nr=y,u=_m(u,"onChange"),0<u.length&&(f=new cs("onChange","change",null,f,y),o.push({event:f,listeners:u}))}var $=null,oe=null;function Oe(o){pN(o,0)}function Le(o){var u=vn(o);if(Q0(u))return o}function Ye(o,u){if(o==="change")return u}var ze=!1;if(_i){var yt;if(_i){var Mt="oninput"in document;if(!Mt){var vt=document.createElement("div");vt.setAttribute("oninput","return;"),Mt=typeof vt.oninput=="function"}yt=Mt}else yt=!1;ze=yt&&(!document.documentMode||9<document.documentMode)}function a0(){$&&($.detachEvent("onpropertychange",e0),oe=$=null)}function e0(o){if(o.propertyName==="value"&&Le(oe)){var u=[];O(u,oe,o,_n(o)),Zo(Oe,u)}}function w0(o,u,f){o==="focusin"?(a0(),$=u,oe=f,$.attachEvent("onpropertychange",e0)):o==="focusout"&&a0()}function ox(o){if(o==="selectionchange"||o==="keyup"||o==="keydown")return Le(oe)}function gx(o,u){if(o==="click")return Le(u)}function vx(o,u){if(o==="input"||o==="change")return Le(u)}function bx(o,u){return o===u&&(o!==0||1/o===1/u)||o!==o&&u!==u}var xt=typeof Object.is=="function"?Object.is:bx;function Vt(o,u){if(xt(o,u))return!0;if(typeof o!="object"||o===null||typeof u!="object"||u===null)return!1;var f=Object.keys(o),y=Object.keys(u);if(f.length!==y.length)return!1;for(y=0;y<f.length;y++){var S=f[y];if(!Q.call(u,S)||!xt(o[S],u[S]))return!1}return!0}function V0(o){for(;o&&o.firstChild;)o=o.firstChild;return o}function Z0(o,u){var f=V0(o);o=0;for(var y;f;){if(f.nodeType===3){if(y=o+f.textContent.length,o<=u&&y>=u)return{node:f,offset:u-o};o=y}e:{for(;f;){if(f.nextSibling){f=f.nextSibling;break e}f=f.parentNode}f=void 0}f=V0(f)}}function Xt(o,u){return o&&u?o===u?!0:o&&o.nodeType===3?!1:u&&u.nodeType===3?Xt(o,u.parentNode):"contains"in o?o.contains(u):o.compareDocumentPosition?!!(o.compareDocumentPosition(u)&16):!1:!1}function $r(o){o=o!=null&&o.ownerDocument!=null&&o.ownerDocument.defaultView!=null?o.ownerDocument.defaultView:window;for(var u=bn(o.document);u instanceof o.HTMLIFrameElement;){try{var f=typeof u.contentWindow.location.href=="string"}catch{f=!1}if(f)o=u.contentWindow;else break;u=bn(o.document)}return u}function sr(o){var u=o&&o.nodeName&&o.nodeName.toLowerCase();return u&&(u==="input"&&(o.type==="text"||o.type==="search"||o.type==="tel"||o.type==="url"||o.type==="password")||u==="textarea"||o.contentEditable==="true")}var Xs=_i&&"documentMode"in document&&11>=document.documentMode,ex=null,or=null,wn=null,_l=!1;function Sl(o,u,f){var y=f.window===f?f.document:f.nodeType===9?f:f.ownerDocument;_l||ex==null||ex!==bn(y)||(y=ex,"selectionStart"in y&&sr(y)?y={start:y.selectionStart,end:y.selectionEnd}:(y=(y.ownerDocument&&y.ownerDocument.defaultView||window).getSelection(),y={anchorNode:y.anchorNode,anchorOffset:y.anchorOffset,focusNode:y.focusNode,focusOffset:y.focusOffset}),wn&&Vt(wn,y)||(wn=y,y=_m(or,"onSelect"),0<y.length&&(u=new cs("onSelect","select",null,u,f),o.push({event:u,listeners:y}),u.target=ex)))}function H0(o,u){var f={};return f[o.toLowerCase()]=u.toLowerCase(),f["Webkit"+o]="webkit"+u,f["Moz"+o]="moz"+u,f}var On={animationend:H0("Animation","AnimationEnd"),animationiteration:H0("Animation","AnimationIteration"),animationstart:H0("Animation","AnimationStart"),transitionrun:H0("Transition","TransitionRun"),transitionstart:H0("Transition","TransitionStart"),transitioncancel:H0("Transition","TransitionCancel"),transitionend:H0("Transition","TransitionEnd")},Bi={},YM={};_i&&(YM=document.createElement("div").style,"AnimationEvent"in window||(delete On.animationend.animation,delete On.animationiteration.animation,delete On.animationstart.animation),"TransitionEvent"in window||delete On.transitionend.transition);function Tl(o){if(Bi[o])return Bi[o];if(!On[o])return o;var u=On[o],f;for(f in u)if(u.hasOwnProperty(f)&&f in YM)return Bi[o]=u[f];return o}var KM=Tl("animationend"),$M=Tl("animationiteration"),QM=Tl("animationstart"),az=Tl("transitionrun"),sz=Tl("transitionstart"),oz=Tl("transitioncancel"),ZM=Tl("transitionend"),JM=new Map,Tv="abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");Tv.push("scrollEnd");function Ra(o,u){JM.set(o,u),fe(u,[o])}var jM=new WeakMap;function Qr(o,u){if(typeof o=="object"&&o!==null){var f=jM.get(o);return f!==void 0?f:(u={value:o,source:u,stack:y0(u)},jM.set(o,u),u)}return{value:o,source:u,stack:y0(u)}}var Zr=[],Hc=0,wv=0;function Fp(){for(var o=Hc,u=wv=Hc=0;u<o;){var f=Zr[u];Zr[u++]=null;var y=Zr[u];Zr[u++]=null;var S=Zr[u];Zr[u++]=null;var w=Zr[u];if(Zr[u++]=null,y!==null&&S!==null){var B=y.pending;B===null?S.next=S:(S.next=B.next,B.next=S),y.pending=S}w!==0&&qM(f,S,w)}}function Bp(o,u,f,y){Zr[Hc++]=o,Zr[Hc++]=u,Zr[Hc++]=f,Zr[Hc++]=y,wv|=y,o.lanes|=y,o=o.alternate,o!==null&&(o.lanes|=y)}function Av(o,u,f,y){return Bp(o,u,f,y),Lp(o)}function Gc(o,u){return Bp(o,null,null,u),Lp(o)}function qM(o,u,f){o.lanes|=f;var y=o.alternate;y!==null&&(y.lanes|=f);for(var S=!1,w=o.return;w!==null;)w.childLanes|=f,y=w.alternate,y!==null&&(y.childLanes|=f),w.tag===22&&(o=w.stateNode,o===null||o._visibility&1||(S=!0)),o=w,w=w.return;return o.tag===3?(w=o.stateNode,S&&u!==null&&(S=31-et(f),o=w.hiddenUpdates,y=o[S],y===null?o[S]=[u]:y.push(u),u.lane=f|536870912),w):null}function Lp(o){if(50<Gd)throw Gd=0,Ib=null,Error(n(185));for(var u=o.return;u!==null;)o=u,u=o.return;return o.tag===3?o.stateNode:null}var Wc={};function lz(o,u,f,y){this.tag=o,this.key=f,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.refCleanup=this.ref=null,this.pendingProps=u,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=y,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function lr(o,u,f,y){return new lz(o,u,f,y)}function Ev(o){return o=o.prototype,!(!o||!o.isReactComponent)}function Ys(o,u){var f=o.alternate;return f===null?(f=lr(o.tag,u,o.key,o.mode),f.elementType=o.elementType,f.type=o.type,f.stateNode=o.stateNode,f.alternate=o,o.alternate=f):(f.pendingProps=u,f.type=o.type,f.flags=0,f.subtreeFlags=0,f.deletions=null),f.flags=o.flags&65011712,f.childLanes=o.childLanes,f.lanes=o.lanes,f.child=o.child,f.memoizedProps=o.memoizedProps,f.memoizedState=o.memoizedState,f.updateQueue=o.updateQueue,u=o.dependencies,f.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext},f.sibling=o.sibling,f.index=o.index,f.ref=o.ref,f.refCleanup=o.refCleanup,f}function eR(o,u){o.flags&=65011714;var f=o.alternate;return f===null?(o.childLanes=0,o.lanes=u,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=f.childLanes,o.lanes=f.lanes,o.child=f.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=f.memoizedProps,o.memoizedState=f.memoizedState,o.updateQueue=f.updateQueue,o.type=f.type,u=f.dependencies,o.dependencies=u===null?null:{lanes:u.lanes,firstContext:u.firstContext}),o}function zp(o,u,f,y,S,w){var B=0;if(y=o,typeof o=="function")Ev(o)&&(B=1);else if(typeof o=="string")B=u5(o,f,le.current)?26:o==="html"||o==="head"||o==="body"?27:5;else e:switch(o){case P:return o=lr(31,f,u,S),o.elementType=P,o.lanes=w,o;case g:return wl(f.children,S,w,u);case _:B=8,S|=24;break;case v:return o=lr(12,f,u,S|2),o.elementType=v,o.lanes=w,o;case M:return o=lr(13,f,u,S),o.elementType=M,o.lanes=w,o;case R:return o=lr(19,f,u,S),o.elementType=R,o.lanes=w,o;default:if(typeof o=="object"&&o!==null)switch(o.$$typeof){case b:case E:B=10;break e;case T:B=9;break e;case A:B=11;break e;case C:B=14;break e;case k:B=16,y=null;break e}B=29,f=Error(n(130,o===null?"null":typeof o,"")),y=null}return u=lr(B,f,u,S),u.elementType=o,u.type=y,u.lanes=w,u}function wl(o,u,f,y){return o=lr(7,o,y,u),o.lanes=f,o}function Mv(o,u,f){return o=lr(6,o,null,u),o.lanes=f,o}function Rv(o,u,f){return u=lr(4,o.children!==null?o.children:[],o.key,u),u.lanes=f,u.stateNode={containerInfo:o.containerInfo,pendingChildren:null,implementation:o.implementation},u}var Xc=[],Yc=0,Vp=null,Hp=0,Jr=[],jr=0,Al=null,Ks=1,$s="";function El(o,u){Xc[Yc++]=Hp,Xc[Yc++]=Vp,Vp=o,Hp=u}function tR(o,u,f){Jr[jr++]=Ks,Jr[jr++]=$s,Jr[jr++]=Al,Al=o;var y=Ks;o=$s;var S=32-et(y)-1;y&=~(1<<S),f+=1;var w=32-et(u)+S;if(30<w){var B=S-S%5;w=(y&(1<<B)-1).toString(32),y>>=B,S-=B,Ks=1<<32-et(u)+S|f<<S|y,$s=w+o}else Ks=1<<w|f<<S|y,$s=o}function Cv(o){o.return!==null&&(El(o,1),tR(o,1,0))}function Nv(o){for(;o===Vp;)Vp=Xc[--Yc],Xc[Yc]=null,Hp=Xc[--Yc],Xc[Yc]=null;for(;o===Al;)Al=Jr[--jr],Jr[jr]=null,$s=Jr[--jr],Jr[jr]=null,Ks=Jr[--jr],Jr[jr]=null}var Si=null,Xx=null,K0=!1,Ml=null,hs=!1,Iv=Error(n(519));function Rl(o){var u=Error(n(418,""));throw _d(Qr(u,o)),Iv}function xR(o){var u=o.stateNode,f=o.type,y=o.memoizedProps;switch(u[L0]=o,u[R0]=y,f){case"dialog":N0("cancel",u),N0("close",u);break;case"iframe":case"object":case"embed":N0("load",u);break;case"video":case"audio":for(f=0;f<Xd.length;f++)N0(Xd[f],u);break;case"source":N0("error",u);break;case"img":case"image":case"link":N0("error",u),N0("load",u);break;case"details":N0("toggle",u);break;case"input":N0("invalid",u),Nx(u,y.value,y.defaultValue,y.checked,y.defaultChecked,y.type,y.name,!0),Di(u);break;case"select":N0("invalid",u);break;case"textarea":N0("invalid",u),Lx(u,y.value,y.defaultValue,y.children),Di(u)}f=y.children,typeof f!="string"&&typeof f!="number"&&typeof f!="bigint"||u.textContent===""+f||y.suppressHydrationWarning===!0||vN(u.textContent,f)?(y.popover!=null&&(N0("beforetoggle",u),N0("toggle",u)),y.onScroll!=null&&N0("scroll",u),y.onScrollEnd!=null&&N0("scrollend",u),y.onClick!=null&&(u.onclick=Sm),u=!0):u=!1,u||Rl(o)}function nR(o){for(Si=o.return;Si;)switch(Si.tag){case 5:case 13:hs=!1;return;case 27:case 3:hs=!0;return;default:Si=Si.return}}function vd(o){if(o!==Si)return!1;if(!K0)return nR(o),K0=!0,!1;var u=o.tag,f;if((f=u!==3&&u!==27)&&((f=u===5)&&(f=o.type,f=!(f!=="form"&&f!=="button")||Kb(o.type,o.memoizedProps)),f=!f),f&&Xx&&Rl(o),nR(o),u===13){if(o=o.memoizedState,o=o!==null?o.dehydrated:null,!o)throw Error(n(317));e:{for(o=o.nextSibling,u=0;o;){if(o.nodeType===8)if(f=o.data,f==="/$"){if(u===0){Xx=Na(o.nextSibling);break e}u--}else f!=="$"&&f!=="$!"&&f!=="$?"||u++;o=o.nextSibling}Xx=null}}else u===27?(u=Xx,p2(o.type)?(o=Jb,Jb=null,Xx=o):Xx=u):Xx=Si?Na(o.stateNode.nextSibling):null;return!0}function bd(){Xx=Si=null,K0=!1}function iR(){var o=Ml;return o!==null&&(Vi===null?Vi=o:Vi.push.apply(Vi,o),Ml=null),o}function _d(o){Ml===null?Ml=[o]:Ml.push(o)}var Ov=se(null),Cl=null,Qs=null;function e2(o,u,f){Me(Ov,u._currentValue),u._currentValue=f}function Zs(o){o._currentValue=Ov.current,ge(Ov)}function Dv(o,u,f){for(;o!==null;){var y=o.alternate;if((o.childLanes&u)!==u?(o.childLanes|=u,y!==null&&(y.childLanes|=u)):y!==null&&(y.childLanes&u)!==u&&(y.childLanes|=u),o===f)break;o=o.return}}function Pv(o,u,f,y){var S=o.child;for(S!==null&&(S.return=o);S!==null;){var w=S.dependencies;if(w!==null){var B=S.child;w=w.firstContext;e:for(;w!==null;){var W=w;w=S;for(var ie=0;ie<u.length;ie++)if(W.context===u[ie]){w.lanes|=f,W=w.alternate,W!==null&&(W.lanes|=f),Dv(w.return,f,o),y||(B=null);break e}w=W.next}}else if(S.tag===18){if(B=S.return,B===null)throw Error(n(341));B.lanes|=f,w=B.alternate,w!==null&&(w.lanes|=f),Dv(B,f,o),B=null}else B=S.child;if(B!==null)B.return=S;else for(B=S;B!==null;){if(B===o){B=null;break}if(S=B.sibling,S!==null){S.return=B.return,B=S;break}B=B.return}S=B}}function Sd(o,u,f,y){o=null;for(var S=u,w=!1;S!==null;){if(!w){if((S.flags&524288)!==0)w=!0;else if((S.flags&262144)!==0)break}if(S.tag===10){var B=S.alternate;if(B===null)throw Error(n(387));if(B=B.memoizedProps,B!==null){var W=S.type;xt(S.pendingProps.value,B.value)||(o!==null?o.push(W):o=[W])}}else if(S===Qe.current){if(B=S.alternate,B===null)throw Error(n(387));B.memoizedState.memoizedState!==S.memoizedState.memoizedState&&(o!==null?o.push(Jd):o=[Jd])}S=S.return}o!==null&&Pv(u,o,f,y),u.flags|=262144}function Gp(o){for(o=o.firstContext;o!==null;){if(!xt(o.context._currentValue,o.memoizedValue))return!0;o=o.next}return!1}function Nl(o){Cl=o,Qs=null,o=o.dependencies,o!==null&&(o.firstContext=null)}function xi(o){return rR(Cl,o)}function Wp(o,u){return Cl===null&&Nl(o),rR(o,u)}function rR(o,u){var f=u._currentValue;if(u={context:u,memoizedValue:f,next:null},Qs===null){if(o===null)throw Error(n(308));Qs=u,o.dependencies={lanes:0,firstContext:u},o.flags|=524288}else Qs=Qs.next=u;return f}var cz=typeof AbortController<"u"?AbortController:function(){var o=[],u=this.signal={aborted:!1,addEventListener:function(f,y){o.push(y)}};this.abort=function(){u.aborted=!0,o.forEach(function(f){return f()})}},uz=x.unstable_scheduleCallback,hz=x.unstable_NormalPriority,An={$$typeof:E,Consumer:null,Provider:null,_currentValue:null,_currentValue2:null,_threadCount:0};function kv(){return{controller:new cz,data:new Map,refCount:0}}function Td(o){o.refCount--,o.refCount===0&&uz(hz,function(){o.controller.abort()})}var wd=null,Uv=0,Kc=0,$c=null;function dz(o,u){if(wd===null){var f=wd=[];Uv=0,Kc=Bb(),$c={status:"pending",value:void 0,then:function(y){f.push(y)}}}return Uv++,u.then(aR,aR),u}function aR(){if(--Uv===0&&wd!==null){$c!==null&&($c.status="fulfilled");var o=wd;wd=null,Kc=0,$c=null;for(var u=0;u<o.length;u++)(0,o[u])()}}function fz(o,u){var f=[],y={status:"pending",value:null,reason:null,then:function(S){f.push(S)}};return o.then(function(){y.status="fulfilled",y.value=u;for(var S=0;S<f.length;S++)(0,f[S])(u)},function(S){for(y.status="rejected",y.reason=S,S=0;S<f.length;S++)(0,f[S])(void 0)}),y}var sR=H.S;H.S=function(o,u){typeof u=="object"&&u!==null&&typeof u.then=="function"&&dz(o,u),sR!==null&&sR(o,u)};var Il=se(null);function Fv(){var o=Il.current;return o!==null?o:_x.pooledCache}function Xp(o,u){u===null?Me(Il,Il.current):Me(Il,u.pool)}function oR(){var o=Fv();return o===null?null:{parent:An._currentValue,pool:o}}var Ad=Error(n(460)),lR=Error(n(474)),Yp=Error(n(542)),Bv={then:function(){}};function cR(o){return o=o.status,o==="fulfilled"||o==="rejected"}function Kp(){}function uR(o,u,f){switch(f=o[f],f===void 0?o.push(u):f!==u&&(u.then(Kp,Kp),u=f),u.status){case"fulfilled":return u.value;case"rejected":throw o=u.reason,dR(o),o;default:if(typeof u.status=="string")u.then(Kp,Kp);else{if(o=_x,o!==null&&100<o.shellSuspendCounter)throw Error(n(482));o=u,o.status="pending",o.then(function(y){if(u.status==="pending"){var S=u;S.status="fulfilled",S.value=y}},function(y){if(u.status==="pending"){var S=u;S.status="rejected",S.reason=y}})}switch(u.status){case"fulfilled":return u.value;case"rejected":throw o=u.reason,dR(o),o}throw Ed=u,Ad}}var Ed=null;function hR(){if(Ed===null)throw Error(n(459));var o=Ed;return Ed=null,o}function dR(o){if(o===Ad||o===Yp)throw Error(n(483))}var t2=!1;function Lv(o){o.updateQueue={baseState:o.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,lanes:0,hiddenCallbacks:null},callbacks:null}}function zv(o,u){o=o.updateQueue,u.updateQueue===o&&(u.updateQueue={baseState:o.baseState,firstBaseUpdate:o.firstBaseUpdate,lastBaseUpdate:o.lastBaseUpdate,shared:o.shared,callbacks:null})}function x2(o){return{lane:o,tag:0,payload:null,callback:null,next:null}}function n2(o,u,f){var y=o.updateQueue;if(y===null)return null;if(y=y.shared,(tx&2)!==0){var S=y.pending;return S===null?u.next=u:(u.next=S.next,S.next=u),y.pending=u,u=Lp(o),qM(o,null,f),u}return Bp(o,y,u,f),Lp(o)}function Md(o,u,f){if(u=u.updateQueue,u!==null&&(u=u.shared,(f&4194048)!==0)){var y=u.lanes;y&=o.pendingLanes,f|=y,u.lanes=f,D0(o,f)}}function Vv(o,u){var f=o.updateQueue,y=o.alternate;if(y!==null&&(y=y.updateQueue,f===y)){var S=null,w=null;if(f=f.firstBaseUpdate,f!==null){do{var B={lane:f.lane,tag:f.tag,payload:f.payload,callback:null,next:null};w===null?S=w=B:w=w.next=B,f=f.next}while(f!==null);w===null?S=w=u:w=w.next=u}else S=w=u;f={baseState:y.baseState,firstBaseUpdate:S,lastBaseUpdate:w,shared:y.shared,callbacks:y.callbacks},o.updateQueue=f;return}o=f.lastBaseUpdate,o===null?f.firstBaseUpdate=u:o.next=u,f.lastBaseUpdate=u}var Hv=!1;function Rd(){if(Hv){var o=$c;if(o!==null)throw o}}function Cd(o,u,f,y){Hv=!1;var S=o.updateQueue;t2=!1;var w=S.firstBaseUpdate,B=S.lastBaseUpdate,W=S.shared.pending;if(W!==null){S.shared.pending=null;var ie=W,Ee=ie.next;ie.next=null,B===null?w=Ee:B.next=Ee,B=ie;var Ke=o.alternate;Ke!==null&&(Ke=Ke.updateQueue,W=Ke.lastBaseUpdate,W!==B&&(W===null?Ke.firstBaseUpdate=Ee:W.next=Ee,Ke.lastBaseUpdate=ie))}if(w!==null){var nt=S.baseState;B=0,Ke=Ee=ie=null,W=w;do{var De=W.lane&-536870913,ke=De!==W.lane;if(ke?(B0&De)===De:(y&De)===De){De!==0&&De===Kc&&(Hv=!0),Ke!==null&&(Ke=Ke.next={lane:0,tag:W.tag,payload:W.payload,callback:null,next:null});e:{var u0=o,o0=W;De=u;var ux=f;switch(o0.tag){case 1:if(u0=o0.payload,typeof u0=="function"){nt=u0.call(ux,nt,De);break e}nt=u0;break e;case 3:u0.flags=u0.flags&-65537|128;case 0:if(u0=o0.payload,De=typeof u0=="function"?u0.call(ux,nt,De):u0,De==null)break e;nt=h({},nt,De);break e;case 2:t2=!0}}De=W.callback,De!==null&&(o.flags|=64,ke&&(o.flags|=8192),ke=S.callbacks,ke===null?S.callbacks=[De]:ke.push(De))}else ke={lane:De,tag:W.tag,payload:W.payload,callback:W.callback,next:null},Ke===null?(Ee=Ke=ke,ie=nt):Ke=Ke.next=ke,B|=De;if(W=W.next,W===null){if(W=S.shared.pending,W===null)break;ke=W,W=ke.next,ke.next=null,S.lastBaseUpdate=ke,S.shared.pending=null}}while(!0);Ke===null&&(ie=nt),S.baseState=ie,S.firstBaseUpdate=Ee,S.lastBaseUpdate=Ke,w===null&&(S.shared.lanes=0),u2|=B,o.lanes=B,o.memoizedState=nt}}function fR(o,u){if(typeof o!="function")throw Error(n(191,o));o.call(u)}function pR(o,u){var f=o.callbacks;if(f!==null)for(o.callbacks=null,o=0;o<f.length;o++)fR(f[o],u)}var Qc=se(null),$p=se(0);function mR(o,u){o=no,Me($p,o),Me(Qc,u),no=o|u.baseLanes}function Gv(){Me($p,no),Me(Qc,Qc.current)}function Wv(){no=$p.current,ge(Qc),ge($p)}var i2=0,_0=null,lx=null,on=null,Qp=!1,Zc=!1,Ol=!1,Zp=0,Nd=0,Jc=null,pz=0;function Jx(){throw Error(n(321))}function Xv(o,u){if(u===null)return!1;for(var f=0;f<u.length&&f<o.length;f++)if(!xt(o[f],u[f]))return!1;return!0}function Yv(o,u,f,y,S,w){return i2=w,_0=u,u.memoizedState=null,u.updateQueue=null,u.lanes=0,H.H=o===null||o.memoizedState===null?qR:eC,Ol=!1,w=f(y,S),Ol=!1,Zc&&(w=gR(u,f,y,S)),yR(o),w}function yR(o){H.H=xm;var u=lx!==null&&lx.next!==null;if(i2=0,on=lx=_0=null,Qp=!1,Nd=0,Jc=null,u)throw Error(n(300));o===null||Dn||(o=o.dependencies,o!==null&&Gp(o)&&(Dn=!0))}function gR(o,u,f,y){_0=o;var S=0;do{if(Zc&&(Jc=null),Nd=0,Zc=!1,25<=S)throw Error(n(301));if(S+=1,on=lx=null,o.updateQueue!=null){var w=o.updateQueue;w.lastEffect=null,w.events=null,w.stores=null,w.memoCache!=null&&(w.memoCache.index=0)}H.H=Sz,w=u(f,y)}while(Zc);return w}function mz(){var o=H.H,u=o.useState()[0];return u=typeof u.then=="function"?Id(u):u,o=o.useState()[0],(lx!==null?lx.memoizedState:null)!==o&&(_0.flags|=1024),u}function Kv(){var o=Zp!==0;return Zp=0,o}function $v(o,u,f){u.updateQueue=o.updateQueue,u.flags&=-2053,o.lanes&=~f}function Qv(o){if(Qp){for(o=o.memoizedState;o!==null;){var u=o.queue;u!==null&&(u.pending=null),o=o.next}Qp=!1}i2=0,on=lx=_0=null,Zc=!1,Nd=Zp=0,Jc=null}function Li(){var o={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return on===null?_0.memoizedState=on=o:on=on.next=o,on}function ln(){if(lx===null){var o=_0.alternate;o=o!==null?o.memoizedState:null}else o=lx.next;var u=on===null?_0.memoizedState:on.next;if(u!==null)on=u,lx=o;else{if(o===null)throw _0.alternate===null?Error(n(467)):Error(n(310));lx=o,o={memoizedState:lx.memoizedState,baseState:lx.baseState,baseQueue:lx.baseQueue,queue:lx.queue,next:null},on===null?_0.memoizedState=on=o:on=on.next=o}return on}function Zv(){return{lastEffect:null,events:null,stores:null,memoCache:null}}function Id(o){var u=Nd;return Nd+=1,Jc===null&&(Jc=[]),o=uR(Jc,o,u),u=_0,(on===null?u.memoizedState:on.next)===null&&(u=u.alternate,H.H=u===null||u.memoizedState===null?qR:eC),o}function Jp(o){if(o!==null&&typeof o=="object"){if(typeof o.then=="function")return Id(o);if(o.$$typeof===E)return xi(o)}throw Error(n(438,String(o)))}function Jv(o){var u=null,f=_0.updateQueue;if(f!==null&&(u=f.memoCache),u==null){var y=_0.alternate;y!==null&&(y=y.updateQueue,y!==null&&(y=y.memoCache,y!=null&&(u={data:y.data.map(function(S){return S.slice()}),index:0})))}if(u==null&&(u={data:[],index:0}),f===null&&(f=Zv(),_0.updateQueue=f),f.memoCache=u,f=u.data[u.index],f===void 0)for(f=u.data[u.index]=Array(o),y=0;y<o;y++)f[y]=N;return u.index++,f}function Js(o,u){return typeof u=="function"?u(o):u}function jp(o){var u=ln();return jv(u,lx,o)}function jv(o,u,f){var y=o.queue;if(y===null)throw Error(n(311));y.lastRenderedReducer=f;var S=o.baseQueue,w=y.pending;if(w!==null){if(S!==null){var B=S.next;S.next=w.next,w.next=B}u.baseQueue=S=w,y.pending=null}if(w=o.baseState,S===null)o.memoizedState=w;else{u=S.next;var W=B=null,ie=null,Ee=u,Ke=!1;do{var nt=Ee.lane&-536870913;if(nt!==Ee.lane?(B0&nt)===nt:(i2&nt)===nt){var De=Ee.revertLane;if(De===0)ie!==null&&(ie=ie.next={lane:0,revertLane:0,action:Ee.action,hasEagerState:Ee.hasEagerState,eagerState:Ee.eagerState,next:null}),nt===Kc&&(Ke=!0);else if((i2&De)===De){Ee=Ee.next,De===Kc&&(Ke=!0);continue}else nt={lane:0,revertLane:Ee.revertLane,action:Ee.action,hasEagerState:Ee.hasEagerState,eagerState:Ee.eagerState,next:null},ie===null?(W=ie=nt,B=w):ie=ie.next=nt,_0.lanes|=De,u2|=De;nt=Ee.action,Ol&&f(w,nt),w=Ee.hasEagerState?Ee.eagerState:f(w,nt)}else De={lane:nt,revertLane:Ee.revertLane,action:Ee.action,hasEagerState:Ee.hasEagerState,eagerState:Ee.eagerState,next:null},ie===null?(W=ie=De,B=w):ie=ie.next=De,_0.lanes|=nt,u2|=nt;Ee=Ee.next}while(Ee!==null&&Ee!==u);if(ie===null?B=w:ie.next=W,!xt(w,o.memoizedState)&&(Dn=!0,Ke&&(f=$c,f!==null)))throw f;o.memoizedState=w,o.baseState=B,o.baseQueue=ie,y.lastRenderedState=w}return S===null&&(y.lanes=0),[o.memoizedState,y.dispatch]}function qv(o){var u=ln(),f=u.queue;if(f===null)throw Error(n(311));f.lastRenderedReducer=o;var y=f.dispatch,S=f.pending,w=u.memoizedState;if(S!==null){f.pending=null;var B=S=S.next;do w=o(w,B.action),B=B.next;while(B!==S);xt(w,u.memoizedState)||(Dn=!0),u.memoizedState=w,u.baseQueue===null&&(u.baseState=w),f.lastRenderedState=w}return[w,y]}function vR(o,u,f){var y=_0,S=ln(),w=K0;if(w){if(f===void 0)throw Error(n(407));f=f()}else f=u();var B=!xt((lx||S).memoizedState,f);B&&(S.memoizedState=f,Dn=!0),S=S.queue;var W=SR.bind(null,y,S,o);if(Od(2048,8,W,[o]),S.getSnapshot!==u||B||on!==null&&on.memoizedState.tag&1){if(y.flags|=2048,jc(9,qp(),_R.bind(null,y,S,f,u),null),_x===null)throw Error(n(349));w||(i2&124)!==0||bR(y,u,f)}return f}function bR(o,u,f){o.flags|=16384,o={getSnapshot:u,value:f},u=_0.updateQueue,u===null?(u=Zv(),_0.updateQueue=u,u.stores=[o]):(f=u.stores,f===null?u.stores=[o]:f.push(o))}function _R(o,u,f,y){u.value=f,u.getSnapshot=y,TR(u)&&wR(o)}function SR(o,u,f){return f(function(){TR(u)&&wR(o)})}function TR(o){var u=o.getSnapshot;o=o.value;try{var f=u();return!xt(o,f)}catch{return!0}}function wR(o){var u=Gc(o,2);u!==null&&fr(u,o,2)}function eb(o){var u=Li();if(typeof o=="function"){var f=o;if(o=f(),Ol){pt(!0);try{f()}finally{pt(!1)}}}return u.memoizedState=u.baseState=o,u.queue={pending:null,lanes:0,dispatch:null,lastRenderedReducer:Js,lastRenderedState:o},u}function AR(o,u,f,y){return o.baseState=f,jv(o,lx,typeof y=="function"?y:Js)}function yz(o,u,f,y,S){if(tm(o))throw Error(n(485));if(o=u.action,o!==null){var w={payload:S,action:o,next:null,isTransition:!0,status:"pending",value:null,reason:null,listeners:[],then:function(B){w.listeners.push(B)}};H.T!==null?f(!0):w.isTransition=!1,y(w),f=u.pending,f===null?(w.next=u.pending=w,ER(u,w)):(w.next=f.next,u.pending=f.next=w)}}function ER(o,u){var f=u.action,y=u.payload,S=o.state;if(u.isTransition){var w=H.T,B={};H.T=B;try{var W=f(S,y),ie=H.S;ie!==null&&ie(B,W),MR(o,u,W)}catch(Ee){tb(o,u,Ee)}finally{H.T=w}}else try{w=f(S,y),MR(o,u,w)}catch(Ee){tb(o,u,Ee)}}function MR(o,u,f){f!==null&&typeof f=="object"&&typeof f.then=="function"?f.then(function(y){RR(o,u,y)},function(y){return tb(o,u,y)}):RR(o,u,f)}function RR(o,u,f){u.status="fulfilled",u.value=f,CR(u),o.state=f,u=o.pending,u!==null&&(f=u.next,f===u?o.pending=null:(f=f.next,u.next=f,ER(o,f)))}function tb(o,u,f){var y=o.pending;if(o.pending=null,y!==null){y=y.next;do u.status="rejected",u.reason=f,CR(u),u=u.next;while(u!==y)}o.action=null}function CR(o){o=o.listeners;for(var u=0;u<o.length;u++)(0,o[u])()}function NR(o,u){return u}function IR(o,u){if(K0){var f=_x.formState;if(f!==null){e:{var y=_0;if(K0){if(Xx){t:{for(var S=Xx,w=hs;S.nodeType!==8;){if(!w){S=null;break t}if(S=Na(S.nextSibling),S===null){S=null;break t}}w=S.data,S=w==="F!"||w==="F"?S:null}if(S){Xx=Na(S.nextSibling),y=S.data==="F!";break e}}Rl(y)}y=!1}y&&(u=f[0])}}return f=Li(),f.memoizedState=f.baseState=u,y={pending:null,lanes:0,dispatch:null,lastRenderedReducer:NR,lastRenderedState:u},f.queue=y,f=ZR.bind(null,_0,y),y.dispatch=f,y=eb(!1),w=ab.bind(null,_0,!1,y.queue),y=Li(),S={state:u,dispatch:null,action:o,pending:null},y.queue=S,f=yz.bind(null,_0,S,w,f),S.dispatch=f,y.memoizedState=o,[u,f,!1]}function OR(o){var u=ln();return DR(u,lx,o)}function DR(o,u,f){if(u=jv(o,u,NR)[0],o=jp(Js)[0],typeof u=="object"&&u!==null&&typeof u.then=="function")try{var y=Id(u)}catch(B){throw B===Ad?Yp:B}else y=u;u=ln();var S=u.queue,w=S.dispatch;return f!==u.memoizedState&&(_0.flags|=2048,jc(9,qp(),gz.bind(null,S,f),null)),[y,w,o]}function gz(o,u){o.action=u}function PR(o){var u=ln(),f=lx;if(f!==null)return DR(u,f,o);ln(),u=u.memoizedState,f=ln();var y=f.queue.dispatch;return f.memoizedState=o,[u,y,!1]}function jc(o,u,f,y){return o={tag:o,create:f,deps:y,inst:u,next:null},u=_0.updateQueue,u===null&&(u=Zv(),_0.updateQueue=u),f=u.lastEffect,f===null?u.lastEffect=o.next=o:(y=f.next,f.next=o,o.next=y,u.lastEffect=o),o}function qp(){return{destroy:void 0,resource:void 0}}function kR(){return ln().memoizedState}function em(o,u,f,y){var S=Li();y=y===void 0?null:y,_0.flags|=o,S.memoizedState=jc(1|u,qp(),f,y)}function Od(o,u,f,y){var S=ln();y=y===void 0?null:y;var w=S.memoizedState.inst;lx!==null&&y!==null&&Xv(y,lx.memoizedState.deps)?S.memoizedState=jc(u,w,f,y):(_0.flags|=o,S.memoizedState=jc(1|u,w,f,y))}function UR(o,u){em(8390656,8,o,u)}function FR(o,u){Od(2048,8,o,u)}function BR(o,u){return Od(4,2,o,u)}function LR(o,u){return Od(4,4,o,u)}function zR(o,u){if(typeof u=="function"){o=o();var f=u(o);return function(){typeof f=="function"?f():u(null)}}if(u!=null)return o=o(),u.current=o,function(){u.current=null}}function VR(o,u,f){f=f!=null?f.concat([o]):null,Od(4,4,zR.bind(null,u,o),f)}function xb(){}function HR(o,u){var f=ln();u=u===void 0?null:u;var y=f.memoizedState;return u!==null&&Xv(u,y[1])?y[0]:(f.memoizedState=[o,u],o)}function GR(o,u){var f=ln();u=u===void 0?null:u;var y=f.memoizedState;if(u!==null&&Xv(u,y[1]))return y[0];if(y=o(),Ol){pt(!0);try{o()}finally{pt(!1)}}return f.memoizedState=[y,u],y}function nb(o,u,f){return f===void 0||(i2&1073741824)!==0?o.memoizedState=u:(o.memoizedState=f,o=YC(),_0.lanes|=o,u2|=o,f)}function WR(o,u,f,y){return xt(f,u)?f:Qc.current!==null?(o=nb(o,f,y),xt(o,u)||(Dn=!0),o):(i2&42)===0?(Dn=!0,o.memoizedState=f):(o=YC(),_0.lanes|=o,u2|=o,u)}function XR(o,u,f,y,S){var w=re.p;re.p=w!==0&&8>w?w:8;var B=H.T,W={};H.T=W,ab(o,!1,u,f);try{var ie=S(),Ee=H.S;if(Ee!==null&&Ee(W,ie),ie!==null&&typeof ie=="object"&&typeof ie.then=="function"){var Ke=fz(ie,y);Dd(o,u,Ke,dr(o))}else Dd(o,u,y,dr(o))}catch(nt){Dd(o,u,{then:function(){},status:"rejected",reason:nt},dr())}finally{re.p=w,H.T=B}}function vz(){}function ib(o,u,f,y){if(o.tag!==5)throw Error(n(476));var S=YR(o).queue;XR(o,S,u,q,f===null?vz:function(){return KR(o),f(y)})}function YR(o){var u=o.memoizedState;if(u!==null)return u;u={memoizedState:q,baseState:q,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Js,lastRenderedState:q},next:null};var f={};return u.next={memoizedState:f,baseState:f,baseQueue:null,queue:{pending:null,lanes:0,dispatch:null,lastRenderedReducer:Js,lastRenderedState:f},next:null},o.memoizedState=u,o=o.alternate,o!==null&&(o.memoizedState=u),u}function KR(o){var u=YR(o).next.queue;Dd(o,u,{},dr())}function rb(){return xi(Jd)}function $R(){return ln().memoizedState}function QR(){return ln().memoizedState}function bz(o){for(var u=o.return;u!==null;){switch(u.tag){case 24:case 3:var f=dr();o=x2(f);var y=n2(u,o,f);y!==null&&(fr(y,u,f),Md(y,u,f)),u={cache:kv()},o.payload=u;return}u=u.return}}function _z(o,u,f){var y=dr();f={lane:y,revertLane:0,action:f,hasEagerState:!1,eagerState:null,next:null},tm(o)?JR(u,f):(f=Av(o,u,f,y),f!==null&&(fr(f,o,y),jR(f,u,y)))}function ZR(o,u,f){var y=dr();Dd(o,u,f,y)}function Dd(o,u,f,y){var S={lane:y,revertLane:0,action:f,hasEagerState:!1,eagerState:null,next:null};if(tm(o))JR(u,S);else{var w=o.alternate;if(o.lanes===0&&(w===null||w.lanes===0)&&(w=u.lastRenderedReducer,w!==null))try{var B=u.lastRenderedState,W=w(B,f);if(S.hasEagerState=!0,S.eagerState=W,xt(W,B))return Bp(o,u,S,0),_x===null&&Fp(),!1}catch{}finally{}if(f=Av(o,u,S,y),f!==null)return fr(f,o,y),jR(f,u,y),!0}return!1}function ab(o,u,f,y){if(y={lane:2,revertLane:Bb(),action:y,hasEagerState:!1,eagerState:null,next:null},tm(o)){if(u)throw Error(n(479))}else u=Av(o,f,y,2),u!==null&&fr(u,o,2)}function tm(o){var u=o.alternate;return o===_0||u!==null&&u===_0}function JR(o,u){Zc=Qp=!0;var f=o.pending;f===null?u.next=u:(u.next=f.next,f.next=u),o.pending=u}function jR(o,u,f){if((f&4194048)!==0){var y=u.lanes;y&=o.pendingLanes,f|=y,u.lanes=f,D0(o,f)}}var xm={readContext:xi,use:Jp,useCallback:Jx,useContext:Jx,useEffect:Jx,useImperativeHandle:Jx,useLayoutEffect:Jx,useInsertionEffect:Jx,useMemo:Jx,useReducer:Jx,useRef:Jx,useState:Jx,useDebugValue:Jx,useDeferredValue:Jx,useTransition:Jx,useSyncExternalStore:Jx,useId:Jx,useHostTransitionStatus:Jx,useFormState:Jx,useActionState:Jx,useOptimistic:Jx,useMemoCache:Jx,useCacheRefresh:Jx},qR={readContext:xi,use:Jp,useCallback:function(o,u){return Li().memoizedState=[o,u===void 0?null:u],o},useContext:xi,useEffect:UR,useImperativeHandle:function(o,u,f){f=f!=null?f.concat([o]):null,em(4194308,4,zR.bind(null,u,o),f)},useLayoutEffect:function(o,u){return em(4194308,4,o,u)},useInsertionEffect:function(o,u){em(4,2,o,u)},useMemo:function(o,u){var f=Li();u=u===void 0?null:u;var y=o();if(Ol){pt(!0);try{o()}finally{pt(!1)}}return f.memoizedState=[y,u],y},useReducer:function(o,u,f){var y=Li();if(f!==void 0){var S=f(u);if(Ol){pt(!0);try{f(u)}finally{pt(!1)}}}else S=u;return y.memoizedState=y.baseState=S,o={pending:null,lanes:0,dispatch:null,lastRenderedReducer:o,lastRenderedState:S},y.queue=o,o=o.dispatch=_z.bind(null,_0,o),[y.memoizedState,o]},useRef:function(o){var u=Li();return o={current:o},u.memoizedState=o},useState:function(o){o=eb(o);var u=o.queue,f=ZR.bind(null,_0,u);return u.dispatch=f,[o.memoizedState,f]},useDebugValue:xb,useDeferredValue:function(o,u){var f=Li();return nb(f,o,u)},useTransition:function(){var o=eb(!1);return o=XR.bind(null,_0,o.queue,!0,!1),Li().memoizedState=o,[!1,o]},useSyncExternalStore:function(o,u,f){var y=_0,S=Li();if(K0){if(f===void 0)throw Error(n(407));f=f()}else{if(f=u(),_x===null)throw Error(n(349));(B0&124)!==0||bR(y,u,f)}S.memoizedState=f;var w={value:f,getSnapshot:u};return S.queue=w,UR(SR.bind(null,y,w,o),[o]),y.flags|=2048,jc(9,qp(),_R.bind(null,y,w,f,u),null),f},useId:function(){var o=Li(),u=_x.identifierPrefix;if(K0){var f=$s,y=Ks;f=(y&~(1<<32-et(y)-1)).toString(32)+f,u=""+u+"R"+f,f=Zp++,0<f&&(u+="H"+f.toString(32)),u+=""}else f=pz++,u=""+u+"r"+f.toString(32)+"";return o.memoizedState=u},useHostTransitionStatus:rb,useFormState:IR,useActionState:IR,useOptimistic:function(o){var u=Li();u.memoizedState=u.baseState=o;var f={pending:null,lanes:0,dispatch:null,lastRenderedReducer:null,lastRenderedState:null};return u.queue=f,u=ab.bind(null,_0,!0,f),f.dispatch=u,[o,u]},useMemoCache:Jv,useCacheRefresh:function(){return Li().memoizedState=bz.bind(null,_0)}},eC={readContext:xi,use:Jp,useCallback:HR,useContext:xi,useEffect:FR,useImperativeHandle:VR,useInsertionEffect:BR,useLayoutEffect:LR,useMemo:GR,useReducer:jp,useRef:kR,useState:function(){return jp(Js)},useDebugValue:xb,useDeferredValue:function(o,u){var f=ln();return WR(f,lx.memoizedState,o,u)},useTransition:function(){var o=jp(Js)[0],u=ln().memoizedState;return[typeof o=="boolean"?o:Id(o),u]},useSyncExternalStore:vR,useId:$R,useHostTransitionStatus:rb,useFormState:OR,useActionState:OR,useOptimistic:function(o,u){var f=ln();return AR(f,lx,o,u)},useMemoCache:Jv,useCacheRefresh:QR},Sz={readContext:xi,use:Jp,useCallback:HR,useContext:xi,useEffect:FR,useImperativeHandle:VR,useInsertionEffect:BR,useLayoutEffect:LR,useMemo:GR,useReducer:qv,useRef:kR,useState:function(){return qv(Js)},useDebugValue:xb,useDeferredValue:function(o,u){var f=ln();return lx===null?nb(f,o,u):WR(f,lx.memoizedState,o,u)},useTransition:function(){var o=qv(Js)[0],u=ln().memoizedState;return[typeof o=="boolean"?o:Id(o),u]},useSyncExternalStore:vR,useId:$R,useHostTransitionStatus:rb,useFormState:PR,useActionState:PR,useOptimistic:function(o,u){var f=ln();return lx!==null?AR(f,lx,o,u):(f.baseState=o,[o,f.queue.dispatch])},useMemoCache:Jv,useCacheRefresh:QR},qc=null,Pd=0;function nm(o){var u=Pd;return Pd+=1,qc===null&&(qc=[]),uR(qc,o,u)}function kd(o,u){u=u.props.ref,o.ref=u!==void 0?u:null}function im(o,u){throw u.$$typeof===d?Error(n(525)):(o=Object.prototype.toString.call(u),Error(n(31,o==="[object Object]"?"object with keys {"+Object.keys(u).join(", ")+"}":o)))}function tC(o){var u=o._init;return u(o._payload)}function xC(o){function u(me,he){if(o){var Ae=me.deletions;Ae===null?(me.deletions=[he],me.flags|=16):Ae.push(he)}}function f(me,he){if(!o)return null;for(;he!==null;)u(me,he),he=he.sibling;return null}function y(me){for(var he=new Map;me!==null;)me.key!==null?he.set(me.key,me):he.set(me.index,me),me=me.sibling;return he}function S(me,he){return me=Ys(me,he),me.index=0,me.sibling=null,me}function w(me,he,Ae){return me.index=Ae,o?(Ae=me.alternate,Ae!==null?(Ae=Ae.index,Ae<he?(me.flags|=67108866,he):Ae):(me.flags|=67108866,he)):(me.flags|=1048576,he)}function B(me){return o&&me.alternate===null&&(me.flags|=67108866),me}function W(me,he,Ae,je){return he===null||he.tag!==6?(he=Mv(Ae,me.mode,je),he.return=me,he):(he=S(he,Ae),he.return=me,he)}function ie(me,he,Ae,je){var Lt=Ae.type;return Lt===g?Ke(me,he,Ae.props.children,je,Ae.key):he!==null&&(he.elementType===Lt||typeof Lt=="object"&&Lt!==null&&Lt.$$typeof===k&&tC(Lt)===he.type)?(he=S(he,Ae.props),kd(he,Ae),he.return=me,he):(he=zp(Ae.type,Ae.key,Ae.props,null,me.mode,je),kd(he,Ae),he.return=me,he)}function Ee(me,he,Ae,je){return he===null||he.tag!==4||he.stateNode.containerInfo!==Ae.containerInfo||he.stateNode.implementation!==Ae.implementation?(he=Rv(Ae,me.mode,je),he.return=me,he):(he=S(he,Ae.children||[]),he.return=me,he)}function Ke(me,he,Ae,je,Lt){return he===null||he.tag!==7?(he=wl(Ae,me.mode,je,Lt),he.return=me,he):(he=S(he,Ae),he.return=me,he)}function nt(me,he,Ae){if(typeof he=="string"&&he!==""||typeof he=="number"||typeof he=="bigint")return he=Mv(""+he,me.mode,Ae),he.return=me,he;if(typeof he=="object"&&he!==null){switch(he.$$typeof){case p:return Ae=zp(he.type,he.key,he.props,null,me.mode,Ae),kd(Ae,he),Ae.return=me,Ae;case m:return he=Rv(he,me.mode,Ae),he.return=me,he;case k:var je=he._init;return he=je(he._payload),nt(me,he,Ae)}if(ae(he)||te(he))return he=wl(he,me.mode,Ae,null),he.return=me,he;if(typeof he.then=="function")return nt(me,nm(he),Ae);if(he.$$typeof===E)return nt(me,Wp(me,he),Ae);im(me,he)}return null}function De(me,he,Ae,je){var Lt=he!==null?he.key:null;if(typeof Ae=="string"&&Ae!==""||typeof Ae=="number"||typeof Ae=="bigint")return Lt!==null?null:W(me,he,""+Ae,je);if(typeof Ae=="object"&&Ae!==null){switch(Ae.$$typeof){case p:return Ae.key===Lt?ie(me,he,Ae,je):null;case m:return Ae.key===Lt?Ee(me,he,Ae,je):null;case k:return Lt=Ae._init,Ae=Lt(Ae._payload),De(me,he,Ae,je)}if(ae(Ae)||te(Ae))return Lt!==null?null:Ke(me,he,Ae,je,null);if(typeof Ae.then=="function")return De(me,he,nm(Ae),je);if(Ae.$$typeof===E)return De(me,he,Wp(me,Ae),je);im(me,Ae)}return null}function ke(me,he,Ae,je,Lt){if(typeof je=="string"&&je!==""||typeof je=="number"||typeof je=="bigint")return me=me.get(Ae)||null,W(he,me,""+je,Lt);if(typeof je=="object"&&je!==null){switch(je.$$typeof){case p:return me=me.get(je.key===null?Ae:je.key)||null,ie(he,me,je,Lt);case m:return me=me.get(je.key===null?Ae:je.key)||null,Ee(he,me,je,Lt);case k:var A0=je._init;return je=A0(je._payload),ke(me,he,Ae,je,Lt)}if(ae(je)||te(je))return me=me.get(Ae)||null,Ke(he,me,je,Lt,null);if(typeof je.then=="function")return ke(me,he,Ae,nm(je),Lt);if(je.$$typeof===E)return ke(me,he,Ae,Wp(he,je),Lt);im(he,je)}return null}function u0(me,he,Ae,je){for(var Lt=null,A0=null,Jt=he,l0=he=0,kn=null;Jt!==null&&l0<Ae.length;l0++){Jt.index>l0?(kn=Jt,Jt=null):kn=Jt.sibling;var W0=De(me,Jt,Ae[l0],je);if(W0===null){Jt===null&&(Jt=kn);break}o&&Jt&&W0.alternate===null&&u(me,Jt),he=w(W0,he,l0),A0===null?Lt=W0:A0.sibling=W0,A0=W0,Jt=kn}if(l0===Ae.length)return f(me,Jt),K0&&El(me,l0),Lt;if(Jt===null){for(;l0<Ae.length;l0++)Jt=nt(me,Ae[l0],je),Jt!==null&&(he=w(Jt,he,l0),A0===null?Lt=Jt:A0.sibling=Jt,A0=Jt);return K0&&El(me,l0),Lt}for(Jt=y(Jt);l0<Ae.length;l0++)kn=ke(Jt,me,l0,Ae[l0],je),kn!==null&&(o&&kn.alternate!==null&&Jt.delete(kn.key===null?l0:kn.key),he=w(kn,he,l0),A0===null?Lt=kn:A0.sibling=kn,A0=kn);return o&&Jt.forEach(function(b2){return u(me,b2)}),K0&&El(me,l0),Lt}function o0(me,he,Ae,je){if(Ae==null)throw Error(n(151));for(var Lt=null,A0=null,Jt=he,l0=he=0,kn=null,W0=Ae.next();Jt!==null&&!W0.done;l0++,W0=Ae.next()){Jt.index>l0?(kn=Jt,Jt=null):kn=Jt.sibling;var b2=De(me,Jt,W0.value,je);if(b2===null){Jt===null&&(Jt=kn);break}o&&Jt&&b2.alternate===null&&u(me,Jt),he=w(b2,he,l0),A0===null?Lt=b2:A0.sibling=b2,A0=b2,Jt=kn}if(W0.done)return f(me,Jt),K0&&El(me,l0),Lt;if(Jt===null){for(;!W0.done;l0++,W0=Ae.next())W0=nt(me,W0.value,je),W0!==null&&(he=w(W0,he,l0),A0===null?Lt=W0:A0.sibling=W0,A0=W0);return K0&&El(me,l0),Lt}for(Jt=y(Jt);!W0.done;l0++,W0=Ae.next())W0=ke(Jt,me,l0,W0.value,je),W0!==null&&(o&&W0.alternate!==null&&Jt.delete(W0.key===null?l0:W0.key),he=w(W0,he,l0),A0===null?Lt=W0:A0.sibling=W0,A0=W0);return o&&Jt.forEach(function(T5){return u(me,T5)}),K0&&El(me,l0),Lt}function ux(me,he,Ae,je){if(typeof Ae=="object"&&Ae!==null&&Ae.type===g&&Ae.key===null&&(Ae=Ae.props.children),typeof Ae=="object"&&Ae!==null){switch(Ae.$$typeof){case p:e:{for(var Lt=Ae.key;he!==null;){if(he.key===Lt){if(Lt=Ae.type,Lt===g){if(he.tag===7){f(me,he.sibling),je=S(he,Ae.props.children),je.return=me,me=je;break e}}else if(he.elementType===Lt||typeof Lt=="object"&&Lt!==null&&Lt.$$typeof===k&&tC(Lt)===he.type){f(me,he.sibling),je=S(he,Ae.props),kd(je,Ae),je.return=me,me=je;break e}f(me,he);break}else u(me,he);he=he.sibling}Ae.type===g?(je=wl(Ae.props.children,me.mode,je,Ae.key),je.return=me,me=je):(je=zp(Ae.type,Ae.key,Ae.props,null,me.mode,je),kd(je,Ae),je.return=me,me=je)}return B(me);case m:e:{for(Lt=Ae.key;he!==null;){if(he.key===Lt)if(he.tag===4&&he.stateNode.containerInfo===Ae.containerInfo&&he.stateNode.implementation===Ae.implementation){f(me,he.sibling),je=S(he,Ae.children||[]),je.return=me,me=je;break e}else{f(me,he);break}else u(me,he);he=he.sibling}je=Rv(Ae,me.mode,je),je.return=me,me=je}return B(me);case k:return Lt=Ae._init,Ae=Lt(Ae._payload),ux(me,he,Ae,je)}if(ae(Ae))return u0(me,he,Ae,je);if(te(Ae)){if(Lt=te(Ae),typeof Lt!="function")throw Error(n(150));return Ae=Lt.call(Ae),o0(me,he,Ae,je)}if(typeof Ae.then=="function")return ux(me,he,nm(Ae),je);if(Ae.$$typeof===E)return ux(me,he,Wp(me,Ae),je);im(me,Ae)}return typeof Ae=="string"&&Ae!==""||typeof Ae=="number"||typeof Ae=="bigint"?(Ae=""+Ae,he!==null&&he.tag===6?(f(me,he.sibling),je=S(he,Ae),je.return=me,me=je):(f(me,he),je=Mv(Ae,me.mode,je),je.return=me,me=je),B(me)):f(me,he)}return function(me,he,Ae,je){try{Pd=0;var Lt=ux(me,he,Ae,je);return qc=null,Lt}catch(Jt){if(Jt===Ad||Jt===Yp)throw Jt;var A0=lr(29,Jt,null,me.mode);return A0.lanes=je,A0.return=me,A0}finally{}}}var eu=xC(!0),nC=xC(!1),qr=se(null),ds=null;function r2(o){var u=o.alternate;Me(En,En.current&1),Me(qr,o),ds===null&&(u===null||Qc.current!==null||u.memoizedState!==null)&&(ds=o)}function iC(o){if(o.tag===22){if(Me(En,En.current),Me(qr,o),ds===null){var u=o.alternate;u!==null&&u.memoizedState!==null&&(ds=o)}}else a2()}function a2(){Me(En,En.current),Me(qr,qr.current)}function js(o){ge(qr),ds===o&&(ds=null),ge(En)}var En=se(0);function rm(o){for(var u=o;u!==null;){if(u.tag===13){var f=u.memoizedState;if(f!==null&&(f=f.dehydrated,f===null||f.data==="$?"||Zb(f)))return u}else if(u.tag===19&&u.memoizedProps.revealOrder!==void 0){if((u.flags&128)!==0)return u}else if(u.child!==null){u.child.return=u,u=u.child;continue}if(u===o)break;for(;u.sibling===null;){if(u.return===null||u.return===o)return null;u=u.return}u.sibling.return=u.return,u=u.sibling}return null}function sb(o,u,f,y){u=o.memoizedState,f=f(y,u),f=f==null?u:h({},u,f),o.memoizedState=f,o.lanes===0&&(o.updateQueue.baseState=f)}var ob={enqueueSetState:function(o,u,f){o=o._reactInternals;var y=dr(),S=x2(y);S.payload=u,f!=null&&(S.callback=f),u=n2(o,S,y),u!==null&&(fr(u,o,y),Md(u,o,y))},enqueueReplaceState:function(o,u,f){o=o._reactInternals;var y=dr(),S=x2(y);S.tag=1,S.payload=u,f!=null&&(S.callback=f),u=n2(o,S,y),u!==null&&(fr(u,o,y),Md(u,o,y))},enqueueForceUpdate:function(o,u){o=o._reactInternals;var f=dr(),y=x2(f);y.tag=2,u!=null&&(y.callback=u),u=n2(o,y,f),u!==null&&(fr(u,o,f),Md(u,o,f))}};function rC(o,u,f,y,S,w,B){return o=o.stateNode,typeof o.shouldComponentUpdate=="function"?o.shouldComponentUpdate(y,w,B):u.prototype&&u.prototype.isPureReactComponent?!Vt(f,y)||!Vt(S,w):!0}function aC(o,u,f,y){o=u.state,typeof u.componentWillReceiveProps=="function"&&u.componentWillReceiveProps(f,y),typeof u.UNSAFE_componentWillReceiveProps=="function"&&u.UNSAFE_componentWillReceiveProps(f,y),u.state!==o&&ob.enqueueReplaceState(u,u.state,null)}function Dl(o,u){var f=u;if("ref"in u){f={};for(var y in u)y!=="ref"&&(f[y]=u[y])}if(o=o.defaultProps){f===u&&(f=h({},f));for(var S in o)f[S]===void 0&&(f[S]=o[S])}return f}var am=typeof reportError=="function"?reportError:function(o){if(typeof window=="object"&&typeof window.ErrorEvent=="function"){var u=new window.ErrorEvent("error",{bubbles:!0,cancelable:!0,message:typeof o=="object"&&o!==null&&typeof o.message=="string"?String(o.message):String(o),error:o});if(!window.dispatchEvent(u))return}else if(typeof process=="object"&&typeof process.emit=="function"){process.emit("uncaughtException",o);return}console.error(o)};function sC(o){am(o)}function oC(o){console.error(o)}function lC(o){am(o)}function sm(o,u){try{var f=o.onUncaughtError;f(u.value,{componentStack:u.stack})}catch(y){setTimeout(function(){throw y})}}function cC(o,u,f){try{var y=o.onCaughtError;y(f.value,{componentStack:f.stack,errorBoundary:u.tag===1?u.stateNode:null})}catch(S){setTimeout(function(){throw S})}}function lb(o,u,f){return f=x2(f),f.tag=3,f.payload={element:null},f.callback=function(){sm(o,u)},f}function uC(o){return o=x2(o),o.tag=3,o}function hC(o,u,f,y){var S=f.type.getDerivedStateFromError;if(typeof S=="function"){var w=y.value;o.payload=function(){return S(w)},o.callback=function(){cC(u,f,y)}}var B=f.stateNode;B!==null&&typeof B.componentDidCatch=="function"&&(o.callback=function(){cC(u,f,y),typeof S!="function"&&(h2===null?h2=new Set([this]):h2.add(this));var W=y.stack;this.componentDidCatch(y.value,{componentStack:W!==null?W:""})})}function Tz(o,u,f,y,S){if(f.flags|=32768,y!==null&&typeof y=="object"&&typeof y.then=="function"){if(u=f.alternate,u!==null&&Sd(u,f,S,!0),f=qr.current,f!==null){switch(f.tag){case 13:return ds===null?Db():f.alternate===null&&Yx===0&&(Yx=3),f.flags&=-257,f.flags|=65536,f.lanes=S,y===Bv?f.flags|=16384:(u=f.updateQueue,u===null?f.updateQueue=new Set([y]):u.add(y),kb(o,y,S)),!1;case 22:return f.flags|=65536,y===Bv?f.flags|=16384:(u=f.updateQueue,u===null?(u={transitions:null,markerInstances:null,retryQueue:new Set([y])},f.updateQueue=u):(f=u.retryQueue,f===null?u.retryQueue=new Set([y]):f.add(y)),kb(o,y,S)),!1}throw Error(n(435,f.tag))}return kb(o,y,S),Db(),!1}if(K0)return u=qr.current,u!==null?((u.flags&65536)===0&&(u.flags|=256),u.flags|=65536,u.lanes=S,y!==Iv&&(o=Error(n(422),{cause:y}),_d(Qr(o,f)))):(y!==Iv&&(u=Error(n(423),{cause:y}),_d(Qr(u,f))),o=o.current.alternate,o.flags|=65536,S&=-S,o.lanes|=S,y=Qr(y,f),S=lb(o.stateNode,y,S),Vv(o,S),Yx!==4&&(Yx=2)),!1;var w=Error(n(520),{cause:y});if(w=Qr(w,f),Hd===null?Hd=[w]:Hd.push(w),Yx!==4&&(Yx=2),u===null)return!0;y=Qr(y,f),f=u;do{switch(f.tag){case 3:return f.flags|=65536,o=S&-S,f.lanes|=o,o=lb(f.stateNode,y,o),Vv(f,o),!1;case 1:if(u=f.type,w=f.stateNode,(f.flags&128)===0&&(typeof u.getDerivedStateFromError=="function"||w!==null&&typeof w.componentDidCatch=="function"&&(h2===null||!h2.has(w))))return f.flags|=65536,S&=-S,f.lanes|=S,S=uC(S),hC(S,o,f,y),Vv(f,S),!1}f=f.return}while(f!==null);return!1}var dC=Error(n(461)),Dn=!1;function $n(o,u,f,y){u.child=o===null?nC(u,null,f,y):eu(u,o.child,f,y)}function fC(o,u,f,y,S){f=f.render;var w=u.ref;if("ref"in y){var B={};for(var W in y)W!=="ref"&&(B[W]=y[W])}else B=y;return Nl(u),y=Yv(o,u,f,B,w,S),W=Kv(),o!==null&&!Dn?($v(o,u,S),qs(o,u,S)):(K0&&W&&Cv(u),u.flags|=1,$n(o,u,y,S),u.child)}function pC(o,u,f,y,S){if(o===null){var w=f.type;return typeof w=="function"&&!Ev(w)&&w.defaultProps===void 0&&f.compare===null?(u.tag=15,u.type=w,mC(o,u,w,y,S)):(o=zp(f.type,null,y,u,u.mode,S),o.ref=u.ref,o.return=u,u.child=o)}if(w=o.child,!yb(o,S)){var B=w.memoizedProps;if(f=f.compare,f=f!==null?f:Vt,f(B,y)&&o.ref===u.ref)return qs(o,u,S)}return u.flags|=1,o=Ys(w,y),o.ref=u.ref,o.return=u,u.child=o}function mC(o,u,f,y,S){if(o!==null){var w=o.memoizedProps;if(Vt(w,y)&&o.ref===u.ref)if(Dn=!1,u.pendingProps=y=w,yb(o,S))(o.flags&131072)!==0&&(Dn=!0);else return u.lanes=o.lanes,qs(o,u,S)}return cb(o,u,f,y,S)}function yC(o,u,f){var y=u.pendingProps,S=y.children,w=o!==null?o.memoizedState:null;if(y.mode==="hidden"){if((u.flags&128)!==0){if(y=w!==null?w.baseLanes|f:f,o!==null){for(S=u.child=o.child,w=0;S!==null;)w=w|S.lanes|S.childLanes,S=S.sibling;u.childLanes=w&~y}else u.childLanes=0,u.child=null;return gC(o,u,y,f)}if((f&536870912)!==0)u.memoizedState={baseLanes:0,cachePool:null},o!==null&&Xp(u,w!==null?w.cachePool:null),w!==null?mR(u,w):Gv(),iC(u);else return u.lanes=u.childLanes=536870912,gC(o,u,w!==null?w.baseLanes|f:f,f)}else w!==null?(Xp(u,w.cachePool),mR(u,w),a2(),u.memoizedState=null):(o!==null&&Xp(u,null),Gv(),a2());return $n(o,u,S,f),u.child}function gC(o,u,f,y){var S=Fv();return S=S===null?null:{parent:An._currentValue,pool:S},u.memoizedState={baseLanes:f,cachePool:S},o!==null&&Xp(u,null),Gv(),iC(u),o!==null&&Sd(o,u,y,!0),null}function om(o,u){var f=u.ref;if(f===null)o!==null&&o.ref!==null&&(u.flags|=4194816);else{if(typeof f!="function"&&typeof f!="object")throw Error(n(284));(o===null||o.ref!==f)&&(u.flags|=4194816)}}function cb(o,u,f,y,S){return Nl(u),f=Yv(o,u,f,y,void 0,S),y=Kv(),o!==null&&!Dn?($v(o,u,S),qs(o,u,S)):(K0&&y&&Cv(u),u.flags|=1,$n(o,u,f,S),u.child)}function vC(o,u,f,y,S,w){return Nl(u),u.updateQueue=null,f=gR(u,y,f,S),yR(o),y=Kv(),o!==null&&!Dn?($v(o,u,w),qs(o,u,w)):(K0&&y&&Cv(u),u.flags|=1,$n(o,u,f,w),u.child)}function bC(o,u,f,y,S){if(Nl(u),u.stateNode===null){var w=Wc,B=f.contextType;typeof B=="object"&&B!==null&&(w=xi(B)),w=new f(y,w),u.memoizedState=w.state!==null&&w.state!==void 0?w.state:null,w.updater=ob,u.stateNode=w,w._reactInternals=u,w=u.stateNode,w.props=y,w.state=u.memoizedState,w.refs={},Lv(u),B=f.contextType,w.context=typeof B=="object"&&B!==null?xi(B):Wc,w.state=u.memoizedState,B=f.getDerivedStateFromProps,typeof B=="function"&&(sb(u,f,B,y),w.state=u.memoizedState),typeof f.getDerivedStateFromProps=="function"||typeof w.getSnapshotBeforeUpdate=="function"||typeof w.UNSAFE_componentWillMount!="function"&&typeof w.componentWillMount!="function"||(B=w.state,typeof w.componentWillMount=="function"&&w.componentWillMount(),typeof w.UNSAFE_componentWillMount=="function"&&w.UNSAFE_componentWillMount(),B!==w.state&&ob.enqueueReplaceState(w,w.state,null),Cd(u,y,w,S),Rd(),w.state=u.memoizedState),typeof w.componentDidMount=="function"&&(u.flags|=4194308),y=!0}else if(o===null){w=u.stateNode;var W=u.memoizedProps,ie=Dl(f,W);w.props=ie;var Ee=w.context,Ke=f.contextType;B=Wc,typeof Ke=="object"&&Ke!==null&&(B=xi(Ke));var nt=f.getDerivedStateFromProps;Ke=typeof nt=="function"||typeof w.getSnapshotBeforeUpdate=="function",W=u.pendingProps!==W,Ke||typeof w.UNSAFE_componentWillReceiveProps!="function"&&typeof w.componentWillReceiveProps!="function"||(W||Ee!==B)&&aC(u,w,y,B),t2=!1;var De=u.memoizedState;w.state=De,Cd(u,y,w,S),Rd(),Ee=u.memoizedState,W||De!==Ee||t2?(typeof nt=="function"&&(sb(u,f,nt,y),Ee=u.memoizedState),(ie=t2||rC(u,f,ie,y,De,Ee,B))?(Ke||typeof w.UNSAFE_componentWillMount!="function"&&typeof w.componentWillMount!="function"||(typeof w.componentWillMount=="function"&&w.componentWillMount(),typeof w.UNSAFE_componentWillMount=="function"&&w.UNSAFE_componentWillMount()),typeof w.componentDidMount=="function"&&(u.flags|=4194308)):(typeof w.componentDidMount=="function"&&(u.flags|=4194308),u.memoizedProps=y,u.memoizedState=Ee),w.props=y,w.state=Ee,w.context=B,y=ie):(typeof w.componentDidMount=="function"&&(u.flags|=4194308),y=!1)}else{w=u.stateNode,zv(o,u),B=u.memoizedProps,Ke=Dl(f,B),w.props=Ke,nt=u.pendingProps,De=w.context,Ee=f.contextType,ie=Wc,typeof Ee=="object"&&Ee!==null&&(ie=xi(Ee)),W=f.getDerivedStateFromProps,(Ee=typeof W=="function"||typeof w.getSnapshotBeforeUpdate=="function")||typeof w.UNSAFE_componentWillReceiveProps!="function"&&typeof w.componentWillReceiveProps!="function"||(B!==nt||De!==ie)&&aC(u,w,y,ie),t2=!1,De=u.memoizedState,w.state=De,Cd(u,y,w,S),Rd();var ke=u.memoizedState;B!==nt||De!==ke||t2||o!==null&&o.dependencies!==null&&Gp(o.dependencies)?(typeof W=="function"&&(sb(u,f,W,y),ke=u.memoizedState),(Ke=t2||rC(u,f,Ke,y,De,ke,ie)||o!==null&&o.dependencies!==null&&Gp(o.dependencies))?(Ee||typeof w.UNSAFE_componentWillUpdate!="function"&&typeof w.componentWillUpdate!="function"||(typeof w.componentWillUpdate=="function"&&w.componentWillUpdate(y,ke,ie),typeof w.UNSAFE_componentWillUpdate=="function"&&w.UNSAFE_componentWillUpdate(y,ke,ie)),typeof w.componentDidUpdate=="function"&&(u.flags|=4),typeof w.getSnapshotBeforeUpdate=="function"&&(u.flags|=1024)):(typeof w.componentDidUpdate!="function"||B===o.memoizedProps&&De===o.memoizedState||(u.flags|=4),typeof w.getSnapshotBeforeUpdate!="function"||B===o.memoizedProps&&De===o.memoizedState||(u.flags|=1024),u.memoizedProps=y,u.memoizedState=ke),w.props=y,w.state=ke,w.context=ie,y=Ke):(typeof w.componentDidUpdate!="function"||B===o.memoizedProps&&De===o.memoizedState||(u.flags|=4),typeof w.getSnapshotBeforeUpdate!="function"||B===o.memoizedProps&&De===o.memoizedState||(u.flags|=1024),y=!1)}return w=y,om(o,u),y=(u.flags&128)!==0,w||y?(w=u.stateNode,f=y&&typeof f.getDerivedStateFromError!="function"?null:w.render(),u.flags|=1,o!==null&&y?(u.child=eu(u,o.child,null,S),u.child=eu(u,null,f,S)):$n(o,u,f,S),u.memoizedState=w.state,o=u.child):o=qs(o,u,S),o}function _C(o,u,f,y){return bd(),u.flags|=256,$n(o,u,f,y),u.child}var ub={dehydrated:null,treeContext:null,retryLane:0,hydrationErrors:null};function hb(o){return{baseLanes:o,cachePool:oR()}}function db(o,u,f){return o=o!==null?o.childLanes&~f:0,u&&(o|=ea),o}function SC(o,u,f){var y=u.pendingProps,S=!1,w=(u.flags&128)!==0,B;if((B=w)||(B=o!==null&&o.memoizedState===null?!1:(En.current&2)!==0),B&&(S=!0,u.flags&=-129),B=(u.flags&32)!==0,u.flags&=-33,o===null){if(K0){if(S?r2(u):a2(),K0){var W=Xx,ie;if(ie=W){e:{for(ie=W,W=hs;ie.nodeType!==8;){if(!W){W=null;break e}if(ie=Na(ie.nextSibling),ie===null){W=null;break e}}W=ie}W!==null?(u.memoizedState={dehydrated:W,treeContext:Al!==null?{id:Ks,overflow:$s}:null,retryLane:536870912,hydrationErrors:null},ie=lr(18,null,null,0),ie.stateNode=W,ie.return=u,u.child=ie,Si=u,Xx=null,ie=!0):ie=!1}ie||Rl(u)}if(W=u.memoizedState,W!==null&&(W=W.dehydrated,W!==null))return Zb(W)?u.lanes=32:u.lanes=536870912,null;js(u)}return W=y.children,y=y.fallback,S?(a2(),S=u.mode,W=lm({mode:"hidden",children:W},S),y=wl(y,S,f,null),W.return=u,y.return=u,W.sibling=y,u.child=W,S=u.child,S.memoizedState=hb(f),S.childLanes=db(o,B,f),u.memoizedState=ub,y):(r2(u),fb(u,W))}if(ie=o.memoizedState,ie!==null&&(W=ie.dehydrated,W!==null)){if(w)u.flags&256?(r2(u),u.flags&=-257,u=pb(o,u,f)):u.memoizedState!==null?(a2(),u.child=o.child,u.flags|=128,u=null):(a2(),S=y.fallback,W=u.mode,y=lm({mode:"visible",children:y.children},W),S=wl(S,W,f,null),S.flags|=2,y.return=u,S.return=u,y.sibling=S,u.child=y,eu(u,o.child,null,f),y=u.child,y.memoizedState=hb(f),y.childLanes=db(o,B,f),u.memoizedState=ub,u=S);else if(r2(u),Zb(W)){if(B=W.nextSibling&&W.nextSibling.dataset,B)var Ee=B.dgst;B=Ee,y=Error(n(419)),y.stack="",y.digest=B,_d({value:y,source:null,stack:null}),u=pb(o,u,f)}else if(Dn||Sd(o,u,f,!1),B=(f&o.childLanes)!==0,Dn||B){if(B=_x,B!==null&&(y=f&-f,y=(y&42)!==0?1:P0(y),y=(y&(B.suspendedLanes|f))!==0?0:y,y!==0&&y!==ie.retryLane))throw ie.retryLane=y,Gc(o,y),fr(B,o,y),dC;W.data==="$?"||Db(),u=pb(o,u,f)}else W.data==="$?"?(u.flags|=192,u.child=o.child,u=null):(o=ie.treeContext,Xx=Na(W.nextSibling),Si=u,K0=!0,Ml=null,hs=!1,o!==null&&(Jr[jr++]=Ks,Jr[jr++]=$s,Jr[jr++]=Al,Ks=o.id,$s=o.overflow,Al=u),u=fb(u,y.children),u.flags|=4096);return u}return S?(a2(),S=y.fallback,W=u.mode,ie=o.child,Ee=ie.sibling,y=Ys(ie,{mode:"hidden",children:y.children}),y.subtreeFlags=ie.subtreeFlags&65011712,Ee!==null?S=Ys(Ee,S):(S=wl(S,W,f,null),S.flags|=2),S.return=u,y.return=u,y.sibling=S,u.child=y,y=S,S=u.child,W=o.child.memoizedState,W===null?W=hb(f):(ie=W.cachePool,ie!==null?(Ee=An._currentValue,ie=ie.parent!==Ee?{parent:Ee,pool:Ee}:ie):ie=oR(),W={baseLanes:W.baseLanes|f,cachePool:ie}),S.memoizedState=W,S.childLanes=db(o,B,f),u.memoizedState=ub,y):(r2(u),f=o.child,o=f.sibling,f=Ys(f,{mode:"visible",children:y.children}),f.return=u,f.sibling=null,o!==null&&(B=u.deletions,B===null?(u.deletions=[o],u.flags|=16):B.push(o)),u.child=f,u.memoizedState=null,f)}function fb(o,u){return u=lm({mode:"visible",children:u},o.mode),u.return=o,o.child=u}function lm(o,u){return o=lr(22,o,null,u),o.lanes=0,o.stateNode={_visibility:1,_pendingMarkers:null,_retryCache:null,_transitions:null},o}function pb(o,u,f){return eu(u,o.child,null,f),o=fb(u,u.pendingProps.children),o.flags|=2,u.memoizedState=null,o}function TC(o,u,f){o.lanes|=u;var y=o.alternate;y!==null&&(y.lanes|=u),Dv(o.return,u,f)}function mb(o,u,f,y,S){var w=o.memoizedState;w===null?o.memoizedState={isBackwards:u,rendering:null,renderingStartTime:0,last:y,tail:f,tailMode:S}:(w.isBackwards=u,w.rendering=null,w.renderingStartTime=0,w.last=y,w.tail=f,w.tailMode=S)}function wC(o,u,f){var y=u.pendingProps,S=y.revealOrder,w=y.tail;if($n(o,u,y.children,f),y=En.current,(y&2)!==0)y=y&1|2,u.flags|=128;else{if(o!==null&&(o.flags&128)!==0)e:for(o=u.child;o!==null;){if(o.tag===13)o.memoizedState!==null&&TC(o,f,u);else if(o.tag===19)TC(o,f,u);else if(o.child!==null){o.child.return=o,o=o.child;continue}if(o===u)break e;for(;o.sibling===null;){if(o.return===null||o.return===u)break e;o=o.return}o.sibling.return=o.return,o=o.sibling}y&=1}switch(Me(En,y),S){case"forwards":for(f=u.child,S=null;f!==null;)o=f.alternate,o!==null&&rm(o)===null&&(S=f),f=f.sibling;f=S,f===null?(S=u.child,u.child=null):(S=f.sibling,f.sibling=null),mb(u,!1,S,f,w);break;case"backwards":for(f=null,S=u.child,u.child=null;S!==null;){if(o=S.alternate,o!==null&&rm(o)===null){u.child=S;break}o=S.sibling,S.sibling=f,f=S,S=o}mb(u,!0,f,null,w);break;case"together":mb(u,!1,null,null,void 0);break;default:u.memoizedState=null}return u.child}function qs(o,u,f){if(o!==null&&(u.dependencies=o.dependencies),u2|=u.lanes,(f&u.childLanes)===0)if(o!==null){if(Sd(o,u,f,!1),(f&u.childLanes)===0)return null}else return null;if(o!==null&&u.child!==o.child)throw Error(n(153));if(u.child!==null){for(o=u.child,f=Ys(o,o.pendingProps),u.child=f,f.return=u;o.sibling!==null;)o=o.sibling,f=f.sibling=Ys(o,o.pendingProps),f.return=u;f.sibling=null}return u.child}function yb(o,u){return(o.lanes&u)!==0?!0:(o=o.dependencies,!!(o!==null&&Gp(o)))}function wz(o,u,f){switch(u.tag){case 3:qe(u,u.stateNode.containerInfo),e2(u,An,o.memoizedState.cache),bd();break;case 27:case 5:Tt(u);break;case 4:qe(u,u.stateNode.containerInfo);break;case 10:e2(u,u.type,u.memoizedProps.value);break;case 13:var y=u.memoizedState;if(y!==null)return y.dehydrated!==null?(r2(u),u.flags|=128,null):(f&u.child.childLanes)!==0?SC(o,u,f):(r2(u),o=qs(o,u,f),o!==null?o.sibling:null);r2(u);break;case 19:var S=(o.flags&128)!==0;if(y=(f&u.childLanes)!==0,y||(Sd(o,u,f,!1),y=(f&u.childLanes)!==0),S){if(y)return wC(o,u,f);u.flags|=128}if(S=u.memoizedState,S!==null&&(S.rendering=null,S.tail=null,S.lastEffect=null),Me(En,En.current),y)break;return null;case 22:case 23:return u.lanes=0,yC(o,u,f);case 24:e2(u,An,o.memoizedState.cache)}return qs(o,u,f)}function AC(o,u,f){if(o!==null)if(o.memoizedProps!==u.pendingProps)Dn=!0;else{if(!yb(o,f)&&(u.flags&128)===0)return Dn=!1,wz(o,u,f);Dn=(o.flags&131072)!==0}else Dn=!1,K0&&(u.flags&1048576)!==0&&tR(u,Hp,u.index);switch(u.lanes=0,u.tag){case 16:e:{o=u.pendingProps;var y=u.elementType,S=y._init;if(y=S(y._payload),u.type=y,typeof y=="function")Ev(y)?(o=Dl(y,o),u.tag=1,u=bC(null,u,y,o,f)):(u.tag=0,u=cb(null,u,y,o,f));else{if(y!=null){if(S=y.$$typeof,S===A){u.tag=11,u=fC(null,u,y,o,f);break e}else if(S===C){u.tag=14,u=pC(null,u,y,o,f);break e}}throw u=xe(y)||y,Error(n(306,u,""))}}return u;case 0:return cb(o,u,u.type,u.pendingProps,f);case 1:return y=u.type,S=Dl(y,u.pendingProps),bC(o,u,y,S,f);case 3:e:{if(qe(u,u.stateNode.containerInfo),o===null)throw Error(n(387));y=u.pendingProps;var w=u.memoizedState;S=w.element,zv(o,u),Cd(u,y,null,f);var B=u.memoizedState;if(y=B.cache,e2(u,An,y),y!==w.cache&&Pv(u,[An],f,!0),Rd(),y=B.element,w.isDehydrated)if(w={element:y,isDehydrated:!1,cache:B.cache},u.updateQueue.baseState=w,u.memoizedState=w,u.flags&256){u=_C(o,u,y,f);break e}else if(y!==S){S=Qr(Error(n(424)),u),_d(S),u=_C(o,u,y,f);break e}else{switch(o=u.stateNode.containerInfo,o.nodeType){case 9:o=o.body;break;default:o=o.nodeName==="HTML"?o.ownerDocument.body:o}for(Xx=Na(o.firstChild),Si=u,K0=!0,Ml=null,hs=!0,f=nC(u,null,y,f),u.child=f;f;)f.flags=f.flags&-3|4096,f=f.sibling}else{if(bd(),y===S){u=qs(o,u,f);break e}$n(o,u,y,f)}u=u.child}return u;case 26:return om(o,u),o===null?(f=CN(u.type,null,u.pendingProps,null))?u.memoizedState=f:K0||(f=u.type,o=u.pendingProps,y=Tm(Fe.current).createElement(f),y[L0]=u,y[R0]=o,Zn(y,f,o),ce(y),u.stateNode=y):u.memoizedState=CN(u.type,o.memoizedProps,u.pendingProps,o.memoizedState),null;case 27:return Tt(u),o===null&&K0&&(y=u.stateNode=EN(u.type,u.pendingProps,Fe.current),Si=u,hs=!0,S=Xx,p2(u.type)?(Jb=S,Xx=Na(y.firstChild)):Xx=S),$n(o,u,u.pendingProps.children,f),om(o,u),o===null&&(u.flags|=4194304),u.child;case 5:return o===null&&K0&&((S=y=Xx)&&(y=jz(y,u.type,u.pendingProps,hs),y!==null?(u.stateNode=y,Si=u,Xx=Na(y.firstChild),hs=!1,S=!0):S=!1),S||Rl(u)),Tt(u),S=u.type,w=u.pendingProps,B=o!==null?o.memoizedProps:null,y=w.children,Kb(S,w)?y=null:B!==null&&Kb(S,B)&&(u.flags|=32),u.memoizedState!==null&&(S=Yv(o,u,mz,null,null,f),Jd._currentValue=S),om(o,u),$n(o,u,y,f),u.child;case 6:return o===null&&K0&&((o=f=Xx)&&(f=qz(f,u.pendingProps,hs),f!==null?(u.stateNode=f,Si=u,Xx=null,o=!0):o=!1),o||Rl(u)),null;case 13:return SC(o,u,f);case 4:return qe(u,u.stateNode.containerInfo),y=u.pendingProps,o===null?u.child=eu(u,null,y,f):$n(o,u,y,f),u.child;case 11:return fC(o,u,u.type,u.pendingProps,f);case 7:return $n(o,u,u.pendingProps,f),u.child;case 8:return $n(o,u,u.pendingProps.children,f),u.child;case 12:return $n(o,u,u.pendingProps.children,f),u.child;case 10:return y=u.pendingProps,e2(u,u.type,y.value),$n(o,u,y.children,f),u.child;case 9:return S=u.type._context,y=u.pendingProps.children,Nl(u),S=xi(S),y=y(S),u.flags|=1,$n(o,u,y,f),u.child;case 14:return pC(o,u,u.type,u.pendingProps,f);case 15:return mC(o,u,u.type,u.pendingProps,f);case 19:return wC(o,u,f);case 31:return y=u.pendingProps,f=u.mode,y={mode:y.mode,children:y.children},o===null?(f=lm(y,f),f.ref=u.ref,u.child=f,f.return=u,u=f):(f=Ys(o.child,y),f.ref=u.ref,u.child=f,f.return=u,u=f),u;case 22:return yC(o,u,f);case 24:return Nl(u),y=xi(An),o===null?(S=Fv(),S===null&&(S=_x,w=kv(),S.pooledCache=w,w.refCount++,w!==null&&(S.pooledCacheLanes|=f),S=w),u.memoizedState={parent:y,cache:S},Lv(u),e2(u,An,S)):((o.lanes&f)!==0&&(zv(o,u),Cd(u,null,null,f),Rd()),S=o.memoizedState,w=u.memoizedState,S.parent!==y?(S={parent:y,cache:y},u.memoizedState=S,u.lanes===0&&(u.memoizedState=u.updateQueue.baseState=S),e2(u,An,y)):(y=w.cache,e2(u,An,y),y!==S.cache&&Pv(u,[An],f,!0))),$n(o,u,u.pendingProps.children,f),u.child;case 29:throw u.pendingProps}throw Error(n(156,u.tag))}function eo(o){o.flags|=4}function EC(o,u){if(u.type!=="stylesheet"||(u.state.loading&4)!==0)o.flags&=-16777217;else if(o.flags|=16777216,!PN(u)){if(u=qr.current,u!==null&&((B0&4194048)===B0?ds!==null:(B0&62914560)!==B0&&(B0&536870912)===0||u!==ds))throw Ed=Bv,lR;o.flags|=8192}}function cm(o,u){u!==null&&(o.flags|=4),o.flags&16384&&(u=o.tag!==22?Xe():536870912,o.lanes|=u,iu|=u)}function Ud(o,u){if(!K0)switch(o.tailMode){case"hidden":u=o.tail;for(var f=null;u!==null;)u.alternate!==null&&(f=u),u=u.sibling;f===null?o.tail=null:f.sibling=null;break;case"collapsed":f=o.tail;for(var y=null;f!==null;)f.alternate!==null&&(y=f),f=f.sibling;y===null?u||o.tail===null?o.tail=null:o.tail.sibling=null:y.sibling=null}}function Hx(o){var u=o.alternate!==null&&o.alternate.child===o.child,f=0,y=0;if(u)for(var S=o.child;S!==null;)f|=S.lanes|S.childLanes,y|=S.subtreeFlags&65011712,y|=S.flags&65011712,S.return=o,S=S.sibling;else for(S=o.child;S!==null;)f|=S.lanes|S.childLanes,y|=S.subtreeFlags,y|=S.flags,S.return=o,S=S.sibling;return o.subtreeFlags|=y,o.childLanes=f,u}function Az(o,u,f){var y=u.pendingProps;switch(Nv(u),u.tag){case 31:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Hx(u),null;case 1:return Hx(u),null;case 3:return f=u.stateNode,y=null,o!==null&&(y=o.memoizedState.cache),u.memoizedState.cache!==y&&(u.flags|=2048),Zs(An),Et(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(o===null||o.child===null)&&(vd(u)?eo(u):o===null||o.memoizedState.isDehydrated&&(u.flags&256)===0||(u.flags|=1024,iR())),Hx(u),null;case 26:return f=u.memoizedState,o===null?(eo(u),f!==null?(Hx(u),EC(u,f)):(Hx(u),u.flags&=-16777217)):f?f!==o.memoizedState?(eo(u),Hx(u),EC(u,f)):(Hx(u),u.flags&=-16777217):(o.memoizedProps!==y&&eo(u),Hx(u),u.flags&=-16777217),null;case 27:Bt(u),f=Fe.current;var S=u.type;if(o!==null&&u.stateNode!=null)o.memoizedProps!==y&&eo(u);else{if(!y){if(u.stateNode===null)throw Error(n(166));return Hx(u),null}o=le.current,vd(u)?xR(u):(o=EN(S,y,f),u.stateNode=o,eo(u))}return Hx(u),null;case 5:if(Bt(u),f=u.type,o!==null&&u.stateNode!=null)o.memoizedProps!==y&&eo(u);else{if(!y){if(u.stateNode===null)throw Error(n(166));return Hx(u),null}if(o=le.current,vd(u))xR(u);else{switch(S=Tm(Fe.current),o){case 1:o=S.createElementNS("http://www.w3.org/2000/svg",f);break;case 2:o=S.createElementNS("http://www.w3.org/1998/Math/MathML",f);break;default:switch(f){case"svg":o=S.createElementNS("http://www.w3.org/2000/svg",f);break;case"math":o=S.createElementNS("http://www.w3.org/1998/Math/MathML",f);break;case"script":o=S.createElement("div"),o.innerHTML="<script><\/script>",o=o.removeChild(o.firstChild);break;case"select":o=typeof y.is=="string"?S.createElement("select",{is:y.is}):S.createElement("select"),y.multiple?o.multiple=!0:y.size&&(o.size=y.size);break;default:o=typeof y.is=="string"?S.createElement(f,{is:y.is}):S.createElement(f)}}o[L0]=u,o[R0]=y;e:for(S=u.child;S!==null;){if(S.tag===5||S.tag===6)o.appendChild(S.stateNode);else if(S.tag!==4&&S.tag!==27&&S.child!==null){S.child.return=S,S=S.child;continue}if(S===u)break e;for(;S.sibling===null;){if(S.return===null||S.return===u)break e;S=S.return}S.sibling.return=S.return,S=S.sibling}u.stateNode=o;e:switch(Zn(o,f,y),f){case"button":case"input":case"select":case"textarea":o=!!y.autoFocus;break e;case"img":o=!0;break e;default:o=!1}o&&eo(u)}}return Hx(u),u.flags&=-16777217,null;case 6:if(o&&u.stateNode!=null)o.memoizedProps!==y&&eo(u);else{if(typeof y!="string"&&u.stateNode===null)throw Error(n(166));if(o=Fe.current,vd(u)){if(o=u.stateNode,f=u.memoizedProps,y=null,S=Si,S!==null)switch(S.tag){case 27:case 5:y=S.memoizedProps}o[L0]=u,o=!!(o.nodeValue===f||y!==null&&y.suppressHydrationWarning===!0||vN(o.nodeValue,f)),o||Rl(u)}else o=Tm(o).createTextNode(y),o[L0]=u,u.stateNode=o}return Hx(u),null;case 13:if(y=u.memoizedState,o===null||o.memoizedState!==null&&o.memoizedState.dehydrated!==null){if(S=vd(u),y!==null&&y.dehydrated!==null){if(o===null){if(!S)throw Error(n(318));if(S=u.memoizedState,S=S!==null?S.dehydrated:null,!S)throw Error(n(317));S[L0]=u}else bd(),(u.flags&128)===0&&(u.memoizedState=null),u.flags|=4;Hx(u),S=!1}else S=iR(),o!==null&&o.memoizedState!==null&&(o.memoizedState.hydrationErrors=S),S=!0;if(!S)return u.flags&256?(js(u),u):(js(u),null)}if(js(u),(u.flags&128)!==0)return u.lanes=f,u;if(f=y!==null,o=o!==null&&o.memoizedState!==null,f){y=u.child,S=null,y.alternate!==null&&y.alternate.memoizedState!==null&&y.alternate.memoizedState.cachePool!==null&&(S=y.alternate.memoizedState.cachePool.pool);var w=null;y.memoizedState!==null&&y.memoizedState.cachePool!==null&&(w=y.memoizedState.cachePool.pool),w!==S&&(y.flags|=2048)}return f!==o&&f&&(u.child.flags|=8192),cm(u,u.updateQueue),Hx(u),null;case 4:return Et(),o===null&&Hb(u.stateNode.containerInfo),Hx(u),null;case 10:return Zs(u.type),Hx(u),null;case 19:if(ge(En),S=u.memoizedState,S===null)return Hx(u),null;if(y=(u.flags&128)!==0,w=S.rendering,w===null)if(y)Ud(S,!1);else{if(Yx!==0||o!==null&&(o.flags&128)!==0)for(o=u.child;o!==null;){if(w=rm(o),w!==null){for(u.flags|=128,Ud(S,!1),o=w.updateQueue,u.updateQueue=o,cm(u,o),u.subtreeFlags=0,o=f,f=u.child;f!==null;)eR(f,o),f=f.sibling;return Me(En,En.current&1|2),u.child}o=o.sibling}S.tail!==null&&bt()>dm&&(u.flags|=128,y=!0,Ud(S,!1),u.lanes=4194304)}else{if(!y)if(o=rm(w),o!==null){if(u.flags|=128,y=!0,o=o.updateQueue,u.updateQueue=o,cm(u,o),Ud(S,!0),S.tail===null&&S.tailMode==="hidden"&&!w.alternate&&!K0)return Hx(u),null}else 2*bt()-S.renderingStartTime>dm&&f!==536870912&&(u.flags|=128,y=!0,Ud(S,!1),u.lanes=4194304);S.isBackwards?(w.sibling=u.child,u.child=w):(o=S.last,o!==null?o.sibling=w:u.child=w,S.last=w)}return S.tail!==null?(u=S.tail,S.rendering=u,S.tail=u.sibling,S.renderingStartTime=bt(),u.sibling=null,o=En.current,Me(En,y?o&1|2:o&1),u):(Hx(u),null);case 22:case 23:return js(u),Wv(),y=u.memoizedState!==null,o!==null?o.memoizedState!==null!==y&&(u.flags|=8192):y&&(u.flags|=8192),y?(f&536870912)!==0&&(u.flags&128)===0&&(Hx(u),u.subtreeFlags&6&&(u.flags|=8192)):Hx(u),f=u.updateQueue,f!==null&&cm(u,f.retryQueue),f=null,o!==null&&o.memoizedState!==null&&o.memoizedState.cachePool!==null&&(f=o.memoizedState.cachePool.pool),y=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(y=u.memoizedState.cachePool.pool),y!==f&&(u.flags|=2048),o!==null&&ge(Il),null;case 24:return f=null,o!==null&&(f=o.memoizedState.cache),u.memoizedState.cache!==f&&(u.flags|=2048),Zs(An),Hx(u),null;case 25:return null;case 30:return null}throw Error(n(156,u.tag))}function Ez(o,u){switch(Nv(u),u.tag){case 1:return o=u.flags,o&65536?(u.flags=o&-65537|128,u):null;case 3:return Zs(An),Et(),o=u.flags,(o&65536)!==0&&(o&128)===0?(u.flags=o&-65537|128,u):null;case 26:case 27:case 5:return Bt(u),null;case 13:if(js(u),o=u.memoizedState,o!==null&&o.dehydrated!==null){if(u.alternate===null)throw Error(n(340));bd()}return o=u.flags,o&65536?(u.flags=o&-65537|128,u):null;case 19:return ge(En),null;case 4:return Et(),null;case 10:return Zs(u.type),null;case 22:case 23:return js(u),Wv(),o!==null&&ge(Il),o=u.flags,o&65536?(u.flags=o&-65537|128,u):null;case 24:return Zs(An),null;case 25:return null;default:return null}}function MC(o,u){switch(Nv(u),u.tag){case 3:Zs(An),Et();break;case 26:case 27:case 5:Bt(u);break;case 4:Et();break;case 13:js(u);break;case 19:ge(En);break;case 10:Zs(u.type);break;case 22:case 23:js(u),Wv(),o!==null&&ge(Il);break;case 24:Zs(An)}}function Fd(o,u){try{var f=u.updateQueue,y=f!==null?f.lastEffect:null;if(y!==null){var S=y.next;f=S;do{if((f.tag&o)===o){y=void 0;var w=f.create,B=f.inst;y=w(),B.destroy=y}f=f.next}while(f!==S)}}catch(W){px(u,u.return,W)}}function s2(o,u,f){try{var y=u.updateQueue,S=y!==null?y.lastEffect:null;if(S!==null){var w=S.next;y=w;do{if((y.tag&o)===o){var B=y.inst,W=B.destroy;if(W!==void 0){B.destroy=void 0,S=u;var ie=f,Ee=W;try{Ee()}catch(Ke){px(S,ie,Ke)}}}y=y.next}while(y!==w)}}catch(Ke){px(u,u.return,Ke)}}function RC(o){var u=o.updateQueue;if(u!==null){var f=o.stateNode;try{pR(u,f)}catch(y){px(o,o.return,y)}}}function CC(o,u,f){f.props=Dl(o.type,o.memoizedProps),f.state=o.memoizedState;try{f.componentWillUnmount()}catch(y){px(o,u,y)}}function Bd(o,u){try{var f=o.ref;if(f!==null){switch(o.tag){case 26:case 27:case 5:var y=o.stateNode;break;case 30:y=o.stateNode;break;default:y=o.stateNode}typeof f=="function"?o.refCleanup=f(y):f.current=y}}catch(S){px(o,u,S)}}function fs(o,u){var f=o.ref,y=o.refCleanup;if(f!==null)if(typeof y=="function")try{y()}catch(S){px(o,u,S)}finally{o.refCleanup=null,o=o.alternate,o!=null&&(o.refCleanup=null)}else if(typeof f=="function")try{f(null)}catch(S){px(o,u,S)}else f.current=null}function NC(o){var u=o.type,f=o.memoizedProps,y=o.stateNode;try{e:switch(u){case"button":case"input":case"select":case"textarea":f.autoFocus&&y.focus();break e;case"img":f.src?y.src=f.src:f.srcSet&&(y.srcset=f.srcSet)}}catch(S){px(o,o.return,S)}}function gb(o,u,f){try{var y=o.stateNode;Kz(y,o.type,f,u),y[R0]=u}catch(S){px(o,o.return,S)}}function IC(o){return o.tag===5||o.tag===3||o.tag===26||o.tag===27&&p2(o.type)||o.tag===4}function vb(o){e:for(;;){for(;o.sibling===null;){if(o.return===null||IC(o.return))return null;o=o.return}for(o.sibling.return=o.return,o=o.sibling;o.tag!==5&&o.tag!==6&&o.tag!==18;){if(o.tag===27&&p2(o.type)||o.flags&2||o.child===null||o.tag===4)continue e;o.child.return=o,o=o.child}if(!(o.flags&2))return o.stateNode}}function bb(o,u,f){var y=o.tag;if(y===5||y===6)o=o.stateNode,u?(f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f).insertBefore(o,u):(u=f.nodeType===9?f.body:f.nodeName==="HTML"?f.ownerDocument.body:f,u.appendChild(o),f=f._reactRootContainer,f!=null||u.onclick!==null||(u.onclick=Sm));else if(y!==4&&(y===27&&p2(o.type)&&(f=o.stateNode,u=null),o=o.child,o!==null))for(bb(o,u,f),o=o.sibling;o!==null;)bb(o,u,f),o=o.sibling}function um(o,u,f){var y=o.tag;if(y===5||y===6)o=o.stateNode,u?f.insertBefore(o,u):f.appendChild(o);else if(y!==4&&(y===27&&p2(o.type)&&(f=o.stateNode),o=o.child,o!==null))for(um(o,u,f),o=o.sibling;o!==null;)um(o,u,f),o=o.sibling}function OC(o){var u=o.stateNode,f=o.memoizedProps;try{for(var y=o.type,S=u.attributes;S.length;)u.removeAttributeNode(S[0]);Zn(u,y,f),u[L0]=o,u[R0]=f}catch(w){px(o,o.return,w)}}var to=!1,jx=!1,_b=!1,DC=typeof WeakSet=="function"?WeakSet:Set,Pn=null;function Mz(o,u){if(o=o.containerInfo,Xb=Cm,o=$r(o),sr(o)){if("selectionStart"in o)var f={start:o.selectionStart,end:o.selectionEnd};else e:{f=(f=o.ownerDocument)&&f.defaultView||window;var y=f.getSelection&&f.getSelection();if(y&&y.rangeCount!==0){f=y.anchorNode;var S=y.anchorOffset,w=y.focusNode;y=y.focusOffset;try{f.nodeType,w.nodeType}catch{f=null;break e}var B=0,W=-1,ie=-1,Ee=0,Ke=0,nt=o,De=null;t:for(;;){for(var ke;nt!==f||S!==0&&nt.nodeType!==3||(W=B+S),nt!==w||y!==0&&nt.nodeType!==3||(ie=B+y),nt.nodeType===3&&(B+=nt.nodeValue.length),(ke=nt.firstChild)!==null;)De=nt,nt=ke;for(;;){if(nt===o)break t;if(De===f&&++Ee===S&&(W=B),De===w&&++Ke===y&&(ie=B),(ke=nt.nextSibling)!==null)break;nt=De,De=nt.parentNode}nt=ke}f=W===-1||ie===-1?null:{start:W,end:ie}}else f=null}f=f||{start:0,end:0}}else f=null;for(Yb={focusedElem:o,selectionRange:f},Cm=!1,Pn=u;Pn!==null;)if(u=Pn,o=u.child,(u.subtreeFlags&1024)!==0&&o!==null)o.return=u,Pn=o;else for(;Pn!==null;){switch(u=Pn,w=u.alternate,o=u.flags,u.tag){case 0:break;case 11:case 15:break;case 1:if((o&1024)!==0&&w!==null){o=void 0,f=u,S=w.memoizedProps,w=w.memoizedState,y=f.stateNode;try{var u0=Dl(f.type,S,f.elementType===f.type);o=y.getSnapshotBeforeUpdate(u0,w),y.__reactInternalSnapshotBeforeUpdate=o}catch(o0){px(f,f.return,o0)}}break;case 3:if((o&1024)!==0){if(o=u.stateNode.containerInfo,f=o.nodeType,f===9)Qb(o);else if(f===1)switch(o.nodeName){case"HEAD":case"HTML":case"BODY":Qb(o);break;default:o.textContent=""}}break;case 5:case 26:case 27:case 6:case 4:case 17:break;default:if((o&1024)!==0)throw Error(n(163))}if(o=u.sibling,o!==null){o.return=u.return,Pn=o;break}Pn=u.return}}function PC(o,u,f){var y=f.flags;switch(f.tag){case 0:case 11:case 15:o2(o,f),y&4&&Fd(5,f);break;case 1:if(o2(o,f),y&4)if(o=f.stateNode,u===null)try{o.componentDidMount()}catch(B){px(f,f.return,B)}else{var S=Dl(f.type,u.memoizedProps);u=u.memoizedState;try{o.componentDidUpdate(S,u,o.__reactInternalSnapshotBeforeUpdate)}catch(B){px(f,f.return,B)}}y&64&&RC(f),y&512&&Bd(f,f.return);break;case 3:if(o2(o,f),y&64&&(o=f.updateQueue,o!==null)){if(u=null,f.child!==null)switch(f.child.tag){case 27:case 5:u=f.child.stateNode;break;case 1:u=f.child.stateNode}try{pR(o,u)}catch(B){px(f,f.return,B)}}break;case 27:u===null&&y&4&&OC(f);case 26:case 5:o2(o,f),u===null&&y&4&&NC(f),y&512&&Bd(f,f.return);break;case 12:o2(o,f);break;case 13:o2(o,f),y&4&&FC(o,f),y&64&&(o=f.memoizedState,o!==null&&(o=o.dehydrated,o!==null&&(f=Uz.bind(null,f),e5(o,f))));break;case 22:if(y=f.memoizedState!==null||to,!y){u=u!==null&&u.memoizedState!==null||jx,S=to;var w=jx;to=y,(jx=u)&&!w?l2(o,f,(f.subtreeFlags&8772)!==0):o2(o,f),to=S,jx=w}break;case 30:break;default:o2(o,f)}}function kC(o){var u=o.alternate;u!==null&&(o.alternate=null,kC(u)),o.child=null,o.deletions=null,o.sibling=null,o.tag===5&&(u=o.stateNode,u!==null&&Gr(u)),o.stateNode=null,o.return=null,o.dependencies=null,o.memoizedProps=null,o.memoizedState=null,o.pendingProps=null,o.stateNode=null,o.updateQueue=null}var Ix=null,zi=!1;function xo(o,u,f){for(f=f.child;f!==null;)UC(o,u,f),f=f.sibling}function UC(o,u,f){if(Ce&&typeof Ce.onCommitFiberUnmount=="function")try{Ce.onCommitFiberUnmount(_t,f)}catch{}switch(f.tag){case 26:jx||fs(f,u),xo(o,u,f),f.memoizedState?f.memoizedState.count--:f.stateNode&&(f=f.stateNode,f.parentNode.removeChild(f));break;case 27:jx||fs(f,u);var y=Ix,S=zi;p2(f.type)&&(Ix=f.stateNode,zi=!1),xo(o,u,f),Kd(f.stateNode),Ix=y,zi=S;break;case 5:jx||fs(f,u);case 6:if(y=Ix,S=zi,Ix=null,xo(o,u,f),Ix=y,zi=S,Ix!==null)if(zi)try{(Ix.nodeType===9?Ix.body:Ix.nodeName==="HTML"?Ix.ownerDocument.body:Ix).removeChild(f.stateNode)}catch(w){px(f,u,w)}else try{Ix.removeChild(f.stateNode)}catch(w){px(f,u,w)}break;case 18:Ix!==null&&(zi?(o=Ix,wN(o.nodeType===9?o.body:o.nodeName==="HTML"?o.ownerDocument.body:o,f.stateNode),tf(o)):wN(Ix,f.stateNode));break;case 4:y=Ix,S=zi,Ix=f.stateNode.containerInfo,zi=!0,xo(o,u,f),Ix=y,zi=S;break;case 0:case 11:case 14:case 15:jx||s2(2,f,u),jx||s2(4,f,u),xo(o,u,f);break;case 1:jx||(fs(f,u),y=f.stateNode,typeof y.componentWillUnmount=="function"&&CC(f,u,y)),xo(o,u,f);break;case 21:xo(o,u,f);break;case 22:jx=(y=jx)||f.memoizedState!==null,xo(o,u,f),jx=y;break;default:xo(o,u,f)}}function FC(o,u){if(u.memoizedState===null&&(o=u.alternate,o!==null&&(o=o.memoizedState,o!==null&&(o=o.dehydrated,o!==null))))try{tf(o)}catch(f){px(u,u.return,f)}}function Rz(o){switch(o.tag){case 13:case 19:var u=o.stateNode;return u===null&&(u=o.stateNode=new DC),u;case 22:return o=o.stateNode,u=o._retryCache,u===null&&(u=o._retryCache=new DC),u;default:throw Error(n(435,o.tag))}}function Sb(o,u){var f=Rz(o);u.forEach(function(y){var S=Fz.bind(null,o,y);f.has(y)||(f.add(y),y.then(S,S))})}function cr(o,u){var f=u.deletions;if(f!==null)for(var y=0;y<f.length;y++){var S=f[y],w=o,B=u,W=B;e:for(;W!==null;){switch(W.tag){case 27:if(p2(W.type)){Ix=W.stateNode,zi=!1;break e}break;case 5:Ix=W.stateNode,zi=!1;break e;case 3:case 4:Ix=W.stateNode.containerInfo,zi=!0;break e}W=W.return}if(Ix===null)throw Error(n(160));UC(w,B,S),Ix=null,zi=!1,w=S.alternate,w!==null&&(w.return=null),S.return=null}if(u.subtreeFlags&13878)for(u=u.child;u!==null;)BC(u,o),u=u.sibling}var Ca=null;function BC(o,u){var f=o.alternate,y=o.flags;switch(o.tag){case 0:case 11:case 14:case 15:cr(u,o),ur(o),y&4&&(s2(3,o,o.return),Fd(3,o),s2(5,o,o.return));break;case 1:cr(u,o),ur(o),y&512&&(jx||f===null||fs(f,f.return)),y&64&&to&&(o=o.updateQueue,o!==null&&(y=o.callbacks,y!==null&&(f=o.shared.hiddenCallbacks,o.shared.hiddenCallbacks=f===null?y:f.concat(y))));break;case 26:var S=Ca;if(cr(u,o),ur(o),y&512&&(jx||f===null||fs(f,f.return)),y&4){var w=f!==null?f.memoizedState:null;if(y=o.memoizedState,f===null)if(y===null)if(o.stateNode===null){e:{y=o.type,f=o.memoizedProps,S=S.ownerDocument||S;t:switch(y){case"title":w=S.getElementsByTagName("title")[0],(!w||w[yi]||w[L0]||w.namespaceURI==="http://www.w3.org/2000/svg"||w.hasAttribute("itemprop"))&&(w=S.createElement(y),S.head.insertBefore(w,S.querySelector("head > title"))),Zn(w,y,f),w[L0]=o,ce(w),y=w;break e;case"link":var B=ON("link","href",S).get(y+(f.href||""));if(B){for(var W=0;W<B.length;W++)if(w=B[W],w.getAttribute("href")===(f.href==null||f.href===""?null:f.href)&&w.getAttribute("rel")===(f.rel==null?null:f.rel)&&w.getAttribute("title")===(f.title==null?null:f.title)&&w.getAttribute("crossorigin")===(f.crossOrigin==null?null:f.crossOrigin)){B.splice(W,1);break t}}w=S.createElement(y),Zn(w,y,f),S.head.appendChild(w);break;case"meta":if(B=ON("meta","content",S).get(y+(f.content||""))){for(W=0;W<B.length;W++)if(w=B[W],w.getAttribute("content")===(f.content==null?null:""+f.content)&&w.getAttribute("name")===(f.name==null?null:f.name)&&w.getAttribute("property")===(f.property==null?null:f.property)&&w.getAttribute("http-equiv")===(f.httpEquiv==null?null:f.httpEquiv)&&w.getAttribute("charset")===(f.charSet==null?null:f.charSet)){B.splice(W,1);break t}}w=S.createElement(y),Zn(w,y,f),S.head.appendChild(w);break;default:throw Error(n(468,y))}w[L0]=o,ce(w),y=w}o.stateNode=y}else DN(S,o.type,o.stateNode);else o.stateNode=IN(S,y,o.memoizedProps);else w!==y?(w===null?f.stateNode!==null&&(f=f.stateNode,f.parentNode.removeChild(f)):w.count--,y===null?DN(S,o.type,o.stateNode):IN(S,y,o.memoizedProps)):y===null&&o.stateNode!==null&&gb(o,o.memoizedProps,f.memoizedProps)}break;case 27:cr(u,o),ur(o),y&512&&(jx||f===null||fs(f,f.return)),f!==null&&y&4&&gb(o,o.memoizedProps,f.memoizedProps);break;case 5:if(cr(u,o),ur(o),y&512&&(jx||f===null||fs(f,f.return)),o.flags&32){S=o.stateNode;try{ki(S,"")}catch(ke){px(o,o.return,ke)}}y&4&&o.stateNode!=null&&(S=o.memoizedProps,gb(o,S,f!==null?f.memoizedProps:S)),y&1024&&(_b=!0);break;case 6:if(cr(u,o),ur(o),y&4){if(o.stateNode===null)throw Error(n(162));y=o.memoizedProps,f=o.stateNode;try{f.nodeValue=y}catch(ke){px(o,o.return,ke)}}break;case 3:if(Em=null,S=Ca,Ca=wm(u.containerInfo),cr(u,o),Ca=S,ur(o),y&4&&f!==null&&f.memoizedState.isDehydrated)try{tf(u.containerInfo)}catch(ke){px(o,o.return,ke)}_b&&(_b=!1,LC(o));break;case 4:y=Ca,Ca=wm(o.stateNode.containerInfo),cr(u,o),ur(o),Ca=y;break;case 12:cr(u,o),ur(o);break;case 13:cr(u,o),ur(o),o.child.flags&8192&&o.memoizedState!==null!=(f!==null&&f.memoizedState!==null)&&(Rb=bt()),y&4&&(y=o.updateQueue,y!==null&&(o.updateQueue=null,Sb(o,y)));break;case 22:S=o.memoizedState!==null;var ie=f!==null&&f.memoizedState!==null,Ee=to,Ke=jx;if(to=Ee||S,jx=Ke||ie,cr(u,o),jx=Ke,to=Ee,ur(o),y&8192)e:for(u=o.stateNode,u._visibility=S?u._visibility&-2:u._visibility|1,S&&(f===null||ie||to||jx||Pl(o)),f=null,u=o;;){if(u.tag===5||u.tag===26){if(f===null){ie=f=u;try{if(w=ie.stateNode,S)B=w.style,typeof B.setProperty=="function"?B.setProperty("display","none","important"):B.display="none";else{W=ie.stateNode;var nt=ie.memoizedProps.style,De=nt!=null&&nt.hasOwnProperty("display")?nt.display:null;W.style.display=De==null||typeof De=="boolean"?"":(""+De).trim()}}catch(ke){px(ie,ie.return,ke)}}}else if(u.tag===6){if(f===null){ie=u;try{ie.stateNode.nodeValue=S?"":ie.memoizedProps}catch(ke){px(ie,ie.return,ke)}}}else if((u.tag!==22&&u.tag!==23||u.memoizedState===null||u===o)&&u.child!==null){u.child.return=u,u=u.child;continue}if(u===o)break e;for(;u.sibling===null;){if(u.return===null||u.return===o)break e;f===u&&(f=null),u=u.return}f===u&&(f=null),u.sibling.return=u.return,u=u.sibling}y&4&&(y=o.updateQueue,y!==null&&(f=y.retryQueue,f!==null&&(y.retryQueue=null,Sb(o,f))));break;case 19:cr(u,o),ur(o),y&4&&(y=o.updateQueue,y!==null&&(o.updateQueue=null,Sb(o,y)));break;case 30:break;case 21:break;default:cr(u,o),ur(o)}}function ur(o){var u=o.flags;if(u&2){try{for(var f,y=o.return;y!==null;){if(IC(y)){f=y;break}y=y.return}if(f==null)throw Error(n(160));switch(f.tag){case 27:var S=f.stateNode,w=vb(o);um(o,w,S);break;case 5:var B=f.stateNode;f.flags&32&&(ki(B,""),f.flags&=-33);var W=vb(o);um(o,W,B);break;case 3:case 4:var ie=f.stateNode.containerInfo,Ee=vb(o);bb(o,Ee,ie);break;default:throw Error(n(161))}}catch(Ke){px(o,o.return,Ke)}o.flags&=-3}u&4096&&(o.flags&=-4097)}function LC(o){if(o.subtreeFlags&1024)for(o=o.child;o!==null;){var u=o;LC(u),u.tag===5&&u.flags&1024&&u.stateNode.reset(),o=o.sibling}}function o2(o,u){if(u.subtreeFlags&8772)for(u=u.child;u!==null;)PC(o,u.alternate,u),u=u.sibling}function Pl(o){for(o=o.child;o!==null;){var u=o;switch(u.tag){case 0:case 11:case 14:case 15:s2(4,u,u.return),Pl(u);break;case 1:fs(u,u.return);var f=u.stateNode;typeof f.componentWillUnmount=="function"&&CC(u,u.return,f),Pl(u);break;case 27:Kd(u.stateNode);case 26:case 5:fs(u,u.return),Pl(u);break;case 22:u.memoizedState===null&&Pl(u);break;case 30:Pl(u);break;default:Pl(u)}o=o.sibling}}function l2(o,u,f){for(f=f&&(u.subtreeFlags&8772)!==0,u=u.child;u!==null;){var y=u.alternate,S=o,w=u,B=w.flags;switch(w.tag){case 0:case 11:case 15:l2(S,w,f),Fd(4,w);break;case 1:if(l2(S,w,f),y=w,S=y.stateNode,typeof S.componentDidMount=="function")try{S.componentDidMount()}catch(Ee){px(y,y.return,Ee)}if(y=w,S=y.updateQueue,S!==null){var W=y.stateNode;try{var ie=S.shared.hiddenCallbacks;if(ie!==null)for(S.shared.hiddenCallbacks=null,S=0;S<ie.length;S++)fR(ie[S],W)}catch(Ee){px(y,y.return,Ee)}}f&&B&64&&RC(w),Bd(w,w.return);break;case 27:OC(w);case 26:case 5:l2(S,w,f),f&&y===null&&B&4&&NC(w),Bd(w,w.return);break;case 12:l2(S,w,f);break;case 13:l2(S,w,f),f&&B&4&&FC(S,w);break;case 22:w.memoizedState===null&&l2(S,w,f),Bd(w,w.return);break;case 30:break;default:l2(S,w,f)}u=u.sibling}}function Tb(o,u){var f=null;o!==null&&o.memoizedState!==null&&o.memoizedState.cachePool!==null&&(f=o.memoizedState.cachePool.pool),o=null,u.memoizedState!==null&&u.memoizedState.cachePool!==null&&(o=u.memoizedState.cachePool.pool),o!==f&&(o!=null&&o.refCount++,f!=null&&Td(f))}function wb(o,u){o=null,u.alternate!==null&&(o=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==o&&(u.refCount++,o!=null&&Td(o))}function ps(o,u,f,y){if(u.subtreeFlags&10256)for(u=u.child;u!==null;)zC(o,u,f,y),u=u.sibling}function zC(o,u,f,y){var S=u.flags;switch(u.tag){case 0:case 11:case 15:ps(o,u,f,y),S&2048&&Fd(9,u);break;case 1:ps(o,u,f,y);break;case 3:ps(o,u,f,y),S&2048&&(o=null,u.alternate!==null&&(o=u.alternate.memoizedState.cache),u=u.memoizedState.cache,u!==o&&(u.refCount++,o!=null&&Td(o)));break;case 12:if(S&2048){ps(o,u,f,y),o=u.stateNode;try{var w=u.memoizedProps,B=w.id,W=w.onPostCommit;typeof W=="function"&&W(B,u.alternate===null?"mount":"update",o.passiveEffectDuration,-0)}catch(ie){px(u,u.return,ie)}}else ps(o,u,f,y);break;case 13:ps(o,u,f,y);break;case 23:break;case 22:w=u.stateNode,B=u.alternate,u.memoizedState!==null?w._visibility&2?ps(o,u,f,y):Ld(o,u):w._visibility&2?ps(o,u,f,y):(w._visibility|=2,tu(o,u,f,y,(u.subtreeFlags&10256)!==0)),S&2048&&Tb(B,u);break;case 24:ps(o,u,f,y),S&2048&&wb(u.alternate,u);break;default:ps(o,u,f,y)}}function tu(o,u,f,y,S){for(S=S&&(u.subtreeFlags&10256)!==0,u=u.child;u!==null;){var w=o,B=u,W=f,ie=y,Ee=B.flags;switch(B.tag){case 0:case 11:case 15:tu(w,B,W,ie,S),Fd(8,B);break;case 23:break;case 22:var Ke=B.stateNode;B.memoizedState!==null?Ke._visibility&2?tu(w,B,W,ie,S):Ld(w,B):(Ke._visibility|=2,tu(w,B,W,ie,S)),S&&Ee&2048&&Tb(B.alternate,B);break;case 24:tu(w,B,W,ie,S),S&&Ee&2048&&wb(B.alternate,B);break;default:tu(w,B,W,ie,S)}u=u.sibling}}function Ld(o,u){if(u.subtreeFlags&10256)for(u=u.child;u!==null;){var f=o,y=u,S=y.flags;switch(y.tag){case 22:Ld(f,y),S&2048&&Tb(y.alternate,y);break;case 24:Ld(f,y),S&2048&&wb(y.alternate,y);break;default:Ld(f,y)}u=u.sibling}}var zd=8192;function xu(o){if(o.subtreeFlags&zd)for(o=o.child;o!==null;)VC(o),o=o.sibling}function VC(o){switch(o.tag){case 26:xu(o),o.flags&zd&&o.memoizedState!==null&&d5(Ca,o.memoizedState,o.memoizedProps);break;case 5:xu(o);break;case 3:case 4:var u=Ca;Ca=wm(o.stateNode.containerInfo),xu(o),Ca=u;break;case 22:o.memoizedState===null&&(u=o.alternate,u!==null&&u.memoizedState!==null?(u=zd,zd=16777216,xu(o),zd=u):xu(o));break;default:xu(o)}}function HC(o){var u=o.alternate;if(u!==null&&(o=u.child,o!==null)){u.child=null;do u=o.sibling,o.sibling=null,o=u;while(o!==null)}}function Vd(o){var u=o.deletions;if((o.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var y=u[f];Pn=y,WC(y,o)}HC(o)}if(o.subtreeFlags&10256)for(o=o.child;o!==null;)GC(o),o=o.sibling}function GC(o){switch(o.tag){case 0:case 11:case 15:Vd(o),o.flags&2048&&s2(9,o,o.return);break;case 3:Vd(o);break;case 12:Vd(o);break;case 22:var u=o.stateNode;o.memoizedState!==null&&u._visibility&2&&(o.return===null||o.return.tag!==13)?(u._visibility&=-3,hm(o)):Vd(o);break;default:Vd(o)}}function hm(o){var u=o.deletions;if((o.flags&16)!==0){if(u!==null)for(var f=0;f<u.length;f++){var y=u[f];Pn=y,WC(y,o)}HC(o)}for(o=o.child;o!==null;){switch(u=o,u.tag){case 0:case 11:case 15:s2(8,u,u.return),hm(u);break;case 22:f=u.stateNode,f._visibility&2&&(f._visibility&=-3,hm(u));break;default:hm(u)}o=o.sibling}}function WC(o,u){for(;Pn!==null;){var f=Pn;switch(f.tag){case 0:case 11:case 15:s2(8,f,u);break;case 23:case 22:if(f.memoizedState!==null&&f.memoizedState.cachePool!==null){var y=f.memoizedState.cachePool.pool;y!=null&&y.refCount++}break;case 24:Td(f.memoizedState.cache)}if(y=f.child,y!==null)y.return=f,Pn=y;else e:for(f=o;Pn!==null;){y=Pn;var S=y.sibling,w=y.return;if(kC(y),y===f){Pn=null;break e}if(S!==null){S.return=w,Pn=S;break e}Pn=w}}}var Cz={getCacheForType:function(o){var u=xi(An),f=u.data.get(o);return f===void 0&&(f=o(),u.data.set(o,f)),f}},Nz=typeof WeakMap=="function"?WeakMap:Map,tx=0,_x=null,C0=null,B0=0,xx=0,hr=null,c2=!1,nu=!1,Ab=!1,no=0,Yx=0,u2=0,kl=0,Eb=0,ea=0,iu=0,Hd=null,Vi=null,Mb=!1,Rb=0,dm=1/0,fm=null,h2=null,Qn=0,d2=null,ru=null,au=0,Cb=0,Nb=null,XC=null,Gd=0,Ib=null;function dr(){if((tx&2)!==0&&B0!==0)return B0&-B0;if(H.T!==null){var o=Kc;return o!==0?o:Bb()}return rn()}function YC(){ea===0&&(ea=(B0&536870912)===0||K0?ft():536870912);var o=qr.current;return o!==null&&(o.flags|=32),ea}function fr(o,u,f){(o===_x&&(xx===2||xx===9)||o.cancelPendingCommit!==null)&&(su(o,0),f2(o,B0,ea,!1)),lt(o,f),((tx&2)===0||o!==_x)&&(o===_x&&((tx&2)===0&&(kl|=f),Yx===4&&f2(o,B0,ea,!1)),ms(o))}function KC(o,u,f){if((tx&6)!==0)throw Error(n(327));var y=!f&&(u&124)===0&&(u&o.expiredLanes)===0||p0(o,u),S=y?Dz(o,u):Pb(o,u,!0),w=y;do{if(S===0){nu&&!y&&f2(o,u,0,!1);break}else{if(f=o.current.alternate,w&&!Iz(f)){S=Pb(o,u,!1),w=!1;continue}if(S===2){if(w=u,o.errorRecoveryDisabledLanes&w)var B=0;else B=o.pendingLanes&-536870913,B=B!==0?B:B&536870912?536870912:0;if(B!==0){u=B;e:{var W=o;S=Hd;var ie=W.current.memoizedState.isDehydrated;if(ie&&(su(W,B).flags|=256),B=Pb(W,B,!1),B!==2){if(Ab&&!ie){W.errorRecoveryDisabledLanes|=w,kl|=w,S=4;break e}w=Vi,Vi=S,w!==null&&(Vi===null?Vi=w:Vi.push.apply(Vi,w))}S=B}if(w=!1,S!==2)continue}}if(S===1){su(o,0),f2(o,u,0,!0);break}e:{switch(y=o,w=S,w){case 0:case 1:throw Error(n(345));case 4:if((u&4194048)!==u)break;case 6:f2(y,u,ea,!c2);break e;case 2:Vi=null;break;case 3:case 5:break;default:throw Error(n(329))}if((u&62914560)===u&&(S=Rb+300-bt(),10<S)){if(f2(y,u,ea,!c2),t0(y,0,!0)!==0)break e;y.timeoutHandle=SN($C.bind(null,y,f,Vi,fm,Mb,u,ea,kl,iu,c2,w,2,-0,0),S);break e}$C(y,f,Vi,fm,Mb,u,ea,kl,iu,c2,w,0,-0,0)}}break}while(!0);ms(o)}function $C(o,u,f,y,S,w,B,W,ie,Ee,Ke,nt,De,ke){if(o.timeoutHandle=-1,nt=u.subtreeFlags,(nt&8192||(nt&16785408)===16785408)&&(Zd={stylesheets:null,count:0,unsuspend:h5},VC(u),nt=f5(),nt!==null)){o.cancelPendingCommit=nt(tN.bind(null,o,u,w,f,y,S,B,W,ie,Ke,1,De,ke)),f2(o,w,B,!Ee);return}tN(o,u,w,f,y,S,B,W,ie)}function Iz(o){for(var u=o;;){var f=u.tag;if((f===0||f===11||f===15)&&u.flags&16384&&(f=u.updateQueue,f!==null&&(f=f.stores,f!==null)))for(var y=0;y<f.length;y++){var S=f[y],w=S.getSnapshot;S=S.value;try{if(!xt(w(),S))return!1}catch{return!1}}if(f=u.child,u.subtreeFlags&16384&&f!==null)f.return=u,u=f;else{if(u===o)break;for(;u.sibling===null;){if(u.return===null||u.return===o)return!0;u=u.return}u.sibling.return=u.return,u=u.sibling}}return!0}function f2(o,u,f,y){u&=~Eb,u&=~kl,o.suspendedLanes|=u,o.pingedLanes&=~u,y&&(o.warmLanes|=u),y=o.expirationTimes;for(var S=u;0<S;){var w=31-et(S),B=1<<w;y[w]=-1,S&=~B}f!==0&&Qt(o,f,u)}function pm(){return(tx&6)===0?(Wd(0),!1):!0}function Ob(){if(C0!==null){if(xx===0)var o=C0.return;else o=C0,Qs=Cl=null,Qv(o),qc=null,Pd=0,o=C0;for(;o!==null;)MC(o.alternate,o),o=o.return;C0=null}}function su(o,u){var f=o.timeoutHandle;f!==-1&&(o.timeoutHandle=-1,Qz(f)),f=o.cancelPendingCommit,f!==null&&(o.cancelPendingCommit=null,f()),Ob(),_x=o,C0=f=Ys(o.current,null),B0=u,xx=0,hr=null,c2=!1,nu=p0(o,u),Ab=!1,iu=ea=Eb=kl=u2=Yx=0,Vi=Hd=null,Mb=!1,(u&8)!==0&&(u|=u&32);var y=o.entangledLanes;if(y!==0)for(o=o.entanglements,y&=u;0<y;){var S=31-et(y),w=1<<S;u|=o[S],y&=~w}return no=u,Fp(),f}function QC(o,u){_0=null,H.H=xm,u===Ad||u===Yp?(u=hR(),xx=3):u===lR?(u=hR(),xx=4):xx=u===dC?8:u!==null&&typeof u=="object"&&typeof u.then=="function"?6:1,hr=u,C0===null&&(Yx=1,sm(o,Qr(u,o.current)))}function ZC(){var o=H.H;return H.H=xm,o===null?xm:o}function JC(){var o=H.A;return H.A=Cz,o}function Db(){Yx=4,c2||(B0&4194048)!==B0&&qr.current!==null||(nu=!0),(u2&134217727)===0&&(kl&134217727)===0||_x===null||f2(_x,B0,ea,!1)}function Pb(o,u,f){var y=tx;tx|=2;var S=ZC(),w=JC();(_x!==o||B0!==u)&&(fm=null,su(o,u)),u=!1;var B=Yx;e:do try{if(xx!==0&&C0!==null){var W=C0,ie=hr;switch(xx){case 8:Ob(),B=6;break e;case 3:case 2:case 9:case 6:qr.current===null&&(u=!0);var Ee=xx;if(xx=0,hr=null,ou(o,W,ie,Ee),f&&nu){B=0;break e}break;default:Ee=xx,xx=0,hr=null,ou(o,W,ie,Ee)}}Oz(),B=Yx;break}catch(Ke){QC(o,Ke)}while(!0);return u&&o.shellSuspendCounter++,Qs=Cl=null,tx=y,H.H=S,H.A=w,C0===null&&(_x=null,B0=0,Fp()),B}function Oz(){for(;C0!==null;)jC(C0)}function Dz(o,u){var f=tx;tx|=2;var y=ZC(),S=JC();_x!==o||B0!==u?(fm=null,dm=bt()+500,su(o,u)):nu=p0(o,u);e:do try{if(xx!==0&&C0!==null){u=C0;var w=hr;t:switch(xx){case 1:xx=0,hr=null,ou(o,u,w,1);break;case 2:case 9:if(cR(w)){xx=0,hr=null,qC(u);break}u=function(){xx!==2&&xx!==9||_x!==o||(xx=7),ms(o)},w.then(u,u);break e;case 3:xx=7;break e;case 4:xx=5;break e;case 7:cR(w)?(xx=0,hr=null,qC(u)):(xx=0,hr=null,ou(o,u,w,7));break;case 5:var B=null;switch(C0.tag){case 26:B=C0.memoizedState;case 5:case 27:var W=C0;if(!B||PN(B)){xx=0,hr=null;var ie=W.sibling;if(ie!==null)C0=ie;else{var Ee=W.return;Ee!==null?(C0=Ee,mm(Ee)):C0=null}break t}}xx=0,hr=null,ou(o,u,w,5);break;case 6:xx=0,hr=null,ou(o,u,w,6);break;case 8:Ob(),Yx=6;break e;default:throw Error(n(462))}}Pz();break}catch(Ke){QC(o,Ke)}while(!0);return Qs=Cl=null,H.H=y,H.A=S,tx=f,C0!==null?0:(_x=null,B0=0,Fp(),Yx)}function Pz(){for(;C0!==null&&!at();)jC(C0)}function jC(o){var u=AC(o.alternate,o,no);o.memoizedProps=o.pendingProps,u===null?mm(o):C0=u}function qC(o){var u=o,f=u.alternate;switch(u.tag){case 15:case 0:u=vC(f,u,u.pendingProps,u.type,void 0,B0);break;case 11:u=vC(f,u,u.pendingProps,u.type.render,u.ref,B0);break;case 5:Qv(u);default:MC(f,u),u=C0=eR(u,no),u=AC(f,u,no)}o.memoizedProps=o.pendingProps,u===null?mm(o):C0=u}function ou(o,u,f,y){Qs=Cl=null,Qv(u),qc=null,Pd=0;var S=u.return;try{if(Tz(o,S,u,f,B0)){Yx=1,sm(o,Qr(f,o.current)),C0=null;return}}catch(w){if(S!==null)throw C0=S,w;Yx=1,sm(o,Qr(f,o.current)),C0=null;return}u.flags&32768?(K0||y===1?o=!0:nu||(B0&536870912)!==0?o=!1:(c2=o=!0,(y===2||y===9||y===3||y===6)&&(y=qr.current,y!==null&&y.tag===13&&(y.flags|=16384))),eN(u,o)):mm(u)}function mm(o){var u=o;do{if((u.flags&32768)!==0){eN(u,c2);return}o=u.return;var f=Az(u.alternate,u,no);if(f!==null){C0=f;return}if(u=u.sibling,u!==null){C0=u;return}C0=u=o}while(u!==null);Yx===0&&(Yx=5)}function eN(o,u){do{var f=Ez(o.alternate,o);if(f!==null){f.flags&=32767,C0=f;return}if(f=o.return,f!==null&&(f.flags|=32768,f.subtreeFlags=0,f.deletions=null),!u&&(o=o.sibling,o!==null)){C0=o;return}C0=o=f}while(o!==null);Yx=6,C0=null}function tN(o,u,f,y,S,w,B,W,ie){o.cancelPendingCommit=null;do ym();while(Qn!==0);if((tx&6)!==0)throw Error(n(327));if(u!==null){if(u===o.current)throw Error(n(177));if(w=u.lanes|u.childLanes,w|=wv,Wt(o,f,w,B,W,ie),o===_x&&(C0=_x=null,B0=0),ru=u,d2=o,au=f,Cb=w,Nb=S,XC=y,(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?(o.callbackNode=null,o.callbackPriority=0,Bz(V,function(){return aN(),null})):(o.callbackNode=null,o.callbackPriority=0),y=(u.flags&13878)!==0,(u.subtreeFlags&13878)!==0||y){y=H.T,H.T=null,S=re.p,re.p=2,B=tx,tx|=4;try{Mz(o,u,f)}finally{tx=B,re.p=S,H.T=y}}Qn=1,xN(),nN(),iN()}}function xN(){if(Qn===1){Qn=0;var o=d2,u=ru,f=(u.flags&13878)!==0;if((u.subtreeFlags&13878)!==0||f){f=H.T,H.T=null;var y=re.p;re.p=2;var S=tx;tx|=4;try{BC(u,o);var w=Yb,B=$r(o.containerInfo),W=w.focusedElem,ie=w.selectionRange;if(B!==W&&W&&W.ownerDocument&&Xt(W.ownerDocument.documentElement,W)){if(ie!==null&&sr(W)){var Ee=ie.start,Ke=ie.end;if(Ke===void 0&&(Ke=Ee),"selectionStart"in W)W.selectionStart=Ee,W.selectionEnd=Math.min(Ke,W.value.length);else{var nt=W.ownerDocument||document,De=nt&&nt.defaultView||window;if(De.getSelection){var ke=De.getSelection(),u0=W.textContent.length,o0=Math.min(ie.start,u0),ux=ie.end===void 0?o0:Math.min(ie.end,u0);!ke.extend&&o0>ux&&(B=ux,ux=o0,o0=B);var me=Z0(W,o0),he=Z0(W,ux);if(me&&he&&(ke.rangeCount!==1||ke.anchorNode!==me.node||ke.anchorOffset!==me.offset||ke.focusNode!==he.node||ke.focusOffset!==he.offset)){var Ae=nt.createRange();Ae.setStart(me.node,me.offset),ke.removeAllRanges(),o0>ux?(ke.addRange(Ae),ke.extend(he.node,he.offset)):(Ae.setEnd(he.node,he.offset),ke.addRange(Ae))}}}}for(nt=[],ke=W;ke=ke.parentNode;)ke.nodeType===1&&nt.push({element:ke,left:ke.scrollLeft,top:ke.scrollTop});for(typeof W.focus=="function"&&W.focus(),W=0;W<nt.length;W++){var je=nt[W];je.element.scrollLeft=je.left,je.element.scrollTop=je.top}}Cm=!!Xb,Yb=Xb=null}finally{tx=S,re.p=y,H.T=f}}o.current=u,Qn=2}}function nN(){if(Qn===2){Qn=0;var o=d2,u=ru,f=(u.flags&8772)!==0;if((u.subtreeFlags&8772)!==0||f){f=H.T,H.T=null;var y=re.p;re.p=2;var S=tx;tx|=4;try{PC(o,u.alternate,u)}finally{tx=S,re.p=y,H.T=f}}Qn=3}}function iN(){if(Qn===4||Qn===3){Qn=0,Ue();var o=d2,u=ru,f=au,y=XC;(u.subtreeFlags&10256)!==0||(u.flags&10256)!==0?Qn=5:(Qn=0,ru=d2=null,rN(o,o.pendingLanes));var S=o.pendingLanes;if(S===0&&(h2=null),s0(f),u=u.stateNode,Ce&&typeof Ce.onCommitFiberRoot=="function")try{Ce.onCommitFiberRoot(_t,u,void 0,(u.current.flags&128)===128)}catch{}if(y!==null){u=H.T,S=re.p,re.p=2,H.T=null;try{for(var w=o.onRecoverableError,B=0;B<y.length;B++){var W=y[B];w(W.value,{componentStack:W.stack})}}finally{H.T=u,re.p=S}}(au&3)!==0&&ym(),ms(o),S=o.pendingLanes,(f&4194090)!==0&&(S&42)!==0?o===Ib?Gd++:(Gd=0,Ib=o):Gd=0,Wd(0)}}function rN(o,u){(o.pooledCacheLanes&=u)===0&&(u=o.pooledCache,u!=null&&(o.pooledCache=null,Td(u)))}function ym(o){return xN(),nN(),iN(),aN()}function aN(){if(Qn!==5)return!1;var o=d2,u=Cb;Cb=0;var f=s0(au),y=H.T,S=re.p;try{re.p=32>f?32:f,H.T=null,f=Nb,Nb=null;var w=d2,B=au;if(Qn=0,ru=d2=null,au=0,(tx&6)!==0)throw Error(n(331));var W=tx;if(tx|=4,GC(w.current),zC(w,w.current,B,f),tx=W,Wd(0,!1),Ce&&typeof Ce.onPostCommitFiberRoot=="function")try{Ce.onPostCommitFiberRoot(_t,w)}catch{}return!0}finally{re.p=S,H.T=y,rN(o,u)}}function sN(o,u,f){u=Qr(f,u),u=lb(o.stateNode,u,2),o=n2(o,u,2),o!==null&&(lt(o,2),ms(o))}function px(o,u,f){if(o.tag===3)sN(o,o,f);else for(;u!==null;){if(u.tag===3){sN(u,o,f);break}else if(u.tag===1){var y=u.stateNode;if(typeof u.type.getDerivedStateFromError=="function"||typeof y.componentDidCatch=="function"&&(h2===null||!h2.has(y))){o=Qr(f,o),f=uC(2),y=n2(u,f,2),y!==null&&(hC(f,y,u,o),lt(y,2),ms(y));break}}u=u.return}}function kb(o,u,f){var y=o.pingCache;if(y===null){y=o.pingCache=new Nz;var S=new Set;y.set(u,S)}else S=y.get(u),S===void 0&&(S=new Set,y.set(u,S));S.has(f)||(Ab=!0,S.add(f),o=kz.bind(null,o,u,f),u.then(o,o))}function kz(o,u,f){var y=o.pingCache;y!==null&&y.delete(u),o.pingedLanes|=o.suspendedLanes&f,o.warmLanes&=~f,_x===o&&(B0&f)===f&&(Yx===4||Yx===3&&(B0&62914560)===B0&&300>bt()-Rb?(tx&2)===0&&su(o,0):Eb|=f,iu===B0&&(iu=0)),ms(o)}function oN(o,u){u===0&&(u=Xe()),o=Gc(o,u),o!==null&&(lt(o,u),ms(o))}function Uz(o){var u=o.memoizedState,f=0;u!==null&&(f=u.retryLane),oN(o,f)}function Fz(o,u){var f=0;switch(o.tag){case 13:var y=o.stateNode,S=o.memoizedState;S!==null&&(f=S.retryLane);break;case 19:y=o.stateNode;break;case 22:y=o.stateNode._retryCache;break;default:throw Error(n(314))}y!==null&&y.delete(u),oN(o,f)}function Bz(o,u){return rt(o,u)}var gm=null,lu=null,Ub=!1,vm=!1,Fb=!1,Ul=0;function ms(o){o!==lu&&o.next===null&&(lu===null?gm=lu=o:lu=lu.next=o),vm=!0,Ub||(Ub=!0,zz())}function Wd(o,u){if(!Fb&&vm){Fb=!0;do for(var f=!1,y=gm;y!==null;){if(o!==0){var S=y.pendingLanes;if(S===0)var w=0;else{var B=y.suspendedLanes,W=y.pingedLanes;w=(1<<31-et(42|o)+1)-1,w&=S&~(B&~W),w=w&201326741?w&201326741|1:w?w|2:0}w!==0&&(f=!0,hN(y,w))}else w=B0,w=t0(y,y===_x?w:0,y.cancelPendingCommit!==null||y.timeoutHandle!==-1),(w&3)===0||p0(y,w)||(f=!0,hN(y,w));y=y.next}while(f);Fb=!1}}function Lz(){lN()}function lN(){vm=Ub=!1;var o=0;Ul!==0&&($z()&&(o=Ul),Ul=0);for(var u=bt(),f=null,y=gm;y!==null;){var S=y.next,w=cN(y,u);w===0?(y.next=null,f===null?gm=S:f.next=S,S===null&&(lu=f)):(f=y,(o!==0||(w&3)!==0)&&(vm=!0)),y=S}Wd(o)}function cN(o,u){for(var f=o.suspendedLanes,y=o.pingedLanes,S=o.expirationTimes,w=o.pendingLanes&-62914561;0<w;){var B=31-et(w),W=1<<B,ie=S[B];ie===-1?((W&f)===0||(W&y)!==0)&&(S[B]=de(W,u)):ie<=u&&(o.expiredLanes|=W),w&=~W}if(u=_x,f=B0,f=t0(o,o===u?f:0,o.cancelPendingCommit!==null||o.timeoutHandle!==-1),y=o.callbackNode,f===0||o===u&&(xx===2||xx===9)||o.cancelPendingCommit!==null)return y!==null&&y!==null&&He(y),o.callbackNode=null,o.callbackPriority=0;if((f&3)===0||p0(o,f)){if(u=f&-f,u===o.callbackPriority)return u;switch(y!==null&&He(y),s0(f)){case 2:case 8:f=Z;break;case 32:f=V;break;case 268435456:f=Ge;break;default:f=V}return y=uN.bind(null,o),f=rt(f,y),o.callbackPriority=u,o.callbackNode=f,u}return y!==null&&y!==null&&He(y),o.callbackPriority=2,o.callbackNode=null,2}function uN(o,u){if(Qn!==0&&Qn!==5)return o.callbackNode=null,o.callbackPriority=0,null;var f=o.callbackNode;if(ym()&&o.callbackNode!==f)return null;var y=B0;return y=t0(o,o===_x?y:0,o.cancelPendingCommit!==null||o.timeoutHandle!==-1),y===0?null:(KC(o,y,u),cN(o,bt()),o.callbackNode!=null&&o.callbackNode===f?uN.bind(null,o):null)}function hN(o,u){if(ym())return null;KC(o,u,!0)}function zz(){Zz(function(){(tx&6)!==0?rt(dt,Lz):lN()})}function Bb(){return Ul===0&&(Ul=ft()),Ul}function dN(o){return o==null||typeof o=="symbol"||typeof o=="boolean"?null:typeof o=="function"?o:rs(""+o)}function fN(o,u){var f=u.ownerDocument.createElement("input");return f.name=u.name,f.value=u.value,o.id&&f.setAttribute("form",o.id),u.parentNode.insertBefore(f,u),o=new FormData(o),f.parentNode.removeChild(f),o}function Vz(o,u,f,y,S){if(u==="submit"&&f&&f.stateNode===S){var w=dN((S[R0]||null).action),B=y.submitter;B&&(u=(u=B[R0]||null)?dN(u.formAction):B.getAttribute("formAction"),u!==null&&(w=u,B=null));var W=new cs("action","action",null,y,S);o.push({event:W,listeners:[{instance:null,listener:function(){if(y.defaultPrevented){if(Ul!==0){var ie=B?fN(S,B):new FormData(S);ib(f,{pending:!0,data:ie,method:S.method,action:w},null,ie)}}else typeof w=="function"&&(W.preventDefault(),ie=B?fN(S,B):new FormData(S),ib(f,{pending:!0,data:ie,method:S.method,action:w},w,ie))},currentTarget:S}]})}}for(var Lb=0;Lb<Tv.length;Lb++){var zb=Tv[Lb],Hz=zb.toLowerCase(),Gz=zb[0].toUpperCase()+zb.slice(1);Ra(Hz,"on"+Gz)}Ra(KM,"onAnimationEnd"),Ra($M,"onAnimationIteration"),Ra(QM,"onAnimationStart"),Ra("dblclick","onDoubleClick"),Ra("focusin","onFocus"),Ra("focusout","onBlur"),Ra(az,"onTransitionRun"),Ra(sz,"onTransitionStart"),Ra(oz,"onTransitionCancel"),Ra(ZM,"onTransitionEnd"),ct("onMouseEnter",["mouseout","mouseover"]),ct("onMouseLeave",["mouseout","mouseover"]),ct("onPointerEnter",["pointerout","pointerover"]),ct("onPointerLeave",["pointerout","pointerover"]),fe("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),fe("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),fe("onBeforeInput",["compositionend","keypress","textInput","paste"]),fe("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),fe("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),fe("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Xd="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Wz=new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Xd));function pN(o,u){u=(u&4)!==0;for(var f=0;f<o.length;f++){var y=o[f],S=y.event;y=y.listeners;e:{var w=void 0;if(u)for(var B=y.length-1;0<=B;B--){var W=y[B],ie=W.instance,Ee=W.currentTarget;if(W=W.listener,ie!==w&&S.isPropagationStopped())break e;w=W,S.currentTarget=Ee;try{w(S)}catch(Ke){am(Ke)}S.currentTarget=null,w=ie}else for(B=0;B<y.length;B++){if(W=y[B],ie=W.instance,Ee=W.currentTarget,W=W.listener,ie!==w&&S.isPropagationStopped())break e;w=W,S.currentTarget=Ee;try{w(S)}catch(Ke){am(Ke)}S.currentTarget=null,w=ie}}}}function N0(o,u){var f=u[q0];f===void 0&&(f=u[q0]=new Set);var y=o+"__bubble";f.has(y)||(mN(u,o,2,!1),f.add(y))}function Vb(o,u,f){var y=0;u&&(y|=4),mN(f,o,y,u)}var bm="_reactListening"+Math.random().toString(36).slice(2);function Hb(o){if(!o[bm]){o[bm]=!0,Ne.forEach(function(f){f!=="selectionchange"&&(Wz.has(f)||Vb(f,!1,o),Vb(f,!0,o))});var u=o.nodeType===9?o:o.ownerDocument;u===null||u[bm]||(u[bm]=!0,Vb("selectionchange",!1,u))}}function mN(o,u,f,y){switch(zN(u)){case 2:var S=y5;break;case 8:S=g5;break;default:S=x_}f=S.bind(null,u,f,o),S=void 0,!Bs||u!=="touchstart"&&u!=="touchmove"&&u!=="wheel"||(S=!0),y?S!==void 0?o.addEventListener(u,f,{capture:!0,passive:S}):o.addEventListener(u,f,!0):S!==void 0?o.addEventListener(u,f,{passive:S}):o.addEventListener(u,f,!1)}function Gb(o,u,f,y,S){var w=y;if((u&1)===0&&(u&2)===0&&y!==null)e:for(;;){if(y===null)return;var B=y.tag;if(B===3||B===4){var W=y.stateNode.containerInfo;if(W===S)break;if(B===4)for(B=y.return;B!==null;){var ie=B.tag;if((ie===3||ie===4)&&B.stateNode.containerInfo===S)return;B=B.return}for(;W!==null;){if(B=Ii(W),B===null)return;if(ie=B.tag,ie===5||ie===6||ie===26||ie===27){y=w=B;continue e}W=W.parentNode}}y=y.return}Zo(function(){var Ee=w,Ke=_n(f),nt=[];e:{var De=JM.get(o);if(De!==void 0){var ke=cs,u0=o;switch(o){case"keypress":if(os(f)===0)break e;case"keydown":case"keyup":ke=st;break;case"focusin":u0="focus",ke=z;break;case"focusout":u0="blur",ke=z;break;case"beforeblur":case"afterblur":ke=z;break;case"click":if(f.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ke=Hs;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ke=In;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ke=c0;break;case KM:case $M:case QM:ke=ne;break;case ZM:ke=Y0;break;case"scroll":case"scrollend":ke=jo;break;case"wheel":ke=z0;break;case"copy":case"cut":case"paste":ke=D;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ke=Gt;break;case"toggle":case"beforetoggle":ke=Tn}var o0=(u&4)!==0,ux=!o0&&(o==="scroll"||o==="scrollend"),me=o0?De!==null?De+"Capture":null:De;o0=[];for(var he=Ee,Ae;he!==null;){var je=he;if(Ae=je.stateNode,je=je.tag,je!==5&&je!==26&&je!==27||Ae===null||me===null||(je=ir(he,me),je!=null&&o0.push(Yd(he,je,Ae))),ux)break;he=he.return}0<o0.length&&(De=new ke(De,u0,null,f,Ke),nt.push({event:De,listeners:o0}))}}if((u&7)===0){e:{if(De=o==="mouseover"||o==="pointerover",ke=o==="mouseout"||o==="pointerout",De&&f!==as&&(u0=f.relatedTarget||f.fromElement)&&(Ii(u0)||u0[Wn]))break e;if((ke||De)&&(De=Ke.window===Ke?Ke:(De=Ke.ownerDocument)?De.defaultView||De.parentWindow:window,ke?(u0=f.relatedTarget||f.toElement,ke=Ee,u0=u0?Ii(u0):null,u0!==null&&(ux=r(u0),o0=u0.tag,u0!==ux||o0!==5&&o0!==27&&o0!==6)&&(u0=null)):(ke=null,u0=Ee),ke!==u0)){if(o0=Hs,je="onMouseLeave",me="onMouseEnter",he="mouse",(o==="pointerout"||o==="pointerover")&&(o0=Gt,je="onPointerLeave",me="onPointerEnter",he="pointer"),ux=ke==null?De:vn(ke),Ae=u0==null?De:vn(u0),De=new o0(je,he+"leave",ke,f,Ke),De.target=ux,De.relatedTarget=Ae,je=null,Ii(Ke)===Ee&&(o0=new o0(me,he+"enter",u0,f,Ke),o0.target=Ae,o0.relatedTarget=ux,je=o0),ux=je,ke&&u0)t:{for(o0=ke,me=u0,he=0,Ae=o0;Ae;Ae=cu(Ae))he++;for(Ae=0,je=me;je;je=cu(je))Ae++;for(;0<he-Ae;)o0=cu(o0),he--;for(;0<Ae-he;)me=cu(me),Ae--;for(;he--;){if(o0===me||me!==null&&o0===me.alternate)break t;o0=cu(o0),me=cu(me)}o0=null}else o0=null;ke!==null&&yN(nt,De,ke,o0,!1),u0!==null&&ux!==null&&yN(nt,ux,u0,o0,!0)}}e:{if(De=Ee?vn(Ee):window,ke=De.nodeName&&De.nodeName.toLowerCase(),ke==="select"||ke==="input"&&De.type==="file")var Lt=Ye;else if(F(De))if(ze)Lt=vx;else{Lt=ox;var A0=w0}else ke=De.nodeName,!ke||ke.toLowerCase()!=="input"||De.type!=="checkbox"&&De.type!=="radio"?Ee&&Fs(Ee.elementType)&&(Lt=Ye):Lt=gx;if(Lt&&(Lt=Lt(o,Ee))){O(nt,Lt,f,Ke);break e}A0&&A0(o,De,Ee),o==="focusout"&&Ee&&De.type==="number"&&Ee.memoizedProps.value!=null&&Pi(De,"number",De.value)}switch(A0=Ee?vn(Ee):window,o){case"focusin":(F(A0)||A0.contentEditable==="true")&&(ex=A0,or=Ee,wn=null);break;case"focusout":wn=or=ex=null;break;case"mousedown":_l=!0;break;case"contextmenu":case"mouseup":case"dragend":_l=!1,Sl(nt,f,Ke);break;case"selectionchange":if(Xs)break;case"keydown":case"keyup":Sl(nt,f,Ke)}var Jt;if(Kn)e:{switch(o){case"compositionstart":var l0="onCompositionStart";break e;case"compositionend":l0="onCompositionEnd";break e;case"compositionupdate":l0="onCompositionUpdate";break e}l0=void 0}else Ws?Gs(o,f)&&(l0="onCompositionEnd"):o==="keydown"&&f.keyCode===229&&(l0="onCompositionStart");l0&&(qo&&f.locale!=="ko"&&(Ws||l0!=="onCompositionStart"?l0==="onCompositionEnd"&&Ws&&(Jt=Jo()):(Fi=Ke,Ls="value"in Fi?Fi.value:Fi.textContent,Ws=!0)),A0=_m(Ee,l0),0<A0.length&&(l0=new X(l0,o,null,f,Ke),nt.push({event:l0,listeners:A0}),Jt?l0.data=Jt:(Jt=ar(f),Jt!==null&&(l0.data=Jt)))),(Jt=zc?kp(o,f):Vc(o,f))&&(l0=_m(Ee,"onBeforeInput"),0<l0.length&&(A0=new X("onBeforeInput","beforeinput",null,f,Ke),nt.push({event:A0,listeners:l0}),A0.data=Jt)),Vz(nt,o,Ee,f,Ke)}pN(nt,u)})}function Yd(o,u,f){return{instance:o,listener:u,currentTarget:f}}function _m(o,u){for(var f=u+"Capture",y=[];o!==null;){var S=o,w=S.stateNode;if(S=S.tag,S!==5&&S!==26&&S!==27||w===null||(S=ir(o,f),S!=null&&y.unshift(Yd(o,S,w)),S=ir(o,u),S!=null&&y.push(Yd(o,S,w))),o.tag===3)return y;o=o.return}return[]}function cu(o){if(o===null)return null;do o=o.return;while(o&&o.tag!==5&&o.tag!==27);return o||null}function yN(o,u,f,y,S){for(var w=u._reactName,B=[];f!==null&&f!==y;){var W=f,ie=W.alternate,Ee=W.stateNode;if(W=W.tag,ie!==null&&ie===y)break;W!==5&&W!==26&&W!==27||Ee===null||(ie=Ee,S?(Ee=ir(f,w),Ee!=null&&B.unshift(Yd(f,Ee,ie))):S||(Ee=ir(f,w),Ee!=null&&B.push(Yd(f,Ee,ie)))),f=f.return}B.length!==0&&o.push({event:u,listeners:B})}var Xz=/\r\n?/g,Yz=/\u0000|\uFFFD/g;function gN(o){return(typeof o=="string"?o:""+o).replace(Xz,`
`).replace(Yz,"")}function vN(o,u){return u=gN(u),gN(o)===u}function Sm(){}function cx(o,u,f,y,S,w){switch(f){case"children":typeof y=="string"?u==="body"||u==="textarea"&&y===""||ki(o,y):(typeof y=="number"||typeof y=="bigint")&&u!=="body"&&ki(o,""+y);break;case"className":Dt(o,"class",y);break;case"tabIndex":Dt(o,"tabindex",y);break;case"dir":case"role":case"viewBox":case"width":case"height":Dt(o,f,y);break;case"style":$o(o,y,w);break;case"data":if(u!=="object"){Dt(o,"data",y);break}case"src":case"href":if(y===""&&(u!=="a"||f!=="href")){o.removeAttribute(f);break}if(y==null||typeof y=="function"||typeof y=="symbol"||typeof y=="boolean"){o.removeAttribute(f);break}y=rs(""+y),o.setAttribute(f,y);break;case"action":case"formAction":if(typeof y=="function"){o.setAttribute(f,"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");break}else typeof w=="function"&&(f==="formAction"?(u!=="input"&&cx(o,u,"name",S.name,S,null),cx(o,u,"formEncType",S.formEncType,S,null),cx(o,u,"formMethod",S.formMethod,S,null),cx(o,u,"formTarget",S.formTarget,S,null)):(cx(o,u,"encType",S.encType,S,null),cx(o,u,"method",S.method,S,null),cx(o,u,"target",S.target,S,null)));if(y==null||typeof y=="symbol"||typeof y=="boolean"){o.removeAttribute(f);break}y=rs(""+y),o.setAttribute(f,y);break;case"onClick":y!=null&&(o.onclick=Sm);break;case"onScroll":y!=null&&N0("scroll",o);break;case"onScrollEnd":y!=null&&N0("scrollend",o);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(n(61));if(f=y.__html,f!=null){if(S.children!=null)throw Error(n(60));o.innerHTML=f}}break;case"multiple":o.multiple=y&&typeof y!="function"&&typeof y!="symbol";break;case"muted":o.muted=y&&typeof y!="function"&&typeof y!="symbol";break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"defaultValue":case"defaultChecked":case"innerHTML":case"ref":break;case"autoFocus":break;case"xlinkHref":if(y==null||typeof y=="function"||typeof y=="boolean"||typeof y=="symbol"){o.removeAttribute("xlink:href");break}f=rs(""+y),o.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",f);break;case"contentEditable":case"spellCheck":case"draggable":case"value":case"autoReverse":case"externalResourcesRequired":case"focusable":case"preserveAlpha":y!=null&&typeof y!="function"&&typeof y!="symbol"?o.setAttribute(f,""+y):o.removeAttribute(f);break;case"inert":case"allowFullScreen":case"async":case"autoPlay":case"controls":case"default":case"defer":case"disabled":case"disablePictureInPicture":case"disableRemotePlayback":case"formNoValidate":case"hidden":case"loop":case"noModule":case"noValidate":case"open":case"playsInline":case"readOnly":case"required":case"reversed":case"scoped":case"seamless":case"itemScope":y&&typeof y!="function"&&typeof y!="symbol"?o.setAttribute(f,""):o.removeAttribute(f);break;case"capture":case"download":y===!0?o.setAttribute(f,""):y!==!1&&y!=null&&typeof y!="function"&&typeof y!="symbol"?o.setAttribute(f,y):o.removeAttribute(f);break;case"cols":case"rows":case"size":case"span":y!=null&&typeof y!="function"&&typeof y!="symbol"&&!isNaN(y)&&1<=y?o.setAttribute(f,y):o.removeAttribute(f);break;case"rowSpan":case"start":y==null||typeof y=="function"||typeof y=="symbol"||isNaN(y)?o.removeAttribute(f):o.setAttribute(f,y);break;case"popover":N0("beforetoggle",o),N0("toggle",o),Ft(o,"popover",y);break;case"xlinkActuate":Zt(o,"http://www.w3.org/1999/xlink","xlink:actuate",y);break;case"xlinkArcrole":Zt(o,"http://www.w3.org/1999/xlink","xlink:arcrole",y);break;case"xlinkRole":Zt(o,"http://www.w3.org/1999/xlink","xlink:role",y);break;case"xlinkShow":Zt(o,"http://www.w3.org/1999/xlink","xlink:show",y);break;case"xlinkTitle":Zt(o,"http://www.w3.org/1999/xlink","xlink:title",y);break;case"xlinkType":Zt(o,"http://www.w3.org/1999/xlink","xlink:type",y);break;case"xmlBase":Zt(o,"http://www.w3.org/XML/1998/namespace","xml:base",y);break;case"xmlLang":Zt(o,"http://www.w3.org/XML/1998/namespace","xml:lang",y);break;case"xmlSpace":Zt(o,"http://www.w3.org/XML/1998/namespace","xml:space",y);break;case"is":Ft(o,"is",y);break;case"innerText":case"textContent":break;default:(!(2<f.length)||f[0]!=="o"&&f[0]!=="O"||f[1]!=="n"&&f[1]!=="N")&&(f=gl.get(f)||f,Ft(o,f,y))}}function Wb(o,u,f,y,S,w){switch(f){case"style":$o(o,y,w);break;case"dangerouslySetInnerHTML":if(y!=null){if(typeof y!="object"||!("__html"in y))throw Error(n(61));if(f=y.__html,f!=null){if(S.children!=null)throw Error(n(60));o.innerHTML=f}}break;case"children":typeof y=="string"?ki(o,y):(typeof y=="number"||typeof y=="bigint")&&ki(o,""+y);break;case"onScroll":y!=null&&N0("scroll",o);break;case"onScrollEnd":y!=null&&N0("scrollend",o);break;case"onClick":y!=null&&(o.onclick=Sm);break;case"suppressContentEditableWarning":case"suppressHydrationWarning":case"innerHTML":case"ref":break;case"innerText":case"textContent":break;default:if(!Ie.hasOwnProperty(f))e:{if(f[0]==="o"&&f[1]==="n"&&(S=f.endsWith("Capture"),u=f.slice(2,S?f.length-7:void 0),w=o[R0]||null,w=w!=null?w[f]:null,typeof w=="function"&&o.removeEventListener(u,w,S),typeof y=="function")){typeof w!="function"&&w!==null&&(f in o?o[f]=null:o.hasAttribute(f)&&o.removeAttribute(f)),o.addEventListener(u,y,S);break e}f in o?o[f]=y:y===!0?o.setAttribute(f,""):Ft(o,f,y)}}}function Zn(o,u,f){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"img":N0("error",o),N0("load",o);var y=!1,S=!1,w;for(w in f)if(f.hasOwnProperty(w)){var B=f[w];if(B!=null)switch(w){case"src":y=!0;break;case"srcSet":S=!0;break;case"children":case"dangerouslySetInnerHTML":throw Error(n(137,u));default:cx(o,u,w,B,f,null)}}S&&cx(o,u,"srcSet",f.srcSet,f,null),y&&cx(o,u,"src",f.src,f,null);return;case"input":N0("invalid",o);var W=w=B=S=null,ie=null,Ee=null;for(y in f)if(f.hasOwnProperty(y)){var Ke=f[y];if(Ke!=null)switch(y){case"name":S=Ke;break;case"type":B=Ke;break;case"checked":ie=Ke;break;case"defaultChecked":Ee=Ke;break;case"value":w=Ke;break;case"defaultValue":W=Ke;break;case"children":case"dangerouslySetInnerHTML":if(Ke!=null)throw Error(n(137,u));break;default:cx(o,u,y,Ke,f,null)}}Nx(o,w,W,ie,Ee,B,S,!1),Di(o);return;case"select":N0("invalid",o),y=B=w=null;for(S in f)if(f.hasOwnProperty(S)&&(W=f[S],W!=null))switch(S){case"value":w=W;break;case"defaultValue":B=W;break;case"multiple":y=W;default:cx(o,u,S,W,f,null)}u=w,f=B,o.multiple=!!y,u!=null?bi(o,!!y,u,!1):f!=null&&bi(o,!!y,f,!0);return;case"textarea":N0("invalid",o),w=S=y=null;for(B in f)if(f.hasOwnProperty(B)&&(W=f[B],W!=null))switch(B){case"value":y=W;break;case"defaultValue":S=W;break;case"children":w=W;break;case"dangerouslySetInnerHTML":if(W!=null)throw Error(n(91));break;default:cx(o,u,B,W,f,null)}Lx(o,y,S,w),Di(o);return;case"option":for(ie in f)if(f.hasOwnProperty(ie)&&(y=f[ie],y!=null))switch(ie){case"selected":o.selected=y&&typeof y!="function"&&typeof y!="symbol";break;default:cx(o,u,ie,y,f,null)}return;case"dialog":N0("beforetoggle",o),N0("toggle",o),N0("cancel",o),N0("close",o);break;case"iframe":case"object":N0("load",o);break;case"video":case"audio":for(y=0;y<Xd.length;y++)N0(Xd[y],o);break;case"image":N0("error",o),N0("load",o);break;case"details":N0("toggle",o);break;case"embed":case"source":case"link":N0("error",o),N0("load",o);case"area":case"base":case"br":case"col":case"hr":case"keygen":case"meta":case"param":case"track":case"wbr":case"menuitem":for(Ee in f)if(f.hasOwnProperty(Ee)&&(y=f[Ee],y!=null))switch(Ee){case"children":case"dangerouslySetInnerHTML":throw Error(n(137,u));default:cx(o,u,Ee,y,f,null)}return;default:if(Fs(u)){for(Ke in f)f.hasOwnProperty(Ke)&&(y=f[Ke],y!==void 0&&Wb(o,u,Ke,y,f,void 0));return}}for(W in f)f.hasOwnProperty(W)&&(y=f[W],y!=null&&cx(o,u,W,y,f,null))}function Kz(o,u,f,y){switch(u){case"div":case"span":case"svg":case"path":case"a":case"g":case"p":case"li":break;case"input":var S=null,w=null,B=null,W=null,ie=null,Ee=null,Ke=null;for(ke in f){var nt=f[ke];if(f.hasOwnProperty(ke)&&nt!=null)switch(ke){case"checked":break;case"value":break;case"defaultValue":ie=nt;default:y.hasOwnProperty(ke)||cx(o,u,ke,null,y,nt)}}for(var De in y){var ke=y[De];if(nt=f[De],y.hasOwnProperty(De)&&(ke!=null||nt!=null))switch(De){case"type":w=ke;break;case"name":S=ke;break;case"checked":Ee=ke;break;case"defaultChecked":Ke=ke;break;case"value":B=ke;break;case"defaultValue":W=ke;break;case"children":case"dangerouslySetInnerHTML":if(ke!=null)throw Error(n(137,u));break;default:ke!==nt&&cx(o,u,De,ke,y,nt)}}Xn(o,B,W,ie,Ee,Ke,w,S);return;case"select":ke=B=W=De=null;for(w in f)if(ie=f[w],f.hasOwnProperty(w)&&ie!=null)switch(w){case"value":break;case"multiple":ke=ie;default:y.hasOwnProperty(w)||cx(o,u,w,null,y,ie)}for(S in y)if(w=y[S],ie=f[S],y.hasOwnProperty(S)&&(w!=null||ie!=null))switch(S){case"value":De=w;break;case"defaultValue":W=w;break;case"multiple":B=w;default:w!==ie&&cx(o,u,S,w,y,ie)}u=W,f=B,y=ke,De!=null?bi(o,!!f,De,!1):!!y!=!!f&&(u!=null?bi(o,!!f,u,!0):bi(o,!!f,f?[]:"",!1));return;case"textarea":ke=De=null;for(W in f)if(S=f[W],f.hasOwnProperty(W)&&S!=null&&!y.hasOwnProperty(W))switch(W){case"value":break;case"children":break;default:cx(o,u,W,null,y,S)}for(B in y)if(S=y[B],w=f[B],y.hasOwnProperty(B)&&(S!=null||w!=null))switch(B){case"value":De=S;break;case"defaultValue":ke=S;break;case"children":break;case"dangerouslySetInnerHTML":if(S!=null)throw Error(n(91));break;default:S!==w&&cx(o,u,B,S,y,w)}Ko(o,De,ke);return;case"option":for(var u0 in f)if(De=f[u0],f.hasOwnProperty(u0)&&De!=null&&!y.hasOwnProperty(u0))switch(u0){case"selected":o.selected=!1;break;default:cx(o,u,u0,null,y,De)}for(ie in y)if(De=y[ie],ke=f[ie],y.hasOwnProperty(ie)&&De!==ke&&(De!=null||ke!=null))switch(ie){case"selected":o.selected=De&&typeof De!="function"&&typeof De!="symbol";break;default:cx(o,u,ie,De,y,ke)}return;case"img":case"link":case"area":case"base":case"br":case"col":case"embed":case"hr":case"keygen":case"meta":case"param":case"source":case"track":case"wbr":case"menuitem":for(var o0 in f)De=f[o0],f.hasOwnProperty(o0)&&De!=null&&!y.hasOwnProperty(o0)&&cx(o,u,o0,null,y,De);for(Ee in y)if(De=y[Ee],ke=f[Ee],y.hasOwnProperty(Ee)&&De!==ke&&(De!=null||ke!=null))switch(Ee){case"children":case"dangerouslySetInnerHTML":if(De!=null)throw Error(n(137,u));break;default:cx(o,u,Ee,De,y,ke)}return;default:if(Fs(u)){for(var ux in f)De=f[ux],f.hasOwnProperty(ux)&&De!==void 0&&!y.hasOwnProperty(ux)&&Wb(o,u,ux,void 0,y,De);for(Ke in y)De=y[Ke],ke=f[Ke],!y.hasOwnProperty(Ke)||De===ke||De===void 0&&ke===void 0||Wb(o,u,Ke,De,y,ke);return}}for(var me in f)De=f[me],f.hasOwnProperty(me)&&De!=null&&!y.hasOwnProperty(me)&&cx(o,u,me,null,y,De);for(nt in y)De=y[nt],ke=f[nt],!y.hasOwnProperty(nt)||De===ke||De==null&&ke==null||cx(o,u,nt,De,y,ke)}var Xb=null,Yb=null;function Tm(o){return o.nodeType===9?o:o.ownerDocument}function bN(o){switch(o){case"http://www.w3.org/2000/svg":return 1;case"http://www.w3.org/1998/Math/MathML":return 2;default:return 0}}function _N(o,u){if(o===0)switch(u){case"svg":return 1;case"math":return 2;default:return 0}return o===1&&u==="foreignObject"?0:o}function Kb(o,u){return o==="textarea"||o==="noscript"||typeof u.children=="string"||typeof u.children=="number"||typeof u.children=="bigint"||typeof u.dangerouslySetInnerHTML=="object"&&u.dangerouslySetInnerHTML!==null&&u.dangerouslySetInnerHTML.__html!=null}var $b=null;function $z(){var o=window.event;return o&&o.type==="popstate"?o===$b?!1:($b=o,!0):($b=null,!1)}var SN=typeof setTimeout=="function"?setTimeout:void 0,Qz=typeof clearTimeout=="function"?clearTimeout:void 0,TN=typeof Promise=="function"?Promise:void 0,Zz=typeof queueMicrotask=="function"?queueMicrotask:typeof TN<"u"?function(o){return TN.resolve(null).then(o).catch(Jz)}:SN;function Jz(o){setTimeout(function(){throw o})}function p2(o){return o==="head"}function wN(o,u){var f=u,y=0,S=0;do{var w=f.nextSibling;if(o.removeChild(f),w&&w.nodeType===8)if(f=w.data,f==="/$"){if(0<y&&8>y){f=y;var B=o.ownerDocument;if(f&1&&Kd(B.documentElement),f&2&&Kd(B.body),f&4)for(f=B.head,Kd(f),B=f.firstChild;B;){var W=B.nextSibling,ie=B.nodeName;B[yi]||ie==="SCRIPT"||ie==="STYLE"||ie==="LINK"&&B.rel.toLowerCase()==="stylesheet"||f.removeChild(B),B=W}}if(S===0){o.removeChild(w),tf(u);return}S--}else f==="$"||f==="$?"||f==="$!"?S++:y=f.charCodeAt(0)-48;else y=0;f=w}while(f);tf(u)}function Qb(o){var u=o.firstChild;for(u&&u.nodeType===10&&(u=u.nextSibling);u;){var f=u;switch(u=u.nextSibling,f.nodeName){case"HTML":case"HEAD":case"BODY":Qb(f),Gr(f);continue;case"SCRIPT":case"STYLE":continue;case"LINK":if(f.rel.toLowerCase()==="stylesheet")continue}o.removeChild(f)}}function jz(o,u,f,y){for(;o.nodeType===1;){var S=f;if(o.nodeName.toLowerCase()!==u.toLowerCase()){if(!y&&(o.nodeName!=="INPUT"||o.type!=="hidden"))break}else if(y){if(!o[yi])switch(u){case"meta":if(!o.hasAttribute("itemprop"))break;return o;case"link":if(w=o.getAttribute("rel"),w==="stylesheet"&&o.hasAttribute("data-precedence"))break;if(w!==S.rel||o.getAttribute("href")!==(S.href==null||S.href===""?null:S.href)||o.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin)||o.getAttribute("title")!==(S.title==null?null:S.title))break;return o;case"style":if(o.hasAttribute("data-precedence"))break;return o;case"script":if(w=o.getAttribute("src"),(w!==(S.src==null?null:S.src)||o.getAttribute("type")!==(S.type==null?null:S.type)||o.getAttribute("crossorigin")!==(S.crossOrigin==null?null:S.crossOrigin))&&w&&o.hasAttribute("async")&&!o.hasAttribute("itemprop"))break;return o;default:return o}}else if(u==="input"&&o.type==="hidden"){var w=S.name==null?null:""+S.name;if(S.type==="hidden"&&o.getAttribute("name")===w)return o}else return o;if(o=Na(o.nextSibling),o===null)break}return null}function qz(o,u,f){if(u==="")return null;for(;o.nodeType!==3;)if((o.nodeType!==1||o.nodeName!=="INPUT"||o.type!=="hidden")&&!f||(o=Na(o.nextSibling),o===null))return null;return o}function Zb(o){return o.data==="$!"||o.data==="$?"&&o.ownerDocument.readyState==="complete"}function e5(o,u){var f=o.ownerDocument;if(o.data!=="$?"||f.readyState==="complete")u();else{var y=function(){u(),f.removeEventListener("DOMContentLoaded",y)};f.addEventListener("DOMContentLoaded",y),o._reactRetry=y}}function Na(o){for(;o!=null;o=o.nextSibling){var u=o.nodeType;if(u===1||u===3)break;if(u===8){if(u=o.data,u==="$"||u==="$!"||u==="$?"||u==="F!"||u==="F")break;if(u==="/$")return null}}return o}var Jb=null;function AN(o){o=o.previousSibling;for(var u=0;o;){if(o.nodeType===8){var f=o.data;if(f==="$"||f==="$!"||f==="$?"){if(u===0)return o;u--}else f==="/$"&&u++}o=o.previousSibling}return null}function EN(o,u,f){switch(u=Tm(f),o){case"html":if(o=u.documentElement,!o)throw Error(n(452));return o;case"head":if(o=u.head,!o)throw Error(n(453));return o;case"body":if(o=u.body,!o)throw Error(n(454));return o;default:throw Error(n(451))}}function Kd(o){for(var u=o.attributes;u.length;)o.removeAttributeNode(u[0]);Gr(o)}var ta=new Map,MN=new Set;function wm(o){return typeof o.getRootNode=="function"?o.getRootNode():o.nodeType===9?o:o.ownerDocument}var io=re.d;re.d={f:t5,r:x5,D:n5,C:i5,L:r5,m:a5,X:o5,S:s5,M:l5};function t5(){var o=io.f(),u=pm();return o||u}function x5(o){var u=Oi(o);u!==null&&u.tag===5&&u.type==="form"?KR(u):io.r(o)}var uu=typeof document>"u"?null:document;function RN(o,u,f){var y=uu;if(y&&typeof u=="string"&&u){var S=T0(u);S='link[rel="'+o+'"][href="'+S+'"]',typeof f=="string"&&(S+='[crossorigin="'+f+'"]'),MN.has(S)||(MN.add(S),o={rel:o,crossOrigin:f,href:u},y.querySelector(S)===null&&(u=y.createElement("link"),Zn(u,"link",o),ce(u),y.head.appendChild(u)))}}function n5(o){io.D(o),RN("dns-prefetch",o,null)}function i5(o,u){io.C(o,u),RN("preconnect",o,u)}function r5(o,u,f){io.L(o,u,f);var y=uu;if(y&&o&&u){var S='link[rel="preload"][as="'+T0(u)+'"]';u==="image"&&f&&f.imageSrcSet?(S+='[imagesrcset="'+T0(f.imageSrcSet)+'"]',typeof f.imageSizes=="string"&&(S+='[imagesizes="'+T0(f.imageSizes)+'"]')):S+='[href="'+T0(o)+'"]';var w=S;switch(u){case"style":w=hu(o);break;case"script":w=du(o)}ta.has(w)||(o=h({rel:"preload",href:u==="image"&&f&&f.imageSrcSet?void 0:o,as:u},f),ta.set(w,o),y.querySelector(S)!==null||u==="style"&&y.querySelector($d(w))||u==="script"&&y.querySelector(Qd(w))||(u=y.createElement("link"),Zn(u,"link",o),ce(u),y.head.appendChild(u)))}}function a5(o,u){io.m(o,u);var f=uu;if(f&&o){var y=u&&typeof u.as=="string"?u.as:"script",S='link[rel="modulepreload"][as="'+T0(y)+'"][href="'+T0(o)+'"]',w=S;switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":w=du(o)}if(!ta.has(w)&&(o=h({rel:"modulepreload",href:o},u),ta.set(w,o),f.querySelector(S)===null)){switch(y){case"audioworklet":case"paintworklet":case"serviceworker":case"sharedworker":case"worker":case"script":if(f.querySelector(Qd(w)))return}y=f.createElement("link"),Zn(y,"link",o),ce(y),f.head.appendChild(y)}}}function s5(o,u,f){io.S(o,u,f);var y=uu;if(y&&o){var S=Y(y).hoistableStyles,w=hu(o);u=u||"default";var B=S.get(w);if(!B){var W={loading:0,preload:null};if(B=y.querySelector($d(w)))W.loading=5;else{o=h({rel:"stylesheet",href:o,"data-precedence":u},f),(f=ta.get(w))&&jb(o,f);var ie=B=y.createElement("link");ce(ie),Zn(ie,"link",o),ie._p=new Promise(function(Ee,Ke){ie.onload=Ee,ie.onerror=Ke}),ie.addEventListener("load",function(){W.loading|=1}),ie.addEventListener("error",function(){W.loading|=2}),W.loading|=4,Am(B,u,y)}B={type:"stylesheet",instance:B,count:1,state:W},S.set(w,B)}}}function o5(o,u){io.X(o,u);var f=uu;if(f&&o){var y=Y(f).hoistableScripts,S=du(o),w=y.get(S);w||(w=f.querySelector(Qd(S)),w||(o=h({src:o,async:!0},u),(u=ta.get(S))&&qb(o,u),w=f.createElement("script"),ce(w),Zn(w,"link",o),f.head.appendChild(w)),w={type:"script",instance:w,count:1,state:null},y.set(S,w))}}function l5(o,u){io.M(o,u);var f=uu;if(f&&o){var y=Y(f).hoistableScripts,S=du(o),w=y.get(S);w||(w=f.querySelector(Qd(S)),w||(o=h({src:o,async:!0,type:"module"},u),(u=ta.get(S))&&qb(o,u),w=f.createElement("script"),ce(w),Zn(w,"link",o),f.head.appendChild(w)),w={type:"script",instance:w,count:1,state:null},y.set(S,w))}}function CN(o,u,f,y){var S=(S=Fe.current)?wm(S):null;if(!S)throw Error(n(446));switch(o){case"meta":case"title":return null;case"style":return typeof f.precedence=="string"&&typeof f.href=="string"?(u=hu(f.href),f=Y(S).hoistableStyles,y=f.get(u),y||(y={type:"style",instance:null,count:0,state:null},f.set(u,y)),y):{type:"void",instance:null,count:0,state:null};case"link":if(f.rel==="stylesheet"&&typeof f.href=="string"&&typeof f.precedence=="string"){o=hu(f.href);var w=Y(S).hoistableStyles,B=w.get(o);if(B||(S=S.ownerDocument||S,B={type:"stylesheet",instance:null,count:0,state:{loading:0,preload:null}},w.set(o,B),(w=S.querySelector($d(o)))&&!w._p&&(B.instance=w,B.state.loading=5),ta.has(o)||(f={rel:"preload",as:"style",href:f.href,crossOrigin:f.crossOrigin,integrity:f.integrity,media:f.media,hrefLang:f.hrefLang,referrerPolicy:f.referrerPolicy},ta.set(o,f),w||c5(S,o,f,B.state))),u&&y===null)throw Error(n(528,""));return B}if(u&&y!==null)throw Error(n(529,""));return null;case"script":return u=f.async,f=f.src,typeof f=="string"&&u&&typeof u!="function"&&typeof u!="symbol"?(u=du(f),f=Y(S).hoistableScripts,y=f.get(u),y||(y={type:"script",instance:null,count:0,state:null},f.set(u,y)),y):{type:"void",instance:null,count:0,state:null};default:throw Error(n(444,o))}}function hu(o){return'href="'+T0(o)+'"'}function $d(o){return'link[rel="stylesheet"]['+o+"]"}function NN(o){return h({},o,{"data-precedence":o.precedence,precedence:null})}function c5(o,u,f,y){o.querySelector('link[rel="preload"][as="style"]['+u+"]")?y.loading=1:(u=o.createElement("link"),y.preload=u,u.addEventListener("load",function(){return y.loading|=1}),u.addEventListener("error",function(){return y.loading|=2}),Zn(u,"link",f),ce(u),o.head.appendChild(u))}function du(o){return'[src="'+T0(o)+'"]'}function Qd(o){return"script[async]"+o}function IN(o,u,f){if(u.count++,u.instance===null)switch(u.type){case"style":var y=o.querySelector('style[data-href~="'+T0(f.href)+'"]');if(y)return u.instance=y,ce(y),y;var S=h({},f,{"data-href":f.href,"data-precedence":f.precedence,href:null,precedence:null});return y=(o.ownerDocument||o).createElement("style"),ce(y),Zn(y,"style",S),Am(y,f.precedence,o),u.instance=y;case"stylesheet":S=hu(f.href);var w=o.querySelector($d(S));if(w)return u.state.loading|=4,u.instance=w,ce(w),w;y=NN(f),(S=ta.get(S))&&jb(y,S),w=(o.ownerDocument||o).createElement("link"),ce(w);var B=w;return B._p=new Promise(function(W,ie){B.onload=W,B.onerror=ie}),Zn(w,"link",y),u.state.loading|=4,Am(w,f.precedence,o),u.instance=w;case"script":return w=du(f.src),(S=o.querySelector(Qd(w)))?(u.instance=S,ce(S),S):(y=f,(S=ta.get(w))&&(y=h({},f),qb(y,S)),o=o.ownerDocument||o,S=o.createElement("script"),ce(S),Zn(S,"link",y),o.head.appendChild(S),u.instance=S);case"void":return null;default:throw Error(n(443,u.type))}else u.type==="stylesheet"&&(u.state.loading&4)===0&&(y=u.instance,u.state.loading|=4,Am(y,f.precedence,o));return u.instance}function Am(o,u,f){for(var y=f.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'),S=y.length?y[y.length-1]:null,w=S,B=0;B<y.length;B++){var W=y[B];if(W.dataset.precedence===u)w=W;else if(w!==S)break}w?w.parentNode.insertBefore(o,w.nextSibling):(u=f.nodeType===9?f.head:f,u.insertBefore(o,u.firstChild))}function jb(o,u){o.crossOrigin==null&&(o.crossOrigin=u.crossOrigin),o.referrerPolicy==null&&(o.referrerPolicy=u.referrerPolicy),o.title==null&&(o.title=u.title)}function qb(o,u){o.crossOrigin==null&&(o.crossOrigin=u.crossOrigin),o.referrerPolicy==null&&(o.referrerPolicy=u.referrerPolicy),o.integrity==null&&(o.integrity=u.integrity)}var Em=null;function ON(o,u,f){if(Em===null){var y=new Map,S=Em=new Map;S.set(f,y)}else S=Em,y=S.get(f),y||(y=new Map,S.set(f,y));if(y.has(o))return y;for(y.set(o,null),f=f.getElementsByTagName(o),S=0;S<f.length;S++){var w=f[S];if(!(w[yi]||w[L0]||o==="link"&&w.getAttribute("rel")==="stylesheet")&&w.namespaceURI!=="http://www.w3.org/2000/svg"){var B=w.getAttribute(u)||"";B=o+B;var W=y.get(B);W?W.push(w):y.set(B,[w])}}return y}function DN(o,u,f){o=o.ownerDocument||o,o.head.insertBefore(f,u==="title"?o.querySelector("head > title"):null)}function u5(o,u,f){if(f===1||u.itemProp!=null)return!1;switch(o){case"meta":case"title":return!0;case"style":if(typeof u.precedence!="string"||typeof u.href!="string"||u.href==="")break;return!0;case"link":if(typeof u.rel!="string"||typeof u.href!="string"||u.href===""||u.onLoad||u.onError)break;switch(u.rel){case"stylesheet":return o=u.disabled,typeof u.precedence=="string"&&o==null;default:return!0}case"script":if(u.async&&typeof u.async!="function"&&typeof u.async!="symbol"&&!u.onLoad&&!u.onError&&u.src&&typeof u.src=="string")return!0}return!1}function PN(o){return!(o.type==="stylesheet"&&(o.state.loading&3)===0)}var Zd=null;function h5(){}function d5(o,u,f){if(Zd===null)throw Error(n(475));var y=Zd;if(u.type==="stylesheet"&&(typeof f.media!="string"||matchMedia(f.media).matches!==!1)&&(u.state.loading&4)===0){if(u.instance===null){var S=hu(f.href),w=o.querySelector($d(S));if(w){o=w._p,o!==null&&typeof o=="object"&&typeof o.then=="function"&&(y.count++,y=Mm.bind(y),o.then(y,y)),u.state.loading|=4,u.instance=w,ce(w);return}w=o.ownerDocument||o,f=NN(f),(S=ta.get(S))&&jb(f,S),w=w.createElement("link"),ce(w);var B=w;B._p=new Promise(function(W,ie){B.onload=W,B.onerror=ie}),Zn(w,"link",f),u.instance=w}y.stylesheets===null&&(y.stylesheets=new Map),y.stylesheets.set(u,o),(o=u.state.preload)&&(u.state.loading&3)===0&&(y.count++,u=Mm.bind(y),o.addEventListener("load",u),o.addEventListener("error",u))}}function f5(){if(Zd===null)throw Error(n(475));var o=Zd;return o.stylesheets&&o.count===0&&e_(o,o.stylesheets),0<o.count?function(u){var f=setTimeout(function(){if(o.stylesheets&&e_(o,o.stylesheets),o.unsuspend){var y=o.unsuspend;o.unsuspend=null,y()}},6e4);return o.unsuspend=u,function(){o.unsuspend=null,clearTimeout(f)}}:null}function Mm(){if(this.count--,this.count===0){if(this.stylesheets)e_(this,this.stylesheets);else if(this.unsuspend){var o=this.unsuspend;this.unsuspend=null,o()}}}var Rm=null;function e_(o,u){o.stylesheets=null,o.unsuspend!==null&&(o.count++,Rm=new Map,u.forEach(p5,o),Rm=null,Mm.call(o))}function p5(o,u){if(!(u.state.loading&4)){var f=Rm.get(o);if(f)var y=f.get(null);else{f=new Map,Rm.set(o,f);for(var S=o.querySelectorAll("link[data-precedence],style[data-precedence]"),w=0;w<S.length;w++){var B=S[w];(B.nodeName==="LINK"||B.getAttribute("media")!=="not all")&&(f.set(B.dataset.precedence,B),y=B)}y&&f.set(null,y)}S=u.instance,B=S.getAttribute("data-precedence"),w=f.get(B)||y,w===y&&f.set(null,S),f.set(B,S),this.count++,y=Mm.bind(this),S.addEventListener("load",y),S.addEventListener("error",y),w?w.parentNode.insertBefore(S,w.nextSibling):(o=o.nodeType===9?o.head:o,o.insertBefore(S,o.firstChild)),u.state.loading|=4}}var Jd={$$typeof:E,Provider:null,Consumer:null,_currentValue:q,_currentValue2:q,_threadCount:0};function m5(o,u,f,y,S,w,B,W){this.tag=1,this.containerInfo=o,this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.next=this.pendingContext=this.context=this.cancelPendingCommit=null,this.callbackPriority=0,this.expirationTimes=Ze(-1),this.entangledLanes=this.shellSuspendCounter=this.errorRecoveryDisabledLanes=this.expiredLanes=this.warmLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Ze(0),this.hiddenUpdates=Ze(null),this.identifierPrefix=y,this.onUncaughtError=S,this.onCaughtError=w,this.onRecoverableError=B,this.pooledCache=null,this.pooledCacheLanes=0,this.formState=W,this.incompleteTransitions=new Map}function kN(o,u,f,y,S,w,B,W,ie,Ee,Ke,nt){return o=new m5(o,u,f,B,W,ie,Ee,nt),u=1,w===!0&&(u|=24),w=lr(3,null,null,u),o.current=w,w.stateNode=o,u=kv(),u.refCount++,o.pooledCache=u,u.refCount++,w.memoizedState={element:y,isDehydrated:f,cache:u},Lv(w),o}function UN(o){return o?(o=Wc,o):Wc}function FN(o,u,f,y,S,w){S=UN(S),y.context===null?y.context=S:y.pendingContext=S,y=x2(u),y.payload={element:f},w=w===void 0?null:w,w!==null&&(y.callback=w),f=n2(o,y,u),f!==null&&(fr(f,o,u),Md(f,o,u))}function BN(o,u){if(o=o.memoizedState,o!==null&&o.dehydrated!==null){var f=o.retryLane;o.retryLane=f!==0&&f<u?f:u}}function t_(o,u){BN(o,u),(o=o.alternate)&&BN(o,u)}function LN(o){if(o.tag===13){var u=Gc(o,67108864);u!==null&&fr(u,o,67108864),t_(o,67108864)}}var Cm=!0;function y5(o,u,f,y){var S=H.T;H.T=null;var w=re.p;try{re.p=2,x_(o,u,f,y)}finally{re.p=w,H.T=S}}function g5(o,u,f,y){var S=H.T;H.T=null;var w=re.p;try{re.p=8,x_(o,u,f,y)}finally{re.p=w,H.T=S}}function x_(o,u,f,y){if(Cm){var S=n_(y);if(S===null)Gb(o,u,y,Nm,f),VN(o,y);else if(b5(S,o,u,f,y))y.stopPropagation();else if(VN(o,y),u&4&&-1<v5.indexOf(o)){for(;S!==null;){var w=Oi(S);if(w!==null)switch(w.tag){case 3:if(w=w.stateNode,w.current.memoizedState.isDehydrated){var B=Ut(w.pendingLanes);if(B!==0){var W=w;for(W.pendingLanes|=2,W.entangledLanes|=2;B;){var ie=1<<31-et(B);W.entanglements[1]|=ie,B&=~ie}ms(w),(tx&6)===0&&(dm=bt()+500,Wd(0))}}break;case 13:W=Gc(w,2),W!==null&&fr(W,w,2),pm(),t_(w,2)}if(w=n_(y),w===null&&Gb(o,u,y,Nm,f),w===S)break;S=w}S!==null&&y.stopPropagation()}else Gb(o,u,y,null,f)}}function n_(o){return o=_n(o),i_(o)}var Nm=null;function i_(o){if(Nm=null,o=Ii(o),o!==null){var u=r(o);if(u===null)o=null;else{var f=u.tag;if(f===13){if(o=a(u),o!==null)return o;o=null}else if(f===3){if(u.stateNode.current.memoizedState.isDehydrated)return u.tag===3?u.stateNode.containerInfo:null;o=null}else u!==o&&(o=null)}}return Nm=o,null}function zN(o){switch(o){case"beforetoggle":case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"toggle":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 2;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 8;case"message":switch(ht()){case dt:return 2;case Z:return 8;case V:case _e:return 32;case Ge:return 268435456;default:return 32}default:return 32}}var r_=!1,m2=null,y2=null,g2=null,jd=new Map,qd=new Map,v2=[],v5="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");function VN(o,u){switch(o){case"focusin":case"focusout":m2=null;break;case"dragenter":case"dragleave":y2=null;break;case"mouseover":case"mouseout":g2=null;break;case"pointerover":case"pointerout":jd.delete(u.pointerId);break;case"gotpointercapture":case"lostpointercapture":qd.delete(u.pointerId)}}function ef(o,u,f,y,S,w){return o===null||o.nativeEvent!==w?(o={blockedOn:u,domEventName:f,eventSystemFlags:y,nativeEvent:w,targetContainers:[S]},u!==null&&(u=Oi(u),u!==null&&LN(u)),o):(o.eventSystemFlags|=y,u=o.targetContainers,S!==null&&u.indexOf(S)===-1&&u.push(S),o)}function b5(o,u,f,y,S){switch(u){case"focusin":return m2=ef(m2,o,u,f,y,S),!0;case"dragenter":return y2=ef(y2,o,u,f,y,S),!0;case"mouseover":return g2=ef(g2,o,u,f,y,S),!0;case"pointerover":var w=S.pointerId;return jd.set(w,ef(jd.get(w)||null,o,u,f,y,S)),!0;case"gotpointercapture":return w=S.pointerId,qd.set(w,ef(qd.get(w)||null,o,u,f,y,S)),!0}return!1}function HN(o){var u=Ii(o.target);if(u!==null){var f=r(u);if(f!==null){if(u=f.tag,u===13){if(u=a(f),u!==null){o.blockedOn=u,Cx(o.priority,function(){if(f.tag===13){var y=dr();y=P0(y);var S=Gc(f,y);S!==null&&fr(S,f,y),t_(f,y)}});return}}else if(u===3&&f.stateNode.current.memoizedState.isDehydrated){o.blockedOn=f.tag===3?f.stateNode.containerInfo:null;return}}}o.blockedOn=null}function Im(o){if(o.blockedOn!==null)return!1;for(var u=o.targetContainers;0<u.length;){var f=n_(o.nativeEvent);if(f===null){f=o.nativeEvent;var y=new f.constructor(f.type,f);as=y,f.target.dispatchEvent(y),as=null}else return u=Oi(f),u!==null&&LN(u),o.blockedOn=f,!1;u.shift()}return!0}function GN(o,u,f){Im(o)&&f.delete(u)}function _5(){r_=!1,m2!==null&&Im(m2)&&(m2=null),y2!==null&&Im(y2)&&(y2=null),g2!==null&&Im(g2)&&(g2=null),jd.forEach(GN),qd.forEach(GN)}function Om(o,u){o.blockedOn===u&&(o.blockedOn=null,r_||(r_=!0,x.unstable_scheduleCallback(x.unstable_NormalPriority,_5)))}var Dm=null;function WN(o){Dm!==o&&(Dm=o,x.unstable_scheduleCallback(x.unstable_NormalPriority,function(){Dm===o&&(Dm=null);for(var u=0;u<o.length;u+=3){var f=o[u],y=o[u+1],S=o[u+2];if(typeof y!="function"){if(i_(y||f)===null)continue;break}var w=Oi(f);w!==null&&(o.splice(u,3),u-=3,ib(w,{pending:!0,data:S,method:f.method,action:y},y,S))}}))}function tf(o){function u(ie){return Om(ie,o)}m2!==null&&Om(m2,o),y2!==null&&Om(y2,o),g2!==null&&Om(g2,o),jd.forEach(u),qd.forEach(u);for(var f=0;f<v2.length;f++){var y=v2[f];y.blockedOn===o&&(y.blockedOn=null)}for(;0<v2.length&&(f=v2[0],f.blockedOn===null);)HN(f),f.blockedOn===null&&v2.shift();if(f=(o.ownerDocument||o).$$reactFormReplay,f!=null)for(y=0;y<f.length;y+=3){var S=f[y],w=f[y+1],B=S[R0]||null;if(typeof w=="function")B||WN(f);else if(B){var W=null;if(w&&w.hasAttribute("formAction")){if(S=w,B=w[R0]||null)W=B.formAction;else if(i_(S)!==null)continue}else W=B.action;typeof W=="function"?f[y+1]=W:(f.splice(y,3),y-=3),WN(f)}}}function a_(o){this._internalRoot=o}Pm.prototype.render=a_.prototype.render=function(o){var u=this._internalRoot;if(u===null)throw Error(n(409));var f=u.current,y=dr();FN(f,y,o,u,null,null)},Pm.prototype.unmount=a_.prototype.unmount=function(){var o=this._internalRoot;if(o!==null){this._internalRoot=null;var u=o.containerInfo;FN(o.current,2,null,o,null,null),pm(),u[Wn]=null}};function Pm(o){this._internalRoot=o}Pm.prototype.unstable_scheduleHydration=function(o){if(o){var u=rn();o={blockedOn:null,target:o,priority:u};for(var f=0;f<v2.length&&u!==0&&u<v2[f].priority;f++);v2.splice(f,0,o),f===0&&HN(o)}};var XN=e.version;if(XN!=="19.1.0")throw Error(n(527,XN,"19.1.0"));re.findDOMNode=function(o){var u=o._reactInternals;if(u===void 0)throw typeof o.render=="function"?Error(n(188)):(o=Object.keys(o).join(","),Error(n(268,o)));return o=l(u),o=o!==null?c(o):null,o=o===null?null:o.stateNode,o};var S5={bundleType:0,version:"19.1.0",rendererPackageName:"react-dom",currentDispatcherRef:H,reconcilerVersion:"19.1.0"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var km=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!km.isDisabled&&km.supportsFiber)try{_t=km.inject(S5),Ce=km}catch{}}return xf.createRoot=function(o,u){if(!i(o))throw Error(n(299));var f=!1,y="",S=sC,w=oC,B=lC,W=null;return u!=null&&(u.unstable_strictMode===!0&&(f=!0),u.identifierPrefix!==void 0&&(y=u.identifierPrefix),u.onUncaughtError!==void 0&&(S=u.onUncaughtError),u.onCaughtError!==void 0&&(w=u.onCaughtError),u.onRecoverableError!==void 0&&(B=u.onRecoverableError),u.unstable_transitionCallbacks!==void 0&&(W=u.unstable_transitionCallbacks)),u=kN(o,1,!1,null,null,f,y,S,w,B,W,null),o[Wn]=u.current,Hb(o),new a_(u)},xf.hydrateRoot=function(o,u,f){if(!i(o))throw Error(n(299));var y=!1,S="",w=sC,B=oC,W=lC,ie=null,Ee=null;return f!=null&&(f.unstable_strictMode===!0&&(y=!0),f.identifierPrefix!==void 0&&(S=f.identifierPrefix),f.onUncaughtError!==void 0&&(w=f.onUncaughtError),f.onCaughtError!==void 0&&(B=f.onCaughtError),f.onRecoverableError!==void 0&&(W=f.onRecoverableError),f.unstable_transitionCallbacks!==void 0&&(ie=f.unstable_transitionCallbacks),f.formState!==void 0&&(Ee=f.formState)),u=kN(o,1,!0,u,f??null,y,S,w,B,W,ie,Ee),u.context=UN(null),f=u.current,y=dr(),y=P0(y),S=x2(y),S.callback=null,n2(f,S,y),f=y,u.current.lanes=f,lt(u,f),ms(u),o[Wn]=u.current,Hb(o),new Pm(u)},xf.version="19.1.0",xf}var qN;function I5(){if(qN)return o_.exports;qN=1;function x(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(x)}catch(e){console.error(e)}}return x(),o_.exports=N5(),o_.exports}var O5=I5();const D5=({onOutfitChange:x})=>{const[e,t]=Jn.useState("onesie"),n=i=>{t(i),x==null||x(i)};return hx.createElement("div",null,hx.createElement("input",{type:"checkbox",id:"outfit-switch",className:"button checkbox",style:{position:"absolute",top:"3.5rem",right:"0.5rem",zIndex:1,display:"none"}}),hx.createElement("div",{className:"carousel"},hx.createElement("input",{type:"radio",name:"model",value:"onesie",className:"carousel-item",style:{backgroundImage:"url(./preview/onesie.png)"},checked:e==="onesie",onChange:i=>n(i.target.value)}),hx.createElement("input",{type:"radio",name:"model",value:"jacket",className:"carousel-item",style:{backgroundImage:"url(./preview/jacket.png)"},checked:e==="jacket",onChange:i=>n(i.target.value)})))};function P5(x,e){return e.forEach(function(t){t&&typeof t!="string"&&!Array.isArray(t)&&Object.keys(t).forEach(function(n){if(n!=="default"&&!(n in x)){var i=Object.getOwnPropertyDescriptor(t,n);Object.defineProperty(x,n,i.get?i:{enumerable:!0,get:function(){return t[n]}})}})}),Object.freeze(x)}const k5=1e-7,U5=1e-4;class QP{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}let Jw=class{refCount(e){return Hi("refCount")}incRef(e){return Hi("incRef")}timerAvailable(){return!0}time(e){return Hi("time")}read(e){return Hi("read")}readSync(e){return Hi("readSync")}readToGPU(e,t){return Hi("readToGPU")}numDataIds(){return Hi("numDataIds")}disposeData(e,t){return Hi("disposeData")}write(e,t,n){return Hi("write")}move(e,t,n,i,r){return Hi("move")}createTensorFromGPUData(e,t,n){return Hi("createTensorFromGPUData")}memory(){return Hi("memory")}floatPrecision(){return Hi("floatPrecision")}epsilon(){return this.floatPrecision()===32?k5:U5}dispose(){return Hi("dispose")}};function Hi(x){throw new Error("'"+x+"' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen")}function mc(x,e,t){return Math.max(x,Math.min(e,t))}function jw(x){return x%2===0?x:x+1}function nf(x,e,t){const n=x[e];x[e]=x[t],x[t]=n}function F5(x){let e=0;for(let t=0;t<x.length;t++)e+=x[t];return e}function ye(x,e){if(!x)throw new Error(typeof e=="string"?e:e())}function qw(x,e,t=""){ye(Zx(x,e),()=>t+(" Shapes "+x+" and "+e+" must match"))}function eA(x){ye(x!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ut(x){if(x.length===0)return 1;let e=x[0];for(let t=1;t<x.length;t++)e*=x[t];return e}function Zx(x,e){if(x===e)return!0;if(x==null||e==null||x.length!==e.length)return!1;for(let t=0;t<x.length;t++)if(x[t]!==e[t])return!1;return!0}function v1(x){return x%1===0}function YS(x){const e=Math.ceil(Math.sqrt(x));return[e,Math.ceil(x/e)]}function rh(x,e){return e<=x.length?x:x+" ".repeat(e-x.length)}function e3(x,e=i=>0,t,n){return new Promise((i,r)=>{let a=0;const s=()=>{if(x()){i();return}a++;const l=e(a);if(t!=null&&a>=t){r();return}n!=null?n(s,l):setTimeout(s,l)};s()})}function ZP(x,e){let t=1,n=-1;for(let r=0;r<x.length;++r)if(x[r]>=0)t*=x[r];else if(x[r]===-1){if(n!==-1)throw Error("Shapes can only have 1 implicit size. Found -1 at dim "+n+" and dim "+r);n=r}else if(x[r]<0)throw Error("Shapes can not be < 0. Found "+x[r]+" at dim "+r);if(n===-1){if(e>0&&e!==t)throw Error("Size("+e+") must match the product of shape "+x);return x}if(t===0)throw Error("Cannot infer the missing size in ["+x+"] when there are 0 elements");if(e%t!==0)throw Error("The implicit shape can't be a fractional number. Got "+e+" / "+t);const i=x.slice();return i[n]=e/t,i}function Ri(x,e){const t=e.length;return x=x==null?e.map((n,i)=>i):[].concat(x),ye(x.every(n=>n>=-t&&n<t),()=>"All values in axis param must be in range [-"+t+", "+t+") but got axis "+x),ye(x.every(n=>v1(n)),()=>"All values in axis param must be integers but got axis "+x),x.map(n=>n<0?t+n:n)}function al(x,e){const t=[],n=[],i=e!=null&&Array.isArray(e)&&e.length===0,r=e==null||i?null:Ri(e,x).sort();let a=0;for(let s=0;s<x.length;++s){if(r!=null){if(r[a]===s&&x[s]!==1)throw new Error("Can't squeeze axis "+s+" since its dim '"+x[s]+"' is not 1");(r[a]==null||r[a]>s)&&x[s]===1&&(t.push(x[s]),n.push(s)),r[a]<=s&&a++}x[s]!==1&&(t.push(x[s]),n.push(s))}return{newShape:t,keptDims:n}}function Ir(x,e){return fn(x,e)}function fn(x,e){let t=null;if(x==null||x==="float32")t=new Float32Array(e);else if(x==="int32")t=new Int32Array(e);else if(x==="bool")t=new Uint8Array(e);else if(x==="string")t=new Array(e);else throw new Error("Unknown data type "+x);return t}function B5(x,e){for(let t=0;t<x.length;t++){const n=x[t];if(isNaN(n)||!isFinite(n))throw Error("A tensor of type "+e+" being uploaded contains "+n+".")}}function L5(x){return x==="bool"||x==="complex64"||x==="float32"||x==="int32"||x==="string"}function JP(x,e){return!(e==="complex64"||e==="float32"&&x!=="complex64"||e==="int32"&&x!=="float32"&&x!=="complex64"||e==="bool"&&x==="bool")}function b1(x){if(x==="float32"||x==="int32")return 4;if(x==="complex64")return 8;if(x==="bool")return 1;throw new Error("Unknown dtype "+x)}function z5(x){if(x==null)return 0;let e=0;return x.forEach(t=>e+=t.length),e}function cp(x){return typeof x=="string"||x instanceof String}function V5(x){return typeof x=="boolean"}function H5(x){return typeof x=="number"}function Qh(x){return Array.isArray(x)?Qh(x[0]):x instanceof Float32Array?"float32":x instanceof Int32Array||x instanceof Uint8Array||x instanceof Uint8ClampedArray?"int32":H5(x)?"float32":cp(x)?"string":V5(x)?"bool":"float32"}function t3(x){return!!(x&&x.constructor&&x.call&&x.apply)}function KS(x,e){for(let t=e;t<x;++t)if(x%t===0)return t;return x}function M0(x){const e=x.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=x[e-1];for(let n=e-3;n>=0;--n)t[n]=t[n+1]*x[n+1];return t}function jP(x,e,t,n=!1){const i=new Array;if(e.length===1){const r=e[0]*(n?2:1);for(let a=0;a<r;a++)i[a]=t[x+a]}else{const r=e[0],a=e.slice(1),s=a.reduce((l,c)=>l*c)*(n?2:1);for(let l=0;l<r;l++)i[l]=jP(x+l*s,a,t,n)}return i}function $S(x,e,t=!1){if(x.length===0)return e[0];const n=x.reduce((i,r)=>i*r)*(t?2:1);if(n===0)return[];if(n!==e.length)throw new Error("["+x+"] does not match the input size "+e.length+(t?" for a complex tensor":"")+".");return jP(0,x,e,t)}function G5(x,e){if(Array.isArray(x))return x;if(e==="float32")return x instanceof Float32Array?x:new Float32Array(x);if(e==="int32")return x instanceof Int32Array?x:new Int32Array(x);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(x));throw new Error("Unknown dtype "+e)}function qP(x,e){const t=Ms(x,e);for(let n=0;n<t.length;n++)t[n]=1;return t}function Ms(x,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(x);if(e==="int32")return new Int32Array(x);if(e==="bool")return new Uint8Array(x);throw new Error("Unknown data type "+e)}function Zh(x){x.forEach(e=>{ye(Number.isInteger(e)&&e>=0,()=>"Tensor must have a shape comprised of positive integers but got shape ["+x+"].")})}function bh(x,e,t){if(e===0)return 0;if(e===1)return x[0];let n=x[x.length-1];for(let i=0;i<x.length-1;++i)n+=t[i]*x[i];return n}function up(x,e,t){if(e===0)return[];if(e===1)return[x];const n=new Array(e);for(let i=0;i<n.length-1;++i)n[i]=Math.floor(x/t[i]),x-=n[i]*t[i];return n[n.length-1]=x,n}function yc(x){return x&&x.then&&typeof x.then=="function"}const x3="tfjsflags";class W5{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=X5,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn("Platform "+this.platformName+" has already been set. Overwriting the platform with "+e+".")),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},this.urlFlags[e]!=null){const i=this.urlFlags[e];Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn("Setting feature override from URL "+e+": "+i+"."),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(yc(t))throw new Error("Flag "+e+" cannot be synchronously evaluated. Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error("Cannot set flag "+e+" as it has not been registered.");this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error("Cannot evaluate flag '"+e+"': no evaluation function found.");return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);x3 in e&&e[x3].split(",").forEach(t=>{const[n,i]=t.split(":");this.urlFlags[n]=K5(n,i)})}}function X5(x){const e={};return x.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...n)=>(Y5(e,n[0],n[1]),n.join("="))),e}function Y5(x,e,t){x[decodeURIComponent(e)]=decodeURIComponent(t||"")}function K5(x,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":""+ +t===t?+t:e}function Pe(){return ek}let ek=null;function $5(x){ek=x}let h_;function tk(){if(h_==null){let x;if(typeof window<"u")x=window;else if(typeof global<"u")x=global;else if(typeof process<"u")x=process;else if(typeof self<"u")x=self;else throw new Error("Could not find a global object");h_=x}return h_}function Q5(){const x=tk();return x._tfGlobals==null&&(x._tfGlobals=new Map),x._tfGlobals}function tA(x,e){const t=Q5();if(t.has(x))return t.get(x);{const n=e();return t.set(x,n),t.get(x)}}const xA="Abs",hp="Add",nA="AddN",ag="Atan2",iA="AvgPool",rA="BatchMatMul",Z5="Bincount",sg="Cast",og="ClipByValue",J5="Complex",j5="ComplexAbs",aA="Concat",sA="Conv2D",q5="Conv2DBackpropFilter",oA="Conv2DBackpropInput",lg="Cos",lA="CropAndResize",cA="DepthToSpace",uA="DepthwiseConv2dNative",eV="DepthwiseConv2dNativeBackpropFilter",tV="DepthwiseConv2dNativeBackpropInput",cg="RealDiv",xV="Einsum",xk="Elu",hA="ExpandDims",dA="Fill",nV="FlipLeftRight",ug="Floor",iV="FloorDiv",fA="GatherV2",rV="Greater",hg="GreaterEqual",dg="Identity",aV="Imag",sV="LeakyRelu",pA="Less",fg="LessEqual",pg="LogicalAnd",mA="LogicalOr",yA="Max",mg="Maximum",gA="MaxPool",vA="Mean",bA="Min",yg="Minimum",gg="Multiply",_A="Neg",oV="NonMaxSuppressionV3",lV="NonMaxSuppressionV4",cV="NonMaxSuppressionV5",SA="Pack",TA="PadV2",vg="Pow",wA="Prelu",AA="Range",uV="Real",bg="Relu",EA="Reshape",hV="ResizeNearestNeighbor",MA="ResizeBilinear",_g="Relu6",dV="Round",fV="TensorScatterUpdate",pV="Select",RA="Slice",Sg="Sin",Tg="Sigmoid",wg="Sqrt",CA="Sum",mV="SplitV",nk="Square",NA="StridedSlice",Ag="Sub",Eg="Tile",IA="Transform",Df="Transpose",yV="Unpack",OA="ZerosLike",gV="Step",QS="FromPixels",DA="RotateWithOffset",_1="_FusedMatMul",S1="FusedConv2D",T1="FusedDepthwiseConv2D";function wo(...x){Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.warn(...x)}function vV(...x){Pe().getBool("IS_TEST")||Pe().getBool("PROD")||console.log(...x)}const w1=tA("kernelRegistry",()=>new Map),bV=tA("gradRegistry",()=>new Map);function ZS(x,e){const t=ik(x,e);return w1.get(t)}function n3(x){return bV.get(x)}function i3(x){const e=w1.entries(),t=[];for(;;){const{done:n,value:i}=e.next();if(n)break;const[r,a]=i,[s]=r.split("_");s===x&&t.push(a)}return t}function Je(x){const{kernelName:e,backendName:t}=x,n=ik(e,t);w1.has(n)&&wo("The kernel '"+e+"' for backend '"+t+"' is already registered"),w1.set(n,x)}function ik(x,e){return e+"_"+x}function rk(x){return x instanceof Float32Array||x instanceof Int32Array||x instanceof Uint8Array||x instanceof Uint8ClampedArray}var Dc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function _V(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,"default")?x.default:x}var ak=Tx,oa=null;try{oa=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Tx(x,e,t){this.low=x|0,this.high=e|0,this.unsigned=!!t}Tx.prototype.__isLong__,Object.defineProperty(Tx.prototype,"__isLong__",{value:!0});function Xi(x){return(x&&x.__isLong__)===!0}Tx.isLong=Xi;var r3={},a3={};function Pc(x,e){var t,n,i;return e?(x>>>=0,(i=0<=x&&x<256)&&(n=a3[x],n)?n:(t=Sx(x,(x|0)<0?-1:0,!0),i&&(a3[x]=t),t)):(x|=0,(i=-128<=x&&x<128)&&(n=r3[x],n)?n:(t=Sx(x,x<0?-1:0,!1),i&&(r3[x]=t),t))}Tx.fromInt=Pc;function pa(x,e){if(isNaN(x))return e?rc:ca;if(e){if(x<0)return rc;if(x>=sk)return ck}else{if(x<=-9223372036854776e3)return Yi;if(x+1>=TV)return lk}return x<0?pa(-x,e).neg():Sx(x%_h|0,x/_h|0,e)}Tx.fromNumber=pa;function Sx(x,e,t){return new Tx(x,e,t)}Tx.fromBits=Sx;var A1=Math.pow;function PA(x,e,t){if(x.length===0)throw Error("empty string");if(x==="NaN"||x==="Infinity"||x==="+Infinity"||x==="-Infinity")return ca;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var n;if((n=x.indexOf("-"))>0)throw Error("interior hyphen");if(n===0)return PA(x.substring(1),e,t).neg();for(var i=pa(A1(t,8)),r=ca,a=0;a<x.length;a+=8){var s=Math.min(8,x.length-a),l=parseInt(x.substring(a,a+s),t);if(s<8){var c=pa(A1(t,s));r=r.mul(c).add(pa(l))}else r=r.mul(i),r=r.add(pa(l))}return r.unsigned=e,r}Tx.fromString=PA;function Fa(x,e){return typeof x=="number"?pa(x,e):typeof x=="string"?PA(x,e):Sx(x.low,x.high,typeof e=="boolean"?e:x.unsigned)}Tx.fromValue=Fa;var s3=65536,SV=1<<24,_h=s3*s3,sk=_h*_h,TV=sk/2,o3=Pc(SV),ca=Pc(0);Tx.ZERO=ca;var rc=Pc(0,!0);Tx.UZERO=rc;var Ju=Pc(1);Tx.ONE=Ju;var ok=Pc(1,!0);Tx.UONE=ok;var JS=Pc(-1);Tx.NEG_ONE=JS;var lk=Sx(-1,2147483647,!1);Tx.MAX_VALUE=lk;var ck=Sx(-1,-1,!0);Tx.MAX_UNSIGNED_VALUE=ck;var Yi=Sx(0,-2147483648,!1);Tx.MIN_VALUE=Yi;var At=Tx.prototype;At.toInt=function(){return this.unsigned?this.low>>>0:this.low},At.toNumber=function(){return this.unsigned?(this.high>>>0)*_h+(this.low>>>0):this.high*_h+(this.low>>>0)},At.toString=function(x){if(x=x||10,x<2||36<x)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Yi)){var e=pa(x),t=this.div(e),n=t.mul(e).sub(this);return t.toString(x)+n.toInt().toString(x)}else return"-"+this.neg().toString(x);for(var i=pa(A1(x,6),this.unsigned),r=this,a="";;){var s=r.div(i),l=r.sub(s.mul(i)).toInt()>>>0,c=l.toString(x);if(r=s,r.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},At.getHighBits=function(){return this.high},At.getHighBitsUnsigned=function(){return this.high>>>0},At.getLowBits=function(){return this.low},At.getLowBitsUnsigned=function(){return this.low>>>0},At.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Yi)?64:this.neg().getNumBitsAbs();for(var x=this.high!=0?this.high:this.low,e=31;e>0&&(x&1<<e)==0;e--);return this.high!=0?e+33:e+1},At.isZero=function(){return this.high===0&&this.low===0},At.eqz=At.isZero,At.isNegative=function(){return!this.unsigned&&this.high<0},At.isPositive=function(){return this.unsigned||this.high>=0},At.isOdd=function(){return(this.low&1)===1},At.isEven=function(){return(this.low&1)===0},At.equals=function(x){return Xi(x)||(x=Fa(x)),this.unsigned!==x.unsigned&&this.high>>>31===1&&x.high>>>31===1?!1:this.high===x.high&&this.low===x.low},At.eq=At.equals,At.notEquals=function(x){return!this.eq(x)},At.neq=At.notEquals,At.ne=At.notEquals,At.lessThan=function(x){return this.comp(x)<0},At.lt=At.lessThan,At.lessThanOrEqual=function(x){return this.comp(x)<=0},At.lte=At.lessThanOrEqual,At.le=At.lessThanOrEqual,At.greaterThan=function(x){return this.comp(x)>0},At.gt=At.greaterThan,At.greaterThanOrEqual=function(x){return this.comp(x)>=0},At.gte=At.greaterThanOrEqual,At.ge=At.greaterThanOrEqual,At.compare=function(x){if(Xi(x)||(x=Fa(x)),this.eq(x))return 0;var e=this.isNegative(),t=x.isNegative();return e&&!t?-1:!e&&t?1:this.unsigned?x.high>>>0>this.high>>>0||x.high===this.high&&x.low>>>0>this.low>>>0?-1:1:this.sub(x).isNegative()?-1:1},At.comp=At.compare,At.negate=function(){return!this.unsigned&&this.eq(Yi)?Yi:this.not().add(Ju)},At.neg=At.negate,At.add=function(x){Xi(x)||(x=Fa(x));var e=this.high>>>16,t=this.high&65535,n=this.low>>>16,i=this.low&65535,r=x.high>>>16,a=x.high&65535,s=x.low>>>16,l=x.low&65535,c=0,h=0,d=0,p=0;return p+=i+l,d+=p>>>16,p&=65535,d+=n+s,h+=d>>>16,d&=65535,h+=t+a,c+=h>>>16,h&=65535,c+=e+r,c&=65535,Sx(d<<16|p,c<<16|h,this.unsigned)},At.subtract=function(x){return Xi(x)||(x=Fa(x)),this.add(x.neg())},At.sub=At.subtract,At.multiply=function(x){if(this.isZero())return ca;if(Xi(x)||(x=Fa(x)),oa){var e=oa.mul(this.low,this.high,x.low,x.high);return Sx(e,oa.get_high(),this.unsigned)}if(x.isZero())return ca;if(this.eq(Yi))return x.isOdd()?Yi:ca;if(x.eq(Yi))return this.isOdd()?Yi:ca;if(this.isNegative())return x.isNegative()?this.neg().mul(x.neg()):this.neg().mul(x).neg();if(x.isNegative())return this.mul(x.neg()).neg();if(this.lt(o3)&&x.lt(o3))return pa(this.toNumber()*x.toNumber(),this.unsigned);var t=this.high>>>16,n=this.high&65535,i=this.low>>>16,r=this.low&65535,a=x.high>>>16,s=x.high&65535,l=x.low>>>16,c=x.low&65535,h=0,d=0,p=0,m=0;return m+=r*c,p+=m>>>16,m&=65535,p+=i*c,d+=p>>>16,p&=65535,p+=r*l,d+=p>>>16,p&=65535,d+=n*c,h+=d>>>16,d&=65535,d+=i*l,h+=d>>>16,d&=65535,d+=r*s,h+=d>>>16,d&=65535,h+=t*c+n*l+i*s+r*a,h&=65535,Sx(p<<16|m,h<<16|d,this.unsigned)},At.mul=At.multiply,At.divide=function(x){if(Xi(x)||(x=Fa(x)),x.isZero())throw Error("division by zero");if(oa){if(!this.unsigned&&this.high===-2147483648&&x.low===-1&&x.high===-1)return this;var e=(this.unsigned?oa.div_u:oa.div_s)(this.low,this.high,x.low,x.high);return Sx(e,oa.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?rc:ca;var t,n,i;if(this.unsigned){if(x.unsigned||(x=x.toUnsigned()),x.gt(this))return rc;if(x.gt(this.shru(1)))return ok;i=rc}else{if(this.eq(Yi)){if(x.eq(Ju)||x.eq(JS))return Yi;if(x.eq(Yi))return Ju;var r=this.shr(1);return t=r.div(x).shl(1),t.eq(ca)?x.isNegative()?Ju:JS:(n=this.sub(x.mul(t)),i=t.add(n.div(x)),i)}else if(x.eq(Yi))return this.unsigned?rc:ca;if(this.isNegative())return x.isNegative()?this.neg().div(x.neg()):this.neg().div(x).neg();if(x.isNegative())return this.div(x.neg()).neg();i=ca}for(n=this;n.gte(x);){t=Math.max(1,Math.floor(n.toNumber()/x.toNumber()));for(var a=Math.ceil(Math.log(t)/Math.LN2),s=a<=48?1:A1(2,a-48),l=pa(t),c=l.mul(x);c.isNegative()||c.gt(n);)t-=s,l=pa(t,this.unsigned),c=l.mul(x);l.isZero()&&(l=Ju),i=i.add(l),n=n.sub(c)}return i},At.div=At.divide,At.modulo=function(x){if(Xi(x)||(x=Fa(x)),oa){var e=(this.unsigned?oa.rem_u:oa.rem_s)(this.low,this.high,x.low,x.high);return Sx(e,oa.get_high(),this.unsigned)}return this.sub(this.div(x).mul(x))},At.mod=At.modulo,At.rem=At.modulo,At.not=function(){return Sx(~this.low,~this.high,this.unsigned)},At.and=function(x){return Xi(x)||(x=Fa(x)),Sx(this.low&x.low,this.high&x.high,this.unsigned)},At.or=function(x){return Xi(x)||(x=Fa(x)),Sx(this.low|x.low,this.high|x.high,this.unsigned)},At.xor=function(x){return Xi(x)||(x=Fa(x)),Sx(this.low^x.low,this.high^x.high,this.unsigned)},At.shiftLeft=function(x){return Xi(x)&&(x=x.toInt()),(x&=63)===0?this:x<32?Sx(this.low<<x,this.high<<x|this.low>>>32-x,this.unsigned):Sx(0,this.low<<x-32,this.unsigned)},At.shl=At.shiftLeft,At.shiftRight=function(x){return Xi(x)&&(x=x.toInt()),(x&=63)===0?this:x<32?Sx(this.low>>>x|this.high<<32-x,this.high>>x,this.unsigned):Sx(this.high>>x-32,this.high>=0?0:-1,this.unsigned)},At.shr=At.shiftRight,At.shiftRightUnsigned=function(x){if(Xi(x)&&(x=x.toInt()),x&=63,x===0)return this;var e=this.high;if(x<32){var t=this.low;return Sx(t>>>x|e<<32-x,e>>>x,this.unsigned)}else return x===32?Sx(e,0,this.unsigned):Sx(e>>>x-32,0,this.unsigned)},At.shru=At.shiftRightUnsigned,At.shr_u=At.shiftRightUnsigned,At.toSigned=function(){return this.unsigned?Sx(this.low,this.high,!1):this},At.toUnsigned=function(){return this.unsigned?this:Sx(this.low,this.high,!0)},At.toBytes=function(x){return x?this.toBytesLE():this.toBytesBE()},At.toBytesLE=function(){var x=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,x&255,x>>>8&255,x>>>16&255,x>>>24]},At.toBytesBE=function(){var x=this.high,e=this.low;return[x>>>24,x>>>16&255,x>>>8&255,x&255,e>>>24,e>>>16&255,e>>>8&255,e&255]},Tx.fromBytes=function(x,e,t){return t?Tx.fromBytesLE(x,e):Tx.fromBytesBE(x,e)},Tx.fromBytesLE=function(x,e){return new Tx(x[0]|x[1]<<8|x[2]<<16|x[3]<<24,x[4]|x[5]<<8|x[6]<<16|x[7]<<24,e)},Tx.fromBytesBE=function(x,e){return new Tx(x[4]<<24|x[5]<<16|x[6]<<8|x[7],x[0]<<24|x[1]<<16|x[2]<<8|x[3],e)};var uk=_V(ak),wV=P5({__proto__:null,default:uk},[ak]);const ec=uk||wV;function Mg(x){return ec.fromString(x,!0,16)}const hk=Mg("c3a5c85c97cb3127"),Jl=Mg("b492b66fbe98f273"),ci=Mg("9ae16a3b2f90404f");function jS(x){return x.xor(x.shru(47))}function dk(x,e,t){const n=x.slice(e,e+t);return ec.fromBytes(Array.from(n),!0,!0)}function mx(x,e){return dk(x,e,8)}function l3(x,e){return dk(x,e,4)}function Rn(x,e){return e===0?x:x.shru(e).or(x.shl(64-e))}function W2(x,e,t=Mg("9ddfea08eb382d69")){let n=x.xor(e).mul(t);n=n.xor(n.shru(47));let i=e.xor(n).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function AV(x,e,t,n,i,r){i=i.add(x),r=Rn(r.add(i).add(n),21);const a=i;return i=i.add(e),i=i.add(t),r=r.add(Rn(i,44)),[i.add(n),r.add(a)]}function Um(x,e,t,n){return AV(mx(x,e),mx(x,e+8),mx(x,e+16),mx(x,e+24),t,n)}function EV(x,e=x.length){if(e>=8){const t=ci.add(e*2),n=mx(x,0).add(ci),i=mx(x,e-8),r=Rn(i,37).mul(t).add(n),a=Rn(n,25).add(i).mul(t);return W2(r,a,t)}if(e>=4){const t=ci.add(e*2),n=l3(x,0);return W2(n.shl(3).add(e),l3(x,e-4),t)}if(e>0){const t=x[0],n=x[e>>1],i=x[e-1],r=t+(n<<8),a=e+(i<<2);return jS(ci.mul(r).xor(hk.mul(a))).mul(ci)}return ci}function MV(x,e=x.length){const t=ci.add(e*2),n=mx(x,0).mul(Jl),i=mx(x,8),r=mx(x,e-8).mul(t),a=mx(x,e-16).mul(ci);return W2(Rn(n.add(i),43).add(Rn(r,30)).add(a),n.add(Rn(i.add(ci),18)).add(r),t)}function RV(x,e=x.length){const t=ci.add(e*2),n=mx(x,0).mul(ci),i=mx(x,8),r=mx(x,e-8).mul(t),a=mx(x,e-16).mul(ci),s=Rn(n.add(i),43).add(Rn(r,30)).add(a),l=W2(s,n.add(Rn(i.add(ci),18)).add(r),t),c=mx(x,16).mul(t),h=mx(x,24),d=s.add(mx(x,e-32)).mul(t),p=l.add(mx(x,e-24)).mul(t);return W2(Rn(c.add(h),43).add(Rn(d,30)).add(p),c.add(Rn(h.add(n),18)).add(d),t)}function CV(x,e=x.length){const t=ec.fromNumber(81,!0);if(e<=32)return e<=16?EV(x,e):MV(x,e);if(e<=64)return RV(x,e);let n=t,i=t.mul(Jl).add(113),r=jS(i.mul(ci).add(113)).mul(ci),a=[ec.UZERO,ec.UZERO],s=[ec.UZERO,ec.UZERO];n=n.mul(ci).add(mx(x,0));let l=0;const c=(e-1>>6)*64,h=c+(e-1&63)-63;do n=Rn(n.add(i).add(a[0]).add(mx(x,l+8)),37).mul(Jl),i=Rn(i.add(a[1]).add(mx(x,l+48)),42).mul(Jl),n=n.xor(s[1]),i=i.add(a[0]).add(mx(x,l+40)),r=Rn(r.add(s[0]),33).mul(Jl),a=Um(x,l,a[1].mul(Jl),n.add(s[0])),s=Um(x,l+32,r.add(s[1]),i.add(mx(x,l+16))),[r,n]=[n,r],l+=64;while(l!==c);const d=Jl.add(r.and(255).shl(1));return l=h,s[0]=s[0].add(e-1&63),a[0]=a[0].add(s[0]),s[0]=s[0].add(a[0]),n=Rn(n.add(i).add(a[0]).add(mx(x,l+8)),37).mul(d),i=Rn(i.add(a[1]).add(mx(x,l+48)),42).mul(d),n=n.xor(s[1].mul(9)),i=i.add(a[0].mul(9).add(mx(x,l+40))),r=Rn(r.add(s[0]),33).mul(d),a=Um(x,l,a[1].mul(d),n.add(s[0])),s=Um(x,l+32,r.add(s[1]),i.add(mx(x,l+16))),[r,n]=[n,r],W2(W2(a[0],s[0],d).add(jS(i).mul(hk)).add(r),W2(a[1],s[1],d).add(n),d)}function dp(x,e){return e==="string"?X2(x):Rg([x],e)}function NV(x,e){return x instanceof Float32Array&&e==="float32"||x instanceof Int32Array&&e==="int32"||x instanceof Uint8Array&&e==="bool"}function Rg(x,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(x)&&(x=gc(x)),Pe().getBool("DEBUG")&&B5(x,e),NV(x,e))return x;if(e==null||e==="float32"||e==="complex64")return new Float32Array(x);if(e==="int32")return new Int32Array(x);if(e==="bool"){const t=new Uint8Array(x.length);for(let n=0;n<t.length;++n)Math.round(x[n])!==0&&(t[n]=1);return t}else throw new Error("Unknown data type "+e)}function Ar(){return Pe().platform.now()}function X2(x,e="utf-8"){return e=e||"utf-8",Pe().platform.encode(x,e)}function Sh(x,e="utf-8"){return e=e||"utf-8",Pe().platform.decode(x,e)}function ba(x){return Pe().platform.isTypedArray!=null?Pe().platform.isTypedArray(x):rk(x)}function gc(x,e=[],t=!1){if(e==null&&(e=[]),typeof x=="boolean"||typeof x=="number"||typeof x=="string"||yc(x)||x==null||ba(x)&&t)e.push(x);else if(Array.isArray(x)||ba(x))for(let n=0;n<x.length;++n)gc(x[n],e,t);else{let n=-1;for(const i of Object.keys(x))/^([1-9]+[0-9]*|0)$/.test(i)&&(n=Math.max(n,Number(i)));for(let i=0;i<=n;i++)gc(x[i],e,t)}return e}class IV{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new DV)}profileKernel(e,t,n){let i;const r=()=>{i=n()};let a;const s=Ar();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(r);else{r();for(const l of i)l.dataSync();a=Promise.resolve({kernelMs:Ar()-s})}if(Pe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<i.length;l++){const c=i[l];c.data().then(h=>{OV(h,c.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:i,inputs:r,extraInfo:a}=e;n.forEach(s=>{Promise.all([s.data(),i,a]).then(l=>{this.logger.logKernelProfile(t,s,l[0],l[1],r,l[2])})})}}function OV(x,e,t){if(e!=="float32")return!1;for(let n=0;n<x.length;n++){const i=x[n];if(isNaN(i)||!isFinite(i))return console.warn("Found "+i+" in the result of '"+t+"'"),!0}return!1}class DV{logKernelProfile(e,t,n,i,r,a){const s=typeof i=="number"?rh(i+"ms",9):i.error,l=rh(e,25),c=t.rank,h=t.size,d=rh(t.shape.toString(),14);let p="";for(const m in r){const g=r[m];if(g!=null){const _=g.shape||t.shape,v=_.length;p+=m+": "+v+"D "+(v>0?_:"")+" "}}console.log("%c"+l+"	%c"+s+"	%c"+c+"D "+d+"	%c"+h+"	%c"+p+"	%c"+a,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function PV(x,e,t){const n={},i={};for(let l=0;l<e.length;l++)n[e[l].id]=!0;for(let l=0;l<x.length;l++){const c=x[l],h=c.inputs;for(const d in h){const p=h[d];let m=!1;for(let g=0;g<e.length;g++)if(n[p.id]){c.outputs.forEach(_=>n[_.id]=!0),m=!0,i[c.id]=!0;break}if(m)break}}const r={};r[t.id]=!0;const a={};for(let l=x.length-1;l>=0;l--){const c=x[l],h=c.inputs;for(let d=0;d<c.outputs.length;d++)if(r[c.outputs[d].id]){for(const p in h)r[h[p].id]=!0,a[c.id]=!0;break}}const s=[];for(let l=0;l<x.length;l++){const c=x[l];if(i[c.id]&&a[c.id]){const h={};for(const p in c.inputs){const m=c.inputs[p];n[m.id]&&(h[p]=m)}const d=Object.assign({},c);d.inputs=h,d.outputs=c.outputs,s.push(d)}}return s}function kV(x,e,t,n){for(let i=e.length-1;i>=0;i--){const r=e[i],a=[];if(r.outputs.forEach(l=>{const c=x[l.id];c!=null?a.push(c):a.push(null)}),r.gradient==null)throw new Error("Cannot compute gradient: gradient function not found for "+r.kernelName+".");const s=r.gradient(a);for(const l in r.inputs){if(!(l in s))throw new Error("Cannot backprop through input "+l+". Available gradients found: "+Object.keys(s)+".");const c=t(()=>s[l]());if(c.dtype!=="float32")throw new Error("Error in gradient for op "+r.kernelName+". The gradient of input "+l+" must have 'float32' dtype, but has '"+c.dtype+"'");const h=r.inputs[l];if(!Zx(c.shape,h.shape))throw new Error("Error in gradient for op "+r.kernelName+". The gradient of input '"+l+"' has shape '"+c.shape+"', which does not match the shape of the input '"+h.shape+"'");if(x[h.id]==null)x[h.id]=c;else{const d=x[h.id];x[h.id]=n(d,c),d.dispose()}}}}const c3=20,rf=3,d_=7;function UV(x,e,t,n){const i=M0(e),r=FV(x,e,t,i),a=e.length,s=Jy(x,e,t,i,r),l=["Tensor"];return n&&(l.push("  dtype: "+t),l.push("  rank: "+a),l.push("  shape: ["+e+"]"),l.push("  values:")),l.push(s.map(c=>"    "+c).join(`
`)),l.join(`
`)}function FV(x,e,t,n){const i=ut(e),r=n[n.length-1],a=new Array(r).fill(0),s=e.length,l=t==="complex64"?Ef(x):x;if(s>1)for(let c=0;c<i/r;c++){const h=c*r;for(let d=0;d<r;d++)a[d]=Math.max(a[d],Af(l[h+d],0,t).length)}return a}function Af(x,e,t){let n;return Array.isArray(x)?n=parseFloat(x[0].toFixed(d_))+" + "+parseFloat(x[1].toFixed(d_))+"j":cp(x)?n="'"+x+"'":t==="bool"?n=fk(x):n=parseFloat(x.toFixed(d_)).toString(),rh(n,e)}function fk(x){return x===0?"false":"true"}function Jy(x,e,t,n,i,r=!0){const a=t==="complex64"?2:1,s=e[0],l=e.length;if(l===0){if(t==="complex64"){const _=Ef(x);return[Af(_[0],0,t)]}return t==="bool"?[fk(x[0])]:[x[0].toString()]}if(l===1){if(s>c3){const _=rf*a;let v=Array.from(x.slice(0,_)),b=Array.from(x.slice((s-rf)*a,s*a));return t==="complex64"&&(v=Ef(v),b=Ef(b)),["["+v.map((T,E)=>Af(T,i[E],t)).join(", ")+", ..., "+b.map((T,E)=>Af(T,i[s-rf+E],t)).join(", ")+"]"]}return["["+(t==="complex64"?Ef(x):Array.from(x)).map((_,v)=>Af(_,i[v],t)).join(", ")+"]"]}const c=e.slice(1),h=n.slice(1),d=n[0]*a,p=[];if(s>c3){for(let _=0;_<rf;_++){const v=_*d,b=v+d;p.push(...Jy(x.slice(v,b),c,t,h,i,!1))}p.push("...");for(let _=s-rf;_<s;_++){const v=_*d,b=v+d;p.push(...Jy(x.slice(v,b),c,t,h,i,_===s-1))}}else for(let _=0;_<s;_++){const v=_*d,b=v+d;p.push(...Jy(x.slice(v,b),c,t,h,i,_===s-1))}const m=l===2?",":"";p[0]="["+(s>0?p[0]+m:"");for(let _=1;_<p.length-1;_++)p[_]=" "+p[_]+m;let g=`,
`;for(let _=2;_<l;_++)g+=`
`;return p[p.length-1]=" "+p[p.length-1]+"]"+(r?"":g),p}function Ef(x){const e=[];for(let t=0;t<x.length;t+=2)e.push([x[t],x[t+1]]);return e}class vc{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ut(e),n!=null){const i=n.length;ye(i===this.size,()=>"Length of values '"+i+"' does not match the size inferred by the shape '"+this.size+"'.")}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||fn(t,this.size),this.strides=M0(e)}set(e,...t){t.length===0&&(t=[0]),ye(t.length===this.rank,()=>"The number of provided coordinates ("+t.length+") must match the rank ("+this.rank+")");const n=this.locToIndex(t);this.values[n]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const r="Requested out of range element at "+e+".   Buffer shape="+this.shape;throw new Error(r)}t++}let n=e[e.length-1];for(let i=0;i<e.length-1;++i)n+=this.strides[i]*e[i];return this.values[n]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return za().makeTensor(this.values,this.shape,this.dtype)}}let za=null,ju=null;function BV(x){za=x}function LV(x){ju=x}class Mr{constructor(e,t,n,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ut(e),this.strides=M0(e),this.dataId=n,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return ju.buffer(this.shape,this.dtype,e)}bufferSync(){return ju.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return $S(this.shape,e,this.dtype==="complex64")}arraySync(){return $S(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=za().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(n=>Sh(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),za().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=za().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Sh(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await za().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),za().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return ju.print(this,e)}clone(){return this.throwIfDisposed(),ju.clone(this)}toString(e=!1){const t=this.dataSync();return UV(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),ju.cast(this,e)}variable(e=!0,t,n){return this.throwIfDisposed(),za().makeVariable(this,e,t,n)}}Object.defineProperty(Mr,Symbol.hasInstance,{value:x=>!!x&&x.data!=null&&x.dataSync!=null&&x.throwIfDisposed!=null});function pk(){return tA("Tensor",()=>Mr)}pk();class qS extends Mr{constructor(e,t,n,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value ("+e.dtype+") and previous value ("+this.dtype+") must match");if(!Zx(e.shape,this.shape))throw new Error("shape of the new value ("+e.shape+") and previous value ("+this.shape+") must match");za().disposeTensor(this),this.dataId=e.dataId,za().incRef(this,null)}dispose(){za().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(qS,Symbol.hasInstance,{value:x=>x instanceof Mr&&x.assign!=null&&x.assign instanceof Function});var u3;(function(x){x.R0="R0",x.R1="R1",x.R2="R2",x.R3="R3",x.R4="R4",x.R5="R5",x.R6="R6"})(u3||(u3={}));var eT;(function(x){x.float32="float32",x.int32="int32",x.bool="int32",x.complex64="complex64"})(eT||(eT={}));var tT;(function(x){x.float32="float32",x.int32="int32",x.bool="bool",x.complex64="complex64"})(tT||(tT={}));var xT;(function(x){x.float32="float32",x.int32="float32",x.bool="float32",x.complex64="complex64"})(xT||(xT={}));var nT;(function(x){x.float32="complex64",x.int32="complex64",x.bool="complex64",x.complex64="complex64"})(nT||(nT={}));const zV={float32:xT,int32:eT,bool:tT,complex64:nT};function Rs(x,e){if(x==="string"||e==="string"){if(x==="string"&&e==="string")return"string";throw new Error("Can not upcast "+x+" with "+e)}return zV[x][e]}function VV(x){return Rs(x,"int32")}function mk(x){return x!=null&&typeof x=="object"&&"texture"in x&&x.texture instanceof WebGLTexture}function yk(x){return typeof GPUBuffer<"u"&&x!=null&&typeof x=="object"&&"buffer"in x&&x.buffer instanceof GPUBuffer}function jn(x,e){if(x.dtype===e.dtype)return[x,e];const t=Rs(x.dtype,e.dtype);return[x.cast(t),e.cast(t)]}function gk(x){const e=[];return vk(x,e,new Set),e}function vk(x,e,t){if(x==null)return;if(x instanceof Mr){e.push(x);return}if(!HV(x))return;const n=x;for(const i in n){const r=n[i];t.has(r)||(t.add(r),vk(r,e,t))}}function HV(x){return Array.isArray(x)||typeof x=="object"}function f_(x){return x.kernelName!=null}class h3{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Th{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new h3}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error("Backend '"+this.backendName+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '"+e+"' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,n=1){return e in this.registryFactory?(wo(e+" backend was already registered. Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error("Backend name '"+e+"' not found in registry");if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new IV(this.backendInstance),!0}setupRegisteredKernels(){i3(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){i3(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error("Cannot initialize backend "+e+", no registration found.");try{const n=t.factory();if(n&&!(n instanceof Jw)&&typeof n.then=="function"){const i=++this.pendingBackendInitId,r=n.then(a=>i<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,wo("Initialization of backend "+e+" failed"),wo(a.stack||a.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[e]=n,{success:!0,asyncInit:!1}}catch(n){return wo("Initialization of backend "+e+" failed"),wo(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(e+" backend not found in registry");this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:i,asyncInit:r}=this.initializeBackend(n);if(r||i)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),i=n.backend,r=this.readSync(t),a=i.refCount(t);i.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=e}let i;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,n){e();try{const i=n();return t(),i}catch(i){throw t(),i}}nextTensorId(){return Th.nextTensorId++}nextVariableId(){return Th.nextVariableId++}clone(e){const t=it.runKernel(dg,{x:e}),n={x:e},i=a=>({x:()=>{const s="float32",l={x:a},c={dtype:s};return it.runKernel(sg,l,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,n,[t],i,r,{}),t}runKernel(e,t,n){if(this.backendName==null&&this.backend,ZS(e,this.backendName)==null)throw new Error("Kernel '"+e+"' not registered for backend '"+this.backendName+"'");return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const i=this.backend.numDataIds();let r=0;n.forEach(l=>{r+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],s=i-t-r-a;if(s>0)throw new Error("Backend '"+this.backendName+"' has an internal memory leak ("+s+" data ids) after running '"+e+"'")}runKernelFunc(e){let t,n=[];const i=this.isTapeOn(),r=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let s;this.backendName==null&&this.backend;let l;const c=f_(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(f_(e)){const{kernelName:g,inputs:_,attrs:v}=e;this.backendName==null&&this.backend;const b=ZS(g,this.backendName);ye(b!=null,()=>"Cannot find registered kernel '"+g+"' for backend '"+this.backendName+"'"),s=()=>{const T=this.backend.numDataIds();l=b.kernelFunc({inputs:_,attrs:v,backend:this.backend});const E=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(g,T,E);const A=E.map(M=>M.rank!=null?M:this.makeTensorFromTensorInfo(M));if(i){const M=this.getTensorsForGradient(g,_,A);n=this.saveTensorsForBackwardMode(M)}return A}}else{const{forwardFunc:g}=e,_=v=>{i&&(n=v.map(b=>this.keep(this.clone(b))))};s=()=>{const v=this.backend.numDataIds();l=this.tidy(()=>g(this.backend,_));const b=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,v,b),b}}const{inputs:h,attrs:d}=e,p=f_(e)?null:e.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=s():(m=this.profiler.profileKernel(c,h,()=>s()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),t=m.outputs)}),i&&this.addTapeNode(c,h,t,p,n,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(g=>h[g]!=null?h[g].shape:null),outputShapes:t.map(g=>g.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(e,t,n){const i=n3(e);if(i!=null){const r=i.inputsToSave||[],a=i.outputsToSave||[];let s;i.saveAllInputs?(ye(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),s=Object.keys(t).map(c=>t[c])):s=r.map(c=>t[c]);const l=n.filter((c,h)=>a[h]);return s.concat(l)}return[]}makeTensor(e,t,n,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",i=i||this.backend;let r=e;n==="string"&&cp(e[0])&&(r=e.map(l=>X2(l)));const a=i.write(r,t,n),s=new Mr(t,n,a,this.nextTensorId());if(this.trackTensor(s,i),n==="string"){const l=this.state.tensorInfo.get(a),c=z5(r);this.state.numBytes+=c-l.bytes,l.bytes=c}return s}makeTensorFromDataId(e,t,n,i){n=n||"float32";const r={dataId:e,shape:t,dtype:n};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:i,dtype:r}=e,a=new Mr(i,r,n,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,n,i){n=n||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const r=new qS(e,t,n,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error("Variable with name "+r.name+" was already registered");return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let n=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(n=e.size*b1(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof qS||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const n=e.size*b1(e.dtype);this.state.numBytes-=n}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,n,i,r,a){const s={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},l=n3(e);l!=null&&(i=l.gradFunc),i!=null&&(s.gradient=c=>(c=c.map((h,d)=>{if(h==null){const p=n[d],m=Ms(p.size,p.dtype);return this.makeTensor(m,p.shape,p.dtype)}return h}),i(c.length>1?c:c[0],r,a))),this.state.activeTape.push(s)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=gk(e),n=new Set(t.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const a=this.state.activeScope.track[r];!a.kept&&!n.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(e,t,n,i=!1){if(ye(t.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error("dy must have 'float32' dtype, but has '"+n.dtype+"'");const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));ye(r instanceof Mr,()=>"The result y returned by f() must be a tensor.");const a=PV(this.state.activeTape,t,r);if(!i&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const s={};s[r.id]=n??GV(r.shape),kV(s,a,c=>this.tidy(c),WV);const l=t.map(c=>s[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const h of c.saved)h.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(e){return ye(t3(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{ye(t.every(s=>s instanceof Mr),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n;const i={};t.forEach((s,l)=>{i[l]=s});const r=(s,l)=>(n=e(...t,l),ye(n.value instanceof Mr,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),ye(t3(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(s,l)=>{const c=n.gradFunc(s,l),h=Array.isArray(c)?c:[c];ye(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),ye(h.every(p=>p instanceof Mr),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return h.forEach((p,m)=>{d[m]=()=>p}),d};return this.runKernelFunc({forwardFunc:r,backwardsFunc:a,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Ar(),n=await this.backend.time(e);return n.wallMs=Ar()-t,n}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new h3;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Th.nextTensorId=0,Th.nextVariableId=0;function GV(x){const e=qP(ut(x),"float32");return it.makeTensor(e,x,"float32")}function bk(){const x=tk();if(x._tfengine==null){const e=new W5(x);x._tfengine=new Th(e)}return $5(x._tfengine.ENV),BV(()=>x._tfengine),x._tfengine}const it=bk();function WV(x,e){const t={a:x,b:e};return it.runKernel(hp,t)}function XV(){return typeof navigator<"u"&&navigator!=null}function d3(x){if(x||XV()){if(x||(x=navigator),x.product==="ReactNative")return!0;const e=x.userAgent||x.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=x;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function _k(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const Ti=Pe();Ti.registerFlag("DEBUG",()=>!1,x=>{x&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")}),Ti.registerFlag("IS_BROWSER",()=>_k()),Ti.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u"),Ti.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor)),Ti.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor)),Ti.registerFlag("PROD",()=>!1),Ti.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ti.getBool("DEBUG")),Ti.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0),Ti.registerFlag("IS_TEST",()=>!1),Ti.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Ti.getBool("DEBUG")),Ti.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1),Ti.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1),Ti.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function fp(x,e){let t=x;if(ba(x))return e==="string"?[]:[x.length];if(mk(x)){const i=x.channels||"RGBA";return[x.height,x.width*i.length]}else if(yk(x))return[x.buffer.size/(e==null?4:b1(e))];if(!Array.isArray(x))return[];const n=[];for(;Array.isArray(t)||ba(t)&&e!=="string";)n.push(t.length),t=t[0];return Array.isArray(x)&&Pe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Sk(x,n,[]),n}function Sk(x,e,t){if(t=t||[],!Array.isArray(x)&&!ba(x)){ye(e.length===0,()=>"Element arr["+t.join("][")+"] is a primitive, but should be an array/TypedArray of "+e[0]+" elements");return}ye(e.length>0,()=>"Element arr["+t.join("][")+"] should be a primitive, but is an array of "+x.length+" elements"),ye(x.length===e[0],()=>"Element arr["+t.join("][")+"] should have "+e[0]+" elements, but has "+x.length+" elements");const n=e.slice(1);for(let i=0;i<x.length;++i)Sk(x[i],n,t.concat(i))}function f3(x,e,t,n){if(x!=="string_or_numeric"){if(x==null)throw new Error("Expected dtype cannot be null.");if(x!=="numeric"&&x!==e||x==="numeric"&&e==="string")throw new Error("Argument '"+t+"' passed to '"+n+"' must be "+x+" tensor, but got "+e+" tensor")}}function We(x,e,t,n="numeric"){if(x instanceof pk())return f3(n,x.dtype,e,t),x;let i=Qh(x);if(i!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(i=n),f3(n,i,e,t),x==null||!ba(x)&&!Array.isArray(x)&&typeof x!="number"&&typeof x!="boolean"&&typeof x!="string"){const s=x==null?"null":x.constructor.name;throw new Error("Argument '"+e+"' passed to '"+t+"' must be a Tensor or TensorLike, but got '"+s+"'")}const r=fp(x,i);!ba(x)&&!Array.isArray(x)&&(x=[x]);const a=i!=="string"?Rg(x,i):gc(x,[],!0);return it.makeTensor(a,r,i)}function Tk(x,e,t,n="numeric"){if(!Array.isArray(x))throw new Error("Argument "+e+" passed to "+t+" must be a `Tensor[]` or `TensorLike[]`");return x.map((i,r)=>We(i,e+"["+r+"]",t,n))}const YV="__op";function mt(x){const e=Object.keys(x);if(e.length!==1)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+e.length+" keys.");let t=e[0];const n=x[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+YV;const i=(...r)=>{it.startScope(t);try{const a=n(...r);return yc(a)&&console.error("Cannot return a Promise inside of tidy."),it.endScope(a),a}catch(a){throw it.endScope(null),a}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}function KV(x,e){const t=We(x,"real","complex"),n=We(e,"imag","complex");qw(t.shape,n.shape,"real and imag shapes, "+t.shape+" and "+n.shape+", must match in call to tf.complex().");const i={real:t,imag:n};return it.runKernel(J5,i)}const Cg=mt({complex_:KV});function pp(x,e,t,n){if(n==null)n=Qh(x);else if(n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(yk(x)||mk(x)){if(n!=="float32"&&n!=="int32")throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is "+n+".");return it.backend.createTensorFromGPUData(x,e||t,n)}if(!ba(x)&&!Array.isArray(x)&&typeof x!="number"&&typeof x!="boolean"&&typeof x!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Zh(e);const i=ut(e),r=ut(t);ye(i===r,()=>"Based on the provided shape, ["+e+"], the tensor should have "+i+" values but has "+r);for(let a=0;a<t.length;++a){const s=t[a],l=a===t.length-1?s!==ut(e.slice(a)):!0;ye(t[a]===e[a]||!l,()=>"Error creating a new Tensor. Inferred shape ("+t+") does not match the provided shape ("+e+"). ")}}return!ba(x)&&!Array.isArray(x)&&(x=[x]),e=e||t,x=n!=="string"?Rg(x,n):gc(x,[],!0),it.makeTensor(x,e,n)}function Y2(x,e,t){const n=fp(x,t);return pp(x,e,n,t)}const bc={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class ja{static join(e){return new ja(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(n=>ba(n)?n.buffer:n),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const i=e[n];n!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+i.byteLength;this.shards.push({buffer:i,start:t,end:r}),t=r}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(n===-1)throw new Error("Could not find start shard for byte "+e);const i=t-e,r=new ArrayBuffer(i),a=new Uint8Array(r);let s=0;for(let l=n;l<this.shards.length;l++){const c=this.shards[l],h=e+s-c.start,d=s,p=Math.min(t,c.end)-c.start,m=new Uint8Array(c.buffer,h,p-h);if(a.set(m,d),s+=m.length,t<c.end)break}return r}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const n=$V(this.shards,t);return n===-1?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function $V(x,e){let t=0,n=x.length;for(;t<=n;){const i=Math.floor((n-t)/2)+t,r=e(x[i]);if(r===0)return i;r<0?n=i:t=i+1}return-1}function QV(){Pe().set("PROD",!0)}function ua(){return it}function hi(x,e){return it.tidy(x,e)}function ZV(x){gk(x).forEach(e=>e.dispose())}function Co(x){return it.keep(x)}function JV(x){return it.setBackend(x)}function wk(){return it.backendName}function Ak(x,e,t=1){return it.registerBackend(x,e,t)}function kA(){return it.backend}const j2=4;async function jV(x,e){const t=[],n=[],i=Array.isArray(x)?x.map(a=>a.name):Object.keys(x);for(let a=0;a<i.length;++a){const s=i[a],l=Array.isArray(x)?x[a].tensor:x[s];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error("Unsupported dtype in weight '"+s+"': "+l.dtype);const c={name:s,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const h=new Promise(async d=>{const p=await l.bytes(),m=p.reduce((v,b)=>v+b.length,0)+j2*p.length,g=new Uint8Array(m);let _=0;for(let v=0;v<p.length;v++){const b=p[v],T=new Uint8Array(new Uint32Array([b.length]).buffer);g.set(T,_),_+=j2,g.set(b,_),_+=b.length}d(g)});n.push(h)}else n.push(l.data());e!=null&&(c.group=e),t.push(c)}const r=await Promise.all(n);return{data:t6(r),specs:t}}function Ek(x,e){const t=new ja(x),n={};let i=0;for(const r of e){const a=qV(r,(s,l)=>t.slice(i+s,i+l));n[r.name]=Mk(r,t.slice(i,i+a)),i+=a}return n}function qV(x,e){const t=ut(x.shape);let n;if("quantization"in x){const i=x.quantization;n=bc[i.dtype]}else if(x.dtype==="string"){let i=0;for(let r=0;r<t;r++)i+=j2+new Uint32Array(e(i,i+j2))[0];return i}else n=bc[x.dtype];return t*n}async function e6(x,e){const t=ut(x.shape);let n;if("quantization"in x){const i=x.quantization;n=bc[i.dtype]}else if(x.dtype==="string"){let i=0;for(let r=0;r<t;r++)i+=j2+new Uint32Array(await e(i,i+j2))[0];return i}else n=bc[x.dtype];return t*n}function Mk(x,e){const t=x.name,n=x.dtype,i=x.shape,r=ut(i);let a,s=0;if("quantization"in x){const l=x.quantization;if(l.dtype==="uint8"||l.dtype==="uint16"){if(!("min"in l&&"scale"in l))throw new Error("Weight "+x.name+" with quantization "+l.dtype+" doesn't have corresponding metadata min and scale.")}else if(l.dtype==="float16"){if(n!=="float32")throw new Error("Weight "+x.name+" is quantized with "+l.dtype+" which only supports weights of type float32 not "+n+".")}else throw new Error("Weight "+x.name+" has unknown quantization dtype "+l.dtype+". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");const c=bc[l.dtype],h=l.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(n==="float32")if(l.dtype==="uint8"||l.dtype==="uint16"){a=new Float32Array(h.length);for(let d=0;d<h.length;d++){const p=h[d];a[d]=p*l.scale+l.min}}else if(l.dtype==="float16")a=o6()(h);else throw new Error("Unsupported quantization type "+l.dtype+" for weight type float32.");else if(n==="int32"){if(l.dtype!=="uint8"&&l.dtype!=="uint16")throw new Error("Unsupported quantization type "+l.dtype+" for weight type int32.");a=new Int32Array(h.length);for(let d=0;d<h.length;d++){const p=h[d];a[d]=Math.round(p*l.scale+l.min)}}else throw new Error("Unsupported dtype in weight '"+t+"': "+n);s+=r*c}else if(n==="string"){const l=ut(x.shape);a=[];for(let c=0;c<l;c++){const h=new Uint32Array(e.slice(s,s+j2))[0];s+=j2;const d=new Uint8Array(e.slice(s,s+h));a.push(d),s+=h}}else{const l=bc[n];if(n==="float32")a=new Float32Array(e);else if(n==="int32")a=new Int32Array(e);else if(n==="bool")a=new Uint8Array(e);else if(n==="complex64"){a=new Float32Array(e);const c=new Float32Array(a.length/2),h=new Float32Array(a.length/2);for(let g=0;g<c.length;g++)c[g]=a[g*2],h[g]=a[g*2+1];const d=Y2(c,i,"float32"),p=Y2(h,i,"float32"),m=Cg(d,p);return d.dispose(),p.dispose(),m}else throw new Error("Unsupported dtype in weight '"+t+"': "+n);s+=r*l}return Y2(a,i,n)}async function p3(x,e,t){let n=new Uint8Array(e);for(;n.byteLength<t;){const{done:i,value:r}=await x.read();if(i&&r==null){const s=t-n.byteLength;throw new Error("Reader is done but "+s+" bytes are still expected")}const a=new Uint8Array(n.length+r.byteLength);a.set(n,0),a.set(new Uint8Array(r),n.length),n=a}return n.buffer}async function Rk(x,e){const t={},n=x.getReader();let i=new ArrayBuffer(0);for(const r of e){const a=await e6(r,async(c,h)=>(i=await p3(n,i,h),i.slice(c,h)));i=await p3(n,i,a);const s=i.slice(0,a);i=i.slice(a);const l=Mk(r,s);if(t[r.name]=l,wk()==="webgpu"){const c=kA();"uploadToGPU"in c&&ut(l.shape)>=Pe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&c.uploadToGPU(l.dataId)}}return t}function t6(x){if(x===null)throw new Error("Invalid input value: "+JSON.stringify(x));let e=0;const t=[];x.forEach(r=>{if(e+=r.byteLength,t.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: "+r.constructor.name)});const n=new Uint8Array(e);let i=0;return t.forEach(r=>{n.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),n.buffer}const UA=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function m3(x){return UA?Buffer.byteLength(x,"utf8"):new Blob([x]).size}function x6(x){if(UA)return Buffer.from(x).toString("base64");const e=new Uint8Array(x);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);return btoa(t)}function n6(x){if(UA){const n=Buffer.from(x,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const e=atob(x),t=new Uint8Array(e.length);for(let n=0;n<e.length;++n)t.set([e.charCodeAt(n)],n);return t.buffer}function i6(x){return ja.join(x)}function y3(x){const e="/";for(x=x.trim();x.endsWith(e);)x=x.slice(0,x.length-1);const t=x.split(e);return t[t.length-1]}function Ck(x,e){const t={modelTopology:x.modelTopology,format:x.format,generatedBy:x.generatedBy,convertedBy:x.convertedBy,weightsManifest:e};return x.signature!=null&&(t.signature=x.signature),x.userDefinedMetadata!=null&&(t.userDefinedMetadata=x.userDefinedMetadata),x.modelInitializer!=null&&(t.modelInitializer=x.modelInitializer),x.initializerSignature!=null&&(t.initializerSignature=x.initializerSignature),x.trainingConfig!=null&&(t.trainingConfig=x.trainingConfig),t}function Nk(x,e,t){const n={modelTopology:x.modelTopology,format:x.format,generatedBy:x.generatedBy,convertedBy:x.convertedBy};if(x.trainingConfig!=null&&(n.trainingConfig=x.trainingConfig),x.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");n.weightSpecs=e,n.weightData=t}return x.signature!=null&&(n.signature=x.signature),x.userDefinedMetadata!=null&&(n.userDefinedMetadata=x.userDefinedMetadata),x.modelInitializer!=null&&(n.modelInitializer=x.modelInitializer),x.initializerSignature!=null&&(n.initializerSignature=x.initializerSignature),n}async function FA(x,e){let t,n;return x.weightsManifest!=null&&([t,n]=await e(x.weightsManifest)),Nk(x,t,n)}function mp(x){if(x.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:x.modelTopology==null?0:m3(JSON.stringify(x.modelTopology)),weightSpecsBytes:x.weightSpecs==null?0:m3(JSON.stringify(x.weightSpecs)),weightDataBytes:x.weightData==null?0:new ja(x.weightData).byteLength}}function iT(x){const e=[];for(const t of x)e.push(...t.weights);return e}function r6(){const x=t=>{let n=t<<13,i=0;for(;(n&8388608)===0;)i-=8388608,n<<=1;return n&=-8388609,i+=947912704,n|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=x(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function a6(){const x=new Uint32Array(64);x[0]=0,x[31]=1199570944,x[32]=2147483648,x[63]=3347054592;for(let e=1;e<31;e++)x[e]=e<<23;for(let e=33;e<63;e++)x[e]=2147483648+(e-32<<23);return x}function s6(){const x=new Uint32Array(64);for(let e=0;e<64;e++)x[e]=1024;return x[0]=x[32]=0,x}function o6(){const x=r6(),e=a6(),t=s6();return n=>{const i=new ArrayBuffer(4*n.length),r=new Uint32Array(i);for(let a=0;a<n.length;a++){const s=n[a],l=x[t[s>>10]+(s&1023)]+e[s>>10];r[a]=l}return new Float32Array(i)}}class Dx{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Dx.instance==null&&(Dx.instance=new Dx),Dx.instance}static registerSaveRouter(e){Dx.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Dx.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Dx.getHandlers(e,"save")}static getLoadHandlers(e,t){return Dx.getHandlers(e,"load",t)}static getHandlers(e,t,n){const i=[];return(t==="load"?Dx.getInstance().loadRouters:Dx.getInstance().saveRouters).forEach(r=>{const a=r(e,n);a!==null&&i.push(a)}),i}}const l6=x=>Dx.registerSaveRouter(x),c6=x=>Dx.registerLoadRouter(x),u6=x=>Dx.getSaveHandlers(x),h6=(x,e)=>Dx.getLoadHandlers(x,e),rT="tensorflowjs",aT=1,ac="models_store",V2="model_info_store";function Ik(){if(!Pe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const x=typeof window>"u"?self:window,e=x.indexedDB||x.mozIndexedDB||x.webkitIndexedDB||x.msIndexedDB||x.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function sT(x){const e=x.result;e.createObjectStore(ac,{keyPath:"modelPath"}),e.createObjectStore(V2,{keyPath:"modelPath"})}class _c{constructor(e){if(this.indexedDB=Ik(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((n,i)=>{const r=this.indexedDB.open(rT,aT);r.onupgradeneeded=()=>sT(r),r.onsuccess=()=>{const a=r.result;if(t==null){const s=a.transaction(ac,"readonly"),l=s.objectStore(ac).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),i(new Error("Cannot find model with path '"+this.modelPath+"' in IndexedDB."));n(l.result.modelArtifacts)},l.onerror=c=>(a.close(),i(l.error)),s.oncomplete=()=>a.close()}else{t.weightData=ja.join(t.weightData);const s=mp(t),l=a.transaction(V2,"readwrite");let c=l.objectStore(V2),h;try{h=c.put({modelPath:this.modelPath,modelArtifactsInfo:s})}catch(p){return i(p)}let d;h.onsuccess=()=>{d=a.transaction(ac,"readwrite");const p=d.objectStore(ac);let m;try{m=p.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:s})}catch(g){return i(g)}m.onsuccess=()=>n({modelArtifactsInfo:s}),m.onerror=g=>{c=l.objectStore(V2);const _=c.delete(this.modelPath);_.onsuccess=()=>(a.close(),i(m.error)),_.onerror=v=>(a.close(),i(m.error))}},h.onerror=p=>(a.close(),i(h.error)),l.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}}},r.onerror=a=>i(r.error)})}}_c.URL_SCHEME="indexeddb://";const g3=x=>Pe().getBool("IS_BROWSER")&&!Array.isArray(x)&&x.startsWith(_c.URL_SCHEME)?d6(x.slice(_c.URL_SCHEME.length)):null;Dx.registerSaveRouter(g3),Dx.registerLoadRouter(g3);function d6(x){return new _c(x)}function f6(x){return x.startsWith(_c.URL_SCHEME)?x.slice(_c.URL_SCHEME.length):x}class p6{constructor(){this.indexedDB=Ik()}async listModels(){return new Promise((e,t)=>{const n=this.indexedDB.open(rT,aT);n.onupgradeneeded=()=>sT(n),n.onsuccess=()=>{const i=n.result,r=i.transaction(V2,"readonly"),a=r.objectStore(V2).getAll();a.onsuccess=()=>{const s={};for(const l of a.result)s[l.modelPath]=l.modelArtifactsInfo;e(s)},a.onerror=s=>(i.close(),t(a.error)),r.oncomplete=()=>i.close()},n.onerror=i=>t(n.error)})}async removeModel(e){return e=f6(e),new Promise((t,n)=>{const i=this.indexedDB.open(rT,aT);i.onupgradeneeded=()=>sT(i),i.onsuccess=()=>{const r=i.result,a=r.transaction(V2,"readwrite"),s=a.objectStore(V2),l=s.get(e);let c;l.onsuccess=()=>{if(l.result==null)return r.close(),n(new Error("Cannot find model with path '"+e+"' in IndexedDB."));{const h=s.delete(e),d=()=>{c=r.transaction(ac,"readwrite");const p=c.objectStore(ac).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=m=>n(l.error)};h.onsuccess=d,h.onerror=p=>(d(),r.close(),n(l.error))}},l.onerror=h=>(r.close(),n(l.error)),a.oncomplete=()=>{c==null?r.close():c.oncomplete=()=>r.close()}},i.onerror=r=>n(i.error)})}}const Ao="/",qu="tensorflowjs_models",Ok="info",m6="model_topology",y6="weight_specs",g6="weight_data",v6="model_metadata";function Dk(x){return{info:[qu,x,Ok].join(Ao),topology:[qu,x,m6].join(Ao),weightSpecs:[qu,x,y6].join(Ao),weightData:[qu,x,g6].join(Ao),modelMetadata:[qu,x,v6].join(Ao)}}function Pk(x){for(const e of Object.values(x))window.localStorage.removeItem(e)}function b6(x){const e=x.split(Ao);if(e.length<3)throw new Error("Invalid key format: "+x);return e.slice(1,e.length-1).join(Ao)}function _6(x){return x.startsWith(Sc.URL_SCHEME)?x.slice(Sc.URL_SCHEME.length):x}class Sc{constructor(e){if(!Pe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Dk(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),i=mp(e),r=ja.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,x6(r));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw Pk(this.keys),new Error("Failed to save model '"+this.modelPath+"' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes="+i.modelTopologyBytes+", weightSpecsBytes="+i.weightSpecsBytes+", weightDataBytes="+i.weightDataBytes+".")}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error("In local storage, there is no model with name '"+this.modelPath+"'");if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error("In local storage, the topology of model '"+this.modelPath+"' is missing.");t.modelTopology=n;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error("In local storage, the weight specs of model '"+this.modelPath+"' are missing.");t.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const s=JSON.parse(r);t.format=s.format,t.generatedBy=s.generatedBy,t.convertedBy=s.convertedBy,s.signature!=null&&(t.signature=s.signature),s.userDefinedMetadata!=null&&(t.userDefinedMetadata=s.userDefinedMetadata),s.modelInitializer!=null&&(t.modelInitializer=s.modelInitializer),s.initializerSignature!=null&&(t.initializerSignature=s.initializerSignature),s.trainingConfig!=null&&(t.trainingConfig=s.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error("In local storage, the binary weight values of model '"+this.modelPath+"' are missing.");return t.weightData=n6(a),t}}Sc.URL_SCHEME="localstorage://";const v3=x=>Pe().getBool("IS_BROWSER")&&!Array.isArray(x)&&x.startsWith(Sc.URL_SCHEME)?S6(x.slice(Sc.URL_SCHEME.length)):null;Dx.registerSaveRouter(v3),Dx.registerLoadRouter(v3);function S6(x){return new Sc(x)}class T6{constructor(){ye(Pe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),ye(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=qu+Ao,n=Ao+Ok;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(n)){const a=b6(r);e[a]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=_6(e);const t=Dk(e);if(this.LS.getItem(t.info)==null)throw new Error("Cannot find model at path '"+e+"'");const n=JSON.parse(this.LS.getItem(t.info));return Pk(t),n}}const w6="model",A6=".json",E6=".weights.bin";function b3(x){return new Promise(e=>setTimeout(e)).then(x)}class Tc{constructor(e){if(!Pe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Tc.URL_SCHEME)&&(e=e.slice(Tc.URL_SCHEME.length)),(e==null||e.length===0)&&(e=w6),this.modelJsonFileName=e+A6,this.weightDataFileName=e+E6}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=ja.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const i=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=Ck(e,i),a=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),s=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(s.download=this.modelJsonFileName,s.href=a,await b3(()=>s.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=n,await b3(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:mp(e)}}}}Tc.URL_SCHEME="downloads://";class M6{constructor(e){if(e==null||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, but received "+e);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=i=>{const r=JSON.parse(i.target.result),a=r.modelTopology;if(a==null){t(new Error("modelTopology field is missing from file "+this.jsonFile.name));return}if(r.weightsManifest==null){t(new Error("weightManifest field is missing from file "+this.jsonFile.name));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const s=FA(r,l=>this.loadWeights(l));e(s)},n.onerror=i=>t("Failed to read model topology and weights manifest JSON from file '"+this.jsonFile.name+"'. BrowserFiles supports loading Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const a of e)t.push(...a.weights),n.push(...a.paths);const i=this.checkManifestAndWeightFiles(e),r=n.map(a=>this.loadWeightsFile(a,i[a]));return Promise.all(r).then(a=>[t,a])}loadWeightsFile(e,t){return new Promise((n,i)=>{const r=new FileReader;r.onload=a=>{const s=a.target.result;n(s)},r.onerror=a=>i("Failed to weights data from file of path '"+e+"'."),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(r=>y3(r.name)),i={};for(const r of e)r.paths.forEach(a=>{const s=y3(a);if(t.indexOf(s)!==-1)throw new Error("Duplicate file basename found in weights manifest: '"+s+"'");if(t.push(s),n.indexOf(s)===-1)throw new Error("Weight file with basename '"+s+"' is not provided.");i[a]=this.weightsFiles[n.indexOf(s)]});if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest ("+t.length+") and the number of weight files provided ("+this.weightsFiles.length+").");return i}}const R6=x=>Pe().getBool("IS_BROWSER")&&!Array.isArray(x)&&x.startsWith(Tc.URL_SCHEME)?C6(x.slice(Tc.URL_SCHEME.length)):null;Dx.registerSaveRouter(R6);function C6(x="model"){return new Tc(x)}function N6(x){return new M6(x)}function _3(x,e,t,n){a(x),t=t??0,n=n??1,s(t,n);let i=0;const r=l=>(l.then(c=>{const h=t+ ++i/x.length*(n-t);return e(h),c}),l);function a(l){ye(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function s(l,c){ye(l>=0&&l<=1,()=>"Progress fraction must be in range [0, 1], but got startFraction "+l),ye(c>=0&&c<=1,()=>"Progress fraction must be in range [0, 1], but got endFraction "+c),ye(c>=l,()=>"startFraction must be no more than endFraction, but got startFraction "+l+" and endFraction "+c)}return Promise.all(x.map(r))}async function kk(x,e){e==null&&(e={});const t=e.fetchFunc==null?Pe().platform.fetch:e.fetchFunc,n=x.map(r=>t(r,e.requestInit,{isBinary:!0})),i=(e.onProgress==null?await Promise.all(n):await _3(n,e.onProgress,0,.5)).map(r=>r.arrayBuffer());return e.onProgress==null?await Promise.all(i):await _3(i,e.onProgress,.5,1)}function I6(x,e){var t;const n=e.fetchFunc==null?Pe().platform.fetch:e.fetchFunc;let i=0,r;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async a=>{for(var s;i<x.length;){r||(r=(await n(x[i],e.requestInit,{isBinary:!0})).body.getReader());const{done:l,value:c}=await r.read();if(l){i++,r=void 0,(s=e.onProgress)===null||s===void 0||s.call(e,i/x.length);continue}a.enqueue(c);return}a.close()}})}async function O6(x,e="",t,n){return Uk(i=>kk(i,{requestInit:n}))(x,e,t)}function Uk(x){return async(e,t="",n)=>{const i=e.map(()=>!1),r={},a=n!=null?n.map(()=>!1):[],s=[];if(e.forEach((m,g)=>{let _=0;m.weights.forEach(v=>{const b="quantization"in v?v.quantization.dtype:v.dtype,T=bc[b]*ut(v.shape),E=()=>{i[g]=!0,r[g]==null&&(r[g]=[]),r[g].push({manifestEntry:v,groupOffset:_,sizeBytes:T})};n!=null?n.forEach((A,M)=>{A===v.name&&(E(),a[M]=!0)}):E(),s.push(v.name),_+=T})}),!a.every(m=>m)){const m=n.filter((g,_)=>!a[_]);throw new Error("Could not find weights in manifest with names: "+m.join(", ")+`. 
Manifest JSON has weights with names: `+s.join(", ")+".")}const l=i.reduce((m,g,_)=>(g&&m.push(_),m),[]),c=[];l.forEach(m=>{e[m].paths.forEach(g=>{const _=t+(t.endsWith("/")?"":"/")+g;c.push(_)})});const h=await x(c),d={};let p=0;return l.forEach(m=>{const g=e[m].paths.length,_=new ja(h.slice(p,p+g));r[m].forEach(v=>{const b=_.slice(v.groupOffset,v.groupOffset+v.sizeBytes),T=Ek(b,[v.manifestEntry]);for(const E in T)d[E]=T[E]}),p+=g}),d}}const D6="application/octet-stream",P6="application/json";class BA{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(ye(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Pe().platform.fetch,ye(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&ye(e.length===2,()=>"URL paths for http must have a length of 2, (actual length is "+e.length+")."),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=Ck(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(i)],{type:P6}),"model.json"),e.weightData!=null){const a=ja.join(e.weightData);t.body.append("model.weights.bin",new Blob([a],{type:D6}),"model.weights.bin")}const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:mp(e),responses:[r]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+r.status+".")}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to "+this.path+" failed with status code "+e.status+". Please verify this URL points to the model JSON of the model to load.");let t;try{t=await e.json()}catch{let a="Failed to parse model JSON of response from "+this.path+".";throw this.path.endsWith(".pb")?a+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":a+=" Please make sure the server is serving valid JSON for this request.",new Error(a)}const n=t.modelTopology,i=t.weightsManifest;if(n==null&&i==null)throw new Error("The JSON from HTTP path "+this.path+" contains neither model topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return FA(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=iT(e.weightsManifest),i=()=>I6(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:i})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,i]=k6(t),r=this.weightPathPrefix||n,a=[],s=[];for(const l of e)for(const c of l.paths)this.weightUrlConverter!=null?s.push(this.weightUrlConverter(c)):a.push(r+c+i);return this.weightUrlConverter&&a.push(...await Promise.all(s)),a}async loadWeights(e){const t=await this.getWeightUrls(e),n=iT(e),i=await kk(t,this.loadOptions);return[n,i]}}BA.URL_SCHEME_REGEX=/^https?:\/\//;function k6(x){const e=x.lastIndexOf("/"),t=x.lastIndexOf("?"),n=x.substring(0,e),i=t>e?x.substring(t):"";return[n+"/",i]}function oT(x){return x.match(BA.URL_SCHEME_REGEX)!=null}const S3=(x,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(x)?t=x.every(n=>oT(n)):t=oT(x),t)return LA(x,e)}return null};Dx.registerSaveRouter(S3),Dx.registerLoadRouter(S3);function LA(x,e){return new BA(x,e)}function U6(x,e){return LA(x,e)}class p_{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Fk{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class F6{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function B6(x,e,t,n){const i=arguments;return new F6(Bk(...i))}function Bk(x,e,t,n){return arguments.length===1?x.modelTopology!=null||x.weightSpecs!=null?new p_(x):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new p_({modelTopology:x})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new p_({modelTopology:x,weightSpecs:e,weightData:t,trainingConfig:n}))}function L6(x){return new Fk(x)}function z6(x){return new Fk(x)}const ah="://";class li{constructor(){this.managers={}}static getInstance(){return li.instance==null&&(li.instance=new li),li.instance}static registerManager(e,t){ye(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(ah)&&(e=e.slice(0,e.indexOf(ah))),ye(e.length>0,()=>"scheme must not be an empty string.");const n=li.getInstance();ye(n.managers[e]==null,()=>"A model store manager is already registered for scheme '"+e+"'."),n.managers[e]=t}static getManager(e){const t=li.getInstance().managers[e];if(t==null)throw new Error("Cannot find model manager for scheme '"+e+"'");return t}static getSchemes(){return Object.keys(li.getInstance().managers)}}function jy(x){if(x.indexOf(ah)===-1)throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+li.getSchemes().join(","));return{scheme:x.split(ah)[0],path:x.split(ah)[1]}}async function Lk(x,e,t=!1){ye(x!==e,()=>"Old path and new path are the same: '"+x+"'");const n=Dx.getLoadHandlers(x);ye(n.length>0,()=>"Copying failed because no load handler is found for source URL "+x+"."),ye(n.length<2,()=>"Copying failed because more than one ("+n.length+") load handlers for source URL "+x+".");const i=n[0],r=Dx.getSaveHandlers(e);ye(r.length>0,()=>"Copying failed because no save handler is found for destination URL "+e+"."),ye(r.length<2,()=>"Copying failed because more than one ("+n.length+") save handlers for destination URL "+e+".");const a=r[0],s=jy(x).scheme,l=jy(x).path,c=s===jy(x).scheme,h=await i.load();t&&c&&await li.getManager(s).removeModel(l);const d=await a.save(h);return t&&!c&&await li.getManager(s).removeModel(l),d.modelArtifactsInfo}async function V6(){const x=li.getSchemes(),e={};for(const t of x){const n=await li.getManager(t).listModels();for(const i in n){const r=t+ah+i;e[r]=n[i]}}return e}async function H6(x){const e=jy(x);return li.getManager(e.scheme).removeModel(e.path)}async function G6(x,e){return Lk(x,e,!1)}async function W6(x,e){return Lk(x,e,!0)}var zk=Object.freeze({__proto__:null,CompositeArrayBuffer:ja,browserFiles:N6,browserHTTPRequest:U6,concatenateArrayBuffers:i6,copyModel:G6,decodeWeights:Ek,decodeWeightsStream:Rk,encodeWeights:jV,fromMemory:B6,fromMemorySync:Bk,getLoadHandlers:h6,getModelArtifactsForJSON:FA,getModelArtifactsForJSONSync:Nk,getModelArtifactsInfoForJSON:mp,getSaveHandlers:u6,getWeightSpecs:iT,http:LA,isHTTPScheme:oT,listModels:V6,loadWeights:O6,moveModel:W6,registerLoadRouter:c6,registerSaveRouter:l6,removeModel:H6,weightsLoaderFactory:Uk,withSaveHandler:L6,withSaveHandlerSync:z6});function X6(x,e){const t=We(x,"x","cast");if(!L5(e))throw new Error("Failed to cast to unknown dtype "+e);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const n={x:t},i={dtype:e};return it.runKernel(sg,n,i)}const Or=mt({cast_:X6});function Y6(x,e,t=!1,n=!1){let i=We(x,"a","matMul"),r=We(e,"b","matMul");[i,r]=jn(i,r);const a={a:i,b:r},s={transposeA:t,transposeB:n};return it.runKernel(rA,a,s)}const bs=mt({matMul_:Y6});function K6(x){const e={input:We(x,"input","imag")};return it.runKernel(aV,e)}const $6=mt({imag_:K6});function Q6(x){const e={x:We(x,"x","neg")};return it.runKernel(_A,e)}const Vk=mt({neg_:Q6});function Z6(x){const e={input:We(x,"input","real")};return it.runKernel(uV,e)}const J6=mt({real_:Z6});function j6(x,e,t){const n=We(x,"x","transpose");if(e==null&&(e=n.shape.map((a,s)=>s).reverse()),ye(n.rank===e.length,()=>"Error in transpose: rank of input "+n.rank+" must match length of perm "+e+"."),e.forEach(a=>{ye(a>=0&&a<n.rank,()=>"All entries in 'perm' must be between 0 and "+(n.rank-1)+" but got "+e)}),n.rank<=1)return n.clone();const i={x:n},r={perm:e};return n.dtype==="complex64"?hi(()=>{let a=J6(n),s=$6(n);return a=it.runKernel(Df,{x:a},r),s=it.runKernel(Df,{x:s},r),t&&(s=Vk(s)),Cg(a,s)}):it.runKernel(Df,i,r)}const q6=mt({transpose_:j6});function wh(x,e){const t=x.length,n=[];for(let i=0;i<t;i++){const r=t-1-i,a=x[r]||1;(e[e.length-1-i]||1)>1&&a===1&&n.unshift(r)}return n}function Hk(x,e){const t=[];for(let n=0;n<e.length;n++){const i=x[x.length-n-1],r=e.length-n-1,a=e[r];(i==null||i===1&&a>1)&&t.unshift(r)}return t}function tn(x,e){const t=Math.max(x.length,e.length),n=new Array(t);for(let i=0;i<t;i++){let r=x[x.length-i-1];r==null&&(r=1);let a=e[e.length-i-1];if(a==null&&(a=1),r===1)n[t-i-1]=a;else if(a===1)n[t-i-1]=r;else if(r!==a){const s="Operands could not be broadcast together with shapes "+x+" and "+e+".";throw Error(s)}else n[t-i-1]=r}return n}function e8(x,e,t){if(eA(x),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const n=fp(x,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return pp(x,e,n,t)}let Fl;function t8(x,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(x==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,i=!1,r=!1,a=!1,s=!1;if(x.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&x instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&x instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement)r=!0;else if(x.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&x instanceof ImageBitmap)s=!0;else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was "+x.constructor.name);if(ZS(QS,it.backendName)!=null){const p={pixels:x},m={numChannels:e};return it.runKernel(QS,p,m)}const[l,c]=i?[x.videoWidth,x.videoHeight]:[x.width,x.height];let h;if(a)h=x.getContext("2d").getImageData(0,0,l,c).data;else if(n||t)h=x.data;else if(r||i||s){if(Fl==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Fl=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Fl=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Fl.canvas.width=l,Fl.canvas.height=c,Fl.drawImage(x,0,0,l,c),h=Fl.getImageData(0,0,l,c).data}let d;if(e===4)d=new Int32Array(h);else{const p=l*c;d=new Int32Array(p*e);for(let m=0;m<p;m++)for(let g=0;g<e;++g)d[m*e+g]=h[m*4+g]}return e8(d,[c,l,e],"int32")}const x8=mt({fromPixels_:t8});function n8(x,e){const t=x.shape.length,n=e.shape.length;if(t<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was "+t+".");if(n<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was "+n+".");if(e.dtype!=="int32")throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was "+e.dtype+".");if(e.shape[n-1]>t)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+e.shape[n-1]+" vs. "+t);if(ut(x.shape)===0)throw new Error("Requested more than 0 entries, but input is empty. Input shape: "+x.shape+".");const i=e.shape,r=i[i.length-1];let a=1;for(let d=0;d<i.length-1;++d)a*=i[d];const s=x.shape,l=i.slice();l.pop();let c=1;for(let d=r;d<t;++d)c*=s[d],l.push(s[d]);const h=[...M0(x.shape).map(d=>d/c),1].slice(0,r);return[l,a,c,h]}function Gk(x,e,t){const n=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,r="Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: "+t.shape+", indices.shape: "+e.shape+", shape: "+x+", sliceDim: "+n+", and batchDim: "+i+".";if(t.rank<i)throw new Error(r+(" update.rank < "+i+". "));if(x.length<n+(t.rank-i))throw new Error(r+(" Output shape length < "+(n+(t.rank-i))));if(t.rank!==i+x.length-n)throw new Error(r+(" update.rank != "+(i+x.length-n)));for(let a=0;a<i;++a)if(t.shape[a]!==e.shape[a])throw new Error(r+(" updates.shape["+a+"] ("+t.shape[a]+") != indices.shape["+a+"] ("+e.shape[a]+")."));for(let a=0;a<t.rank-i;++a)if(t.shape[a+i]!==x[a+n])throw new Error(r+(" updates.shape["+(a+i)+"] ("+t.shape[a+i]+") != shape["+(a+i)+"] ("+x[a+i]+")"))}function Wk(x,e,t){if(e.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was "+e.rank+".");if(x.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was "+x.rank+".");if(e.dtype!=="int32")throw new Error("The dtype of 'indices' should be int32, but got dtype: "+e.dtype);if(t.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: "+t);if(t.length===0){if(e.size===0)throw new Error("Indices specified for empty output. indices shape: "+e.shape);if(x.size===0)throw new Error("Updates specified for empty output. updates shape: "+x.shape)}Gk(t,e,x)}function i8(x,e,t){const n=e.shape.length,i=n>1?e.shape[n-1]:1,r=t.length;let a=1;for(let d=i;d<r;++d)a*=t[d];const s=i<1?1:i,l=ut(e.shape)/s,c=[...M0(t.slice(0,i)),1],h=ut(t);return{sliceRank:i,numUpdates:l,sliceSize:a,strides:c,outputSize:h}}const lT=-2,r8=-1;function zA(x,e,t){const n=x.shape.length;ye(n===e.length,()=>"Error in slice"+n+"D: Length of begin "+e+" must match the rank of the array ("+n+")."),ye(n===t.length,()=>"Error in slice"+n+"D: Length of size "+t+" must match the rank of the array ("+n+").");for(let i=0;i<n;++i)ye(e[i]+t[i]<=x.shape[i],()=>"Error in slice"+n+"D: begin["+i+"] + size["+i+"] ("+(e[i]+t[i])+") would overflow input.shape["+i+"] ("+x.shape[i]+")")}function a8(x){const e=[];let t=0;for(;x>0;)x&1&&e.push(t),x/=2,t++;return e}function VA(x,e,t){const n=[];for(let i=0;i<x.length;i++)n[i]=Math.ceil((e[i]-x[i])/t[i]);return n}function Xk(x,e,t,n){const i=[...x];for(let r=i.length;r<n.length;r++)i.push(1);for(let r=0;r<t;r++)r===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function Yk(x,e,t){return t<=x?t:t-(e-1)}function Kk(x,e){const t=[];for(let n=0;n<x;n++)t.push(e+n);return t}function s8(x,e,t,n,i,r,a,s,l){const c=x.length;let h=new Array(c),d=new Array(c),p=new Array(c);if(e.length&&t>0){const m=e[0],g=t+1;h=$k(a,m,g,n,x),d=Qk(s,m,g,i,x),p=Xk(r,m,g,x)}else for(let m=0;m<c;m++)h[m]=Jk(a,n,r,x,m,l),d[m]=jk(s,i,r,x,m,l),p[m]=Zk(r,m,l);return{begin:h,end:d,strides:p}}function $k(x,e,t,n,i){const r=[...i],a=Kk(t,e);for(let s=0;s<r.length;s++)if(a.indexOf(s)>-1)r[s]=0;else{const l=Yk(e,t,s);let c=n[l];x&1<<l&&(c=0),r[s]=c}return r}function Qk(x,e,t,n,i){const r=[...i],a=Kk(t,e);for(let s=0;s<r.length;s++)if(a.indexOf(s)>-1)r[s]=Number.MAX_SAFE_INTEGER;else{const l=Yk(e,t,s);let c=n[l];x&1<<l&&(c=Number.MAX_SAFE_INTEGER),r[s]=c}for(let s=0;s<r.length;s++){const l=i[s];r[s]<0&&(r[s]+=l),r[s]=mc(0,r[s],i[s])}return r}function Zk(x,e,t){let n=x[e];return(t&1<<e||n==null)&&(n=1),n}function Jk(x,e,t,n,i,r){let a=e[i];const s=t[i]||1;(x&1<<i||r&1<<i||a==null)&&(s>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=n[i];return a<0&&(a+=l),a=mc(0,a,l-1),a}function jk(x,e,t,n,i,r){let a=e[i];const s=t[i]||1;(x&1<<i||r&1<<i||a==null)&&(s>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=n[i];return a<0&&(a+=l),s>0?a=mc(0,a,l):a=mc(-1,a,l-1),a}function HA(x,e,t){let n=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){n=i;break}for(let i=n+1;i<t.length;i++)if(e[i]>0||t[i]!==x[i])return!1;return!0}function GA(x,e){let t=x.length>0?x[x.length-1]:1;for(let n=0;n<x.length-1;n++)t+=x[n]*e[n];return t}function WA(x,e,t){let n;const i=x.shape.length;typeof e=="number"?n=[e,...new Array(i-1).fill(0)]:e.length<i?n=e.concat(new Array(i-e.length).fill(0)):n=e.slice(),n.forEach(a=>{ye(a!==-1,()=>"slice() does not support negative begin indexing.")});let r;return t==null?r=new Array(i).fill(-1):typeof t=="number"?r=[t,...new Array(i-1).fill(-1)]:t.length<i?r=t.concat(new Array(i-t.length).fill(-1)):r=t,r=r.map((a,s)=>a>=0?a:(ye(a===-1,()=>"Negative size values should be exactly -1 but got "+a+" for the slice() size at index "+s+"."),x.shape[s]-n[s])),[n,r]}function XA(x,e,t,n,i,r,a,s,l){let c;if(n==null?(c=new Array(e.length),c.fill(1)):c=n,a!=null&&(a&a-1)!==0)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:s,shrinkAxisMask:l};for(let T=0;T<d.dims;T++)h&&(1<<T&s)!==0&&d.numAddAxisAfterEllipsis++,1<<T&a&&(h=!0);h||(d.ellipsisMask|=1<<d.dims,d.dims++);const p={dims:x.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};o8(d,p);let m=!0,g=!0,_=!0;const v=[],b=[];for(let T=0;T<x.length;++T){if(p.strides[T]===0)throw Error("strides["+T+"] must be non-zero");const E=!!(p.shrinkAxisMask&1<<T),A=x[T];if(A===-1){v.push(E?1:-1);continue}const M=[p.beginMask&1<<T,p.endMask&1<<T],R=[p.strides[T]>0?0:-1,p.strides[T]>0?A:A-1];if(E&&p.strides[T]<=0)throw Error("only stride 1 allowed on non-range indexing.");_=_&&p.strides[T]===1;const C=!!(p.beginMask&1<<T&&p.endMask&1<<T);if(p.beginValid&&p.endValid){if(E){const G=p.begin[T]<0?A+p.begin[T]:p.begin[T];if(p.begin[T]=G,p.end[T]=p.begin[T]+1,G<0||G>=A)throw Error("slice index "+p.begin[T]+" of dimension "+T+" out of bounds.")}else p.begin[T]=T3(p.begin[T],0,p.strides[T],A,M,R),p.end[T]=T3(p.end[T],1,p.strides[T],A,M,R);const N=p.strides[T]===1&&p.begin[T]===0&&p.end[T]===A;m=m&&N,g=g&&(T===0&&p.strides[T]===1||N)}else m=m&&p.strides[T]===1&&C,g=g&&(T===0&&p.strides[T]===1||C);let k,P=!1;if(p.beginValid&&p.endValid?(k=p.end[T]-p.begin[T],P=!0):E?(k=1,P=!0):C&&A>=0&&(p.strides[T]<0?k=-A:k=A,P=!0),P){let N;k===0||k<0!=p.strides[T]<0?N=0:N=Math.trunc(k/p.strides[T])+(k%p.strides[T]!==0?1:0),v.push(N)}else v.push(-1)}for(let T=0;T<p.finalShapeGatherIndices.length;++T){const E=p.finalShapeGatherIndices[T];E>=0?b.push(v[E]):E===lT&&b.push(1)}return{finalShapeSparse:b.filter((T,E)=>p.finalShapeGatherIndices[E]!==lT),finalShape:b,isIdentity:m,sliceDim0:g,isSimpleSlice:_,begin:p.begin,end:p.end,strides:p.strides}}function o8(x,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=x.begin!=null,e.endValid=x.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let n=0;n<x.dims;n++)if(1<<n&x.ellipsisMask){const i=Math.min(e.dims-(x.dims-n)+1+x.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=n}else if(1<<n&x.newAxisMask)e.finalShapeGatherIndices.push(lT),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error("Index out of range using input dim "+t+"; input has only "+e.dims+" dims, "+e.begin.length+".");x.begin!=null&&(e.begin[t]=x.begin[n]),x.end!=null&&(e.end[t]=x.end[n]),e.strides[t]=x.strides[n],x.beginMask&1<<n&&(e.beginMask|=1<<t),x.endMask&1<<n&&(e.endMask|=1<<t),x.shrinkAxisMask&1<<n?(e.finalShapeGatherIndices.push(r8),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(n)),e.inputShapeGatherIndicesSparse[t]=n,t++}}function T3(x,e,t,n,i,r){if(i[e])return t>0?r[e]:r[e+1&1];{const a=x<0?n+x:x;return a<r[0]?r[0]:a>r[1]?r[1]:a}}var l8=Object.freeze({__proto__:null,assertParamsValid:zA,computeFlatOffset:GA,computeOutShape:VA,getNormalizedAxes:s8,isSliceContinous:HA,maskToAxes:a8,parseSliceParams:WA,sliceInfo:XA,startForAxis:Jk,startIndicesWithElidedDims:$k,stopForAxis:jk,stopIndicesWithElidedDims:Qk,stridesForAxis:Zk,stridesWithElidedDims:Xk});function c8(x,e){let t=We(x,"a","add"),n=We(e,"b","add");[t,n]=jn(t,n);const i={a:t,b:n};return it.runKernel(hp,i)}const Qi=mt({add_:c8});function u8(x,e){let t=We(x,"a","floorDiv"),n=We(e,"b","floorDiv");[t,n]=jn(t,n);const i={a:t,b:n};return it.runKernel(iV,i)}const h8=mt({floorDiv_:u8});function d8(x,e){let t=We(x,"a","div"),n=We(e,"b","div");if([t,n]=jn(t,n),t.dtype==="int32"&&n.dtype==="int32")return h8(t,n);const i={a:t,b:n},r={};return it.runKernel(cg,i,r)}const Va=mt({div_:d8});function f8(x,e){let t=We(x,"a","mul"),n=We(e,"b","mul");[t,n]=jn(t,n);const i={a:t,b:n};return it.runKernel(gg,i)}const Ji=mt({mul_:f8});function p8(x){const e=We(x,"x","abs");if(e.dtype==="complex64"){const t={x:e};return it.runKernel(j5,t)}else{const t={x:e};return it.runKernel(xA,t)}}const _2=mt({abs_:p8});function m8(x){ye(Array.isArray(x),()=>"The argument passed to tf.addN() must be a list of tensors"),ye(x.length>=1,()=>"Must pass at least one tensor to tf.addN(), but got "+x.length);const e=x.map((i,r)=>We(i,"tensors"+r,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!Zx(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const n=e;return it.runKernel(nA,n)}const y8=mt({addN_:m8});function g8(x,e){let t=We(x,"a","atan2"),n=We(e,"b","atan2");[t,n]=jn(t,n);const i={a:t,b:n};return it.runKernel(ag,i)}const v8=mt({atan2_:g8});function b8(x,e,t,n,i="NHWC",r){const a=x[3],s=[...e,a],l=kc(i);return Ur(x,s,t,r,n,null,null,l)}function yp(x,e,t,n,i,r,a="channelsLast"){const[s,l]=Gf(e);let c;if(a==="channelsLast")c=[s,l,x[3],x[3]];else if(a==="channelsFirst")c=[s,l,x[1],x[1]];else throw new Error("Unknown dataFormat "+a);return Ur(x,c,t,n,i,r,!1,a)}function _8(x,e,t,n,i,r,a="NDHWC"){const[s,l,c]=cT(e);let h,d;if(a==="NDHWC")d="channelsLast",h=[s,l,c,x[4],x[4]];else if(a==="NCDHW")d="channelsFirst",h=[s,l,c,x[1],x[1]];else throw new Error("Unknown dataFormat "+a);return qk(x,h,t,n,i,!1,d,r)}function Ur(x,e,t,n,i,r,a=!1,s="channelsLast"){let[l,c,h,d]=[-1,-1,-1,-1];if(s==="channelsLast")[l,c,h,d]=x;else if(s==="channelsFirst")[l,d,c,h]=x;else throw new Error("Unknown dataFormat "+s);const[p,m,,g]=e,[_,v]=Gf(t),[b,T]=Gf(n),E=sh(p,b),A=sh(m,T),{padInfo:M,outHeight:R,outWidth:C}=w8(i,c,h,_,v,E,A,r,s),k=a?g*d:g;let P;return s==="channelsFirst"?P=[l,k,R,C]:s==="channelsLast"&&(P=[l,R,C,k]),{batchSize:l,dataFormat:s,inHeight:c,inWidth:h,inChannels:d,outHeight:R,outWidth:C,outChannels:k,padInfo:M,strideHeight:_,strideWidth:v,filterHeight:p,filterWidth:m,effectiveFilterHeight:E,effectiveFilterWidth:A,dilationHeight:b,dilationWidth:T,inShape:x,outShape:P,filterShape:e}}function qk(x,e,t,n,i,r=!1,a="channelsLast",s){let[l,c,h,d,p]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,c,h,d,p]=x;else if(a==="channelsFirst")[l,p,c,h,d]=x;else throw new Error("Unknown dataFormat "+a);const[m,g,_,,v]=e,[b,T,E]=cT(t),[A,M,R]=cT(n),C=sh(m,A),k=sh(g,M),P=sh(_,R),{padInfo:N,outDepth:G,outHeight:te,outWidth:j}=A8(i,c,h,d,b,T,E,C,k,P,s),xe=r?v*p:v;let ae;return a==="channelsFirst"?ae=[l,xe,G,te,j]:a==="channelsLast"&&(ae=[l,G,te,j,xe]),{batchSize:l,dataFormat:a,inDepth:c,inHeight:h,inWidth:d,inChannels:p,outDepth:G,outHeight:te,outWidth:j,outChannels:xe,padInfo:N,strideDepth:b,strideHeight:T,strideWidth:E,filterDepth:m,filterHeight:g,filterWidth:_,effectiveFilterDepth:C,effectiveFilterHeight:k,effectiveFilterWidth:P,dilationDepth:A,dilationHeight:M,dilationWidth:R,inShape:x,outShape:ae,filterShape:e}}function S8(x,e,t,n,i){n==null&&(n=YA(x,e,t));const r=x[0],a=x[1],s=Wf((r-e+2*n)/t+1,i),l=Wf((a-e+2*n)/t+1,i);return[s,l]}function T8(x,e,t,n,i,r){i==null&&(i=YA(x,e[0],n[0]));const a=[0,0,0,t];for(let s=0;s<3;s++)x[s]+2*i>=e[s]&&(a[s]=Wf((x[s]-e[s]+2*i)/n[s]+1,r));return a}function YA(x,e,t,n=1){const i=sh(e,n);return Math.floor((x[0]*(t-1)-t+i)/2)}function Gf(x){return typeof x=="number"?[x,x,x]:x.length===2?[x[0],x[1],1]:x}function cT(x){return typeof x=="number"?[x,x,x]:x}function sh(x,e){return e<=1?x:x+(x-1)*(e-1)}function w8(x,e,t,n,i,r,a,s,l){let c,h,d;if(typeof x=="number"){c={top:x,bottom:x,left:x,right:x,type:x===0?"VALID":"NUMBER"};const p=S8([e,t],r,n,x,s);h=p[0],d=p[1]}else if(x==="same"){h=Math.ceil(e/n),d=Math.ceil(t/i);const p=Math.max(0,(h-1)*n+r-e),m=Math.max(0,(d-1)*i+a-t),g=Math.floor(p/2),_=p-g,v=Math.floor(m/2),b=m-v;c={top:g,bottom:_,left:v,right:b,type:"SAME"}}else if(x==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-r+1)/n),d=Math.ceil((t-a+1)/i);else if(typeof x=="object"){const p=l==="channelsLast"?x[1][0]:x[2][0],m=l==="channelsLast"?x[1][1]:x[2][1],g=l==="channelsLast"?x[2][0]:x[3][0],_=l==="channelsLast"?x[2][1]:x[3][1];c={top:p,bottom:m,left:g,right:_,type:p===0&&m===0&&g===0&&_===0?"VALID":"EXPLICIT"},h=Wf((e-r+p+m)/n+1,s),d=Wf((t-a+g+_)/i+1,s)}else throw Error("Unknown padding parameter: "+x);return{padInfo:c,outHeight:h,outWidth:d}}function A8(x,e,t,n,i,r,a,s,l,c,h){let d,p,m,g;if(x==="valid"&&(x=0),typeof x=="number"){d={top:x,bottom:x,left:x,right:x,front:x,back:x,type:x===0?"VALID":"NUMBER"};const _=T8([e,t,n,1],[s,l,c],1,[i,r,a],x,h);p=_[0],m=_[1],g=_[2]}else if(x==="same"){p=Math.ceil(e/i),m=Math.ceil(t/r),g=Math.ceil(n/a);const _=(p-1)*i+s-e,v=(m-1)*r+l-t,b=(g-1)*a+c-n,T=Math.floor(_/2),E=_-T,A=Math.floor(v/2),M=v-A,R=Math.floor(b/2),C=b-R;d={top:A,bottom:M,left:R,right:C,front:T,back:E,type:"SAME"}}else throw Error("Unknown padding parameter: "+x);return{padInfo:d,outDepth:p,outHeight:m,outWidth:g}}function Wf(x,e){if(!e)return Math.trunc(x);switch(e){case"round":return Math.round(x);case"ceil":return Math.ceil(x);case"floor":return Math.floor(x);default:throw new Error("Unknown roundingMode "+e)}}function Xf(x){const[e,t,n]=Gf(x);return e===1&&t===1&&n===1}function Fr(x,e){return Xf(x)||Xf(e)}function uT(x){return Gf(x).every(e=>e>0)}function kc(x){if(x==="NHWC")return"channelsLast";if(x==="NCHW")return"channelsFirst";throw new Error("Unknown dataFormat "+x)}function Vo(x,e,t){if(t!=null){if(typeof e=="string")throw Error("Error in "+x+": pad must be an integer when using dimRoundingMode "+t+" but got pad "+e+".");if(typeof e=="number")ye(v1(e),()=>"Error in "+x+": pad must be an integer when using dimRoundingMode "+t+" but got pad "+e+".");else if(typeof e=="object")e.forEach(n=>{n.forEach(i=>{ye(v1(i),()=>"Error in "+x+": pad must be an integer when using dimRoundingMode "+t+" but got pad "+i+".")})});else throw Error("Error in "+x+": Unknown padding parameter: "+e)}}function E8(x,e){const t={x:We(x,"x","reshape","string_or_numeric")},n={shape:e};return it.runKernel(EA,t,n)}const x0=mt({reshape_:E8});function M8(x,e,t,n,i){const r=We(x,"x","avgPool","float32"),a=1;ye(Fr(t,a),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+a+"'");let s=r,l=!1;r.rank===3&&(l=!0,s=x0(r,[1,r.shape[0],r.shape[1],r.shape[2]])),ye(s.rank===4,()=>"Error in avgPool: x must be rank 4 but got rank "+s.rank+"."),Vo("avgPool",n,i);const c={x:s},h={filterSize:e,strides:t,pad:n,dimRoundingMode:i};let d=it.runKernel(iA,c,h);return d=Or(d,r.dtype),l?x0(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const R8=mt({avgPool_:M8});function C8(x){const e={x:We(x,"x","clone","string_or_numeric")};return it.runKernel(dg,e)}const Ng=mt({clone_:C8});function N8(x,e=0){ye(x.length>=1,()=>"Pass at least one tensor to concat");const t=Tk(x,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype `+r.dtype+". ")}),t.length===1)return Ng(t[0]);const n=t,i={axis:e};return it.runKernel(aA,n,i)}const Ig=mt({concat_:N8});function I8(x){const e={x:We(x,"x","sigmoid","float32")};return it.runKernel(Tg,e)}const KA=mt({sigmoid_:I8});function O8(x,e,t){const n=We(x,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const i={x:n},r={begin:e,size:t};return it.runKernel(RA,i,r)}const wr=mt({slice_:O8});function D8(x,e,t){const n=We(x,"x","bincount"),i=We(e,"weights","bincount");ye(n.dtype==="int32",()=>"Error in bincount: input dtype must be int32, but got "+n.dtype),ye(t>=0,()=>"size must be non-negative, but got "+t+"."),ye(i.size===n.size||i.size===0,()=>"Error in bincount: weights must have the same size as input or0-length, but got input shape: "+n.shape+", weights shape: "+i.shape+".");const r={x:n,weights:i},a={size:t};return it.runKernel(Z5,r,a)}const P8=mt({bincount_:D8});function k8(x,e){let t=We(x,"broadcastTo","x");const n=t.shape;if(Zh(e),e.length<t.rank)throw new Error("broadcastTo(): shape.length="+e.length+" < input.rank="+t.rank+".");if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=x0(t,l)}const i=t.shape,r=Array.from(e);for(let l=e.length-1;l>=0;l--)if(i[l]===e[l])r[l]=1;else if(t.shape[l]!==1)throw new Error("broadcastTo(): ["+n+"] cannot be broadcast to ["+e+"].");if(r.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return Ng(t);const a={x:t},s={reps:r};return it.runKernel(Eg,a,s)}const qy=mt({broadcastTo_:k8});function kx(x,e="float32",t){return e=e||"float32",Zh(x),new vc(x,e,t)}function $A(x,e,t){Zh(x),t=t||Qh(e);const n={shape:x,value:e,dtype:t};return it.runKernel(dA,{},n)}function U8(x,e,t){const n=We(x,"x","clipByValue");if(ye(e<=t,()=>"Error in clip: min ("+e+") must be less than or equal to max ("+t+")."),e===t)return $A(n.shape,e,n.dtype);const i={x:n},r={clipValueMin:e,clipValueMax:t};return it.runKernel(og,i,r)}const F8=mt({clipByValue_:U8});function B8(x,e){return Ig(x,e)}const w3=mt({concat2d_:B8});function L8(x,e,t,n,i="NHWC",r=[1,1],a){const s=We(x,"x","conv2d","float32"),l=We(e,"filter","conv2d","float32");let c=s,h=!1;s.rank===3&&(h=!0,c=x0(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ye(c.rank===4,()=>"Error in conv2d: input must be rank 4, but got rank "+c.rank+"."),ye(l.rank===4,()=>"Error in conv2d: filter must be rank 4, but got rank "+l.rank+"."),Vo("conv2d",n,a);const d=i==="NHWC"?c.shape[3]:c.shape[1];ye(d===l.shape[2],()=>"Error in conv2d: depth of input ("+d+") must match input depth for filter "+l.shape[2]+"."),ye(Fr(t,r),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+r+"'"),ye(uT(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),ye(uT(t),()=>"Error in conv2D: Strides should be larger than 0.");const p={x:c,filter:l},m={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a},g=it.runKernel(sA,p,m);return h?x0(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const eU=mt({conv2d_:L8});function z8(x,e,t,n,i,r="NHWC",a){ye(x.length===e.rank,()=>"Length of inShape ("+x.length+") and rank of dy ("+e.rank+") must match");let s=x,l=e,c=!1;e.rank===3&&(c=!0,l=x0(e,[1,e.shape[0],e.shape[1],e.shape[2]]),s=[1,x[0],x[1],x[2]]),ye(s.length===4,()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+s.length+"."),ye(l.rank===4,()=>"Error in conv2dDerInput: dy must be rank 4, but got rank "+l.rank),ye(t.rank===4,()=>"Error in conv2dDerInput: filter must be rank 4, but got rank "+t.rank);const h=r==="NHWC"?s[3]:s[1],d=r==="NHWC"?l.shape[3]:l.shape[1];ye(h===t.shape[2],()=>"Error in conv2dDerInput: depth of input ("+h+") must match input depth for filter "+t.shape[2]+"."),ye(d===t.shape[3],()=>"Error in conv2dDerInput: depth of output ("+d+") must match output depth for filter "+t.shape[3]+"."),Vo("conv2dDerInput",i,a);const p={dy:l,filter:t},m={strides:n,pad:i,dataFormat:r,dimRoundingMode:a,inputShape:s},g=it.runKernel(oA,p,m);return c?x0(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const tU=mt({conv2DBackpropInput_:z8});function V8(x,e,t,n,i,r){const a=We(x,"x","conv2dTranspose"),s=We(e,"filter","conv2dTranspose");return tU(t,a,s,n,i,"NHWC",r)}const H8=mt({conv2dTranspose_:V8});function G8(x){const e={x:We(x,"x","cos","float32")};return it.runKernel(lg,e)}const W8=mt({cos_:G8});function X8(x,e,t="NHWC"){const n=We(x,"x","depthToSpace","float32"),i=t==="NHWC"?n.shape[1]:n.shape[2],r=t==="NHWC"?n.shape[2]:n.shape[3],a=t==="NHWC"?n.shape[3]:n.shape[1];ye(e>1,()=>"blockSize should be > 1 for depthToSpace, but was: "+e),ye(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+i+" and "+e+`  for depthToSpace with input shape
    `+n.shape),ye(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    `+r+" and "+e+` for depthToSpace with input shape
        `+n.shape),ye(a%(e*e)===0,()=>"Dimension size must be evenly divisible by "+e*e+" but is "+a+" for depthToSpace with input shape "+n.shape);const s={x:n},l={blockSize:e,dataFormat:t};return it.runKernel(cA,s,l)}const Y8=mt({depthToSpace_:X8});function K8(x,e,t,n,i="NHWC",r=[1,1],a){const s=We(x,"x","depthwiseConv2d","float32"),l=We(e,"filter","depthwiseConv2d","float32");let c=s,h=!1;s.rank===3&&(h=!0,c=x0(s,[1,s.shape[0],s.shape[1],s.shape[2]])),ye(c.rank===4,()=>"Error in depthwiseConv2d: input must be rank 4, but got rank "+c.rank+"."),ye(l.rank===4,()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+l.rank+".");const d=i==="NHWC"?c.shape[3]:c.shape[1];ye(d===l.shape[2],()=>"Error in depthwiseConv2d: number of input channels ("+d+") must match the inChannels dimension in filter "+l.shape[2]+"."),Vo("depthwiseConv2d",n,a);const p={x:c,filter:l},m={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a},g=it.runKernel(uA,p,m);return h?x0(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const xU=mt({depthwiseConv2d_:K8});function $8(x,e,t){const n=We(e,"a","where"),i=We(t,"b","where"),r=We(x,"condition","where","bool"),a=tn(tn(r.shape,n.shape),i.shape),s=qy(r,a),l=qy(n,a),c=qy(i,a),h={condition:s,t:l,e:c};return it.runKernel(pV,h)}const A3=mt({where_:$8});function Q8(x){const e={x:We(x,"x","zerosLike")};return it.runKernel(OA,e)}const Z8=mt({zerosLike_:Q8});function J8(x,...e){const t=e.map((i,r)=>We(i,"tensors"+r,"einsum")),n={equation:x};return it.runKernel(xV,t,n)}const af=mt({einsum_:J8});function j8(x){const e={x:We(x,"x","elu","float32")};return it.runKernel(xk,e)}const q8=mt({elu_:j8});function QA(x,e){for(let t=0;t<x.length;++t)if(x[x.length-t-1]!==e-1-t)return!1;return!0}function nU(x,e,t){const n=x.length+e.length,i=[];let r=0,a=0;for(let s=0;s<n;s++)t.indexOf(s)===-1?i.push(x[r++]):i.push(e[a++]);return i}function Is(x,e){const t=[],n=x.length;for(let r=0;r<n;r++)e.indexOf(r)===-1&&t.push(x[r]);const i=e.map(r=>x[r]);return[t,i]}function Ho(x,e){const t=e.map(n=>1);return nU(x,t,e)}function sl(x,e,t){ye(QA(e,t),()=>x+" supports only inner-most axes for now. Got axes "+e+" and rank-"+t+" input.")}function ol(x,e){if(QA(x,e))return null;const t=[];for(let n=0;n<e;++n)x.indexOf(n)===-1&&t.push(n);return x.forEach(n=>t.push(n)),t}function eH(x){return x.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ll(x,e){const t=[];for(let n=e-x;n<e;++n)t.push(n);return t}function tH(x,e=null,t=!1){const n={x:We(x,"x","max")},i={reductionIndices:e,keepDims:t};return it.runKernel(yA,n,i)}const e1=mt({max_:tH});function xH(x,e=null,t=!1){const n={x:We(x,"x","min")},i={axis:e,keepDims:t};return it.runKernel(bA,n,i)}const hT=mt({min_:xH});function nH(x,e){let t=We(x,"base","pow"),n=We(e,"exp","pow");[t,n]=jn(t,n);const i={a:t,b:n};return it.runKernel(vg,i)}const iH=mt({pow_:nH});function $a(x,e){if((ba(x)&&e!=="string"||Array.isArray(x))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&ba(x)&&!(x instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return pp(x,[],[],e)}function rH(x){const e={x:We(x,"x","sqrt","float32")};return it.runKernel(wg,e)}const E3=mt({sqrt_:rH});function aH(x){const e=We(x,"x","square"),t={};return it.runKernel("Square",{x:e},t)}const sH=mt({square_:aH});function oH(x,e=null,t=!1){let n=We(x,"x","sum");n.dtype==="bool"&&(n=Or(n,"int32"));const i={x:n},r={axis:e,keepDims:t};return it.runKernel(CA,i,r)}const Rr=mt({sum_:oH});function lH(x,e="euclidean",t=null,n=!1){x=We(x,"x","norm");const i=iU(x,e,t);let r=i.shape;if(n){const a=Ri(t,x.shape);r=Ho(i.shape,a)}return x0(i,r)}function iU(x,e,t=null){if(x.rank===0)return _2(x);if(x.rank!==1&&t===null)return iU(x0(x,[-1]),e,t);if(x.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Rr(_2(x),t);if(e===1/0)return e1(_2(x),t);if(e===-1/0)return hT(_2(x),t);if(e==="euclidean"||e===2)return E3(Rr(iH(_2(x),$a(2,"int32")),t));throw new Error("Error in norm: invalid ord value: "+e)}if(Array.isArray(t)&&t.length===2){if(e===1)return e1(Rr(_2(x),t[0]),t[1]-1);if(e===1/0)return e1(Rr(_2(x),t[1]),t[0]);if(e===-1/0)return hT(Rr(_2(x),t[1]),t[0]);if(e==="fro"||e==="euclidean")return E3(Rr(sH(x),t));throw new Error("Error in norm: invalid ord value: "+e)}throw new Error("Error in norm: invalid axis: "+t)}const cH=mt({norm_:lH});function uH(x,e=null,t=!1){return cH(x,"euclidean",e,t)}mt({euclideanNorm_:uH});function hH(x,e=0){const t=We(x,"x","expandDims","string_or_numeric");ye(e<=t.rank,()=>"Axis must be <= rank of the tensor");const n={input:t},i={dim:e};return it.runKernel(hA,n,i)}const ZA=mt({expandDims_:hH});function dH(x,e){const t=We(x,"x","tile","string_or_numeric");ye(t.rank===e.length,()=>"Error in transpose: rank of input "+t.rank+" must match length of reps "+e+".");const n={x:t},i={reps:e};return it.runKernel(Eg,n,i)}const rU=mt({tile_:dH});function fH(x){const e={x:We(x,"x","floor","float32")};return it.runKernel(ug,e)}const pH=mt({floor_:fH});function mH(x,e,t=0,n=0){const i=We(x,"x","gather"),r=We(e,"indices","gather","int32"),a={x:i,indices:r},s={axis:t,batchDims:n};return it.runKernel(fA,a,s)}const yH=mt({gather_:mH});function gH(x,e){let t=We(x,"a","greater","string_or_numeric"),n=We(e,"b","greater","string_or_numeric");[t,n]=jn(t,n),tn(t.shape,n.shape);const i={a:t,b:n};return it.runKernel(rV,i)}const aU=mt({greater_:gH});function vH(x,e){let t=We(x,"a","greaterEqual","string_or_numeric"),n=We(e,"b","greaterEqual","string_or_numeric");[t,n]=jn(t,n),tn(t.shape,n.shape);const i={a:t,b:n};return it.runKernel(hg,i)}const bH=mt({greaterEqual_:vH});function _H(x,e=.2){const t={x:We(x,"x","leakyRelu")},n={alpha:e};return it.runKernel(sV,t,n)}const SH=mt({leakyRelu_:_H});function TH(x,e){let t=We(x,"a","lessEqual","string_or_numeric"),n=We(e,"b","lessEqual","string_or_numeric");[t,n]=jn(t,n),tn(t.shape,n.shape);const i={a:t,b:n};return it.runKernel(fg,i)}const sU=mt({lessEqual_:TH});function Ah(x){return it.customGrad(x)}function wH(x,e){let t=We(x,"a","sub"),n=We(e,"b","sub");[t,n]=jn(t,n);const i={a:t,b:n};return it.runKernel(Ag,i)}const Eh=mt({sub_:wH});function AH(x,e){const t=We(x,"a","logicalAnd","bool"),n=We(e,"b","logicalAnd","bool");tn(t.shape,n.shape);const i={a:t,b:n};return it.runKernel(pg,i)}const EH=mt({logicalAnd_:AH});function MH(x,e,t,n,i){const r=We(x,"x","maxPool"),a=1;let s=r,l=!1;r.rank===3&&(l=!0,s=x0(r,[1,r.shape[0],r.shape[1],r.shape[2]])),ye(s.rank===4,()=>"Error in maxPool: input must be rank 4 but got rank "+s.rank+"."),ye(Fr(t,a),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+a+"'"),Vo("maxPool",n,i);const c={x:s},h={filterSize:e,strides:t,pad:n,dimRoundingMode:i},d=it.runKernel(gA,c,h);return l?x0(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const RH=mt({maxPool_:MH});function CH(x,e){let t=We(x,"a","maximum"),n=We(e,"b","maximum");[t,n]=jn(t,n),t.dtype==="bool"&&(t=Or(t,"int32"),n=Or(n,"int32")),tn(t.shape,n.shape);const i={a:t,b:n};return it.runKernel(mg,i)}const NH=mt({maximum_:CH});function IH(x,e=null,t=!1){const n={x:We(x,"x","mean")},i={axis:e,keepDims:t};return it.runKernel(vA,n,i)}const OH=mt({mean_:IH});function wc(x,e="float32"){if(Zh(x),e==="complex64"){const n=wc(x,"float32"),i=wc(x,"float32");return Cg(n,i)}const t=Ms(ut(x),e);return it.makeTensor(t,x,e)}function oU(x,e="float32"){if(Zh(x),e==="complex64"){const n=oU(x,"float32"),i=wc(x,"float32");return Cg(n,i)}const t=qP(ut(x),e);return it.makeTensor(t,x,e)}function DH(x,e){let t=We(x,"a","minimum"),n=We(e,"b","minimum");[t,n]=jn(t,n),t.dtype==="bool"&&(t=Or(t,"int32"),n=Or(n,"int32")),tn(t.shape,n.shape);const i={a:t,b:n};return it.runKernel(yg,i)}const PH=mt({minimum_:DH});function kH(x,e,t=0){const n=We(x,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},r={x:n};return it.runKernel(TA,r,i)}const lU=mt({pad_:kH});function UH(x,e){const t=We(x,"x","prelu"),n=We(e,"alpha","prelu"),i={x:t,alpha:n};return it.runKernel(wA,i)}const cU=mt({prelu_:UH});function FH(x,e=!1){console.log(x.toString(e))}var uU={exports:{}};(function(x){(function(e,t,n){function i(l){var c=this,h=s();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=h(" "),c.s1=h(" "),c.s2=h(" "),c.s0-=h(l),c.s0<0&&(c.s0+=1),c.s1-=h(l),c.s1<0&&(c.s1+=1),c.s2-=h(l),c.s2<0&&(c.s2+=1),h=null}function r(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function a(l,c){var h=new i(l),d=c&&c.state,p=h.next;return p.int32=function(){return h.next()*4294967296|0},p.double=function(){return p()+(p()*2097152|0)*11102230246251565e-32},p.quick=p,d&&(typeof d=="object"&&r(d,h),p.state=function(){return r(h,{})}),p}function s(){var l=4022871197,c=function(h){h=String(h);for(var d=0;d<h.length;d++){l+=h.charCodeAt(d);var p=.02519603282416938*l;l=p>>>0,p-=l,p*=l,l=p>>>0,p-=l,l+=p*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=a:this.alea=a})(Dc,x)})(uU);var BH=uU.exports,hU={exports:{}};(function(x){(function(e,t,n){function i(s){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},s===(s|0)?l.x=s:c+=s;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,l.next()}function r(s,l){return l.x=s.x,l.y=s.y,l.z=s.z,l.w=s.w,l}function a(s,l){var c=new i(s),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&r(h,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=a:this.xor128=a})(Dc,x)})(hU);var LH=hU.exports,dU={exports:{}};(function(x){(function(e,t,n){function i(s){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,s===(s|0)?l.x=s:c+=s;for(var h=0;h<c.length+64;h++)l.x^=c.charCodeAt(h)|0,h==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function r(s,l){return l.x=s.x,l.y=s.y,l.z=s.z,l.w=s.w,l.v=s.v,l.d=s.d,l}function a(s,l){var c=new i(s),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&r(h,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=a:this.xorwow=a})(Dc,x)})(dU);var zH=dU.exports,fU={exports:{}};(function(x){(function(e,t,n){function i(s){var l=this;l.next=function(){var h=l.x,d=l.i,p,m;return p=h[d],p^=p>>>7,m=p^p<<24,p=h[d+1&7],m^=p^p>>>10,p=h[d+3&7],m^=p^p>>>3,p=h[d+4&7],m^=p^p<<7,p=h[d+7&7],p=p^p<<13,m^=p^p<<9,h[d]=m,l.i=d+1&7,m};function c(h,d){var p,m=[];if(d===(d|0))m[0]=d;else for(d=""+d,p=0;p<d.length;++p)m[p&7]=m[p&7]<<15^d.charCodeAt(p)+m[p+1&7]<<13;for(;m.length<8;)m.push(0);for(p=0;p<8&&m[p]===0;++p);for(p==8?m[7]=-1:m[p],h.x=m,h.i=0,p=256;p>0;--p)h.next()}c(l,s)}function r(s,l){return l.x=s.x.slice(),l.i=s.i,l}function a(s,l){s==null&&(s=+new Date);var c=new i(s),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(h.x&&r(h,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=a:this.xorshift7=a})(Dc,x)})(fU);var VH=fU.exports,pU={exports:{}};(function(x){(function(e,t,n){function i(s){var l=this;l.next=function(){var h=l.w,d=l.X,p=l.i,m,g;return l.w=h=h+1640531527|0,g=d[p+34&127],m=d[p=p+1&127],g^=g<<13,m^=m<<17,g^=g>>>15,m^=m>>>12,g=d[p]=g^m,l.i=p,g+(h^h>>>16)|0};function c(h,d){var p,m,g,_,v,b=[],T=128;for(d===(d|0)?(m=d,d=null):(d=d+"\0",m=0,T=Math.max(T,d.length)),g=0,_=-32;_<T;++_)d&&(m^=d.charCodeAt((_+32)%d.length)),_===0&&(v=m),m^=m<<10,m^=m>>>15,m^=m<<4,m^=m>>>13,_>=0&&(v=v+1640531527|0,p=b[_&127]^=m+v,g=p==0?g+1:0);for(g>=128&&(b[(d&&d.length||0)&127]=-1),g=127,_=4*128;_>0;--_)m=b[g+34&127],p=b[g=g+1&127],m^=m<<13,p^=p<<17,m^=m>>>15,p^=p>>>12,b[g]=m^p;h.w=v,h.X=b,h.i=g}c(l,s)}function r(s,l){return l.i=s.i,l.w=s.w,l.X=s.X.slice(),l}function a(s,l){s==null&&(s=+new Date);var c=new i(s),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(h.X&&r(h,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=a:this.xor4096=a})(Dc,x)})(pU);var HH=pU.exports,mU={exports:{}};(function(x){(function(e,t,n){function i(s){var l=this,c="";l.next=function(){var d=l.b,p=l.c,m=l.d,g=l.a;return d=d<<25^d>>>7^p,p=p-m|0,m=m<<24^m>>>8^g,g=g-d|0,l.b=d=d<<20^d>>>12^p,l.c=p=p-m|0,l.d=m<<16^p>>>16^g,l.a=g-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,s===Math.floor(s)?(l.a=s/4294967296|0,l.b=s|0):c+=s;for(var h=0;h<c.length+20;h++)l.b^=c.charCodeAt(h)|0,l.next()}function r(s,l){return l.a=s.a,l.b=s.b,l.c=s.c,l.d=s.d,l}function a(s,l){var c=new i(s),h=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var p=c.next()>>>11,m=(c.next()>>>0)/4294967296,g=(p+m)/(1<<21);while(g===0);return g},d.int32=c.next,d.quick=d,h&&(typeof h=="object"&&r(h,c),d.state=function(){return r(c,{})}),d}t&&t.exports?t.exports=a:this.tychei=a})(Dc,x)})(mU);var GH=mU.exports,yU={exports:{}};(function(x){(function(e,t,n){var i=256,r=6,a=52,s="random",l=n.pow(i,r),c=n.pow(2,a),h=c*2,d=i-1,p;function m(A,M,R){var C=[];M=M==!0?{entropy:!0}:M||{};var k=b(v(M.entropy?[A,E(t)]:A??T(),3),C),P=new g(C),N=function(){for(var G=P.g(r),te=l,j=0;G<c;)G=(G+j)*i,te*=i,j=P.g(1);for(;G>=h;)G/=2,te/=2,j>>>=1;return(G+j)/te};return N.int32=function(){return P.g(4)|0},N.quick=function(){return P.g(4)/4294967296},N.double=N,b(E(P.S),t),(M.pass||R||function(G,te,j,xe){return xe&&(xe.S&&_(xe,P),G.state=function(){return _(P,{})}),j?(n[s]=G,te):G})(N,k,"global"in M?M.global:this==n,M.state)}function g(A){var M,R=A.length,C=this,k=0,P=C.i=C.j=0,N=C.S=[];for(R||(A=[R++]);k<i;)N[k]=k++;for(k=0;k<i;k++)N[k]=N[P=d&P+A[k%R]+(M=N[k])],N[P]=M;(C.g=function(G){for(var te,j=0,xe=C.i,ae=C.j,H=C.S;G--;)te=H[xe=d&xe+1],j=j*i+H[d&(H[xe]=H[ae=d&ae+te])+(H[ae]=te)];return C.i=xe,C.j=ae,j})(i)}function _(A,M){return M.i=A.i,M.j=A.j,M.S=A.S.slice(),M}function v(A,M){var R=[],C=typeof A,k;if(M&&C=="object")for(k in A)try{R.push(v(A[k],M-1))}catch{}return R.length?R:C=="string"?A:A+"\0"}function b(A,M){for(var R=A+"",C,k=0;k<R.length;)M[d&k]=d&(C^=M[d&k]*19)+R.charCodeAt(k++);return E(M)}function T(){try{var A;return p&&(A=p.randomBytes)?A=A(i):(A=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(A)),E(A)}catch{var M=e.navigator,R=M&&M.plugins;return[+new Date,e,R,e.screen,E(t)]}}function E(A){return String.fromCharCode.apply(0,A)}if(b(n.random(),t),x.exports){x.exports=m;try{p=require("crypto")}catch{}}else n["seed"+s]=m})(typeof self<"u"?self:Dc,[],Math)})(yU);var WH=yU.exports,XH=BH,YH=LH,KH=zH,$H=VH,QH=HH,ZH=GH,fu=WH;fu.alea=XH,fu.xor128=YH,fu.xorwow=KH,fu.xorshift7=$H,fu.xor4096=QH,fu.tychei=ZH;function dT(x,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:x,stop:e,step:t,dtype:n};return it.runKernel(AA,{},i)}function JH(x){const e={x:We(x,"x","relu")};return it.runKernel(bg,e)}const gU=mt({relu_:JH});function jH(x){const e={x:We(x,"x","relu6")};return it.runKernel(_g,e)}const vU=mt({relu6_:jH});function qH(x){const e={x:We(x,"x","round")};return it.runKernel(dV,e)}const e7=mt({round_:qH});function t7(x){const e={x:We(x,"x","sin","float32")};return it.runKernel(Sg,e)}const x7=mt({sin_:t7});function n7(x,e,t){const n=We(x,"x","slice3d");return ye(n.rank===3,()=>"slice3d expects a rank-3 tensor, but got a rank-"+n.rank+" tensor"),wr(n,e,t)}mt({slice3d_:n7});function i7(x,e,t=0){const n={x:We(x,"x","split")},i={numOrSizeSplits:e,axis:t};return it.runKernel(mV,n,i)}const r7=mt({split_:i7});function a7(x,e){const t=We(x,"x","squeeze","string_or_numeric");return x0(t,al(t.shape,e).newShape)}const Ba=mt({squeeze_:a7});function s7(x,e=0){const t=Tk(x,"tensors","stack","string_or_numeric");ye(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&ye(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const n=t,i={axis:e};return it.runKernel(SA,n,i)}const Yf=mt({stack_:s7});function o7(x,e=0){const t={x:We(x,"x","step")},n={alpha:e};return it.runKernel(gV,t,n)}const l7=mt({step_:o7});function c7(x,e,t,n,i=0,r=0,a=0,s=0,l=0){const c={x:We(x,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:n,beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:s,shrinkAxisMask:l};return it.runKernel(NA,c,h)}const u7=mt({stridedSlice_:c7});function ji(x,e){eA(x);const t=fp(x,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return pp(x,null,t,e)}function h7(x,e,t){eA(x);const n=fp(x,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return pp(x,e,n,t)}function d7(x,e,t){const n=We(x,"tensor","tensorScatterupdate"),i=We(e,"indices","tensorScatterupdate","int32"),r=We(t,"updates","tensorScatterupdate");if(Wk(r,i,n.shape),n.dtype!==r.dtype)throw new Error("tensor and updates must have the same dtype, instead they are "+n.dtype+" and "+r.dtype+".");const a={tensor:n,indices:i,updates:r},s={};return it.runKernel(fV,a,s)}mt({tensorScatterUpdate_:d7});function f7(x,e=0){const t=We(x,"x","unstack","string_or_numeric");ye(e>=-t.shape.length&&e<t.shape.length,()=>"Axis = "+e+" is not in [-"+t.shape.length+", "+t.shape.length+")");const n={value:t},i={axis:e};return it.runKernel(yV,n,i)}const Og=mt({unstack_:f7});function bU(x,e){const t=[];for(let r=0;r<e.length;r++)e[r]&&t.push(r);const n=kx(x,"int32"),i=kx([t.length,x.length],"int32");for(let r=0;r<t.length;r++){const a=n.indexToLoc(t[r]),s=r*x.length;i.values.set(a,s)}return i.toTensor()}function p7(x,e,t,n,i,r="NHWC",a){let s=x;x.rank===3&&(s=x0(x,[1,x.shape[0],x.shape[1],x.shape[2]]));let l=e;l.rank===3&&(l=x0(e,[1,e.shape[0],e.shape[1],e.shape[2]])),ye(s.rank===4,()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+s.shape+"."),ye(l.rank===4,()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+l.shape+"."),ye(t.length===4,()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+t+".");const c=r==="NHWC"?s.shape[3]:s.shape[1],h=r==="NHWC"?l.shape[3]:l.shape[1];ye(c===t[2],()=>"Error in conv2dDerFilter: depth of input "+c+") must match input depth in filter ("+t[2]+"."),ye(h===t[3],()=>"Error in conv2dDerFilter: depth of dy ("+h+") must match output depth for filter ("+t[3]+")."),Vo("conv2dDerFilter",i,a);const d={x:s,dy:l},p={strides:n,pad:i,dataFormat:r,dimRoundingMode:a,filterShape:t};return it.runKernel(q5,d,p)}const m7=mt({conv2DBackpropFilter_:p7});function Dg(x,e,t){if(t==null||t==="linear")return x;if(t==="relu")return Ji(x,l7(e));throw new Error("Cannot compute gradient for fused activation "+t+".")}function Pg(x,e){let t=e;const n=Hk(x.shape,e.shape);return n.length>0&&(t=Rr(t,n)),x0(t,x.shape)}function kg(x,e,t,n){if(e==="linear")return x;if(e==="relu")return gU(x);if(e==="elu")return q8(x);if(e==="relu6")return vU(x);if(e==="prelu")return cU(x,t);if(e==="leakyrelu")return SH(x,n);if(e==="sigmoid")return KA(x);throw new Error("Unknown fused activation "+e+".")}const Ug=(x,e)=>!(x>0)||e==="linear";function y7({x,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:s,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(l=l||"linear",Ug(it.state.gradientDepth,l)===!1){ye(i==="NHWC",()=>"Error in fused conv2d: got dataFormat of "+i+" but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");let R=eU(x,e,t,n,i,r,a);return s!=null&&(R=Qi(R,s)),kg(R,l,c,h)}const d=We(x,"x","conv2d","float32"),p=We(e,"filter","conv2d","float32");let m=d,g=!1;d.rank===3&&(g=!0,m=x0(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ye(m.rank===4,()=>"Error in fused conv2d: input must be rank 4, but got rank "+m.rank+"."),ye(p.rank===4,()=>"Error in fused conv2d: filter must be rank 4, but got rank "+p.rank+"."),Vo("fused conv2d",n,a);const _=i==="NHWC"?m.shape[3]:m.shape[1];ye(p.shape[2]===_,()=>"Error in conv2d: depth of input ("+_+") must match input depth for filter "+p.shape[2]+"."),ye(Fr(t,r),()=>"Error in conv2D: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+r+"'");const v=Ur(m.shape,p.shape,t,r,n,a);let b;s!=null&&(b=We(s,"bias","fused conv2d"),[b]=jn(b,d),i==="NHWC"?tn(v.outShape,b.shape):(ye(b.shape.length<=1,()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-"+b.shape.length+"."),ye(b.shape.length===0||b.shape[0]===v.outChannels||b.shape[0]===1,()=>"Error in fused conv2d: bias shape ("+b.shape+") is not compatible with the number of output channels ("+v.outChannels+")")));let T;if(c!=null){const R=c.shape;if(ye(R.length<=1||R.length===3,()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-"+R.length+"."),R.length===1)ye(R[0]===1||R[0]===v.outChannels,()=>"Error in fused conv2d: PReLU activation weights ("+R+") is not compatible with the number of output channels ("+v.outChannels+").");else if(R.length===3)try{tn(R,v.outShape)}catch{const k="Error in fused conv2d: PReLU activation weights ("+R+") is not compatible with the output shape of the conv2d ("+v.outShape+").";throw Error(k)}T=We(c,"prelu weights","fused conv2d")}const E=(R,C)=>{ye(i==="NHWC",()=>"Error in gradient of fused conv2D: got dataFormat of "+i+" but only NHWC is currently supported.");const[k,P,N,G]=C,te=Dg(R,N,l);ye(Xf(r),()=>"Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '"+r+"'");const j=tU(P.shape,te,k,t,n),xe=m7(P,te,k.shape,t,n),ae=[j,xe];if(G!=null){const H=Pg(G,te);ae.push(H)}return ae},A={x:m,filter:p,bias:b,preluActivationWeights:T},M={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:h};return s==null?Ah((R,C,k)=>{let P=it.runKernel(S1,A,M);return k([C,R,P]),g&&(P=x0(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:E}})(m,p):Ah((R,C,k,P)=>{let N=it.runKernel(S1,A,M);return P([C,R,N,k]),g&&(N=x0(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:E}})(m,p,b)}const g7=mt({fusedConv2d_:y7});function v7(x,e,t,n,i,r=[1,1],a){let s=x;x.rank===3&&(s=x0(x,[1,x.shape[0],x.shape[1],x.shape[2]]));let l=e;l.rank===3&&(l=x0(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:s,dy:l},h={strides:n,pad:i,dimRoundingMode:a,dilations:r,filterShape:t};return it.runKernel(eV,c,h)}const b7=mt({depthwiseConv2dNativeBackpropFilter_:v7});function _7(x,e,t,n,i,r=[1,1],a){let s=e,l=!1;e.rank===3&&(l=!0,s=x0(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:s,filter:t},h={strides:n,pad:i,dimRoundingMode:a,dilations:r,inputShape:x},d=it.runKernel(tV,c,h);return l?x0(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const S7=mt({depthwiseConv2dNativeBackpropInput_:_7});function T7({x,filter:e,strides:t,pad:n,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:s,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:h}){if(Ug(it.state.gradientDepth,l)===!1){let M=xU(x,e,t,n,i,r,a);return s!=null&&(M=Qi(M,s)),kg(M,l,c,h)}const d=We(x,"x","depthwiseConv2d","float32"),p=We(e,"filter","depthwiseConv2d","float32");let m=d,g=!1;d.rank===3&&(g=!0,m=x0(d,[1,d.shape[0],d.shape[1],d.shape[2]])),ye(m.rank===4,()=>"Error in fused depthwiseConv2d: input must be rank 4, but got rank "+m.rank+"."),ye(p.rank===4,()=>"Error in fused depthwiseConv2d: filter must be rank 4, but got rank "+p.rank+"."),ye(m.shape[3]===p.shape[2],()=>"Error in fused depthwiseConv2d: number of input channels ("+m.shape[3]+") must match the inChannels dimension in filter "+p.shape[2]+"."),r==null&&(r=[1,1]),ye(Fr(t,r),()=>"Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides "+t+" and dilations '"+r+"'"),Vo("fused depthwiseConv2d",n,a);const _=Ur(m.shape,p.shape,t,r,n,a,!0);let v;s!=null&&(v=We(s,"bias","fused conv2d"),[v]=jn(v,d),tn(_.outShape,v.shape));let b;c!=null&&(b=We(c,"prelu weights","fused depthwiseConv2d"));const T=(M,R)=>{ye(Xf(r),()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '"+r+"'");const[C,k,P,N]=R,G=Dg(M,P,l),te=S7(k.shape,G,C,t,n,r,a),j=b7(k,G,C.shape,t,n,r,a);if(N!=null){const xe=Pg(v,G);return[te,j,xe]}return[te,j]},E={x:m,filter:p,bias:v,preluActivationWeights:b},A={strides:t,pad:n,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:h};return s==null?Ah((M,R,C)=>{let k=it.runKernel(T1,E,A);return C([R,M,k]),g&&(k=x0(k,[k.shape[1],k.shape[2],k.shape[3]])),{value:k,gradFunc:T}})(m,p):Ah((M,R,C,k)=>{let P=it.runKernel(T1,E,A);return k([R,M,P,C]),g&&(P=x0(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:T}})(m,p,v)}const w7=mt({fusedDepthwiseConv2d_:T7});function A7({a:x,b:e,transposeA:t=!1,transposeB:n=!1,bias:i,activation:r="linear",preluActivationWeights:a,leakyreluAlpha:s=.2}){if(Ug(it.state.gradientDepth,r)===!1){let N=bs(x,e,t,n);return i!=null&&(N=Qi(N,i)),kg(N,r,a,s)}let l=We(x,"a","fused matMul"),c=We(e,"b","fused matMul");[l,c]=jn(l,c);const h=t?l.shape[l.rank-2]:l.shape[l.rank-1],d=n?c.shape[c.rank-1]:c.shape[c.rank-2],p=t?l.shape[l.rank-1]:l.shape[l.rank-2],m=n?c.shape[c.rank-2]:c.shape[c.rank-1],g=l.shape.slice(0,-2),_=c.shape.slice(0,-2),v=ut(g),b=ut(_);ye(h===d,()=>"Error in fused matMul: inner shapes ("+h+") and ("+d+") of Tensors with shapes "+l.shape+" and "+c.shape+" and transposeA="+t+" and transposeB="+n+" must match.");const T=tn(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,m]),E=t?x0(l,[v,h,p]):x0(l,[v,p,h]),A=n?x0(c,[b,m,d]):x0(c,[b,d,m]);let M;i!=null&&(M=We(i,"bias","fused matMul"),[M]=jn(M,l),tn(T,M.shape));let R;a!=null&&(R=We(a,"prelu weights","fused matMul"));const C=(N,G)=>{const[te,j,xe,ae]=G,H=Dg(x0(N,xe.shape),xe,r);let re,q;if(!t&&!n?(re=bs(H,j,!1,!0),q=bs(te,H,!0,!1)):!t&&n?(re=bs(H,j,!1,!1),q=bs(H,te,!0,!1)):t&&!n?(re=bs(j,H,!1,!0),q=bs(te,H,!1,!1)):(re=bs(j,H,!0,!0),q=bs(H,te,!0,!0)),i!=null){const be=Pg(ae,H);return[re,q,be]}else return[re,q]},k={a:E,b:A,bias:M,preluActivationWeights:R},P={transposeA:t,transposeB:n,activation:r,leakyreluAlpha:s};return i==null?Ah((N,G,te)=>{const j=it.runKernel(_1,k,P);return te([N,G,j]),{value:x0(j,T),gradFunc:C}})(E,A):Ah((N,G,te,j)=>{const xe=it.runKernel(_1,k,P);return j([N,G,xe,te]),{value:x0(xe,T),gradFunc:C}})(E,A,M)}const E7=mt({fusedMatMul_:A7});function M7(x,e,t,n,i="bilinear",r=0){const a=We(x,"image","cropAndResize"),s=We(e,"boxes","cropAndResize","float32"),l=We(t,"boxInd","cropAndResize","int32"),c=s.shape[0];ye(a.rank===4,()=>"Error in cropAndResize: image must be rank 4,but got rank "+a.rank+"."),ye(s.rank===2&&s.shape[1]===4,()=>"Error in cropAndResize: boxes must be have size ["+c+",4] but had shape "+s.shape+"."),ye(l.rank===1&&l.shape[0]===c,()=>"Error in cropAndResize: boxInd must be have size ["+c+"] but had shape "+s.shape+"."),ye(n.length===2,()=>"Error in cropAndResize: cropSize must be of length 2, but got length "+n.length+"."),ye(n[0]>=1&&n[1]>=1,()=>"cropSize must be atleast [1,1], but was "+n),ye(i==="bilinear"||i==="nearest",()=>"method must be bilinear or nearest, but was "+i);const h={image:a,boxes:s,boxInd:l},d={method:i,extrapolationValue:r,cropSize:n};return it.runKernel(lA,h,d)}const R7=mt({cropAndResize_:M7});function C7(x){const e=We(x,"image","flipLeftRight","float32");ye(e.rank===4,()=>"Error in flipLeftRight: image must be rank 4,but got rank "+e.rank+".");const t={image:e};return it.runKernel(nV,t,{})}const N7=mt({flipLeftRight_:C7});function I7(x){const e=We(x,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];ye(e.rank>=2,()=>"Error in grayscaleToRGB: images must be at least rank 2, but got rank "+e.rank+"."),ye(n===1,()=>"Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size "+n+".");const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,rU(e,i)}const O7=mt({grayscaleToRGB_:I7});function D7(x){const e=We(x,"image","RGBToGrayscale"),t=e.rank-1,n=e.shape[t];ye(e.rank>=2,()=>"Error in RGBToGrayscale: images must be at least rank 2, but got rank "+e.rank+"."),ye(n===3,()=>"Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size "+n+".");const i=e.dtype,r=Or(e,"float32"),a=ji([.2989,.587,.114]);let s;switch(e.rank){case 2:s=af("ij,j->i",r,a);break;case 3:s=af("ijk,k->ij",r,a);break;case 4:s=af("ijkl,l->ijk",r,a);break;case 5:s=af("ijklm,m->ijkl",r,a);break;case 6:s=af("ijklmn,n->ijklm",r,a);break;default:throw new Error("Not a valid tensor rank.")}return s=ZA(s,-1),Or(s,i)}const P7=mt({rgbToGrayscale_:D7});function k7(x,e,t=0,n=.5){const i=We(x,"image","rotateWithOffset","float32");ye(i.rank===4,()=>"Error in rotateWithOffset: image must be rank 4,but got rank "+i.rank+".");const r={image:i},a={radians:e,fillValue:t,center:n};return it.runKernel(DA,r,a)}const U7=mt({rotateWithOffset_:k7});function Jh(x,e,t,n,i,r){n==null&&(n=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const a=x.shape[0];return t=Math.min(t,a),ye(0<=n&&n<=1,()=>"iouThreshold must be in [0, 1], but was '"+n+"'"),ye(x.rank===2,()=>"boxes must be a 2D tensor, but was of rank '"+x.rank+"'"),ye(x.shape[1]===4,()=>"boxes must have 4 columns, but 2nd dimension was "+x.shape[1]),ye(e.rank===1,()=>"scores must be a 1D tensor"),ye(e.shape[0]===a,()=>"scores has incompatible shape with boxes. Expected "+a+", but was "+e.shape[0]),ye(0<=r&&r<=1,()=>"softNmsSigma must be in [0, 1], but was '"+r+"'"),{maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:r}}function F7(x,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const r=We(x,"boxes","nonMaxSuppression","float32"),a=We(e,"scores","nonMaxSuppression","float32"),s=Jh(r,a,t,n,i);t=s.maxOutputSize,n=s.iouThreshold,i=s.scoreThreshold;const l={maxOutputSize:t,iouThreshold:n,scoreThreshold:i};return it.runKernel(oV,{boxes:r,scores:a},l)}const B7=mt({nonMaxSuppression_:F7});function L7(x,e,t){const n=z7(x,e,t),i=n<0?-(n+1):n;x.splice(i,0,e)}function z7(x,e,t){return H7(x,e,t||V7)}function V7(x,e){return x>e?1:x<e?-1:0}function H7(x,e,t){let n=0,i=x.length,r=0,a=!1;for(;n<i;){r=n+(i-n>>>1);const s=t(e,x[r]);s>0?n=r+1:(i=r,a=!s)}return a?n:-n-1}function G7(x,e,t,n,i){return JA(x,e,t,n,i,0)}function W7(x,e,t,n,i,r){return JA(x,e,t,n,i,0,!1,r,!0)}function X7(x,e,t,n,i,r){return JA(x,e,t,n,i,r,!0)}function JA(x,e,t,n,i,r,a=!1,s=!1,l=!1){const c=[];for(let v=0;v<e.length;v++)e[v]>i&&c.push({score:e[v],boxIndex:v,suppressBeginIndex:0});c.sort(M3);const h=r>0?-.5/r:0,d=[],p=[];for(;d.length<t&&c.length>0;){const v=c.pop(),{score:b,boxIndex:T,suppressBeginIndex:E}=v;if(b<i)break;let A=!1;for(let M=d.length-1;M>=E;--M){const R=Y7(x,T,d[M]);if(R>=n){A=!0;break}if(v.score=v.score*K7(n,h,R),v.score<=i)break}v.suppressBeginIndex=d.length,A||(v.score===b?(d.push(T),p.push(v.score)):v.score>i&&L7(c,v,M3))}const m=d.length,g=t-m;s&&g>0&&(d.push(...new Array(g).fill(0)),p.push(...new Array(g).fill(0)));const _={selectedIndices:d};return a&&(_.selectedScores=p),l&&(_.validOutputs=m),_}function Y7(x,e,t){const n=x.subarray(e*4,e*4+4),i=x.subarray(t*4,t*4+4),r=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),s=Math.max(n[0],n[2]),l=Math.max(n[1],n[3]),c=Math.min(i[0],i[2]),h=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),p=Math.max(i[1],i[3]),m=(s-r)*(l-a),g=(d-c)*(p-h);if(m<=0||g<=0)return 0;const _=Math.max(r,c),v=Math.max(a,h),b=Math.min(s,d),T=Math.min(l,p),E=Math.max(b-_,0)*Math.max(T-v,0);return E/(m+g-E)}function K7(x,e,t){const n=Math.exp(e*t*t);return t<=x?n:0}function M3(x,e){return x.score-e.score||x.score===e.score&&e.boxIndex-x.boxIndex}async function $7(x,e,t,n=.5,i=Number.NEGATIVE_INFINITY){const r=We(x,"boxes","nonMaxSuppressionAsync"),a=We(e,"scores","nonMaxSuppressionAsync"),s=Jh(r,a,t,n,i);t=s.maxOutputSize,n=s.iouThreshold,i=s.scoreThreshold;const l=await Promise.all([r.data(),a.data()]),c=l[0],h=l[1],{selectedIndices:d}=G7(c,h,t,n,i);return r!==x&&r.dispose(),a!==e&&a.dispose(),ji(d,"int32")}const Q7=$7;function Z7(x,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=We(x,"boxes","nonMaxSuppression"),s=We(e,"scores","nonMaxSuppression"),l=Jh(a,s,t,n,i,r);t=l.maxOutputSize,n=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c={boxes:a,scores:s},h={maxOutputSize:t,iouThreshold:n,scoreThreshold:i,softNmsSigma:r},d=it.runKernel(cV,c,h);return{selectedIndices:d[0],selectedScores:d[1]}}const J7=mt({nonMaxSuppressionWithScore_:Z7});async function j7(x,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=We(x,"boxes","nonMaxSuppressionAsync"),s=We(e,"scores","nonMaxSuppressionAsync"),l=Jh(a,s,t,n,i,r);t=l.maxOutputSize,n=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c=await Promise.all([a.data(),s.data()]),h=c[0],d=c[1],{selectedIndices:p,selectedScores:m}=X7(h,d,t,n,i,r);return a!==x&&a.dispose(),s!==e&&s.dispose(),{selectedIndices:ji(p,"int32"),selectedScores:ji(m)}}const q7=j7;function eG(x,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=We(x,"boxes","nonMaxSuppression"),s=We(e,"scores","nonMaxSuppression"),l=Jh(a,s,t,n,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,p={boxes:a,scores:s},m={maxOutputSize:c,iouThreshold:h,scoreThreshold:d,padToMaxOutputSize:r},g=it.runKernel(lV,p,m);return{selectedIndices:g[0],validOutputs:g[1]}}const tG=mt({nonMaxSuppressionPadded_:eG});async function xG(x,e,t,n=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=We(x,"boxes","nonMaxSuppressionAsync"),s=We(e,"scores","nonMaxSuppressionAsync"),l=Jh(a,s,t,n,i,null),c=l.maxOutputSize,h=l.iouThreshold,d=l.scoreThreshold,[p,m]=await Promise.all([a.data(),s.data()]),{selectedIndices:g,validOutputs:_}=W7(p,m,c,h,d,r);return a!==x&&a.dispose(),s!==e&&s.dispose(),{selectedIndices:ji(g,"int32"),validOutputs:$a(_,"int32")}}const nG=xG;function iG(x,e,t=!1,n=!1){const i=We(x,"images","resizeBilinear");ye(i.rank===3||i.rank===4,()=>"Error in resizeBilinear: x must be rank 3 or 4, but got rank "+i.rank+"."),ye(e.length===2,()=>"Error in resizeBilinear: new shape must 2D, but got shape "+e+"."),ye(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=x0(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const s={images:r},l={alignCorners:t,halfPixelCenters:n,size:e},c=it.runKernel(MA,s,l);return a?x0(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const _U=mt({resizeBilinear_:iG});function rG(x,e,t=!1,n=!1){const i=We(x,"images","resizeNearestNeighbor");ye(i.rank===3||i.rank===4,()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank "+i.rank+"."),ye(e.length===2,()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+e+"."),ye(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),ye(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=x0(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const s={images:r},l={alignCorners:t,halfPixelCenters:n,size:e},c=it.runKernel(hV,s,l);return a?x0(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const aG=mt({resizeNearestNeighbor_:rG});function sG(x,e="binary",t=!1,n=.5){const i=We(x,"image","threshold"),r=.2989,a=.587,s=.114,l=i.shape[0]*i.shape[1];let c=Ji(ji([n]),255),h,d,p,m;if(ye(i.rank===3,()=>"Error in threshold: image must be rank 3,but got rank "+i.rank+"."),ye(i.shape[2]===3||i.shape[2]===1,()=>"Error in threshold: image color channel must be equal to 3 or 1but got "+i.shape[2]+"."),ye(i.dtype==="int32"||i.dtype==="float32",()=>"Error in dtype: image dtype must be int32 or float32,but got dtype "+i.dtype+"."),ye(e==="otsu"||e==="binary",()=>"Method must be binary or otsu, but was "+e),i.shape[2]===3){[h,d,p]=r7(i,[1,1,1],-1);const _=Ji(h,r),v=Ji(d,a),b=Ji(p,s);m=Qi(Qi(_,v),b)}else m=x;if(e==="otsu"){const _=P8(Or(e7(m),"int32"),Y2([]),256);c=oG(_,l)}const g=t?sU(m,c):aU(m,c);return Or(Ji(g,255),"int32")}function oG(x,e){let t=ji([-1]),n=ji([0]),i=ji([0]),r,a,s,l,c,h;for(let d=0;d<x.size-1;d++){r=wr(x,0,d+1),a=wr(x,d+1),c=Va(Rr(r),e),h=Va(Rr(a),e);const p=Rr(Ji(r,dT(0,r.size)));s=Va(p,Rr(r));const m=$A(a.shape,r.size),g=Qi(dT(0,a.size),m),_=Ji(a,g);l=Va(Rr(_),Rr(a));const v=Eh(s,l),b=Eh(s,l),T=Ji(c,h);i=Ji(Ji(T,v),b);const E=aU(i,n);n=A3(E,i,n),t=A3(E,ji([d]),t)}return t}const lG=mt({threshold_:sG});function cG(x,e,t="nearest",n="constant",i=0,r){const a=We(x,"image","transform","float32"),s=We(e,"transforms","transform","float32");ye(a.rank===4,()=>"Error in transform: image must be rank 4,but got rank "+a.rank+"."),ye(s.rank===2&&(s.shape[0]===a.shape[0]||s.shape[0]===1)&&s.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),ye(r==null||r.length===2,()=>"Error in transform: outputShape must be [height, width] or null, but got "+r+".");const l={image:a,transforms:s},c={interpolation:t,fillMode:n,fillValue:i,outputShape:r};return it.runKernel(IA,l,c)}const uG=mt({transform_:cG});var R3;(function(x){x[x.NONE=0]="NONE",x[x.MEAN=1]="MEAN",x[x.SUM=2]="SUM",x[x.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(R3||(R3={}));const E1={flipLeftRight:N7,grayscaleToRGB:O7,resizeNearestNeighbor:aG,resizeBilinear:_U,rgbToGrayscale:P7,rotateWithOffset:U7,cropAndResize:R7,nonMaxSuppression:B7,nonMaxSuppressionAsync:Q7,nonMaxSuppressionWithScore:J7,nonMaxSuppressionWithScoreAsync:q7,nonMaxSuppressionPadded:tG,nonMaxSuppressionPaddedAsync:nG,threshold:lG,transform:uG},hG=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:x=>x();function dG(){return new Promise(x=>hG(()=>x()))}function jA(x,e){const t=x[0].length;x.forEach((i,r)=>{ye(i.length===t,()=>"Error in concat"+t+"D: rank of tensors["+r+"] must be the same as the rank of the rest ("+t+")")}),ye(e>=0&&e<t,()=>"Error in concat"+t+"D: axis must be between 0 and "+(t-1)+".");const n=x[0];x.forEach((i,r)=>{for(let a=0;a<t;a++)ye(a===e||i[a]===n[a],()=>"Error in concat"+t+"D: Shape of tensors["+r+"] ("+i+") does not match the shape of the rest ("+n+") along the non-concatenated axis "+r+".")})}function As(x,e){const t=x[0].slice();for(let n=1;n<x.length;n++)t[e]+=x[n][e];return t}var Ha;(function(x){x[x.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",x[x.VALUE_ROWIDS=1]="VALUE_ROWIDS",x[x.ROW_LENGTHS=2]="ROW_LENGTHS",x[x.ROW_SPLITS=3]="ROW_SPLITS",x[x.ROW_LIMITS=4]="ROW_LIMITS",x[x.ROW_STARTS=5]="ROW_STARTS"})(Ha||(Ha={}));function SU(x,e,t){let n=new Array;if(t==null&&e==null)return n;if(e==null)for(;n.length<x+t.length;)n.push(-1);else n=e.slice();if(t==null)return n;if(x+t.length!==n.length)throw new Error("rt input.shape and shape="+e+" are incompatible: rt input.rank = "+(x+t.length)+", but shape.rank = "+n.length);for(let i=1;i<t.length;++i){const r=t[i],a=n[n.length-t.length+i],s=n[a];if(r>=0)if(s>=0){if(s!==r)throw new Error("rt input.shape and shape="+e+" are incompatible: rt input.shape["+(i+x)+"] = "+r+" but shape["+(i+x)+"] = "+s)}else n[a]=r}return n}function TU(x){const e={FIRST_DIM_SIZE:Ha.FIRST_DIM_SIZE,VALUE_ROWIDS:Ha.VALUE_ROWIDS,ROW_LENGTHS:Ha.ROW_LENGTHS,ROW_SPLITS:Ha.ROW_SPLITS,ROW_LIMITS:Ha.ROW_LIMITS,ROW_STARTS:Ha.ROW_STARTS},t=[];for(const n of x)if(n in e)t.push(e[n]);else break;return t}function wU(x){return x.length===0?0:x[0]===Ha.FIRST_DIM_SIZE?x.length-1:x.length}function AU(x,e){if(x==null||e==null)return;const t=x.length,n=e.length;if(t>=n)throw new Error("defaultValue.shape="+x+" and ragged tensor flatValues.shape="+e+", are incompatible: defaultValue.rank = "+t+" must be less than ragged tensor input flatValues.rank = "+n+")");for(let i=0;i<Math.min(t,n-1);++i){const r=x[i],a=e[i+1];if(r>=0&&a>=0&&r!==1&&r!==a)throw new Error("defaultValue.shape="+x+", and ragged tensor input flatValues.shape="+e+" are incompatible: defaultValue.shape["+(i-x.length)+"] = "+r+" but ragged tensor input.flatValues.shape["+(i-x.length)+"] = "+a)}}const qA=30;function EU(x){return x<=qA?x:KS(x,Math.floor(Math.sqrt(x)))}function eE(x,e,t){const n=t*(typeof x=="number"?x:x[0]),i=e*(typeof x=="number"?x:x[1]);return[n,i]}function fG(x,e,t,n=!0){let i=[];if(n)i=i.concat(e.slice(0)),i.push(x[0]/t),i=i.concat(x.slice(1));else{i=i.concat(x[0]);const r=e.length;for(let a=0;a<r;++a)i=i.concat([x[a+1]/e[a],e[a]]);i=i.concat(x.slice(r+1))}return i}function pG(x,e,t=!0){const n=[];if(t){n.push(e);for(let i=e+1;i<x;++i)i<=2*e?(n.push(i),n.push(i-(e+1))):n.push(i)}else{const i=[],r=[];for(let a=1;a<x;++a)a>=e*2+1||a%2===1?r.push(a):i.push(a);n.push(...i),n.push(0),n.push(...r)}return n}function mG(x,e,t,n=!0){const i=[];n?i.push(x[0]/t):i.push(x[0]*t);for(let r=1;r<x.length;++r)r<=e.length?n?i.push(e[r-1]*x[r]):i.push(x[r]/e[r-1]):i.push(x[r]);return i}function yG(x,e){const t=[0];for(let n=0;n<e;++n)t.push(x[n][0]);return t}function gG(x,e,t){const n=x.slice(0,1);for(let i=0;i<t;++i)n.push(x[i+1]-e[i][0]-e[i][1]);return n}const vG=1.7580993408473768,bG=1.0507009873554805,_G=.3275911,SG=.254829592,TG=-.284496736,wG=1.421413741,AG=-1.453152027,EG=1.061405429;function Mh(x,e){if(x.length!==e.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+x.length+", imag: "+e.length+".");const t=new Float32Array(x.length*2);for(let n=0;n<t.length;n+=2)t[n]=x[n/2],t[n+1]=e[n/2];return t}function MG(x){const e=new Float32Array(x.length/2),t=new Float32Array(x.length/2);for(let n=0;n<x.length;n+=2)e[n/2]=x[n],t[n/2]=x[n+1];return{real:e,imag:t}}function RG(x){const e=Math.ceil(x.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let i=0;i<x.length;i+=4)t[Math.floor(i/4)]=x[i],n[Math.floor(i/4)]=x[i+1];return{real:t,imag:n}}function CG(x){const e=Math.floor(x.length/4),t=new Float32Array(e),n=new Float32Array(e);for(let i=2;i<x.length;i+=4)t[Math.floor(i/4)]=x[i],n[Math.floor(i/4)]=x[i+1];return{real:t,imag:n}}function NG(x,e){const t=x[e*2],n=x[e*2+1];return{real:t,imag:n}}function IG(x,e,t,n){x[n*2]=e,x[n*2+1]=t}function OG(x,e){const t=new Float32Array(x/2),n=new Float32Array(x/2);for(let i=0;i<Math.ceil(x/2);i++){const r=(e?2:-2)*Math.PI*(i/x);t[i]=Math.cos(r),n[i]=Math.sin(r)}return{real:t,imag:n}}function DG(x,e,t){const n=(t?2:-2)*Math.PI*(x/e),i=Math.cos(n),r=Math.sin(n);return{real:i,imag:r}}const m_="->",PG=/->/g,C3=",",N3="...";function kG(x,e){x=x.replace(/\s/g,"");const t=(x.length-x.replace(PG,"").length)/m_.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error('Equation must contain exactly one arrow ("'+m_+'").');const[n,i]=x.split(m_);ye(n.indexOf(N3)===-1,()=>'The ellipsis notation ("'+N3+'") is not supported yet.');const r=n.split(C3),a=r.length;if(e!==a)throw new Error("Expected "+a+" input tensors, received "+e);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const s=[];for(let p=0;p<i.length;++p){const m=i[p];if(!r.some(g=>g.indexOf(m)!==-1))throw new Error("Output subscripts contain the label "+m+" not present in the input subscripts.");s.indexOf(m)===-1&&s.push(m)}for(let p=0;p<n.length;++p){const m=n[p];s.indexOf(m)===-1&&m!==C3&&s.push(m)}const l=new Array(r.length);for(let p=0;p<a;++p){if(new Set(r[p].split("")).size!==r[p].length)throw new Error("Found duplicate axes in input component "+r[p]+". Support for duplicate axes in input is not implemented yet.");l[p]=[];for(let m=0;m<r[p].length;++m)l[p].push(s.indexOf(r[p][m]))}const c=s.length,h=i.length,d=[];for(let p=h;p<c;++p)d.push(p);return{allDims:s,summedDims:d,idDims:l}}function UG(x,e){let t=new Array(x);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const n=[];for(let i=0;i<x;++i)t[i]===-1&&n.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:n}}function FG(x,e,t){const n=new Array(x);for(let i=0;i<t.length;++i){const r=t[i].shape;for(let a=0;a<e[i].length;++a)n[e[i][a]]===void 0?n[e[i][a]]=r[a]:ye(n[e[i][a]]===r[a],()=>"Expected dimension "+n[e[i][a]]+" at axis "+a+" of input shaped "+JSON.stringify(r)+", but got dimension "+r[a])}}function BG(x,e){const t=x,n=[];let i=0;x.length===0&&t.push(-1),i=x.length+1;for(let a=0;a<i;++a)n.push([]);const r=[];for(let a=0;a<t.length;++a){const s=t[a],l=zG(e,s);for(const c of l)r.indexOf(c)===-1&&(n[a].push(c),r.push(c))}return{path:t,steps:n}}function LG(x){return x.every((e,t)=>e===t)}function zG(x,e){const t=[];for(let n=0;n<x.length;++n)(x[n].length===0||x[n].indexOf(e)!==-1||e===-1)&&t.push(n);return t}function VG(x,e,t=0){let n=[];if(typeof e=="number")ye(x.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),n=new Array(e).fill(x.shape[t]/e);else{const i=e.reduce((a,s)=>(s===-1&&(a+=1),a),0);ye(i<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(r!==-1){const a=e.reduce((s,l)=>l>0?s+l:s);e[r]=x.shape[t]-a}ye(x.shape[t]===e.reduce((a,s)=>a+s),()=>"The sum of sizes must match the size of the axis dimension."),n=e}return n}function MU(x){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = `+x}function RU(x,e){return"indices("+x+", 0) is invalid: "+e+" < 0"}function CU(x,e,t){return"indices("+x+", 0) is invalid: "+e+" >= "+t}function NU(x,e){return"only one output dimension may be -1, not both "+x+" and "+e}function IU(x,e){return"size "+x+" must be non-negative, not "+e}function OU(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function DU(x,e){const t=ut(x),n=ut(e);return"Input to reshape is a SparseTensor with "+t+`
  dense values, but the requested shape requires a multiple of `+n+". inputShape="+x+" outputShape= "+e}function PU(x,e){const t=ut(x),n=ut(e);return"Input to reshape is a tensor with "+t+" dense values, but the requested shape has "+n+". inputShape="+x+" outputShape="+e}function fT(){return"segment ids must be >= 0"}function kU(){return"segment ids are not increasing"}function UU(x,e){return"Segment id "+x+" out of range [0, "+e+"), possibly because segmentIds input is not sorted."}function FU(x,e,t){return"Bad: indices["+x+"] == "+e+" out of range [0, "+t+")"}function HG(x,e){let t=!1,n;for(x<=qA?(n=x,t=!0):n=KS(x,Math.floor(Math.sqrt(x)));!t;)n>e||n===x?t=!0:n=KS(x,n+1);return n}function GG(x,e,t){const n=[],i=x.length;for(let r=0;r<i;r++)r!==e?n.push(x[r]):n.push(t);return n}function tE(x,e,t,n){const i=e.shape.length,r=x.shape.length;if(n!==0&&(n<-i||n>i))throw new Error("Expect batchDims in the range of [-"+i+", "+i+"], but got "+n);if(n<0&&(n+=i),n>r)throw new Error("batchDims ("+n+`) must be less than rank(x) (
    `+r+").");if(t<n)throw new Error("batchDims ("+n+") must be less than or equal to axis ("+t+").");for(let d=0;d<n;++d)if(x.shape[d]!==e.shape[d])throw new Error("x.shape["+d+"]: "+x.shape[d]+" should be equal to indices.shape["+d+"]: "+e.shape[d]+".");const a=x.shape[t],s=[];let l=1,c=1,h=1;for(let d=0;d<n;++d)s.push(x.shape[d]),l*=x.shape[d];for(let d=n;d<t;d++)s.push(x.shape[d]),c*=x.shape[d];for(let d=n;d<i;d++)s.push(e.shape[d]);for(let d=t+1;d<r;d++)s.push(x.shape[d]),h*=x.shape[d];return{batchSize:l,sliceSize:h,outerSize:c,dimSize:a,outputShape:s}}var WG=Object.freeze({__proto__:null,collectGatherOpShapeInfo:tE,computeOutShape:GG,segOpComputeOptimalWindowSize:HG});function q2(x){try{return x.map(e=>Sh(e))}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8, error: "+e)}}function BU(x){return x.map(e=>X2(e))}var XG=Object.freeze({__proto__:null,ERF_A1:SG,ERF_A2:TG,ERF_A3:wG,ERF_A4:AG,ERF_A5:EG,ERF_P:_G,PARALLELIZE_THRESHOLD:qA,get RowPartitionType(){return Ha},SELU_SCALE:bG,SELU_SCALEALPHA:vG,applyActivation:kg,assertAndGetBroadcastShape:tn,assertAxesAreInnerMostDims:sl,assertParamsConsistent:jA,assignToTypedArray:IG,axesAreInnerMostDims:QA,calculateShapes:i8,checkEinsumDimSizes:FG,checkPadOnDimRoundingMode:Vo,combineLocations:nU,combineRaggedTensorToTensorShapes:SU,complexWithEvenIndex:RG,complexWithOddIndex:CG,computeConv2DInfo:Ur,computeConv3DInfo:qk,computeDefaultPad:YA,computeDilation2DInfo:b8,computeOptimalWindowSize:EU,computeOutAndReduceShapes:Is,computeOutShape:As,computePool2DInfo:yp,computePool3DInfo:_8,convertConv2DDataFormat:kc,decodeEinsumEquation:kG,eitherStridesOrDilationsAreOne:Fr,expandShapeToKeepDim:Ho,exponent:DG,exponents:OG,fromStringArrayToUint8:BU,fromUint8ToStringArray:q2,getAxesPermutation:ol,getBroadcastDims:wh,getComplexWithIndex:NG,getEinsumComputePath:BG,getEinsumPermutation:UG,getFusedBiasGradient:Pg,getFusedDyActivation:Dg,getImageCenter:eE,getInnerMostAxes:ll,getPermuted:pG,getRaggedRank:wU,getReductionAxes:Hk,getReshaped:fG,getReshapedPermuted:mG,getRowPartitionTypesHelper:TU,getSliceBeginCoords:yG,getSliceSize:gG,getSparseFillEmptyRowsIndicesDenseShapeMismatch:MU,getSparseFillEmptyRowsNegativeIndexErrorMessage:RU,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:CU,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:OU,getSparseReshapeInputOutputMismatchErrorMessage:PU,getSparseReshapeInputOutputMultipleErrorMessage:DU,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:NU,getSparseReshapeNegativeOutputDimErrorMessage:IU,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:FU,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:fT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:kU,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:UU,getUndoAxesPermutation:eH,isIdentityPermutation:LG,log:vV,mergeRealAndImagArrays:Mh,prepareAndValidate:n8,prepareSplitSize:VG,segment_util:WG,shouldFuse:Ug,slice_util:l8,splitRealAndImagArrays:MG,stridesOrDilationsArePositive:uT,tupleValuesAreOne:Xf,upcastType:Rs,validateDefaultValueShape:AU,validateInput:Wk,validateUpdateShape:Gk,warn:wo});class YG{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error("Browser's encoder only supports utf-8, but got "+t);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!Pe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",n=>{if(n.source===window&&n.data.name===this.messageName){n.stopPropagation();const i=this.functionRefs[n.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return rk(e)}}if(Pe().get("IS_BROWSER")){Pe().setPlatform("browser",new YG);try{li.registerManager(Sc.URL_SCHEME,new T6)}catch{}try{li.registerManager(_c.URL_SCHEME,new p6)}catch{}}const KG={importFetch:()=>require("node-fetch")};let y_;class $G{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Pe().global.fetch!=null?Pe().global.fetch(e,t):(y_==null&&(y_=KG.importFetch()),y_(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error("Node built-in encoder only supports utf-8, but got "+t);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}Pe().get("IS_NODE")&&!Pe().get("IS_BROWSER")&&Pe().setPlatform("node",new $G),bk();const QG={buffer:kx,cast:Or,clone:Ng,print:FH};LV(QG);var ZG=Object.defineProperty,I3=Object.getOwnPropertySymbols,JG=Object.prototype.hasOwnProperty,jG=Object.prototype.propertyIsEnumerable,O3=(x,e,t)=>e in x?ZG(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,qG=(x,e)=>{for(var t in e||(e={}))JG.call(e,t)&&O3(x,t,e[t]);if(I3)for(var t of I3(e))jG.call(e,t)&&O3(x,t,e[t]);return x};class eW{constructor(e){this.model=e,this.posesMax=1,this.iouThresh=.3,this.scoreThresh=.5,this.model=e,this.modelSize=e.inputs[0].shape?{width:e.inputs[0].shape[2],height:e.inputs[0].shape[1]}:{width:224,height:224},this.modelRatio=this.modelSize.width/this.modelSize.height,this.anchorsData=this.buildAnchors(this.modelSize),this.anchorsX=ji(this.anchorsData.map(t=>t.x)),this.anchorsY=ji(this.anchorsData.map(t=>t.y))}async process(e){let t={x:0,y:0};const[n,i]=hi(()=>{const c={width:e.shape[2],height:e.shape[1]},h=c.width/c.height;let d=qG({},c),p={x:0,y:0};h>this.modelRatio?(d.height=e.shape[2]/this.modelRatio,p.y=Math.floor((d.height-e.shape[1])*.5),t.y=p.y/d.height):h<this.modelRatio&&(d.width=e.shape[1]*this.modelRatio,p.x=Math.floor((d.width-e.shape[2])*.5),t.x=p.x/d.width);const m=lU(e,[[0,0],[p.y,p.y],[p.x,p.x],[0,0]],0),g=E1.resizeBilinear(m,[this.modelSize.height,this.modelSize.width]),_=this.model.execute(g,"person"),v=Ba(wr(_,[0,0,1],[1,-1,-1])),b=Ba(wr(_,[0,0,0],[1,-1,1])),T=KA(F8(b,-100,100));return[this.decodeBoxes(v,[this.anchorsX,this.anchorsY],this.modelSize),T]}),r=await n.data(),a=await i.data();let s=[];for(let c=0;c<a.length;c++){if(a[c]<this.scoreThresh)continue;const h=r[c*12+2]-r[c*12+0],d=r[c*12+3]-r[c*12+1];h<0||d<0||s.push({box:[[r[c*12+0],r[c*12+1]],[r[c*12+2],r[c*12+3]]],points:[[r[c*12+4],r[c*12+5]],[r[c*12+6],r[c*12+7]],[r[c*12+8],r[c*12+9]],[r[c*12+10],r[c*12+11]]],score:a[c]})}if(n.dispose(),i.dispose(),s.length<1)return[];if(s.length>1){const c=h7(s.map(g=>[g.box[0][1],g.box[0][0],g.box[1][1],g.box[1][0]])),h=ji(s.map(g=>g.score)),d=await E1.nonMaxSuppressionAsync(c,h,this.posesMax,this.iouThresh,this.scoreThresh),p=await d.data();d.dispose();const m=[];for(let g=0;g<p.length;g++)m.push(s[p[g]]);s=m}if(s.length<1)return[];const l={width:1-2*t.x,height:1-2*t.y};return s.map(c=>({box:c.box.map(h=>[(h[0]-t.x)/l.width,(h[1]-t.y)/l.height]),points:c.points.map(h=>[(h[0]-t.x)/l.width,(h[1]-t.y)/l.height]),score:c.score}))}decodeBoxes(e,t,n){let i=Ba(wr(e,[0,0],[-1,1])),r=Ba(wr(e,[0,1],[-1,1])),a=Ba(wr(e,[0,2],[-1,1])),s=Ba(wr(e,[0,3],[-1,1]));i=Qi(Va(i,n.width),t[0]),r=Qi(Va(r,n.height),t[1]),a=Va(a,n.width*2),s=Va(s,n.height*2);const l=x0(Eh(i,a),[2254,1]),c=x0(Eh(r,s),[2254,1]),h=x0(Qi(i,a),[2254,1]),d=x0(Qi(r,s),[2254,1]);let p=w3([l,c,h,d],1);for(let m=0;m<4;m++){let g=Ba(wr(e,[0,4+m*2],[-1,1])),_=Ba(wr(e,[0,4+m*2+1],[-1,1]));g=x0(Qi(Va(g,n.width),t[0]),[2254,1]),_=x0(Qi(Va(_,n.height),t[1]),[2254,1]),p=w3([p,g,_],1)}return p}buildAnchors(e){const t=[8,16,32,32,32],n=[];let i=0;for(;i<5;){let r=0,a=i;for(;a<t.length&&t[a]===t[i];)r+=2,a++;const s=t[i],l=Math.ceil(e.height/s),c=Math.ceil(e.width/s);for(let h=0;h<l;++h)for(let d=0;d<c;++d)for(let p=0;p<r;++p)n.push({x:(d+.5)/c,y:(h+.5)/l});i=a}return n}async prepare(){const{width:e,height:t}=this.modelSize,n=wc([1,t,e,3]),i=this.model.execute(n,"person");await i.data(),n.dispose(),i.dispose()}dispose(){this.model.dispose(),this.anchorsX.dispose(),this.anchorsY.dispose()}}class tW{constructor(e){if(this.size=e,wk()!=="webgl")return;const{width:t,height:n}=e;this.backend=kA(),this.prog={variableNames:["maskT","prevT"],outputShape:[n,t],userCode:`
                void main() {
                    ivec2 c = getOutputCoords();
                    float mask = getMaskT(c[0], c[1]);
                    float prev = getPrevT(c[0], c[1]);
                    float t = mask - 0.5;
                    float x = t * t;
                    float alpha = 1.0 - min(
                        x * (5.74062006 + x * (-2.90180189 + x * (-30.34594285 +
                        x * (153.83657925 + x * (-387.53530186))))), 1.0);
                    float smoothed = mask + (prev - mask) * (alpha * 0.9);
                    setOutput(smoothed);
                }
        `}}process(e){var t;if(!this.backend||!this.prog)return;const n=this.backend.compileAndRun(this.prog,[e,this.prev||e]),i=ua().makeTensorFromTensorInfo(n);return(t=this.prev)==null||t.dispose(),this.prev=i,i}resize(e){const{width:t,height:n}=e;this.size={width:t,height:n},this.prog&&(this.prog.outputShape=[n,t])}reset(){var e;(e=this.prev)==null||e.dispose(),delete this.prev}async prepare(){if(!this.backend||!this.prog)return;const{width:e,height:t}=this.size,n=wc([t,e]),i=oU([t,e]),r=this.backend.compileAndRun(this.prog,[n,i]),a=ua().makeTensorFromTensorInfo(r);await a.data(),n.dispose(),i.dispose(),a.dispose()}dispose(){this.reset(),delete this.prog,delete this.backend}}class xW{constructor(e,t=!1){this.model=e,this.mask=t,this.sizeFactor=1.2,this.model=e,this.modelSize=e.inputs[0].shape?{width:e.inputs[0].shape[2],height:e.inputs[0].shape[1]}:{width:256,height:256},typeof t=="object"&&t.smooth&&(this.maskFilter=new tW(this.modelSize))}process(e,t){const[n,i]=[e.shape[1],e.shape[2]],{modelSize:r}=this;return t.map(a=>{var s;const l=[a.center[0]*i,a.center[1]*n],c=[a.top[0]*i,a.top[1]*n],h=[c[0]-l[0],c[1]-l[1]],d=Math.sqrt(h[0]*h[0]+h[1]*h[1])*this.sizeFactor,p=Math.atan2(h[0],-h[1]),m=[l[1]-d,l[0]-d,l[1]+d,l[0]+d],g=hi(()=>{const N=this.rotatedRect(e,m,p,r);return Qi(Ji(N,.5),.5)}),_=["ld_3d","world_3d","output_poseflag","activation_heatmap"];this.mask&&_.push("activation_segmentation");const[v,b,T,E,A]=this.model.execute(g,_),M=v.dataSync(),R=b.dataSync(),C=T.dataSync()[0];let k=[];for(let N=0;N<39;N++)k.push([M[N*5+0]/r.width,M[N*5+1]/r.height,M[N*5+2]/r.width]);let P;if(A){const N=E1.rotateWithOffset(A,-p),G=Ba(N),te=((s=this.maskFilter)==null?void 0:s.process(G))||G,j=Ji(te,255);P=new Uint8Array(j.dataSync()),A.dispose(),N.dispose(),G.dispose(),j.dispose()}return g.dispose(),v.dispose(),b.dispose(),T.dispose(),k=this.refinePoints(k,E),E.dispose(),{points:k,pointsData:M,metricData:R,maskData:P,score:C,center:l,top:c,radius:d,angle:p}}).map(a=>{const{points:s,pointsData:l,metricData:c,maskData:h,score:d,center:p,top:m,radius:g,angle:_}=a;let v=s.map((C,k)=>({pixel:C,metric:[c[k*3+0],c[k*3+1],c[k*3+2]],norm:[c[k*3+0],c[k*3+1],c[k*3+2]],score:1/(1+Math.exp(-l[k*5+3])),visibility:1/(1+Math.exp(-l[k*5+4]))}));v.forEach(C=>{C.pixel[0]=(C.pixel[0]-.5)*2*g,C.pixel[1]=(C.pixel[1]-.5)*2*g,C.pixel[2]*=2*g});const b=Math.sin(_),T=Math.cos(_);v.forEach(C=>{const k=C.pixel[0],P=C.pixel[1];C.pixel[0]=(k*T-P*b+p[0])/i,C.pixel[1]=(k*b+P*T+p[1])/n,C.pixel[2]/=i;const N=C.metric[0],G=C.metric[1];C.metric[0]=N*T-G*b,C.metric[1]=N*b+G*T});const E=v.map(C=>C.pixel[0]),A=v.map(C=>C.pixel[1]),M=[[Math.min(...E),Math.min(...A)],[Math.max(...E),Math.max(...A)]],R=h&&{buffer:h,size:{width:256,height:256},box:[[(p[0]-g)/i,(p[1]-g)/n],[(p[0]+g)/i,(p[1]+g)/n]]};return{keypoints:v,score:d,mask:R,center:[v[33].pixel[0],v[33].pixel[1]],top:[v[34].pixel[0],v[34].pixel[1]],debug:{center:p,top:m,box:M,radius:g,angle:_}}})}refinePoints(e,t){const n=Ba(t,[0]),i=n.bufferSync(),[r,a,s]=n.shape;return e.map((l,c)=>{const h=l,d=Math.trunc(h[0]*a),p=Math.trunc(h[1]*r);if(d<0||d>=a||p<0||p>=r)return l;const m=Math.trunc(6/2),g=Math.max(d-m,0),_=Math.min(d+m+1,a),v=Math.max(p-m,0),b=Math.min(p+m+1,r);let T=0,E=0,A=0,M=0;for(let R=v;R<b;R++)for(let C=g;C<_;C++){const k=i.get(R,C,c);T+=k,E=Math.max(k,E),A+=C*k,M+=R*k}return n.dispose(),E>=.5&&T>0?[A/T/a,M/T/r,h[2]]:l})}rotatedRect(e,t,n,i){const[r,a]=[t[2]-t[0],t[3]-t[1]],[s,l]=[(t[2]+t[0])*.5,(t[3]+t[1])*.5],[c,h]=[r/i.height,a/i.width],[d,p]=[Math.cos(n),Math.sin(n)],m=[d*h,-p*c,(-d*a+p*r)*.5+l,p*h,d*c,(-p*a-d*r)*.5+s,0,0];return E1.transform(e,[m],"bilinear","constant",0,[i.height,i.width])}reset(){var e;(e=this.maskFilter)==null||e.reset()}async prepare(){var e;const{width:t,height:n}=this.modelSize,i=wc([1,n,t,3]),r=this.model.execute(i);await Promise.all(r.map(async a=>{await a.data(),a.dispose()})),await((e=this.maskFilter)==null?void 0:e.prepare()),i.dispose()}async dispose(){var e,t;(e=this.model)==null||e.dispose(),(t=this.maskFilter)==null||t.dispose(),delete this.maskFilter}}var nW=Object.defineProperty,D3=Object.getOwnPropertySymbols,iW=Object.prototype.hasOwnProperty,rW=Object.prototype.propertyIsEnumerable,P3=(x,e,t)=>e in x?nW(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,k3=(x,e)=>{for(var t in e||(e={}))iW.call(e,t)&&P3(x,t,e[t]);if(D3)for(var t of D3(e))rW.call(e,t)&&P3(x,t,e[t]);return x};class aW{constructor(){this.freq=30,this.pixelParams={minCutOff:1,minCutOffD:1,beta:40},this.metricParams={minCutOff:1,minCutOffD:1,beta:5},this.boxParams={minCutOff:1,minCutOffD:1,beta:5},this.scoreCutOff=1,this.visibilityCutOff=1,this.time=0}filter(e,t,n=1){return this.time>=t?e:(this.time!==0&&(this.freq=1/(t-this.time)),this.time=t,!this.raw||!this.smooth||!this.der?(this.raw=this.clonePose(e),this.smooth=this.clonePose(e),this.der={keypoints:e.keypoints.map(()=>({pixel:[0,0,0],metric:[0,0,0],norm:[0,0,0],score:0,visibility:0})),score:0,center:[0,0],top:[0,0],debug:{box:[[0,0],[0,0]],center:[0,0],top:[0,0],radius:0,angle:0}},this.clonePose(this.smooth)):(this.filterKeypoints(e.keypoints,this.raw.keypoints,this.der.keypoints,this.smooth.keypoints,n),this.filterCoord2D(e.center,this.raw.center,this.der.center,this.smooth.center,n,this.boxParams),this.filterCoord2D(e.top,this.raw.top,this.der.top,this.smooth.top,n,this.boxParams),this.smooth.score=e.score,this.smooth.mask=e.mask&&{buffer:e.mask.buffer,size:k3({},e.mask.size),box:[[...e.mask.box[0]],[...e.mask.box[1]]]},this.smooth.debug=e.debug&&{center:[...e.debug.center],top:[...e.debug.top],box:[[...e.debug.box[0]],[...e.debug.box[1]]],radius:e.debug.radius,angle:e.debug.angle},this.clonePose(this.smooth)))}filterKeypoints(e,t,n,i,r){const a=this.alpha(this.visibilityCutOff),s=this.alpha(this.scoreCutOff);for(let l=0;l<e.length;l++)this.filterCoord3D(e[l].pixel,t[l].pixel,n[l].pixel,i[l].pixel,r,this.pixelParams),this.filterCoord3D(e[l].metric,t[l].metric,n[l].metric,i[l].metric,r,this.metricParams),this.filterCoord3D(e[l].norm,t[l].norm,n[l].norm,i[l].norm,r,this.metricParams),i[l].score=i[l].score+s*(e[l].score-i[l].score),i[l].visibility=i[l].visibility+a*(e[l].visibility-i[l].visibility)}filterCoord3D(e,t,n,i,r,a){const s=[(e[0]-i[0])*r*this.freq,(e[1]-i[1])*r*this.freq,(e[2]-i[2])*r*this.freq],l=this.alpha(a.minCutOffD);n[0]=n[0]+l*(s[0]-n[0]),n[1]=n[1]+l*(s[1]-n[1]),n[2]=n[2]+l*(s[2]-n[2]);const c=[this.alpha(a.minCutOff+a.beta*Math.abs(n[0])),this.alpha(a.minCutOff+a.beta*Math.abs(n[1])),this.alpha(a.minCutOff+a.beta*Math.abs(n[2]))];i[0]=i[0]+c[0]*(e[0]-i[0]),i[1]=i[1]+c[1]*(e[1]-i[1]),i[2]=i[2]+c[2]*(e[2]-i[2]),t[0]=e[0],t[1]=e[1],t[2]=e[2]}filterCoord2D(e,t,n,i,r,a){const s=[(e[0]-i[0])*r*this.freq,(e[1]-i[1])*r*this.freq],l=this.alpha(a.minCutOffD);n[0]=n[0]+l*(s[0]-n[0]),n[1]=n[1]+l*(s[1]-n[1]);const c=[this.alpha(a.minCutOff+a.beta*Math.abs(n[0])),this.alpha(a.minCutOff+a.beta*Math.abs(n[1]))];i[0]=i[0]+c[0]*(e[0]-i[0]),i[1]=i[1]+c[1]*(e[1]-i[1]),t[0]=e[0],t[1]=e[1]}reset(){delete this.raw,delete this.smooth,delete this.der}alpha(e){return 1/(1+this.freq/(2*Math.PI*e))}clonePose(e){return{keypoints:e.keypoints.map(t=>({pixel:[...t.pixel],metric:[...t.metric],norm:[...t.norm],score:t.score,visibility:t.visibility})),score:e.score,center:[...e.center],top:[...e.top],mask:e.mask&&{buffer:e.mask.buffer,size:k3({},e.mask.size),box:[[...e.mask.box[0]],[...e.mask.box[1]]]},debug:e.debug&&{box:[[...e.debug.box[0]],[...e.debug.box[1]]],center:[...e.debug.center],top:[...e.debug.top],radius:e.debug.radius,angle:e.debug.angle}}}}function sW(x,e){const t=[[Math.max(x[0][0],e[0][0]),Math.max(x[0][1],e[0][1])],[Math.min(x[1][0],e[1][0]),Math.min(x[1][1],e[1][1])]],n=(t[1][0]-t[0][0])*(t[1][1]-t[0][1]);return n/((x[1][0]-x[0][0])*(x[1][1]-x[0][1])+(e[1][0]-e[0][0])*(e[1][1]-e[0][1])-n)}var oW=(()=>{var x=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(e={}){var t=e,n,i;t.ready=new Promise((F,O)=>{n=F,i=O});var r=Object.assign({},t),a="./this.program",s=(F,O)=>{throw O},l=!0,c="";function h(F){return t.locateFile?t.locateFile(F,c):c+F}typeof document<"u"&&document.currentScript&&(c=document.currentScript.src),x&&(c=x),c.startsWith("blob:")?c="":c=c.substr(0,c.replace(/[?#].*/,"").lastIndexOf("/")+1),t.print||console.log.bind(console);var d=t.printErr||console.error.bind(console);Object.assign(t,r),r=null,t.arguments&&t.arguments,t.thisProgram&&(a=t.thisProgram),t.quit&&(s=t.quit);var p;t.wasmBinary&&(p=t.wasmBinary);var m,g=!1,_,v,b,T,E,A,M,R,C;function k(){var F=m.buffer;t.HEAP8=v=new Int8Array(F),t.HEAP16=T=new Int16Array(F),t.HEAPU8=b=new Uint8Array(F),t.HEAPU16=E=new Uint16Array(F),t.HEAP32=A=new Int32Array(F),t.HEAPU32=M=new Uint32Array(F),t.HEAPF32=R=new Float32Array(F),t.HEAPF64=C=new Float64Array(F)}var P=[],N=[],G=[];function te(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)ae(t.preRun.shift());Q(P)}function j(){Q(N)}function xe(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)re(t.postRun.shift());Q(G)}function ae(F){P.unshift(F)}function H(F){N.unshift(F)}function re(F){G.unshift(F)}var q=0,be=null;function K(F){var O;q++,(O=t.monitorRunDependencies)==null||O.call(t,q)}function se(F){var O;if(q--,(O=t.monitorRunDependencies)==null||O.call(t,q),q==0&&be){var $=be;be=null,$()}}function ge(F){var O;(O=t.onAbort)==null||O.call(t,F),F="Aborted("+F+")",d(F),g=!0,_=1,F+=". Build with -sASSERTIONS for more info.";var $=new WebAssembly.RuntimeError(F);throw i($),$}var Me="data:application/octet-stream;base64,",le=F=>F.startsWith(Me),Se;Se="bodyutils.wasm",le(Se)||(Se=h(Se));function Fe(F){if(F==Se&&p)return new Uint8Array(p);throw"both async and sync fetching of the wasm failed"}function Qe(F){return!p&&l&&typeof fetch=="function"?fetch(F,{credentials:"same-origin"}).then(O=>{if(!O.ok)throw"failed to load wasm binary file at '"+F+"'";return O.arrayBuffer()}).catch(()=>Fe(F)):Promise.resolve().then(()=>Fe(F))}function qe(F,O,$){return Qe(F).then(oe=>WebAssembly.instantiate(oe,O)).then($,oe=>{d("failed to asynchronously prepare wasm: "+oe),ge(oe)})}function Et(F,O,$,oe){return!F&&typeof WebAssembly.instantiateStreaming=="function"&&!le(O)&&typeof fetch=="function"?fetch(O,{credentials:"same-origin"}).then(Oe=>{var Le=WebAssembly.instantiateStreaming(Oe,$);return Le.then(oe,function(Ye){return d("wasm streaming compile failed: "+Ye),d("falling back to ArrayBuffer instantiation"),qe(O,$,oe)})}):qe(O,$,oe)}function Tt(){var F={a:bl};function O(oe,Oe){return ti=oe.exports,m=ti.E,k(),Kt=ti.H,H(ti.F),se(),ti}K();function $(oe){O(oe.instance)}if(t.instantiateWasm)try{return t.instantiateWasm(F,O)}catch(oe){d("Module.instantiateWasm callback failed with error: "+oe),i(oe)}return Et(p,Se,F,$).catch(i),{}}function Bt(F){this.name="ExitStatus",this.message="Program terminated with exit("+F+")",this.status=F}var Q=F=>{for(;F.length>0;)F.shift()(t)};t.noExitRuntime;class rt{constructor(O){this.excPtr=O,this.ptr=O-24}set_type(O){M[this.ptr+4>>2]=O}get_type(){return M[this.ptr+4>>2]}set_destructor(O){M[this.ptr+8>>2]=O}get_destructor(){return M[this.ptr+8>>2]}set_caught(O){O=O?1:0,v[this.ptr+12]=O}get_caught(){return v[this.ptr+12]!=0}set_rethrown(O){O=O?1:0,v[this.ptr+13]=O}get_rethrown(){return v[this.ptr+13]!=0}init(O,$){this.set_adjusted_ptr(0),this.set_type(O),this.set_destructor($)}set_adjusted_ptr(O){M[this.ptr+16>>2]=O}get_adjusted_ptr(){return M[this.ptr+16>>2]}get_exception_ptr(){var O=kp(this.get_type());if(O)return M[this.excPtr>>2];var $=this.get_adjusted_ptr();return $!==0?$:this.excPtr}}var He=0,at=(F,O,$)=>{var oe=new rt(F);throw oe.init(O,$),He=F,He},Ue=(F,O,$,oe,Oe)=>{},bt=()=>{for(var F=new Array(256),O=0;O<256;++O)F[O]=String.fromCharCode(O);ht=F},ht,dt=F=>{for(var O="",$=F;b[$];)O+=ht[b[$++]];return O},Z={},V={},_e={},Ge,Re=F=>{throw new Ge(F)},Ve,_t=F=>{throw new Ve(F)},Ce=(F,O,$)=>{F.forEach(function(ze){_e[ze]=O});function oe(ze){var yt=$(ze);yt.length!==F.length&&_t("Mismatched type converter count");for(var Mt=0;Mt<F.length;++Mt)et(F[Mt],yt[Mt])}var Oe=new Array(O.length),Le=[],Ye=0;O.forEach((ze,yt)=>{V.hasOwnProperty(ze)?Oe[yt]=V[ze]:(Le.push(ze),Z.hasOwnProperty(ze)||(Z[ze]=[]),Z[ze].push(()=>{Oe[yt]=V[ze],++Ye,Ye===Le.length&&oe(Oe)}))}),Le.length===0&&oe(Oe)};function pt(F,O,$={}){var oe=O.name;if(F||Re('type "'+oe+'" must have a positive integer typeid pointer'),V.hasOwnProperty(F)){if($.ignoreDuplicateRegistrations)return;Re("Cannot register type '"+oe+"' twice")}if(V[F]=O,delete _e[F],Z.hasOwnProperty(F)){var Oe=Z[F];delete Z[F],Oe.forEach(Le=>Le())}}function et(F,O,$={}){if(!("argPackAdvance"in O))throw new TypeError("registerType registeredInstance requires argPackAdvance");return pt(F,O,$)}var tt=8,gt=(F,O,$,oe)=>{O=dt(O),et(F,{name:O,fromWireType:function(Oe){return!!Oe},toWireType:function(Oe,Le){return Le?$:oe},argPackAdvance:tt,readValueFromPointer:function(Oe){return this.fromWireType(b[Oe])},destructorFunction:null})},i0=F=>({count:F.count,deleteScheduled:F.deleteScheduled,preservePointerOnDelete:F.preservePointerOnDelete,ptr:F.ptr,ptrType:F.ptrType,smartPtr:F.smartPtr,smartPtrType:F.smartPtrType}),Ht=F=>{function O($){return $.$$.ptrType.registeredClass.name}Re(O(F)+" instance already deleted")},St=!1,Ut=F=>{},t0=F=>{F.smartPtr?F.smartPtrType.rawDestructor(F.smartPtr):F.ptrType.registeredClass.rawDestructor(F.ptr)},p0=F=>{F.count.value-=1;var O=F.count.value===0;O&&t0(F)},de=(F,O,$)=>{if(O===$)return F;if($.baseClass===void 0)return null;var oe=de(F,O,$.baseClass);return oe===null?null:$.downcast(oe)},ft={},Xe=()=>Object.keys(s0).length,Ze=()=>{var F=[];for(var O in s0)s0.hasOwnProperty(O)&&F.push(s0[O]);return F},lt=[],Wt=()=>{for(;lt.length;){var F=lt.pop();F.$$.deleteScheduled=!1,F.delete()}},Qt,D0=F=>{Qt=F,lt.length&&Qt&&Qt(Wt)},P0=()=>{t.getInheritedInstanceCount=Xe,t.getLiveInheritedInstances=Ze,t.flushPendingDeletes=Wt,t.setDelayFunction=D0},s0={},rn=(F,O)=>{for(O===void 0&&Re("ptr should not be undefined");F.baseClass;)O=F.upcast(O),F=F.baseClass;return O},Cx=(F,O)=>(O=rn(F,O),s0[O]),ax=(F,O)=>{(!O.ptrType||!O.ptr)&&_t("makeClassHandle requires ptr and ptrType");var $=!!O.smartPtrType,oe=!!O.smartPtr;return $!==oe&&_t("Both smartPtrType and smartPtr must be specified"),O.count={value:1},R0(Object.create(F,{$$:{value:O,writable:!0}}))};function L0(F){var O=this.getPointee(F);if(!O)return this.destructor(F),null;var $=Cx(this.registeredClass,O);if($!==void 0){if($.$$.count.value===0)return $.$$.ptr=O,$.$$.smartPtr=F,$.clone();var oe=$.clone();return this.destructor(F),oe}function Oe(){return this.isSmartPointer?ax(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:O,smartPtrType:this,smartPtr:F}):ax(this.registeredClass.instancePrototype,{ptrType:this,ptr:F})}var Le=this.registeredClass.getActualType(O),Ye=ft[Le];if(!Ye)return Oe.call(this);var ze;this.isConst?ze=Ye.constPointerType:ze=Ye.pointerType;var yt=de(O,this.registeredClass,ze.registeredClass);return yt===null?Oe.call(this):this.isSmartPointer?ax(ze.registeredClass.instancePrototype,{ptrType:ze,ptr:yt,smartPtrType:this,smartPtr:F}):ax(ze.registeredClass.instancePrototype,{ptrType:ze,ptr:yt})}var R0=F=>typeof FinalizationRegistry>"u"?(R0=O=>O,F):(St=new FinalizationRegistry(O=>{p0(O.$$)}),R0=O=>{var $=O.$$,oe=!!$.smartPtr;if(oe){var Oe={$$:$};St.register(O,Oe,O)}return O},Ut=O=>St.unregister(O),R0(F)),Wn=()=>{Object.assign(q0.prototype,{isAliasOf(F){if(!(this instanceof q0)||!(F instanceof q0))return!1;var O=this.$$.ptrType.registeredClass,$=this.$$.ptr;F.$$=F.$$;for(var oe=F.$$.ptrType.registeredClass,Oe=F.$$.ptr;O.baseClass;)$=O.upcast($),O=O.baseClass;for(;oe.baseClass;)Oe=oe.upcast(Oe),oe=oe.baseClass;return O===oe&&$===Oe},clone(){if(this.$$.ptr||Ht(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var F=R0(Object.create(Object.getPrototypeOf(this),{$$:{value:i0(this.$$)}}));return F.$$.count.value+=1,F.$$.deleteScheduled=!1,F},delete(){this.$$.ptr||Ht(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Re("Object already scheduled for deletion"),Ut(this),p0(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||Ht(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Re("Object already scheduled for deletion"),lt.push(this),lt.length===1&&Qt&&Qt(Wt),this.$$.deleteScheduled=!0,this}})};function q0(){}var Fx=(F,O)=>Object.defineProperty(O,"name",{value:F}),gn=(F,O,$)=>{if(F[O].overloadTable===void 0){var oe=F[O];F[O]=function(...Oe){return F[O].overloadTable.hasOwnProperty(Oe.length)||Re("Function '"+$+"' called with an invalid number of arguments ("+Oe.length+") - expects one of ("+F[O].overloadTable+")!"),F[O].overloadTable[Oe.length].apply(this,Oe)},F[O].overloadTable=[],F[O].overloadTable[oe.argCount]=oe}},mi=(F,O,$)=>{t.hasOwnProperty(F)?(Re("Cannot register public name '"+F+"' twice"),gn(t,F,F),t.hasOwnProperty($)&&Re("Cannot register multiple overloads of a function with the same number of arguments ("+$+")!"),t[F].overloadTable[$]=O):t[F]=O},yi=48,Gr=57,Ii=F=>{if(F===void 0)return"_unknown";F=F.replace(/[^a-zA-Z0-9_]/g,"$");var O=F.charCodeAt(0);return O>=yi&&O<=Gr?"_"+F:F};function Oi(F,O,$,oe,Oe,Le,Ye,ze){this.name=F,this.constructor=O,this.instancePrototype=$,this.rawDestructor=oe,this.baseClass=Oe,this.getActualType=Le,this.upcast=Ye,this.downcast=ze,this.pureVirtualFunctions=[]}var vn=(F,O,$)=>{for(;O!==$;)O.upcast||Re("Expected null or instance of "+$.name+", got an instance of "+O.name),F=O.upcast(F),O=O.baseClass;return F};function Y(F,O){if(O===null)return this.isReference&&Re("null is not a valid "+this.name),0;O.$$||Re('Cannot pass "'+Wr(O)+'" as a '+this.name),O.$$.ptr||Re("Cannot pass deleted object as a pointer of type "+this.name);var $=O.$$.ptrType.registeredClass,oe=vn(O.$$.ptr,$,this.registeredClass);return oe}function ce(F,O){var $;if(O===null)return this.isReference&&Re("null is not a valid "+this.name),this.isSmartPointer?($=this.rawConstructor(),F!==null&&F.push(this.rawDestructor,$),$):0;(!O||!O.$$)&&Re('Cannot pass "'+Wr(O)+'" as a '+this.name),O.$$.ptr||Re("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&O.$$.ptrType.isConst&&Re("Cannot convert argument of type "+(O.$$.smartPtrType?O.$$.smartPtrType.name:O.$$.ptrType.name)+" to parameter type "+this.name);var oe=O.$$.ptrType.registeredClass;if($=vn(O.$$.ptr,oe,this.registeredClass),this.isSmartPointer)switch(O.$$.smartPtr===void 0&&Re("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:O.$$.smartPtrType===this?$=O.$$.smartPtr:Re("Cannot convert argument of type "+(O.$$.smartPtrType?O.$$.smartPtrType.name:O.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:$=O.$$.smartPtr;break;case 2:if(O.$$.smartPtrType===this)$=O.$$.smartPtr;else{var Oe=O.clone();$=this.rawShare($,Lx.toHandle(()=>Oe.delete())),F!==null&&F.push(this.rawDestructor,$)}break;default:Re("Unsupporting sharing policy")}return $}function Ne(F,O){if(O===null)return this.isReference&&Re("null is not a valid "+this.name),0;O.$$||Re('Cannot pass "'+Wr(O)+'" as a '+this.name),O.$$.ptr||Re("Cannot pass deleted object as a pointer of type "+this.name),O.$$.ptrType.isConst&&Re("Cannot convert argument of type "+O.$$.ptrType.name+" to parameter type "+this.name);var $=O.$$.ptrType.registeredClass,oe=vn(O.$$.ptr,$,this.registeredClass);return oe}function Ie(F){return this.fromWireType(M[F>>2])}var fe=()=>{Object.assign(ct.prototype,{getPointee(F){return this.rawGetPointee&&(F=this.rawGetPointee(F)),F},destructor(F){var O;(O=this.rawDestructor)==null||O.call(this,F)},argPackAdvance:tt,readValueFromPointer:Ie,fromWireType:L0})};function ct(F,O,$,oe,Oe,Le,Ye,ze,yt,Mt,vt){this.name=F,this.registeredClass=O,this.isReference=$,this.isConst=oe,this.isSmartPointer=Oe,this.pointeeType=Le,this.sharingPolicy=Ye,this.rawGetPointee=ze,this.rawConstructor=yt,this.rawShare=Mt,this.rawDestructor=vt,!Oe&&O.baseClass===void 0?oe?(this.toWireType=Y,this.destructorFunction=null):(this.toWireType=Ne,this.destructorFunction=null):this.toWireType=ce}var wt=(F,O,$)=>{t.hasOwnProperty(F)||_t("Replacing nonexistent public symbol"),t[F].overloadTable!==void 0&&$!==void 0?t[F].overloadTable[$]=O:(t[F]=O,t[F].argCount=$)},It=(F,O,$)=>{var oe=t["dynCall_"+F];return oe(O,...$)},Ct=[],Kt,Ft=F=>{var O=Ct[F];return O||(F>=Ct.length&&(Ct.length=F+1),Ct[F]=O=Kt.get(F)),O},Dt=(F,O,$=[])=>{if(F.includes("j"))return It(F,O,$);var oe=Ft(O)(...$);return oe},Zt=(F,O)=>(...$)=>Dt(F,O,$),v0=(F,O)=>{F=dt(F);function $(){return F.includes("j")?Zt(F,O):Ft(O)}var oe=$();return typeof oe!="function"&&Re("unknown function pointer with signature "+F+": "+O),oe},h0=(F,O)=>{var $=Fx(O,function(oe){this.name=O,this.message=oe;var Oe=new Error(oe).stack;Oe!==void 0&&(this.stack=this.toString()+`
`+Oe.replace(/^Error(:[^\n]*)?\n/,""))});return $.prototype=Object.create(F.prototype),$.prototype.constructor=$,$.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},$},sx,d0=F=>{var O=Ws(F),$=dt(O);return ar(O),$},Ot=(F,O)=>{var $=[],oe={};function Oe(Le){if(!oe[Le]&&!V[Le]){if(_e[Le]){_e[Le].forEach(Oe);return}$.push(Le),oe[Le]=!0}}throw O.forEach(Oe),new sx(F+": "+$.map(d0).join([", "]))},$0=(F,O,$,oe,Oe,Le,Ye,ze,yt,Mt,vt,a0,e0)=>{vt=dt(vt),Le=v0(Oe,Le),ze&&(ze=v0(Ye,ze)),Mt&&(Mt=v0(yt,Mt)),e0=v0(a0,e0);var w0=Ii(vt);mi(w0,function(){Ot("Cannot construct "+vt+" due to unbound types",[oe])}),Ce([F,O,$],oe?[oe]:[],ox=>{var gx;ox=ox[0];var vx,bx;oe?(vx=ox.registeredClass,bx=vx.instancePrototype):bx=q0.prototype;var xt=Fx(vt,function(...sr){if(Object.getPrototypeOf(this)!==Vt)throw new Ge("Use 'new' to construct "+vt);if(V0.constructor_body===void 0)throw new Ge(vt+" has no accessible constructor");var Xs=V0.constructor_body[sr.length];if(Xs===void 0)throw new Ge("Tried to invoke ctor of "+vt+" with invalid number of parameters ("+sr.length+") - expected ("+Object.keys(V0.constructor_body).toString()+") parameters instead!");return Xs.apply(this,sr)}),Vt=Object.create(bx,{constructor:{value:xt}});xt.prototype=Vt;var V0=new Oi(vt,xt,Vt,e0,vx,Le,ze,Mt);V0.baseClass&&((gx=V0.baseClass).__derivedClasses!=null||(gx.__derivedClasses=[]),V0.baseClass.__derivedClasses.push(V0));var Z0=new ct(vt,V0,!0,!1,!1),Xt=new ct(vt+"*",V0,!1,!1,!1),$r=new ct(vt+" const*",V0,!1,!0,!1);return ft[F]={pointerType:Xt,constPointerType:$r},wt(w0,xt),[Z0,Xt,$r]})},y0=(F,O)=>{for(var $=[],oe=0;oe<F;oe++)$.push(M[O+oe*4>>2]);return $},U0=F=>{for(;F.length;){var O=F.pop(),$=F.pop();$(O)}};function gi(F){for(var O=1;O<F.length;++O)if(F[O]!==null&&F[O].destructorFunction===void 0)return!0;return!1}function Bx(F,O,$,oe,Oe,Le){var Ye=O.length;Ye<2&&Re("argTypes array size mismatch! Must at least get return value and 'this' types!");var ze=O[1]!==null&&$!==null,yt=gi(O),Mt=O[0].name!=="void",vt=Ye-2,a0=new Array(vt),e0=[],w0=[],ox=function(...gx){gx.length!==vt&&Re("function "+F+" called with "+gx.length+" arguments, expected "+vt),w0.length=0;var vx;e0.length=ze?2:1,e0[0]=Oe,ze&&(vx=O[1].toWireType(w0,this),e0[1]=vx);for(var bx=0;bx<vt;++bx)a0[bx]=O[bx+2].toWireType(w0,gx[bx]),e0.push(a0[bx]);var xt=oe(...e0);function Vt(V0){if(yt)U0(w0);else for(var Z0=ze?1:2;Z0<O.length;Z0++){var Xt=Z0===1?vx:a0[Z0-2];O[Z0].destructorFunction!==null&&O[Z0].destructorFunction(Xt)}if(Mt)return O[0].fromWireType(V0)}return Vt(xt)};return Fx(F,ox)}var Di=(F,O,$,oe,Oe,Le)=>{var Ye=y0(O,$);Oe=v0(oe,Oe),Ce([],[F],ze=>{ze=ze[0];var yt="constructor "+ze.name;if(ze.registeredClass.constructor_body===void 0&&(ze.registeredClass.constructor_body=[]),ze.registeredClass.constructor_body[O-1]!==void 0)throw new Ge("Cannot register multiple constructors with identical number of parameters ("+(O-1)+") for class '"+ze.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return ze.registeredClass.constructor_body[O-1]=()=>{Ot("Cannot construct "+ze.name+" due to unbound types",Ye)},Ce([],Ye,Mt=>(Mt.splice(1,0,null),ze.registeredClass.constructor_body[O-1]=Bx(yt,Mt,null,Oe,Le),[])),[]})},Q0=F=>{F=F.trim();const O=F.indexOf("(");return O!==-1?F.substr(0,O):F},bn=(F,O,$,oe,Oe,Le,Ye,ze,yt)=>{var Mt=y0($,oe);O=dt(O),O=Q0(O),Le=v0(Oe,Le),Ce([],[F],vt=>{vt=vt[0];var a0=vt.name+"."+O;O.startsWith("@@")&&(O=Symbol[O.substring(2)]),ze&&vt.registeredClass.pureVirtualFunctions.push(O);function e0(){Ot("Cannot call "+a0+" due to unbound types",Mt)}var w0=vt.registeredClass.instancePrototype,ox=w0[O];return ox===void 0||ox.overloadTable===void 0&&ox.className!==vt.name&&ox.argCount===$-2?(e0.argCount=$-2,e0.className=vt.name,w0[O]=e0):(gn(w0,O,a0),w0[O].overloadTable[$-2]=e0),Ce([],Mt,gx=>{var vx=Bx(a0,gx,vt,Le,Ye);return w0[O].overloadTable===void 0?(vx.argCount=$-2,w0[O]=vx):w0[O].overloadTable[$-2]=vx,[]}),[]})},vi=(F,O,$)=>(F instanceof Object||Re($+' with invalid "this": '+F),F instanceof O.registeredClass.constructor||Re($+' incompatible with "this" of type '+F.constructor.name),F.$$.ptr||Re("cannot call emscripten binding method "+$+" on deleted object"),vn(F.$$.ptr,F.$$.ptrType.registeredClass,O.registeredClass)),T0=(F,O,$,oe,Oe,Le,Ye,ze,yt,Mt)=>{O=dt(O),Oe=v0(oe,Oe),Ce([],[F],vt=>{vt=vt[0];var a0=vt.name+"."+O,e0={get(){Ot("Cannot access "+a0+" due to unbound types",[$,Ye])},enumerable:!0,configurable:!0};return yt?e0.set=()=>Ot("Cannot access "+a0+" due to unbound types",[$,Ye]):e0.set=w0=>Re(a0+" is a read-only property"),Object.defineProperty(vt.registeredClass.instancePrototype,O,e0),Ce([],yt?[$,Ye]:[$],w0=>{var ox=w0[0],gx={get(){var bx=vi(this,vt,a0+" getter");return ox.fromWireType(Oe(Le,bx))},enumerable:!0};if(yt){yt=v0(ze,yt);var vx=w0[1];gx.set=function(bx){var xt=vi(this,vt,a0+" setter"),Vt=[];yt(Mt,xt,vx.toWireType(Vt,bx)),U0(Vt)}}return Object.defineProperty(vt.registeredClass.instancePrototype,O,gx),[]}),[]})},Xn=[],Nx=[],Pi=F=>{F>9&&--Nx[F+1]===0&&(Nx[F]=void 0,Xn.push(F))},bi=()=>Nx.length/2-5-Xn.length,Ko=()=>{Nx.push(0,1,void 0,1,null,1,!0,1,!1,1),t.count_emval_handles=bi},Lx={toValue:F=>(F||Re("Cannot use deleted val. handle = "+F),Nx[F]),toHandle:F=>{switch(F){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const O=Xn.pop()||Nx.length;return Nx[O]=F,Nx[O+1]=1,O}}}},ki={name:"emscripten::val",fromWireType:F=>{var O=Lx.toValue(F);return Pi(F),O},toWireType:(F,O)=>Lx.toHandle(O),argPackAdvance:tt,readValueFromPointer:Ie,destructorFunction:null},yl=F=>et(F,ki),Wr=F=>{if(F===null)return"null";var O=typeof F;return O==="object"||O==="array"||O==="function"?F.toString():""+F},$o=(F,O)=>{switch(O){case 4:return function($){return this.fromWireType(R[$>>2])};case 8:return function($){return this.fromWireType(C[$>>3])};default:throw new TypeError("invalid float width ("+O+"): "+F)}},Fs=(F,O,$)=>{O=dt(O),et(F,{name:O,fromWireType:oe=>oe,toWireType:(oe,Oe)=>Oe,argPackAdvance:tt,readValueFromPointer:$o(O,$),destructorFunction:null})},gl=(F,O,$)=>{switch(O){case 1:return $?oe=>v[oe]:oe=>b[oe];case 2:return $?oe=>T[oe>>1]:oe=>E[oe>>1];case 4:return $?oe=>A[oe>>2]:oe=>M[oe>>2];default:throw new TypeError("invalid integer width ("+O+"): "+F)}},vl=(F,O,$,oe,Oe)=>{O=dt(O);var Le=vt=>vt;if(oe===0){var Ye=32-8*$;Le=vt=>vt<<Ye>>>Ye}var ze=O.includes("unsigned"),yt=(vt,a0)=>{},Mt;ze?Mt=function(vt,a0){return yt(a0,this.name),a0>>>0}:Mt=function(vt,a0){return yt(a0,this.name),a0},et(F,{name:O,fromWireType:Le,toWireType:Mt,argPackAdvance:tt,readValueFromPointer:gl(O,$,oe!==0),destructorFunction:null})},rs=(F,O,$)=>{var oe=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],Oe=oe[O];function Le(Ye){var ze=M[Ye>>2],yt=M[Ye+4>>2];return new Oe(v.buffer,yt,ze)}$=dt($),et(F,{name:$,fromWireType:Le,argPackAdvance:tt,readValueFromPointer:Le},{ignoreDuplicateRegistrations:!0})},as=(F,O,$,oe)=>{if(!(oe>0))return 0;for(var Oe=$,Le=$+oe-1,Ye=0;Ye<F.length;++Ye){var ze=F.charCodeAt(Ye);if(ze>=55296&&ze<=57343){var yt=F.charCodeAt(++Ye);ze=65536+((ze&1023)<<10)|yt&1023}if(ze<=127){if($>=Le)break;O[$++]=ze}else if(ze<=2047){if($+1>=Le)break;O[$++]=192|ze>>6,O[$++]=128|ze&63}else if(ze<=65535){if($+2>=Le)break;O[$++]=224|ze>>12,O[$++]=128|ze>>6&63,O[$++]=128|ze&63}else{if($+3>=Le)break;O[$++]=240|ze>>18,O[$++]=128|ze>>12&63,O[$++]=128|ze>>6&63,O[$++]=128|ze&63}}return O[$]=0,$-Oe},_n=(F,O,$)=>as(F,b,O,$),nr=F=>{for(var O=0,$=0;$<F.length;++$){var oe=F.charCodeAt($);oe<=127?O++:oe<=2047?O+=2:oe>=55296&&oe<=57343?(O+=4,++$):O+=3}return O},Ui=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Qo=(F,O,$)=>{for(var oe=O+$,Oe=O;F[Oe]&&!(Oe>=oe);)++Oe;if(Oe-O>16&&F.buffer&&Ui)return Ui.decode(F.subarray(O,Oe));for(var Le="";O<Oe;){var Ye=F[O++];if(!(Ye&128)){Le+=String.fromCharCode(Ye);continue}var ze=F[O++]&63;if((Ye&224)==192){Le+=String.fromCharCode((Ye&31)<<6|ze);continue}var yt=F[O++]&63;if((Ye&240)==224?Ye=(Ye&15)<<12|ze<<6|yt:Ye=(Ye&7)<<18|ze<<12|yt<<6|F[O++]&63,Ye<65536)Le+=String.fromCharCode(Ye);else{var Mt=Ye-65536;Le+=String.fromCharCode(55296|Mt>>10,56320|Mt&1023)}}return Le},zx=(F,O)=>F?Qo(b,F,O):"",Zo=(F,O)=>{O=dt(O);var $=O==="std::string";et(F,{name:O,fromWireType(oe){var Oe=M[oe>>2],Le=oe+4,Ye;if($)for(var ze=Le,yt=0;yt<=Oe;++yt){var Mt=Le+yt;if(yt==Oe||b[Mt]==0){var vt=Mt-ze,a0=zx(ze,vt);Ye===void 0?Ye=a0:(Ye+="\0",Ye+=a0),ze=Mt+1}}else{for(var e0=new Array(Oe),yt=0;yt<Oe;++yt)e0[yt]=String.fromCharCode(b[Le+yt]);Ye=e0.join("")}return ar(oe),Ye},toWireType(oe,Oe){Oe instanceof ArrayBuffer&&(Oe=new Uint8Array(Oe));var Le,Ye=typeof Oe=="string";Ye||Oe instanceof Uint8Array||Oe instanceof Uint8ClampedArray||Oe instanceof Int8Array||Re("Cannot pass non-string to std::string"),$&&Ye?Le=nr(Oe):Le=Oe.length;var ze=Gs(4+Le+1),yt=ze+4;if(M[ze>>2]=Le,$&&Ye)_n(Oe,yt,Le+1);else if(Ye)for(var Mt=0;Mt<Le;++Mt){var vt=Oe.charCodeAt(Mt);vt>255&&(ar(yt),Re("String has UTF-16 code units that do not fit in 8 bits")),b[yt+Mt]=vt}else for(var Mt=0;Mt<Le;++Mt)b[yt+Mt]=Oe[Mt];return oe!==null&&oe.push(ar,ze),ze},argPackAdvance:tt,readValueFromPointer:Ie,destructorFunction(oe){ar(oe)}})},ir=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,_i=(F,O)=>{for(var $=F,oe=$>>1,Oe=oe+O/2;!(oe>=Oe)&&E[oe];)++oe;if($=oe<<1,$-F>32&&ir)return ir.decode(b.subarray(F,$));for(var Le="",Ye=0;!(Ye>=O/2);++Ye){var ze=T[F+Ye*2>>1];if(ze==0)break;Le+=String.fromCharCode(ze)}return Le},Bs=(F,O,$)=>{if($!=null||($=2147483647),$<2)return 0;$-=2;for(var oe=O,Oe=$<F.length*2?$/2:F.length,Le=0;Le<Oe;++Le){var Ye=F.charCodeAt(Le);T[O>>1]=Ye,O+=2}return T[O>>1]=0,O-oe},Ma=F=>F.length*2,Fi=(F,O)=>{for(var $=0,oe="";!($>=O/4);){var Oe=A[F+$*4>>2];if(Oe==0)break;if(++$,Oe>=65536){var Le=Oe-65536;oe+=String.fromCharCode(55296|Le>>10,56320|Le&1023)}else oe+=String.fromCharCode(Oe)}return oe},Ls=(F,O,$)=>{if($!=null||($=2147483647),$<4)return 0;for(var oe=O,Oe=oe+$-4,Le=0;Le<F.length;++Le){var Ye=F.charCodeAt(Le);if(Ye>=55296&&Ye<=57343){var ze=F.charCodeAt(++Le);Ye=65536+((Ye&1023)<<10)|ze&1023}if(A[O>>2]=Ye,O+=4,O+4>Oe)break}return A[O>>2]=0,O-oe},ss=F=>{for(var O=0,$=0;$<F.length;++$){var oe=F.charCodeAt($);oe>=55296&&oe<=57343&&++$,O+=4}return O},Jo=(F,O,$)=>{$=dt($);var oe,Oe,Le,Ye;O===2?(oe=_i,Oe=Bs,Ye=Ma,Le=ze=>E[ze>>1]):O===4&&(oe=Fi,Oe=Ls,Ye=ss,Le=ze=>M[ze>>2]),et(F,{name:$,fromWireType:ze=>{for(var yt=M[ze>>2],Mt,vt=ze+4,a0=0;a0<=yt;++a0){var e0=ze+4+a0*O;if(a0==yt||Le(e0)==0){var w0=e0-vt,ox=oe(vt,w0);Mt===void 0?Mt=ox:(Mt+="\0",Mt+=ox),vt=e0+O}}return ar(ze),Mt},toWireType:(ze,yt)=>{typeof yt!="string"&&Re("Cannot pass non-string to C++ string type "+$);var Mt=Ye(yt),vt=Gs(4+Mt+O);return M[vt>>2]=Mt/O,Oe(yt,vt+4,Mt+O),ze!==null&&ze.push(ar,vt),vt},argPackAdvance:tt,readValueFromPointer:Ie,destructorFunction(ze){ar(ze)}})},os=(F,O)=>{O=dt(O),et(F,{isVoid:!0,name:O,argPackAdvance:0,fromWireType:()=>{},toWireType:($,oe)=>{}})};function ls(F){if(D.xhrs.has(F)){var O=D.xhrs.get(F);D.xhrs.free(F),O.readyState>0&&O.readyState<4&&O.abort()}}var zs=(F,O)=>{var $=V[F];return $===void 0&&Re(O+" has unknown type "+d0(F)),$},an=(F,O,$)=>{var oe=[],Oe=F.toWireType(oe,$);return oe.length&&(M[O>>2]=Lx.toHandle(oe)),Oe},rr=(F,O,$)=>(F=Lx.toValue(F),O=zs(O,"emval::as"),an(O,$,F)),cs={},Xr=F=>{var O=cs[F];return O===void 0?dt(F):O},jo=()=>{if(typeof globalThis=="object")return globalThis;function F(O){O.$$$embind_global$$$=O;var $=typeof $$$embind_global$$$=="object"&&O.$$$embind_global$$$==O;return $||delete O.$$$embind_global$$$,$}if(typeof $$$embind_global$$$=="object"||(typeof global=="object"&&F(global)?$$$embind_global$$$=global:typeof self=="object"&&F(self)&&($$$embind_global$$$=self),typeof $$$embind_global$$$=="object"))return $$$embind_global$$$;throw Error("unable to get global object.")},Vs=F=>F===0?Lx.toHandle(jo()):(F=Xr(F),Lx.toHandle(jo()[F])),Yn=(F,O)=>(F=Lx.toValue(F),O=Lx.toValue(O),Lx.toHandle(F[O])),Sn=F=>Lx.toHandle(Xr(F)),Yr=F=>{var O=Lx.toValue(F);U0(O),Pi(F)},Hs=(F,O)=>{F=zs(F,"_emval_take_value");var $=F.readValueFromPointer(O);return Lx.toHandle($)},ei=()=>{ge("")},In=()=>!0,us=(F,O,$)=>b.copyWithin(F,O,O+$),z=()=>2147483648,L=F=>{var O=m.buffer,$=(F-O.byteLength+65535)/65536;try{return m.grow($),k(),1}catch{}},ne=F=>{var O=b.length;F>>>=0;var $=z();if(F>$)return!1;for(var oe=(yt,Mt)=>yt+(Mt-yt%Mt)%Mt,Oe=1;Oe<=4;Oe*=2){var Le=O*(1+.2/Oe);Le=Math.min(Le,F+100663296);var Ye=Math.min($,oe(Math.max(F,Le),65536)),ze=L(Ye);if(ze)return!0}return!1};class Te{constructor(){this.allocated=[void 0],this.freelist=[]}get(O){return this.allocated[O]}has(O){return this.allocated[O]!==void 0}allocate(O){var $=this.freelist.pop()||this.allocated.length;return this.allocated[$]=O,$}free(O){this.allocated[O]=void 0,this.freelist.push(O)}}var D={openDatabase(F,O,$,oe){try{var Oe=indexedDB.open(F,O)}catch(Le){return oe(Le)}Oe.onupgradeneeded=Le=>{var Ye=Le.target.result;Ye.objectStoreNames.contains("FILES")&&Ye.deleteObjectStore("FILES"),Ye.createObjectStore("FILES")},Oe.onsuccess=Le=>$(Le.target.result),Oe.onerror=oe},init(){D.xhrs=new Te;var F=$=>{D.dbInstance=$,se()},O=()=>{D.dbInstance=!1,se()};K(),D.openDatabase("emscripten_filesystem",1,F,O)}};function U(F,O,$,oe,Oe){var Le=M[F+8>>2];if(!Le){$(F,0,"no url specified!");return}var Ye=zx(Le),ze=F+112,yt=zx(ze+0);yt||(yt="GET");var Mt=M[ze+56>>2],vt=M[ze+68>>2],a0=M[ze+72>>2],e0=M[ze+76>>2],w0=M[ze+80>>2],ox=M[ze+84>>2],gx=M[ze+88>>2],vx=M[ze+52>>2],bx=!!(vx&1),xt=!!(vx&2),Vt=!!(vx&64),V0=vt?zx(vt):void 0,Z0=a0?zx(a0):void 0,Xt=new XMLHttpRequest;if(Xt.withCredentials=!!b[ze+60],Xt.open(yt,Ye,!Vt,V0,Z0),Vt||(Xt.timeout=Mt),Xt.url_=Ye,Xt.responseType="arraybuffer",w0){var $r=zx(w0);Xt.overrideMimeType($r)}if(e0)for(;;){var sr=M[e0>>2];if(!sr)break;var Xs=M[e0+4>>2];if(!Xs)break;e0+=8;var ex=zx(sr),or=zx(Xs);Xt.setRequestHeader(ex,or)}var wn=D.xhrs.allocate(Xt);M[F>>2]=wn;var _l=ox&&gx?b.slice(ox,ox+gx):null;function Sl(){var H0=0,On=0;Xt.response&&bx&&M[F+12>>2]===0&&(On=Xt.response.byteLength),On>0&&(H0=Gs(On),b.set(new Uint8Array(Xt.response),H0)),M[F+12>>2]=H0,pe(F+16,On),pe(F+24,0);var Bi=Xt.response?Xt.response.byteLength:0;Bi&&pe(F+32,Bi),T[F+40>>1]=Xt.readyState,T[F+42>>1]=Xt.status,Xt.statusText&&_n(Xt.statusText,F+44,64)}Xt.onload=H0=>{D.xhrs.has(wn)&&(Sl(),Xt.status>=200&&Xt.status<300?O==null||O(F,Xt,H0):$==null||$(F,Xt,H0))},Xt.onerror=H0=>{D.xhrs.has(wn)&&(Sl(),$==null||$(F,Xt,H0))},Xt.ontimeout=H0=>{D.xhrs.has(wn)&&($==null||$(F,Xt,H0))},Xt.onprogress=H0=>{if(D.xhrs.has(wn)){var On=bx&&xt&&Xt.response?Xt.response.byteLength:0,Bi=0;On>0&&bx&&xt&&(Bi=Gs(On),b.set(new Uint8Array(Xt.response),Bi)),M[F+12>>2]=Bi,pe(F+16,On),pe(F+24,H0.loaded-On),pe(F+32,H0.total),T[F+40>>1]=Xt.readyState,Xt.readyState>=3&&Xt.status===0&&H0.loaded>0&&(Xt.status=200),T[F+42>>1]=Xt.status,Xt.statusText&&_n(Xt.statusText,F+44,64),oe==null||oe(F,Xt,H0),Bi&&ar(Bi)}},Xt.onreadystatechange=H0=>{D.xhrs.has(wn)&&(T[F+40>>1]=Xt.readyState,Xt.readyState>=2&&(T[F+42>>1]=Xt.status),Oe==null||Oe(F,Xt,H0))};try{Xt.send(_l)}catch(H0){$==null||$(F,Xt,H0)}}var X=F=>{if(F instanceof Bt||F=="unwind")return _;s(1,F)},J=()=>{},ue=F=>{if(!g)try{F(),J()}catch(O){X(O)}},pe=(F,O)=>{M[F>>2]=O;var $=M[F>>2];M[F+4>>2]=(O-$)/4294967296};function ve(F,O,$,oe,Oe){if(!F){Oe(O,0,"IndexedDB not available!");return}var Le=O+112,Ye=M[Le+64>>2];Ye||(Ye=M[O+8>>2]);var ze=zx(Ye);try{var yt=F.transaction(["FILES"],"readwrite"),Mt=yt.objectStore("FILES"),vt=Mt.put($,ze);vt.onsuccess=a0=>{T[O+40>>1]=4,T[O+42>>1]=200,_n("OK",O+44,64),oe(O,0,ze)},vt.onerror=a0=>{T[O+40>>1]=4,T[O+42>>1]=413,_n("Payload Too Large",O+44,64),Oe(O,0,a0)}}catch(a0){Oe(O,0,a0)}}function we(F,O,$,oe){if(!F){oe(O,0,"IndexedDB not available!");return}var Oe=O+112,Le=M[Oe+64>>2];Le||(Le=M[O+8>>2]);var Ye=zx(Le);try{var ze=F.transaction(["FILES"],"readonly"),yt=ze.objectStore("FILES"),Mt=yt.get(Ye);Mt.onsuccess=vt=>{if(vt.target.result){var a0=vt.target.result,e0=a0.byteLength||a0.length,w0=Gs(e0);b.set(new Uint8Array(a0),w0),M[O+12>>2]=w0,pe(O+16,e0),pe(O+24,0),pe(O+32,e0),T[O+40>>1]=4,T[O+42>>1]=200,_n("OK",O+44,64),$(O,0,a0)}else T[O+40>>1]=4,T[O+42>>1]=404,_n("Not Found",O+44,64),oe(O,0,"no data")},Mt.onerror=vt=>{T[O+40>>1]=4,T[O+42>>1]=404,_n("Not Found",O+44,64),oe(O,0,vt)}}catch(vt){oe(O,0,vt)}}function $e(F,O,$,oe){if(!F){oe(O,0,"IndexedDB not available!");return}var Oe=O+112,Le=M[Oe+64>>2];Le||(Le=M[O+8>>2]);var Ye=zx(Le);try{var ze=F.transaction(["FILES"],"readwrite"),yt=ze.objectStore("FILES"),Mt=yt.delete(Ye);Mt.onsuccess=vt=>{var a0=vt.target.result;M[O+12>>2]=0,pe(O+16,0),pe(O+24,0),pe(O+32,0),T[O+40>>1]=4,T[O+42>>1]=200,_n("OK",O+44,64),$(O,0,a0)},Mt.onerror=vt=>{T[O+40>>1]=4,T[O+42>>1]=404,_n("Not Found",O+44,64),oe(O,0,vt)}}catch(vt){oe(O,0,vt)}}function st(F,O,$,oe,Oe){var Le=F+112,Ye=M[Le+36>>2],ze=M[Le+40>>2],yt=M[Le+44>>2],Mt=M[Le+48>>2],vt=M[Le+52>>2],a0=!!(vt&64);function e0(ex){a0?ex():ue(ex)}var w0=(ex,or,wn)=>{e0(()=>{Ye?Ft(Ye)(ex):O==null||O(ex)})},ox=(ex,or,wn)=>{e0(()=>{yt?Ft(yt)(ex):oe==null||oe(ex)})},gx=(ex,or,wn)=>{e0(()=>{ze?Ft(ze)(ex):$==null||$(ex)})},vx=(ex,or,wn)=>{e0(()=>{Mt?Ft(Mt)(ex):Oe==null||Oe(ex)})},bx=(ex,or,wn)=>{U(ex,w0,gx,ox,vx)},xt=(ex,or,wn)=>{var _l=(H0,On,Bi)=>{e0(()=>{Ye?Ft(Ye)(H0):O==null||O(H0)})},Sl=(H0,On,Bi)=>{e0(()=>{Ye?Ft(Ye)(H0):O==null||O(H0)})};ve(D.dbInstance,ex,or.response,_l,Sl)},Vt=(ex,or,wn)=>{U(ex,xt,gx,ox,vx)},V0=zx(Le+0),Z0=!!(vt&16),Xt=!!(vt&4),$r=!!(vt&32);if(V0==="EM_IDB_STORE"){var sr=M[Le+84>>2],Xs=M[Le+88>>2];ve(D.dbInstance,F,b.slice(sr,sr+Xs),w0,gx)}else if(V0==="EM_IDB_DELETE")$e(D.dbInstance,F,w0,gx);else if(!Z0)we(D.dbInstance,F,w0,$r?gx:Xt?Vt:bx);else if(!$r)U(F,Xt?xt:w0,gx,ox,vx);else return 0;return F}var ot={},Gt=()=>a||"./this.program",r0=()=>{if(!r0.strings){var F=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",O={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:F,_:Gt()};for(var $ in ot)ot[$]===void 0?delete O[$]:O[$]=ot[$];var oe=[];for(var $ in O)oe.push($+"="+O[$]);r0.strings=oe}return r0.strings},c0=(F,O)=>{for(var $=0;$<F.length;++$)v[O++]=F.charCodeAt($);v[O]=0},F0=(F,O)=>{var $=0;return r0().forEach((oe,Oe)=>{var Le=O+$;M[F+Oe*4>>2]=Le,c0(oe,Le),$+=oe.length+1}),0},Y0=(F,O)=>{var $=r0();M[F>>2]=$.length;var oe=0;return $.forEach(Oe=>oe+=Oe.length+1),M[O>>2]=oe,0},b0=F=>F%4===0&&(F%100!==0||F%400===0),z0=(F,O)=>{for(var $=0,oe=0;oe<=O;$+=F[oe++]);return $},Vx=[31,29,31,30,31,30,31,31,30,31,30,31],Tn=[31,28,31,30,31,30,31,31,30,31,30,31],sn=(F,O)=>{for(var $=new Date(F.getTime());O>0;){var oe=b0($.getFullYear()),Oe=$.getMonth(),Le=(oe?Vx:Tn)[Oe];if(O>Le-$.getDate())O-=Le-$.getDate()+1,$.setDate(1),Oe<11?$.setMonth(Oe+1):($.setMonth(0),$.setFullYear($.getFullYear()+1));else return $.setDate($.getDate()+O),$}return $};function Kn(F,O,$){var oe=nr(F)+1,Oe=new Array(oe);return as(F,Oe,0,Oe.length),Oe}var Kr=(F,O)=>{v.set(F,O)},zc=(F,O,$,oe)=>{var Oe=M[oe+40>>2],Le={tm_sec:A[oe>>2],tm_min:A[oe+4>>2],tm_hour:A[oe+8>>2],tm_mday:A[oe+12>>2],tm_mon:A[oe+16>>2],tm_year:A[oe+20>>2],tm_wday:A[oe+24>>2],tm_yday:A[oe+28>>2],tm_isdst:A[oe+32>>2],tm_gmtoff:A[oe+36>>2],tm_zone:Oe?zx(Oe):""},Ye=zx($),ze={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var yt in ze)Ye=Ye.replace(new RegExp(yt,"g"),ze[yt]);var Mt=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],vt=["January","February","March","April","May","June","July","August","September","October","November","December"];function a0(xt,Vt,V0){for(var Z0=typeof xt=="number"?xt.toString():xt||"";Z0.length<Vt;)Z0=V0[0]+Z0;return Z0}function e0(xt,Vt){return a0(xt,Vt,"0")}function w0(xt,Vt){function V0(Xt){return Xt<0?-1:Xt>0?1:0}var Z0;return(Z0=V0(xt.getFullYear()-Vt.getFullYear()))===0&&(Z0=V0(xt.getMonth()-Vt.getMonth()))===0&&(Z0=V0(xt.getDate()-Vt.getDate())),Z0}function ox(xt){switch(xt.getDay()){case 0:return new Date(xt.getFullYear()-1,11,29);case 1:return xt;case 2:return new Date(xt.getFullYear(),0,3);case 3:return new Date(xt.getFullYear(),0,2);case 4:return new Date(xt.getFullYear(),0,1);case 5:return new Date(xt.getFullYear()-1,11,31);case 6:return new Date(xt.getFullYear()-1,11,30)}}function gx(xt){var Vt=sn(new Date(xt.tm_year+1900,0,1),xt.tm_yday),V0=new Date(Vt.getFullYear(),0,4),Z0=new Date(Vt.getFullYear()+1,0,4),Xt=ox(V0),$r=ox(Z0);return w0(Xt,Vt)<=0?w0($r,Vt)<=0?Vt.getFullYear()+1:Vt.getFullYear():Vt.getFullYear()-1}var vx={"%a":xt=>Mt[xt.tm_wday].substring(0,3),"%A":xt=>Mt[xt.tm_wday],"%b":xt=>vt[xt.tm_mon].substring(0,3),"%B":xt=>vt[xt.tm_mon],"%C":xt=>{var Vt=xt.tm_year+1900;return e0(Vt/100|0,2)},"%d":xt=>e0(xt.tm_mday,2),"%e":xt=>a0(xt.tm_mday,2," "),"%g":xt=>gx(xt).toString().substring(2),"%G":gx,"%H":xt=>e0(xt.tm_hour,2),"%I":xt=>{var Vt=xt.tm_hour;return Vt==0?Vt=12:Vt>12&&(Vt-=12),e0(Vt,2)},"%j":xt=>e0(xt.tm_mday+z0(b0(xt.tm_year+1900)?Vx:Tn,xt.tm_mon-1),3),"%m":xt=>e0(xt.tm_mon+1,2),"%M":xt=>e0(xt.tm_min,2),"%n":()=>`
`,"%p":xt=>xt.tm_hour>=0&&xt.tm_hour<12?"AM":"PM","%S":xt=>e0(xt.tm_sec,2),"%t":()=>"	","%u":xt=>xt.tm_wday||7,"%U":xt=>{var Vt=xt.tm_yday+7-xt.tm_wday;return e0(Math.floor(Vt/7),2)},"%V":xt=>{var Vt=Math.floor((xt.tm_yday+7-(xt.tm_wday+6)%7)/7);if((xt.tm_wday+371-xt.tm_yday-2)%7<=2&&Vt++,Vt){if(Vt==53){var V0=(xt.tm_wday+371-xt.tm_yday)%7;V0!=4&&(V0!=3||!b0(xt.tm_year))&&(Vt=1)}}else{Vt=52;var Z0=(xt.tm_wday+7-xt.tm_yday-1)%7;(Z0==4||Z0==5&&b0(xt.tm_year%400-1))&&Vt++}return e0(Vt,2)},"%w":xt=>xt.tm_wday,"%W":xt=>{var Vt=xt.tm_yday+7-(xt.tm_wday+6)%7;return e0(Math.floor(Vt/7),2)},"%y":xt=>(xt.tm_year+1900).toString().substring(2),"%Y":xt=>xt.tm_year+1900,"%z":xt=>{var Vt=xt.tm_gmtoff,V0=Vt>=0;return Vt=Math.abs(Vt)/60,Vt=Vt/60*100+Vt%60,(V0?"+":"-")+("0000"+Vt).slice(-4)},"%Z":xt=>xt.tm_zone,"%%":()=>"%"};Ye=Ye.replace(/%%/g,"\0\0");for(var yt in vx)Ye.includes(yt)&&(Ye=Ye.replace(new RegExp(yt,"g"),vx[yt](Le)));Ye=Ye.replace(/\0\0/g,"%");var bx=Kn(Ye);return bx.length>O?0:(Kr(bx,F),bx.length-1)},qo=(F,O,$,oe,Oe)=>zc(F,O,$,oe);bt(),Ge=t.BindingError=class extends Error{constructor(F){super(F),this.name="BindingError"}},Ve=t.InternalError=class extends Error{constructor(F){super(F),this.name="InternalError"}},Wn(),P0(),fe(),sx=t.UnboundTypeError=h0(Error,"UnboundTypeError"),Ko(),D.init();var bl={a:at,s:Ue,z:gt,l:$0,f:Di,d:bn,o:T0,y:yl,r:Fs,e:vl,b:rs,q:Zo,m:Jo,A:os,B:ls,g:rr,c:Pi,n:Vs,h:Yn,j:Sn,i:Yr,k:Hs,p:ei,D:In,x:us,w:ne,C:st,u:F0,v:Y0,t:qo},ti=Tt(),Gs=F=>(Gs=ti.G)(F),ar=F=>(ar=ti.I)(F),Ws=F=>(Ws=ti.J)(F),kp=F=>(kp=ti.K)(F);t.dynCall_viijii=(F,O,$,oe,Oe,Le,Ye)=>(t.dynCall_viijii=ti.L)(F,O,$,oe,Oe,Le,Ye),t.dynCall_iiiiij=(F,O,$,oe,Oe,Le,Ye)=>(t.dynCall_iiiiij=ti.M)(F,O,$,oe,Oe,Le,Ye),t.dynCall_iiiiijj=(F,O,$,oe,Oe,Le,Ye,ze,yt)=>(t.dynCall_iiiiijj=ti.N)(F,O,$,oe,Oe,Le,Ye,ze,yt),t.dynCall_iiiiiijj=(F,O,$,oe,Oe,Le,Ye,ze,yt,Mt)=>(t.dynCall_iiiiiijj=ti.O)(F,O,$,oe,Oe,Le,Ye,ze,yt,Mt);var Vc;be=function F(){Vc||Up(),Vc||(be=F)};function Up(){if(q>0||(te(),q>0))return;function F(){Vc||(Vc=!0,t.calledRun=!0,!g&&(j(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),xe()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),F()},1)):F()}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return Up(),e.ready}})();async function lW(x,e="./",t=!1){const n=await oW({locateFile:i=>e+i});return n.Loader.prototype.promisify=function(i,...r){return i.call(this,...r),new Promise(a=>{const s=setInterval(()=>{if(this.ready)return clearInterval(s),a(this.status)},5)})},n.Loader.prototype.load=function(i){return this.promisify(this.loadAsync,i,t)},n.Loader.prototype.remove=function(i){return this.promisify(this.removeAsync,i)},n.DictLoader.prototype.loadDict=function(i){return this.promisify(this.loadDictAsync,x,i)},n}var cW=(()=>{var x=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(e={}){var t=e,n,i;t.ready=new Promise((z,L)=>{n=z,i=L});var r=Object.assign({},t),a=!0,s="";function l(z){return t.locateFile?t.locateFile(z,s):s+z}typeof document<"u"&&document.currentScript&&(s=document.currentScript.src),x&&(s=x),s.startsWith("blob:")?s="":s=s.substr(0,s.replace(/[?#].*/,"").lastIndexOf("/")+1),t.print||console.log.bind(console);var c=t.printErr||console.error.bind(console);Object.assign(t,r),r=null,t.arguments&&t.arguments,t.thisProgram&&t.thisProgram,t.quit&&t.quit;var h;t.wasmBinary&&(h=t.wasmBinary);var d,p=!1,m,g,_,v,b,T,E,A;function M(){var z=d.buffer;t.HEAP8=m=new Int8Array(z),t.HEAP16=_=new Int16Array(z),t.HEAPU8=g=new Uint8Array(z),t.HEAPU16=v=new Uint16Array(z),t.HEAP32=b=new Int32Array(z),t.HEAPU32=T=new Uint32Array(z),t.HEAPF32=E=new Float32Array(z),t.HEAPF64=A=new Float64Array(z)}var R=[],C=[],k=[];function P(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)te(t.preRun.shift());qe(R)}function N(){qe(C)}function G(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)xe(t.postRun.shift());qe(k)}function te(z){R.unshift(z)}function j(z){C.unshift(z)}function xe(z){k.unshift(z)}var ae=0,H=null;function re(z){var L;ae++,(L=t.monitorRunDependencies)==null||L.call(t,ae)}function q(z){var L;if(ae--,(L=t.monitorRunDependencies)==null||L.call(t,ae),ae==0&&H){var ne=H;H=null,ne()}}function be(z){var L;(L=t.onAbort)==null||L.call(t,z),z="Aborted("+z+")",c(z),p=!0,z+=". Build with -sASSERTIONS for more info.";var ne=new WebAssembly.RuntimeError(z);throw i(ne),ne}var K="data:application/octet-stream;base64,",se=z=>z.startsWith(K),ge;ge="poseutils.wasm",se(ge)||(ge=l(ge));function Me(z){if(z==ge&&h)return new Uint8Array(h);throw"both async and sync fetching of the wasm failed"}function le(z){return!h&&a&&typeof fetch=="function"?fetch(z,{credentials:"same-origin"}).then(L=>{if(!L.ok)throw"failed to load wasm binary file at '"+z+"'";return L.arrayBuffer()}).catch(()=>Me(z)):Promise.resolve().then(()=>Me(z))}function Se(z,L,ne){return le(z).then(Te=>WebAssembly.instantiate(Te,L)).then(ne,Te=>{c("failed to asynchronously prepare wasm: "+Te),be(Te)})}function Fe(z,L,ne,Te){return!z&&typeof WebAssembly.instantiateStreaming=="function"&&!se(L)&&typeof fetch=="function"?fetch(L,{credentials:"same-origin"}).then(D=>{var U=WebAssembly.instantiateStreaming(D,ne);return U.then(Te,function(X){return c("wasm streaming compile failed: "+X),c("falling back to ArrayBuffer instantiation"),Se(L,ne,Te)})}):Se(L,ne,Te)}function Qe(){var z={a:Vs};function L(Te,D){return Yn=Te.exports,d=Yn.v,M(),Ct=Yn.z,j(Yn.w),q(),Yn}re();function ne(Te){L(Te.instance)}if(t.instantiateWasm)try{return t.instantiateWasm(z,L)}catch(Te){c("Module.instantiateWasm callback failed with error: "+Te),i(Te)}return Fe(h,ge,z,ne).catch(i),{}}var qe=z=>{for(;z.length>0;)z.shift()(t)};t.noExitRuntime;class Et{constructor(L){this.excPtr=L,this.ptr=L-24}set_type(L){T[this.ptr+4>>2]=L}get_type(){return T[this.ptr+4>>2]}set_destructor(L){T[this.ptr+8>>2]=L}get_destructor(){return T[this.ptr+8>>2]}set_caught(L){L=L?1:0,m[this.ptr+12]=L}get_caught(){return m[this.ptr+12]!=0}set_rethrown(L){L=L?1:0,m[this.ptr+13]=L}get_rethrown(){return m[this.ptr+13]!=0}init(L,ne){this.set_adjusted_ptr(0),this.set_type(L),this.set_destructor(ne)}set_adjusted_ptr(L){T[this.ptr+16>>2]=L}get_adjusted_ptr(){return T[this.ptr+16>>2]}get_exception_ptr(){var L=ei(this.get_type());if(L)return T[this.excPtr>>2];var ne=this.get_adjusted_ptr();return ne!==0?ne:this.excPtr}}var Tt=0,Bt=(z,L,ne)=>{var Te=new Et(z);throw Te.init(L,ne),Tt=z,Tt},Q={},rt=z=>{for(;z.length;){var L=z.pop(),ne=z.pop();ne(L)}};function He(z){return this.fromWireType(T[z>>2])}var at={},Ue={},bt={},ht,dt=z=>{throw new ht(z)},Z=(z,L,ne)=>{z.forEach(function(J){bt[J]=L});function Te(J){var ue=ne(J);ue.length!==z.length&&dt("Mismatched type converter count");for(var pe=0;pe<z.length;++pe)et(z[pe],ue[pe])}var D=new Array(L.length),U=[],X=0;L.forEach((J,ue)=>{Ue.hasOwnProperty(J)?D[ue]=Ue[J]:(U.push(J),at.hasOwnProperty(J)||(at[J]=[]),at[J].push(()=>{D[ue]=Ue[J],++X,X===U.length&&Te(D)}))}),U.length===0&&Te(D)},V=z=>{var L=Q[z];delete Q[z];var ne=L.rawConstructor,Te=L.rawDestructor,D=L.fields,U=D.map(X=>X.getterReturnType).concat(D.map(X=>X.setterArgumentType));Z([z],U,X=>{var J={};return D.forEach((ue,pe)=>{var ve=ue.fieldName,we=X[pe],$e=ue.getter,st=ue.getterContext,ot=X[pe+D.length],Gt=ue.setter,r0=ue.setterContext;J[ve]={read:c0=>we.fromWireType($e(st,c0)),write:(c0,F0)=>{var Y0=[];Gt(r0,c0,ot.toWireType(Y0,F0)),rt(Y0)}}}),[{name:L.name,fromWireType:ue=>{var pe={};for(var ve in J)pe[ve]=J[ve].read(ue);return Te(ue),pe},toWireType:(ue,pe)=>{for(var ve in J)if(!(ve in pe))throw new TypeError('Missing field: "'+ve+'"');var we=ne();for(ve in J)J[ve].write(we,pe[ve]);return ue!==null&&ue.push(Te,we),we},argPackAdvance:tt,readValueFromPointer:He,destructorFunction:Te}]})},_e=(z,L,ne,Te,D)=>{},Ge=()=>{for(var z=new Array(256),L=0;L<256;++L)z[L]=String.fromCharCode(L);Re=z},Re,Ve=z=>{for(var L="",ne=z;g[ne];)L+=Re[g[ne++]];return L},_t,Ce=z=>{throw new _t(z)};function pt(z,L,ne={}){var Te=L.name;if(z||Ce('type "'+Te+'" must have a positive integer typeid pointer'),Ue.hasOwnProperty(z)){if(ne.ignoreDuplicateRegistrations)return;Ce("Cannot register type '"+Te+"' twice")}if(Ue[z]=L,delete bt[z],at.hasOwnProperty(z)){var D=at[z];delete at[z],D.forEach(U=>U())}}function et(z,L,ne={}){if(!("argPackAdvance"in L))throw new TypeError("registerType registeredInstance requires argPackAdvance");return pt(z,L,ne)}var tt=8,gt=(z,L,ne,Te)=>{L=Ve(L),et(z,{name:L,fromWireType:function(D){return!!D},toWireType:function(D,U){return U?ne:Te},argPackAdvance:tt,readValueFromPointer:function(D){return this.fromWireType(g[D])},destructorFunction:null})},i0=z=>({count:z.count,deleteScheduled:z.deleteScheduled,preservePointerOnDelete:z.preservePointerOnDelete,ptr:z.ptr,ptrType:z.ptrType,smartPtr:z.smartPtr,smartPtrType:z.smartPtrType}),Ht=z=>{function L(ne){return ne.$$.ptrType.registeredClass.name}Ce(L(z)+" instance already deleted")},St=!1,Ut=z=>{},t0=z=>{z.smartPtr?z.smartPtrType.rawDestructor(z.smartPtr):z.ptrType.registeredClass.rawDestructor(z.ptr)},p0=z=>{z.count.value-=1;var L=z.count.value===0;L&&t0(z)},de=(z,L,ne)=>{if(L===ne)return z;if(ne.baseClass===void 0)return null;var Te=de(z,L,ne.baseClass);return Te===null?null:ne.downcast(Te)},ft={},Xe=()=>Object.keys(s0).length,Ze=()=>{var z=[];for(var L in s0)s0.hasOwnProperty(L)&&z.push(s0[L]);return z},lt=[],Wt=()=>{for(;lt.length;){var z=lt.pop();z.$$.deleteScheduled=!1,z.delete()}},Qt,D0=z=>{Qt=z,lt.length&&Qt&&Qt(Wt)},P0=()=>{t.getInheritedInstanceCount=Xe,t.getLiveInheritedInstances=Ze,t.flushPendingDeletes=Wt,t.setDelayFunction=D0},s0={},rn=(z,L)=>{for(L===void 0&&Ce("ptr should not be undefined");z.baseClass;)L=z.upcast(L),z=z.baseClass;return L},Cx=(z,L)=>(L=rn(z,L),s0[L]),ax=(z,L)=>{(!L.ptrType||!L.ptr)&&dt("makeClassHandle requires ptr and ptrType");var ne=!!L.smartPtrType,Te=!!L.smartPtr;return ne!==Te&&dt("Both smartPtrType and smartPtr must be specified"),L.count={value:1},R0(Object.create(z,{$$:{value:L,writable:!0}}))};function L0(z){var L=this.getPointee(z);if(!L)return this.destructor(z),null;var ne=Cx(this.registeredClass,L);if(ne!==void 0){if(ne.$$.count.value===0)return ne.$$.ptr=L,ne.$$.smartPtr=z,ne.clone();var Te=ne.clone();return this.destructor(z),Te}function D(){return this.isSmartPointer?ax(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:L,smartPtrType:this,smartPtr:z}):ax(this.registeredClass.instancePrototype,{ptrType:this,ptr:z})}var U=this.registeredClass.getActualType(L),X=ft[U];if(!X)return D.call(this);var J;this.isConst?J=X.constPointerType:J=X.pointerType;var ue=de(L,this.registeredClass,J.registeredClass);return ue===null?D.call(this):this.isSmartPointer?ax(J.registeredClass.instancePrototype,{ptrType:J,ptr:ue,smartPtrType:this,smartPtr:z}):ax(J.registeredClass.instancePrototype,{ptrType:J,ptr:ue})}var R0=z=>typeof FinalizationRegistry>"u"?(R0=L=>L,z):(St=new FinalizationRegistry(L=>{p0(L.$$)}),R0=L=>{var ne=L.$$,Te=!!ne.smartPtr;if(Te){var D={$$:ne};St.register(L,D,L)}return L},Ut=L=>St.unregister(L),R0(z)),Wn=()=>{Object.assign(q0.prototype,{isAliasOf(z){if(!(this instanceof q0)||!(z instanceof q0))return!1;var L=this.$$.ptrType.registeredClass,ne=this.$$.ptr;z.$$=z.$$;for(var Te=z.$$.ptrType.registeredClass,D=z.$$.ptr;L.baseClass;)ne=L.upcast(ne),L=L.baseClass;for(;Te.baseClass;)D=Te.upcast(D),Te=Te.baseClass;return L===Te&&ne===D},clone(){if(this.$$.ptr||Ht(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var z=R0(Object.create(Object.getPrototypeOf(this),{$$:{value:i0(this.$$)}}));return z.$$.count.value+=1,z.$$.deleteScheduled=!1,z},delete(){this.$$.ptr||Ht(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Ce("Object already scheduled for deletion"),Ut(this),p0(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||Ht(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&Ce("Object already scheduled for deletion"),lt.push(this),lt.length===1&&Qt&&Qt(Wt),this.$$.deleteScheduled=!0,this}})};function q0(){}var Fx=(z,L)=>Object.defineProperty(L,"name",{value:z}),gn=(z,L,ne)=>{if(z[L].overloadTable===void 0){var Te=z[L];z[L]=function(...D){return z[L].overloadTable.hasOwnProperty(D.length)||Ce("Function '"+ne+"' called with an invalid number of arguments ("+D.length+") - expects one of ("+z[L].overloadTable+")!"),z[L].overloadTable[D.length].apply(this,D)},z[L].overloadTable=[],z[L].overloadTable[Te.argCount]=Te}},mi=(z,L,ne)=>{t.hasOwnProperty(z)?(Ce("Cannot register public name '"+z+"' twice"),gn(t,z,z),t.hasOwnProperty(ne)&&Ce("Cannot register multiple overloads of a function with the same number of arguments ("+ne+")!"),t[z].overloadTable[ne]=L):t[z]=L},yi=48,Gr=57,Ii=z=>{if(z===void 0)return"_unknown";z=z.replace(/[^a-zA-Z0-9_]/g,"$");var L=z.charCodeAt(0);return L>=yi&&L<=Gr?"_"+z:z};function Oi(z,L,ne,Te,D,U,X,J){this.name=z,this.constructor=L,this.instancePrototype=ne,this.rawDestructor=Te,this.baseClass=D,this.getActualType=U,this.upcast=X,this.downcast=J,this.pureVirtualFunctions=[]}var vn=(z,L,ne)=>{for(;L!==ne;)L.upcast||Ce("Expected null or instance of "+ne.name+", got an instance of "+L.name),z=L.upcast(z),L=L.baseClass;return z};function Y(z,L){if(L===null)return this.isReference&&Ce("null is not a valid "+this.name),0;L.$$||Ce('Cannot pass "'+ki(L)+'" as a '+this.name),L.$$.ptr||Ce("Cannot pass deleted object as a pointer of type "+this.name);var ne=L.$$.ptrType.registeredClass,Te=vn(L.$$.ptr,ne,this.registeredClass);return Te}function ce(z,L){var ne;if(L===null)return this.isReference&&Ce("null is not a valid "+this.name),this.isSmartPointer?(ne=this.rawConstructor(),z!==null&&z.push(this.rawDestructor,ne),ne):0;(!L||!L.$$)&&Ce('Cannot pass "'+ki(L)+'" as a '+this.name),L.$$.ptr||Ce("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&L.$$.ptrType.isConst&&Ce("Cannot convert argument of type "+(L.$$.smartPtrType?L.$$.smartPtrType.name:L.$$.ptrType.name)+" to parameter type "+this.name);var Te=L.$$.ptrType.registeredClass;if(ne=vn(L.$$.ptr,Te,this.registeredClass),this.isSmartPointer)switch(L.$$.smartPtr===void 0&&Ce("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:L.$$.smartPtrType===this?ne=L.$$.smartPtr:Ce("Cannot convert argument of type "+(L.$$.smartPtrType?L.$$.smartPtrType.name:L.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:ne=L.$$.smartPtr;break;case 2:if(L.$$.smartPtrType===this)ne=L.$$.smartPtr;else{var D=L.clone();ne=this.rawShare(ne,bi.toHandle(()=>D.delete())),z!==null&&z.push(this.rawDestructor,ne)}break;default:Ce("Unsupporting sharing policy")}return ne}function Ne(z,L){if(L===null)return this.isReference&&Ce("null is not a valid "+this.name),0;L.$$||Ce('Cannot pass "'+ki(L)+'" as a '+this.name),L.$$.ptr||Ce("Cannot pass deleted object as a pointer of type "+this.name),L.$$.ptrType.isConst&&Ce("Cannot convert argument of type "+L.$$.ptrType.name+" to parameter type "+this.name);var ne=L.$$.ptrType.registeredClass,Te=vn(L.$$.ptr,ne,this.registeredClass);return Te}var Ie=()=>{Object.assign(fe.prototype,{getPointee(z){return this.rawGetPointee&&(z=this.rawGetPointee(z)),z},destructor(z){var L;(L=this.rawDestructor)==null||L.call(this,z)},argPackAdvance:tt,readValueFromPointer:He,fromWireType:L0})};function fe(z,L,ne,Te,D,U,X,J,ue,pe,ve){this.name=z,this.registeredClass=L,this.isReference=ne,this.isConst=Te,this.isSmartPointer=D,this.pointeeType=U,this.sharingPolicy=X,this.rawGetPointee=J,this.rawConstructor=ue,this.rawShare=pe,this.rawDestructor=ve,!D&&L.baseClass===void 0?Te?(this.toWireType=Y,this.destructorFunction=null):(this.toWireType=Ne,this.destructorFunction=null):this.toWireType=ce}var ct=(z,L,ne)=>{t.hasOwnProperty(z)||dt("Replacing nonexistent public symbol"),t[z].overloadTable!==void 0&&ne!==void 0?t[z].overloadTable[ne]=L:(t[z]=L,t[z].argCount=ne)},wt=(z,L,ne)=>{var Te=t["dynCall_"+z];return Te(L,...ne)},It=[],Ct,Kt=z=>{var L=It[z];return L||(z>=It.length&&(It.length=z+1),It[z]=L=Ct.get(z)),L},Ft=(z,L,ne=[])=>{if(z.includes("j"))return wt(z,L,ne);var Te=Kt(L)(...ne);return Te},Dt=(z,L)=>(...ne)=>Ft(z,L,ne),Zt=(z,L)=>{z=Ve(z);function ne(){return z.includes("j")?Dt(z,L):Kt(L)}var Te=ne();return typeof Te!="function"&&Ce("unknown function pointer with signature "+z+": "+L),Te},v0=(z,L)=>{var ne=Fx(L,function(Te){this.name=L,this.message=Te;var D=new Error(Te).stack;D!==void 0&&(this.stack=this.toString()+`
`+D.replace(/^Error(:[^\n]*)?\n/,""))});return ne.prototype=Object.create(z.prototype),ne.prototype.constructor=ne,ne.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},ne},h0,sx=z=>{var L=Hs(z),ne=Ve(L);return Sn(L),ne},d0=(z,L)=>{var ne=[],Te={};function D(U){if(!Te[U]&&!Ue[U]){if(bt[U]){bt[U].forEach(D);return}ne.push(U),Te[U]=!0}}throw L.forEach(D),new h0(z+": "+ne.map(sx).join([", "]))},Ot=(z,L,ne,Te,D,U,X,J,ue,pe,ve,we,$e)=>{ve=Ve(ve),U=Zt(D,U),J&&(J=Zt(X,J)),pe&&(pe=Zt(ue,pe)),$e=Zt(we,$e);var st=Ii(ve);mi(st,function(){d0("Cannot construct "+ve+" due to unbound types",[Te])}),Z([z,L,ne],Te?[Te]:[],ot=>{var Gt;ot=ot[0];var r0,c0;Te?(r0=ot.registeredClass,c0=r0.instancePrototype):c0=q0.prototype;var F0=Fx(ve,function(...sn){if(Object.getPrototypeOf(this)!==Y0)throw new _t("Use 'new' to construct "+ve);if(b0.constructor_body===void 0)throw new _t(ve+" has no accessible constructor");var Kn=b0.constructor_body[sn.length];if(Kn===void 0)throw new _t("Tried to invoke ctor of "+ve+" with invalid number of parameters ("+sn.length+") - expected ("+Object.keys(b0.constructor_body).toString()+") parameters instead!");return Kn.apply(this,sn)}),Y0=Object.create(c0,{constructor:{value:F0}});F0.prototype=Y0;var b0=new Oi(ve,F0,Y0,$e,r0,U,J,pe);b0.baseClass&&((Gt=b0.baseClass).__derivedClasses!=null||(Gt.__derivedClasses=[]),b0.baseClass.__derivedClasses.push(b0));var z0=new fe(ve,b0,!0,!1,!1),Vx=new fe(ve+"*",b0,!1,!1,!1),Tn=new fe(ve+" const*",b0,!1,!0,!1);return ft[z]={pointerType:Vx,constPointerType:Tn},ct(st,F0),[z0,Vx,Tn]})},$0=(z,L)=>{for(var ne=[],Te=0;Te<z;Te++)ne.push(T[L+Te*4>>2]);return ne};function y0(z){for(var L=1;L<z.length;++L)if(z[L]!==null&&z[L].destructorFunction===void 0)return!0;return!1}function U0(z,L,ne,Te,D,U){var X=L.length;X<2&&Ce("argTypes array size mismatch! Must at least get return value and 'this' types!");var J=L[1]!==null&&ne!==null,ue=y0(L),pe=L[0].name!=="void",ve=X-2,we=new Array(ve),$e=[],st=[],ot=function(...Gt){Gt.length!==ve&&Ce("function "+z+" called with "+Gt.length+" arguments, expected "+ve),st.length=0;var r0;$e.length=J?2:1,$e[0]=D,J&&(r0=L[1].toWireType(st,this),$e[1]=r0);for(var c0=0;c0<ve;++c0)we[c0]=L[c0+2].toWireType(st,Gt[c0]),$e.push(we[c0]);var F0=Te(...$e);function Y0(b0){if(ue)rt(st);else for(var z0=J?1:2;z0<L.length;z0++){var Vx=z0===1?r0:we[z0-2];L[z0].destructorFunction!==null&&L[z0].destructorFunction(Vx)}if(pe)return L[0].fromWireType(b0)}return Y0(F0)};return Fx(z,ot)}var gi=(z,L,ne,Te,D,U)=>{var X=$0(L,ne);D=Zt(Te,D),Z([],[z],J=>{J=J[0];var ue="constructor "+J.name;if(J.registeredClass.constructor_body===void 0&&(J.registeredClass.constructor_body=[]),J.registeredClass.constructor_body[L-1]!==void 0)throw new _t("Cannot register multiple constructors with identical number of parameters ("+(L-1)+") for class '"+J.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return J.registeredClass.constructor_body[L-1]=()=>{d0("Cannot construct "+J.name+" due to unbound types",X)},Z([],X,pe=>(pe.splice(1,0,null),J.registeredClass.constructor_body[L-1]=U0(ue,pe,null,D,U),[])),[]})},Bx=z=>{z=z.trim();const L=z.indexOf("(");return L!==-1?z.substr(0,L):z},Di=(z,L,ne,Te,D,U,X,J,ue)=>{var pe=$0(ne,Te);L=Ve(L),L=Bx(L),U=Zt(D,U),Z([],[z],ve=>{ve=ve[0];var we=ve.name+"."+L;L.startsWith("@@")&&(L=Symbol[L.substring(2)]),J&&ve.registeredClass.pureVirtualFunctions.push(L);function $e(){d0("Cannot call "+we+" due to unbound types",pe)}var st=ve.registeredClass.instancePrototype,ot=st[L];return ot===void 0||ot.overloadTable===void 0&&ot.className!==ve.name&&ot.argCount===ne-2?($e.argCount=ne-2,$e.className=ve.name,st[L]=$e):(gn(st,L,we),st[L].overloadTable[ne-2]=$e),Z([],pe,Gt=>{var r0=U0(we,Gt,ve,U,X);return st[L].overloadTable===void 0?(r0.argCount=ne-2,st[L]=r0):st[L].overloadTable[ne-2]=r0,[]}),[]})},Q0=(z,L,ne)=>(z instanceof Object||Ce(ne+' with invalid "this": '+z),z instanceof L.registeredClass.constructor||Ce(ne+' incompatible with "this" of type '+z.constructor.name),z.$$.ptr||Ce("cannot call emscripten binding method "+ne+" on deleted object"),vn(z.$$.ptr,z.$$.ptrType.registeredClass,L.registeredClass)),bn=(z,L,ne,Te,D,U,X,J,ue,pe)=>{L=Ve(L),D=Zt(Te,D),Z([],[z],ve=>{ve=ve[0];var we=ve.name+"."+L,$e={get(){d0("Cannot access "+we+" due to unbound types",[ne,X])},enumerable:!0,configurable:!0};return ue?$e.set=()=>d0("Cannot access "+we+" due to unbound types",[ne,X]):$e.set=st=>Ce(we+" is a read-only property"),Object.defineProperty(ve.registeredClass.instancePrototype,L,$e),Z([],ue?[ne,X]:[ne],st=>{var ot=st[0],Gt={get(){var c0=Q0(this,ve,we+" getter");return ot.fromWireType(D(U,c0))},enumerable:!0};if(ue){ue=Zt(J,ue);var r0=st[1];Gt.set=function(c0){var F0=Q0(this,ve,we+" setter"),Y0=[];ue(pe,F0,r0.toWireType(Y0,c0)),rt(Y0)}}return Object.defineProperty(ve.registeredClass.instancePrototype,L,Gt),[]}),[]})},vi=[],T0=[],Xn=z=>{z>9&&--T0[z+1]===0&&(T0[z]=void 0,vi.push(z))},Nx=()=>T0.length/2-5-vi.length,Pi=()=>{T0.push(0,1,void 0,1,null,1,!0,1,!1,1),t.count_emval_handles=Nx},bi={toValue:z=>(z||Ce("Cannot use deleted val. handle = "+z),T0[z]),toHandle:z=>{switch(z){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const L=vi.pop()||T0.length;return T0[L]=z,T0[L+1]=1,L}}}},Ko={name:"emscripten::val",fromWireType:z=>{var L=bi.toValue(z);return Xn(z),L},toWireType:(z,L)=>bi.toHandle(L),argPackAdvance:tt,readValueFromPointer:He,destructorFunction:null},Lx=z=>et(z,Ko),ki=z=>{if(z===null)return"null";var L=typeof z;return L==="object"||L==="array"||L==="function"?z.toString():""+z},yl=(z,L)=>{switch(L){case 4:return function(ne){return this.fromWireType(E[ne>>2])};case 8:return function(ne){return this.fromWireType(A[ne>>3])};default:throw new TypeError("invalid float width ("+L+"): "+z)}},Wr=(z,L,ne)=>{L=Ve(L),et(z,{name:L,fromWireType:Te=>Te,toWireType:(Te,D)=>D,argPackAdvance:tt,readValueFromPointer:yl(L,ne),destructorFunction:null})},$o=(z,L,ne)=>{switch(L){case 1:return ne?Te=>m[Te]:Te=>g[Te];case 2:return ne?Te=>_[Te>>1]:Te=>v[Te>>1];case 4:return ne?Te=>b[Te>>2]:Te=>T[Te>>2];default:throw new TypeError("invalid integer width ("+L+"): "+z)}},Fs=(z,L,ne,Te,D)=>{L=Ve(L);var U=ve=>ve;if(Te===0){var X=32-8*ne;U=ve=>ve<<X>>>X}var J=L.includes("unsigned"),ue=(ve,we)=>{},pe;J?pe=function(ve,we){return ue(we,this.name),we>>>0}:pe=function(ve,we){return ue(we,this.name),we},et(z,{name:L,fromWireType:U,toWireType:pe,argPackAdvance:tt,readValueFromPointer:$o(L,ne,Te!==0),destructorFunction:null})},gl=(z,L,ne)=>{var Te=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],D=Te[L];function U(X){var J=T[X>>2],ue=T[X+4>>2];return new D(m.buffer,ue,J)}ne=Ve(ne),et(z,{name:ne,fromWireType:U,argPackAdvance:tt,readValueFromPointer:U},{ignoreDuplicateRegistrations:!0})},vl=(z,L,ne,Te)=>{if(!(Te>0))return 0;for(var D=ne,U=ne+Te-1,X=0;X<z.length;++X){var J=z.charCodeAt(X);if(J>=55296&&J<=57343){var ue=z.charCodeAt(++X);J=65536+((J&1023)<<10)|ue&1023}if(J<=127){if(ne>=U)break;L[ne++]=J}else if(J<=2047){if(ne+1>=U)break;L[ne++]=192|J>>6,L[ne++]=128|J&63}else if(J<=65535){if(ne+2>=U)break;L[ne++]=224|J>>12,L[ne++]=128|J>>6&63,L[ne++]=128|J&63}else{if(ne+3>=U)break;L[ne++]=240|J>>18,L[ne++]=128|J>>12&63,L[ne++]=128|J>>6&63,L[ne++]=128|J&63}}return L[ne]=0,ne-D},rs=(z,L,ne)=>vl(z,g,L,ne),as=z=>{for(var L=0,ne=0;ne<z.length;++ne){var Te=z.charCodeAt(ne);Te<=127?L++:Te<=2047?L+=2:Te>=55296&&Te<=57343?(L+=4,++ne):L+=3}return L},_n=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,nr=(z,L,ne)=>{for(var Te=L+ne,D=L;z[D]&&!(D>=Te);)++D;if(D-L>16&&z.buffer&&_n)return _n.decode(z.subarray(L,D));for(var U="";L<D;){var X=z[L++];if(!(X&128)){U+=String.fromCharCode(X);continue}var J=z[L++]&63;if((X&224)==192){U+=String.fromCharCode((X&31)<<6|J);continue}var ue=z[L++]&63;if((X&240)==224?X=(X&15)<<12|J<<6|ue:X=(X&7)<<18|J<<12|ue<<6|z[L++]&63,X<65536)U+=String.fromCharCode(X);else{var pe=X-65536;U+=String.fromCharCode(55296|pe>>10,56320|pe&1023)}}return U},Ui=(z,L)=>z?nr(g,z,L):"",Qo=(z,L)=>{L=Ve(L);var ne=L==="std::string";et(z,{name:L,fromWireType(Te){var D=T[Te>>2],U=Te+4,X;if(ne)for(var J=U,ue=0;ue<=D;++ue){var pe=U+ue;if(ue==D||g[pe]==0){var ve=pe-J,we=Ui(J,ve);X===void 0?X=we:(X+="\0",X+=we),J=pe+1}}else{for(var $e=new Array(D),ue=0;ue<D;++ue)$e[ue]=String.fromCharCode(g[U+ue]);X=$e.join("")}return Sn(Te),X},toWireType(Te,D){D instanceof ArrayBuffer&&(D=new Uint8Array(D));var U,X=typeof D=="string";X||D instanceof Uint8Array||D instanceof Uint8ClampedArray||D instanceof Int8Array||Ce("Cannot pass non-string to std::string"),ne&&X?U=as(D):U=D.length;var J=Yr(4+U+1),ue=J+4;if(T[J>>2]=U,ne&&X)rs(D,ue,U+1);else if(X)for(var pe=0;pe<U;++pe){var ve=D.charCodeAt(pe);ve>255&&(Sn(ue),Ce("String has UTF-16 code units that do not fit in 8 bits")),g[ue+pe]=ve}else for(var pe=0;pe<U;++pe)g[ue+pe]=D[pe];return Te!==null&&Te.push(Sn,J),J},argPackAdvance:tt,readValueFromPointer:He,destructorFunction(Te){Sn(Te)}})},zx=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Zo=(z,L)=>{for(var ne=z,Te=ne>>1,D=Te+L/2;!(Te>=D)&&v[Te];)++Te;if(ne=Te<<1,ne-z>32&&zx)return zx.decode(g.subarray(z,ne));for(var U="",X=0;!(X>=L/2);++X){var J=_[z+X*2>>1];if(J==0)break;U+=String.fromCharCode(J)}return U},ir=(z,L,ne)=>{if(ne!=null||(ne=2147483647),ne<2)return 0;ne-=2;for(var Te=L,D=ne<z.length*2?ne/2:z.length,U=0;U<D;++U){var X=z.charCodeAt(U);_[L>>1]=X,L+=2}return _[L>>1]=0,L-Te},_i=z=>z.length*2,Bs=(z,L)=>{for(var ne=0,Te="";!(ne>=L/4);){var D=b[z+ne*4>>2];if(D==0)break;if(++ne,D>=65536){var U=D-65536;Te+=String.fromCharCode(55296|U>>10,56320|U&1023)}else Te+=String.fromCharCode(D)}return Te},Ma=(z,L,ne)=>{if(ne!=null||(ne=2147483647),ne<4)return 0;for(var Te=L,D=Te+ne-4,U=0;U<z.length;++U){var X=z.charCodeAt(U);if(X>=55296&&X<=57343){var J=z.charCodeAt(++U);X=65536+((X&1023)<<10)|J&1023}if(b[L>>2]=X,L+=4,L+4>D)break}return b[L>>2]=0,L-Te},Fi=z=>{for(var L=0,ne=0;ne<z.length;++ne){var Te=z.charCodeAt(ne);Te>=55296&&Te<=57343&&++ne,L+=4}return L},Ls=(z,L,ne)=>{ne=Ve(ne);var Te,D,U,X;L===2?(Te=Zo,D=ir,X=_i,U=J=>v[J>>1]):L===4&&(Te=Bs,D=Ma,X=Fi,U=J=>T[J>>2]),et(z,{name:ne,fromWireType:J=>{for(var ue=T[J>>2],pe,ve=J+4,we=0;we<=ue;++we){var $e=J+4+we*L;if(we==ue||U($e)==0){var st=$e-ve,ot=Te(ve,st);pe===void 0?pe=ot:(pe+="\0",pe+=ot),ve=$e+L}}return Sn(J),pe},toWireType:(J,ue)=>{typeof ue!="string"&&Ce("Cannot pass non-string to C++ string type "+ne);var pe=X(ue),ve=Yr(4+pe+L);return T[ve>>2]=pe/L,D(ue,ve+4,pe+L),J!==null&&J.push(Sn,ve),ve},argPackAdvance:tt,readValueFromPointer:He,destructorFunction(J){Sn(J)}})},ss=(z,L,ne,Te,D,U)=>{Q[z]={name:Ve(L),rawConstructor:Zt(ne,Te),rawDestructor:Zt(D,U),fields:[]}},Jo=(z,L,ne,Te,D,U,X,J,ue,pe)=>{Q[z].fields.push({fieldName:Ve(L),getterReturnType:ne,getter:Zt(Te,D),getterContext:U,setterArgumentType:X,setter:Zt(J,ue),setterContext:pe})},os=(z,L)=>{L=Ve(L),et(z,{isVoid:!0,name:L,argPackAdvance:0,fromWireType:()=>{},toWireType:(ne,Te)=>{}})},ls=(z,L)=>{var ne=Ue[z];return ne===void 0&&Ce(L+" has unknown type "+sx(z)),ne},zs=(z,L)=>{z=ls(z,"_emval_take_value");var ne=z.readValueFromPointer(L);return bi.toHandle(ne)},an=()=>{be("")},rr=(z,L,ne)=>g.copyWithin(z,L,L+ne),cs=()=>2147483648,Xr=z=>{var L=d.buffer,ne=(z-L.byteLength+65535)/65536;try{return d.grow(ne),M(),1}catch{}},jo=z=>{var L=g.length;z>>>=0;var ne=cs();if(z>ne)return!1;for(var Te=(ue,pe)=>ue+(pe-ue%pe)%pe,D=1;D<=4;D*=2){var U=L*(1+.2/D);U=Math.min(U,z+100663296);var X=Math.min(ne,Te(Math.max(z,U),65536)),J=Xr(X);if(J)return!0}return!1};ht=t.InternalError=class extends Error{constructor(z){super(z),this.name="InternalError"}},Ge(),_t=t.BindingError=class extends Error{constructor(z){super(z),this.name="BindingError"}},Wn(),P0(),Ie(),h0=t.UnboundTypeError=v0(Error,"UnboundTypeError"),Pi();var Vs={c:Bt,m:V,p:_e,u:gt,i:Ot,h:gi,b:Di,e:bn,t:Lx,k:Wr,d:Fs,a:gl,j:Qo,g:Ls,n:ss,f:Jo,l:os,o:zs,q:an,s:rr,r:jo},Yn=Qe(),Sn=z=>(Sn=Yn.x)(z),Yr=z=>(Yr=Yn.y)(z),Hs=z=>(Hs=Yn.A)(z),ei=z=>(ei=Yn.B)(z),In;H=function z(){In||us(),In||(H=z)};function us(){if(ae>0||(P(),ae>0))return;function z(){In||(In=!0,t.calledRun=!0,!p&&(N(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),G()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),z()},1)):z()}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return us(),e.ready}})();const uW=Pe();uW.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,x=>{x&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Ki;(function(x){x[x.DT_INVALID=0]="DT_INVALID",x[x.DT_FLOAT=1]="DT_FLOAT",x[x.DT_DOUBLE=2]="DT_DOUBLE",x[x.DT_INT32=3]="DT_INT32",x[x.DT_UINT8=4]="DT_UINT8",x[x.DT_INT16=5]="DT_INT16",x[x.DT_INT8=6]="DT_INT8",x[x.DT_STRING=7]="DT_STRING",x[x.DT_COMPLEX64=8]="DT_COMPLEX64",x[x.DT_INT64=9]="DT_INT64",x[x.DT_BOOL=10]="DT_BOOL",x[x.DT_QINT8=11]="DT_QINT8",x[x.DT_QUINT8=12]="DT_QUINT8",x[x.DT_QINT32=13]="DT_QINT32",x[x.DT_BFLOAT16=14]="DT_BFLOAT16",x[x.DT_QINT16=15]="DT_QINT16",x[x.DT_QUINT16=16]="DT_QUINT16",x[x.DT_UINT16=17]="DT_UINT16",x[x.DT_COMPLEX128=18]="DT_COMPLEX128",x[x.DT_HALF=19]="DT_HALF",x[x.DT_RESOURCE=20]="DT_RESOURCE",x[x.DT_VARIANT=21]="DT_VARIANT",x[x.DT_UINT32=22]="DT_UINT32",x[x.DT_UINT64=23]="DT_UINT64",x[x.DT_FLOAT_REF=101]="DT_FLOAT_REF",x[x.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",x[x.DT_INT32_REF=103]="DT_INT32_REF",x[x.DT_UINT8_REF=104]="DT_UINT8_REF",x[x.DT_INT16_REF=105]="DT_INT16_REF",x[x.DT_INT8_REF=106]="DT_INT8_REF",x[x.DT_STRING_REF=107]="DT_STRING_REF",x[x.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",x[x.DT_INT64_REF=109]="DT_INT64_REF",x[x.DT_BOOL_REF=110]="DT_BOOL_REF",x[x.DT_QINT8_REF=111]="DT_QINT8_REF",x[x.DT_QUINT8_REF=112]="DT_QUINT8_REF",x[x.DT_QINT32_REF=113]="DT_QINT32_REF",x[x.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",x[x.DT_QINT16_REF=115]="DT_QINT16_REF",x[x.DT_QUINT16_REF=116]="DT_QUINT16_REF",x[x.DT_UINT16_REF=117]="DT_UINT16_REF",x[x.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",x[x.DT_HALF_REF=119]="DT_HALF_REF",x[x.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",x[x.DT_VARIANT_REF=121]="DT_VARIANT_REF",x[x.DT_UINT32_REF=122]="DT_UINT32_REF",x[x.DT_UINT64_REF=123]="DT_UINT64_REF"})(Ki||(Ki={}));var U3;(function(x){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(x.CheckpointFormatVersion||(x.CheckpointFormatVersion={}))})(U3||(U3={}));const hW={};function LU(x){return hW[x]}function I(x,e,t,n,i){const r=e.inputParams[x];if(r&&r.inputIndexStart!==void 0){const s=r.inputIndexStart,l=r.inputIndexEnd===0?void 0:r.inputIndexEnd===void 0?s+1:r.inputIndexEnd,c=s<0?e.inputNames.length+s:s;if(r.type==="tensor")return zn(e.inputNames[c],t,n,i);if(r.type==="tensors"){const p=e.inputs.slice(s,l);return e.inputNames.slice(s,l).filter((m,g)=>{var _;return((_=p[g])===null||_===void 0?void 0:_.op)!=="NoOp"}).map(m=>zn(m,t,n,i))}const h=zn(e.inputNames[c],t,n,i),d=h.dataSync();return r.type==="number"?d[0]:$S(h.shape,d)}const a=e.attrParams[x];return a&&a.value}function zn(x,e,t,n){const[i,r]=$i(x,t);if(n!=null){const s=n.getHashTableHandleByName(i);if(s!=null)return s}const a=t.currentContextIds.find(s=>!!e[M1(i,s)]);return a!==void 0?e[M1(i,a)][r]:void 0}function F3(x,e,t){return e[M1(x,t.currentContextId)]}function bo(x,e){const[t,n,i]=$i(x,e);return[M1(t,e&&e.currentContextId),n,i]}function M1(x,e){return e?x+"-"+e:x}function $i(x,e){if(x==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const r=e.parseNodeNameCache.get(x);if(r!=null)return r}const n=x.split(":");let i;if(n.length===1)i=[x,0,void 0];else{const r=n[0],a=n.length===3?n[1]:void 0,s=Number(n[n.length-1]);i=[r,s,a]}return t&&e.parseNodeNameCache.set(x,i),i}function t1(x,e,t){let n=I("pad",x,e,t);if(n==="explicit"){n=I("explicitPaddings",x,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let r=0;r<4;r++)i[r][0]=n[r*2],i[r][1]=n[r*2+1];return i}return n}function _o(x){return x.kept?x:Ng(x)}const dW=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var fW=Object.freeze({__proto__:null,json:dW});const pW=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var mW=Object.freeze({__proto__:null,json:pW});const yW=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}];var gW=Object.freeze({__proto__:null,json:yW});const vW=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var bW=Object.freeze({__proto__:null,json:vW});const _W=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var SW=Object.freeze({__proto__:null,json:_W});const TW=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var wW=Object.freeze({__proto__:null,json:TW});const AW=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var EW=Object.freeze({__proto__:null,json:AW});const MW=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var RW=Object.freeze({__proto__:null,json:MW});const CW=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var NW=Object.freeze({__proto__:null,json:CW});const IW=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}];var OW=Object.freeze({__proto__:null,json:IW});const DW=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}];var PW=Object.freeze({__proto__:null,json:DW});const kW=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}];var UW=Object.freeze({__proto__:null,json:kW});const FW=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}];var BW=Object.freeze({__proto__:null,json:FW});const LW=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var zW=Object.freeze({__proto__:null,json:LW});const VW=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}];var HW=Object.freeze({__proto__:null,json:VW});const GW=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var WW=Object.freeze({__proto__:null,json:GW});const XW=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var YW=Object.freeze({__proto__:null,json:XW});const KW=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var $W=Object.freeze({__proto__:null,json:KW});const QW=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var ZW=Object.freeze({__proto__:null,json:QW});let B3=class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[fW,mW,gW,bW,SW,wW,EW,RW,NW,OW,PW,UW,BW,zW,HW,WW,YW,$W,ZW],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,i)=>(n[i.tfOpName]=i,n),{})}transformGraph(e,t={}){const n=e.node,i=[],r=[],a=[],s=n.reduce((_,v)=>(_[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?i.push(_[v.name]):v.op==="Const"?r.push(_[v.name]):(v.input==null||v.input.length===0)&&a.push(_[v.name]),_),{});let l=[];const c=[];let h={},d={};t!=null&&(h=this.mapSignatureEntries(t.inputs),d=this.mapSignatureEntries(t.outputs));const p=Object.keys(s);p.forEach(_=>{const v=s[_];v.inputNames.forEach((b,T)=>{const[E,,A]=bo(b),M=s[E];if(M.outputs!=null){const R=M.outputs.indexOf(A);if(R!==-1){const C=E+":"+R;v.inputNames[T]=C}}v.inputs.push(M),M.children.push(v)})}),Object.keys(d).length===0?p.forEach(_=>{const v=s[_];v.children.length===0&&c.push(v)}):Object.keys(d).forEach(_=>{const[v]=bo(_),b=s[v];b!=null&&(b.signatureKey=d[_],c.push(b))}),Object.keys(h).length>0?Object.keys(h).forEach(_=>{const[v]=bo(_),b=s[v];b&&(b.signatureKey=h[_],l.push(b))}):l=i;let m={};e.library!=null&&e.library.function!=null&&(m=e.library.function.reduce((_,v)=>(_[v.signature.name]=this.mapFunction(v),_),{}));const g={nodes:s,inputs:l,outputs:c,weights:r,placeholders:i,signature:t,functions:m};return a.length>0&&(g.initNodes=a),g}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=LU(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((i,r)=>(i[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},i),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((i,r)=>{const a=r.type;let s;switch(r.type){case"string":s=pT(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=pT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":s=ST(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=ST(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":s=yT(e.attr,r.tfName,r.defaultValue||0),s===void 0&&r.tfDeprecatedName&&(s=yT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":s=_T(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=_T(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":s=mT(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=mT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":s=wT(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=wT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":s=bT(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=bT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":s=TT(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=TT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":s=gT(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=gT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":s=vT(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=vT(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":s=L3(e.attr,r.tfName,r.defaultValue),s===void 0&&r.tfDeprecatedName&&(s=L3(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: "+r.type+" for op: "+e.op)}return i[r.name]={value:s,type:a},i},{})),n}mapFunction(e){const t=e.nodeDef,n=[],i=[];let r={};t!=null&&(r=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&i.push(h[d.name]),h),{}));const a=[],s=[];e.signature.inputArg.forEach(h=>{const[d]=bo(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:xE(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,a.push(p),r[d]=p}),Object.keys(r).forEach(h=>{const d=r[h];d.inputNames.forEach((p,m)=>{const[g,,_]=bo(p),v=r[g];if(v.outputs!=null){const b=v.outputs.indexOf(_);if(b!==-1){const T=g+":"+b;d.inputNames[m]=T}}d.inputs.push(v),v.children.push(d)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=bo(l[h.name]),m=r[d];m!=null&&(m.defaultOutput=p,s.push(m))});const c=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:s,weights:i,placeholders:n,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}};function JW(x){const e=Pe().global;if(typeof e.atob<"u")return e.atob(x);if(typeof Buffer<"u")return new Buffer(x,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function zU(x,e){const t=Array.isArray(x)?String.fromCharCode.apply(null,x):JW(x);return e?t:t.toLowerCase()}function pT(x,e,t,n=!1){const i=x[e];return i!=null?zU(i.s,n):t}function mT(x,e,t){const n=x[e];return n?n.b:t}function yT(x,e,t){const n=x[e]||{},i=n.i!=null?n.i:n.f!=null?n.f:t;return typeof i=="number"?i:parseInt(i,10)}function xE(x){switch(typeof x=="string"&&(x=Ki[x]),x){case Ki.DT_FLOAT:case Ki.DT_HALF:return"float32";case Ki.DT_INT32:case Ki.DT_INT64:case Ki.DT_INT8:case Ki.DT_UINT8:return"int32";case Ki.DT_BOOL:return"bool";case Ki.DT_DOUBLE:return"float32";case Ki.DT_STRING:return"string";case Ki.DT_COMPLEX64:case Ki.DT_COMPLEX128:return"complex64";default:return null}}function L3(x,e,t){const n=x[e];return n&&n.func?n.func.name:t}function gT(x,e,t){const n=x[e];return n&&n.type?xE(n.type):t}function vT(x,e,t){const n=x[e];return n&&n.list&&n.list.type?n.list.type.map(i=>xE(i)):t}function VU(x){if(!x.unknownRank)return x.dim!=null?x.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function bT(x,e,t){const n=x[e];return n&&n.shape?VU(n.shape):t}function _T(x,e,t){const n=x[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function ST(x,e,t,n=!1){const i=x[e];return i&&i.list&&i.list.s?i.list.s.map(r=>zU(r,n)):t}function TT(x,e,t){const n=x[e];return n&&n.list&&n.list.shape?n.list.shape.map(i=>VU(i)):t}function wT(x,e,t){const n=x[e];return n&&n.list&&n.list.b?n.list.b:t}let jW=class{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,r)=>(i[r]=this.getAttr(r),i),{}))}getInput(e){return zn(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null)return zn(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return yT(this.node.rawAttrs,e,t);if(n.s!=null)return pT(this.node.rawAttrs,e,t);if(n.b!=null)return mT(this.node.rawAttrs,e,t);if(n.shape!=null)return bT(this.node.rawAttrs,e,t);if(n.type!=null)return gT(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return _T(this.node.rawAttrs,e,t);if(n.list.s!=null)return ST(this.node.rawAttrs,e,t);if(n.list.shape!=null)return TT(this.node.rawAttrs,e,t);if(n.list.b!=null)return wT(this.node.rawAttrs,e,t);if(n.list.type!=null)return vT(this.node.rawAttrs,e,t)}return t}};const qW={conv2d:g7,depthwiseConv2d:w7,matMul:E7},e9={resizeBilinear:_U};var Gn=Object.freeze({__proto__:null,add:Qi,addN:y8,atan2:v8,avgPool:R8,cast:Or,concat:Ig,conv2d:eU,conv2dTranspose:H8,cos:W8,depthToSpace:Y8,depthwiseConv2d:xU,expandDims:ZA,fill:$A,floor:pH,fused:qW,gather:yH,greaterEqual:bH,image:e9,lessEqual:sU,logicalAnd:EH,matMul:bs,max:e1,maxPool:RH,maximum:NH,mean:OH,min:hT,minimum:PH,mul:Ji,neg:Vk,pad:lU,prelu:cU,range:dT,relu:gU,relu6:vU,reshape:x0,scalar:$a,sigmoid:KA,sin:x7,squeeze:Ba,stack:Yf,stridedSlice:u7,sub:Eh,tensor1d:ji,tile:rU,transpose:q6,zerosLike:Z8});const t9=(x,e,t,n=Gn)=>{switch(x.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(I("a",x,e,t),I("b",x,e,t))];case"AddN":return[n.addN(I("tensors",x,e,t))];case"FloorMod":case"Mod":return[n.mod(I("a",x,e,t),I("b",x,e,t))];case"Mul":return[n.mul(I("a",x,e,t),I("b",x,e,t))];case"RealDiv":case"Div":return[n.div(I("a",x,e,t),I("b",x,e,t))];case"DivNoNan":return[n.divNoNan(I("a",x,e,t),I("b",x,e,t))];case"FloorDiv":return[n.floorDiv(I("a",x,e,t),I("b",x,e,t))];case"Sub":return[n.sub(I("a",x,e,t),I("b",x,e,t))];case"Minimum":return[n.minimum(I("a",x,e,t),I("b",x,e,t))];case"Maximum":return[n.maximum(I("a",x,e,t),I("b",x,e,t))];case"Pow":return[n.pow(I("a",x,e,t),I("b",x,e,t))];case"SquaredDifference":return[n.squaredDifference(I("a",x,e,t),I("b",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},x9=(x,e,t,n=Gn)=>{switch(x.op){case"Abs":case"ComplexAbs":return[n.abs(I("x",x,e,t))];case"Acos":return[n.acos(I("x",x,e,t))];case"Acosh":return[n.acosh(I("x",x,e,t))];case"Asin":return[n.asin(I("x",x,e,t))];case"Asinh":return[n.asinh(I("x",x,e,t))];case"Atan":return[n.atan(I("x",x,e,t))];case"Atan2":return[n.atan2(I("x",x,e,t),I("y",x,e,t))];case"Atanh":return[n.atanh(I("x",x,e,t))];case"Ceil":return[n.ceil(I("x",x,e,t))];case"Complex":return[n.complex(I("real",x,e,t),I("imag",x,e,t))];case"Cos":return[n.cos(I("x",x,e,t))];case"Cosh":return[n.cosh(I("x",x,e,t))];case"Elu":return[n.elu(I("x",x,e,t))];case"Erf":return[n.erf(I("x",x,e,t))];case"Exp":return[n.exp(I("x",x,e,t))];case"Expm1":return[n.expm1(I("x",x,e,t))];case"Floor":return[n.floor(I("x",x,e,t))];case"Log":return[n.log(I("x",x,e,t))];case"Log1p":return[n.log1p(I("x",x,e,t))];case"Imag":return[n.imag(I("x",x,e,t))];case"Neg":return[n.neg(I("x",x,e,t))];case"Reciprocal":return[n.reciprocal(I("x",x,e,t))];case"Real":return[n.real(I("x",x,e,t))];case"Relu":return[n.relu(I("x",x,e,t))];case"Round":return[n.round(I("x",x,e,t))];case"Selu":return[n.selu(I("x",x,e,t))];case"Sigmoid":return[n.sigmoid(I("x",x,e,t))];case"Sin":return[n.sin(I("x",x,e,t))];case"Sign":return[n.sign(I("x",x,e,t))];case"Sinh":return[n.sinh(I("x",x,e,t))];case"Softplus":return[n.softplus(I("x",x,e,t))];case"Sqrt":return[n.sqrt(I("x",x,e,t))];case"Square":return[n.square(I("x",x,e,t))];case"Tanh":return[n.tanh(I("x",x,e,t))];case"Tan":return[n.tan(I("x",x,e,t))];case"ClipByValue":return[n.clipByValue(I("x",x,e,t),I("clipValueMin",x,e,t),I("clipValueMax",x,e,t))];case"Relu6":return[n.relu6(I("x",x,e,t))];case"Rsqrt":return[n.rsqrt(zn(x.inputNames[0],e,t))];case"LeakyRelu":return[n.leakyRelu(I("x",x,e,t),I("alpha",x,e,t))];case"Prelu":return[n.prelu(I("x",x,e,t),I("alpha",x,e,t))];case"IsNan":return[n.isNaN(zn(x.inputNames[0],e,t))];case"IsInf":return[n.isInf(zn(x.inputNames[0],e,t))];case"IsFinite":return[n.isFinite(zn(x.inputNames[0],e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}};function ha(x,e,t=""){if(!(typeof x=="number"||typeof e=="number")){ye(x.length===e.length,()=>t+(" Shapes "+x+" and "+e+" must match"));for(let n=0;n<x.length;n++){const i=x[n],r=e[n];ye(i<0||r<0||i===r,()=>t+(" Shapes "+x+" and "+e+" must match"))}}}function z3(x){return!(typeof x=="number"||x.some(e=>e<0))}function sf(x,e,t){let n=AT(x,t);const i=!z3(n);if(i&&e.length===0)throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: "+n);if(i&&e.forEach(r=>{n=AT(r.shape,n)}),!z3(n))throw new Error("Non-fully-defined elementShape: "+n);return n}function AT(x,e){if(typeof x=="number")return e;if(typeof e=="number")return x;if(x.length!==e.length)throw new Error("Incompatible ranks during merge: "+x+" vs. "+e);const t=[];for(let n=0;n<x.length;++n){const i=x[n],r=e[n];if(i>=0&&r>=0&&i!==r)throw new Error("Incompatible shape during merge: "+x+" vs. "+e);t[n]=i>=0?i:r}return t}class n9{constructor(e,t,n,i,r,a,s){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=i,this.identicalElementShapes=r,this.dynamicSize=a,this.clearAfterRead=s,this.tensors=[],this.closed_=!1,this.idTensor=$a(0),Co(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||e>=this.size())throw new Error("Tried to read from index "+e+", but array size is: "+this.size());const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray "+this.name+": Could not read index "+e+" twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error("TensorArray "+this.name+" has already been closed.");if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index "+e+", but array is not resizeable and size is: "+this.maxSize);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+`,
          because the value dtype is `+t.dtype+", but TensorArray dtype is "+this.dtype+".");if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),ha(this.elementShape,t.shape,"TensorArray "+this.name+": Could not write to TensorArray index "+e+"."),n.read)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been read.");if(n.written)throw new Error("TensorArray "+this.name+": Could not write to TensorArray index "+e+", because it has already been written.");n.tensor=t,Co(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray "+this.name+": could not write multiple tensors,because the index size: "+e.length+" is not the same as tensors size: "+t.length+".");e.forEach((n,i)=>this.write(n,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but gather requested dtype "+t);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Y2([],[0].concat(this.elementShape));const n=this.readMany(e);return ha(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),Yf(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but concat requested dtype "+e);if(this.size()===0)return Y2([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const n=this.readMany(t);return ha(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape ("+this.elementShape+") vs first tensor shape ("+n[0].shape+")"),Ig(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+e.length+" vs. "+t.shape[0]);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size ("+n+"  vs. "+this.maxSize+")");this.writeMany(e,Og(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is "+this.dtype+" but tensor has dtype "+t.dtype);let n=0;const i=e.map(l=>(n+=l,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+n+", and tensor's shape is: "+t.shape);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths ("+this.maxSize+" vs. "+e.length+"), and the TensorArray is not marked as dynamically resizeable");const r=n===0?0:t.size/n,a=[];hi(()=>{t=x0(t,[1,n,r]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:i[l-1],0],h=[1,e[l],r];a[l]=x0(wr(t,c,h),this.elementShape)}return a});const s=[];for(let l=0;l<e.length;l++)s[l]=l;this.writeMany(s,a)}}class Ac{get id(){return this.idTensor.id}constructor(e,t,n,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e!=null&&e.forEach(r=>{if(n!==r.dtype)throw new Error("Invalid data types; op elements "+n+", but list elements "+r.dtype);ha(t,r.shape,"TensorList shape mismatch: "),Co(r)}),this.idTensor=$a(0),this.maxNumElements=i,Co(this.idTensor)}copy(){return new Ac([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements "+t+", but list elements "+this.elementDtype);if(n!==-1&&this.tensors.length!==n)throw new Error("Operation expected a list with "+n+" elements but got a list with "+this.tensors.length+" elements.");ha(e,this.elementShape,"TensorList shape mismatch: ");const i=sf(this.elementShape,this.tensors,e);return hi(()=>{const r=this.tensors.map(a=>x0(a,i));return Yf(r,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements "+t+", but list elements "+this.elementDtype);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const n=sf(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,ha(i.shape,e,"TensorList shape mismatch: "),x0(i,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+e.dtype+", but list elements "+this.elementDtype);if(ha(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Co(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: "+e);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error("TensorListResize input size "+e+" is greater maxNumElement "+this.maxNumElements+".");const t=new Ac([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements "+n+", but list elements "+this.elementDtype);if(e<0||e>this.tensors.length)throw new Error("Trying to access element "+e+" in a list with "+this.tensors.length+" elements.");if(this.tensors[e]==null)throw new Error("element at index "+e+" is null.");ha(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=sf(this.elementShape,this.tensors,t);return x0(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements "+t.dtype+", but list elements "+this.elementDtype);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error("Trying to set element "+e+" in a list with max "+this.maxNumElements+" elements.");ha(this.elementShape,t.shape,"TensorList shape mismatch: "),Co(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements "+t+", but list elements "+this.elementDtype);ha(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=sf(this.elementShape,this.tensors,n);return e.length===0?Y2([],[0].concat(i)):hi(()=>{const r=e.map(a=>x0(this.tensors[a],i));return Yf(r,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is "+this.elementDtype+" but concat requested dtype "+e);ha(this.elementShape,t,"TensorList shape mismatch: ");const n=sf(this.elementShape,this.tensors,t);return this.size()===0?Y2([],[0].concat(n)):hi(()=>{const i=this.tensors.map(r=>x0(r,n));return Ig(i,0)})}}function i9(x,e,t){const n=x.dtype;if(x.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: "+x.shape);if(x.dtype!==t)throw new Error("Invalid data types; op elements "+x.dtype+", but list elements "+t);const i=x.shape.slice(1);ha(i,e,"TensorList shape mismatch: ");const r=Og(x);return new Ac(r,e,n)}function r9(x,e,t,n){return new Ac([],x,e,n)}function a9(x,e,t,n){if(e.length!==x.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: "+e.length+" vs. "+x.shape[0]);const i=Math.max(...e);if(n!=null&&n!==-1&&i>=n)throw new Error("Max index must be < array size ("+i+"  vs. "+n+")");const r=new Ac([],t,x.dtype,n),a=Og(x,0);return e.forEach((s,l)=>{r.setItem(s,a[l])}),r}function s9(x,e,t){let n=0;const i=e.map(h=>(n+=h,n));if(n!==x.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        `+n+", and tensor's shape is: "+x.shape);const r=x.shape.slice(1),a=AT(r,t),s=n===0?0:x.size/n,l=hi(()=>{const h=[];x=x0(x,[1,n,s]);for(let d=0;d<e.length;++d){const p=[0,d===0?0:i[d-1],0],m=[1,e[d],s];h[d]=x0(wr(x,p,m),a)}return x.dispose(),h}),c=new Ac([],t,x.dtype,e.length);for(let h=0;h<l.length;h++)c.setItem(h,l[h]);return c}const o9=async(x,e,t)=>{switch(x.op){case"If":case"StatelessIf":{const n=I("thenBranch",x,e,t),i=I("elseBranch",x,e,t),r=I("cond",x,e,t),a=I("args",x,e,t);return(await r.data())[0]?t.functionMap[n].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const n=I("body",x,e,t),i=I("cond",x,e,t),r=I("args",x,e,t),a=await t.functionMap[i].executeFunctionAsync(r,t.tensorArrayMap,t.tensorListMap),s=r.map(h=>h.id);let l=await a[0].data();a.forEach(h=>{!h.kept&&s.indexOf(h.id)===-1&&h.dispose()});let c=r;for(;l[0];){const h=c;c=await t.functionMap[n].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const d=c.map(m=>m.id);h.forEach(m=>{!m.kept&&s.indexOf(m.id)===-1&&d.indexOf(m.id)===-1&&m.dispose()});const p=await t.functionMap[i].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await p[0].data(),p.forEach(m=>{!m.kept&&s.indexOf(m.id)===-1&&d.indexOf(m.id)===-1&&m.dispose()})}return c}case"LoopCond":{const n=I("pred",x,e,t);return[_o(n)]}case"Switch":{const n=I("pred",x,e,t);let i=I("data",x,e,t);return i.kept||(i=_o(i)),(await n.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const n=x.inputNames.find(i=>zn(i,e,t)!==void 0);if(n){const i=zn(n,e,t);return[_o(i)]}return}case"Enter":{const n=I("frameName",x,e,t),i=I("tensor",x,e,t);return t.enterFrame(n),[_o(i)]}case"Exit":{const n=I("tensor",x,e,t);return t.exitFrame(),[_o(n)]}case"NextIteration":{const n=I("tensor",x,e,t);return t.nextIteration(),[_o(n)]}case"TensorArrayV3":{const n=I("size",x,e,t),i=I("dtype",x,e,t),r=I("elementShape",x,e,t),a=I("dynamicSize",x,e,t),s=I("clearAfterRead",x,e,t),l=I("identicalElementShapes",x,e,t),c=I("name",x,e,t),h=new n9(c,i,n,r,l,a,s);return t.addTensorArray(h),[h.idTensor,$a(1)]}case"TensorArrayWriteV3":{const n=I("tensorArrayId",x,e,t),i=I("index",x,e,t),r=I("tensor",x,e,t),a=t.getTensorArray(n.id);return a.write(i,r),[a.idTensor]}case"TensorArrayReadV3":{const n=I("tensorArrayId",x,e,t),i=I("index",x,e,t);return[t.getTensorArray(n.id).read(i)]}case"TensorArrayGatherV3":{const n=I("tensorArrayId",x,e,t),i=I("indices",x,e,t),r=I("dtype",x,e,t);return[t.getTensorArray(n.id).gather(i,r)]}case"TensorArrayScatterV3":{const n=I("tensorArrayId",x,e,t),i=I("indices",x,e,t),r=I("tensor",x,e,t),a=t.getTensorArray(n.id);return a.scatter(i,r),[a.idTensor]}case"TensorArrayConcatV3":{const n=I("tensorArrayId",x,e,t),i=t.getTensorArray(n.id),r=I("dtype",x,e,t);return[i.concat(r)]}case"TensorArraySplitV3":{const n=I("tensorArrayId",x,e,t),i=I("tensor",x,e,t),r=I("lengths",x,e,t),a=t.getTensorArray(n.id);return a.split(r,i),[a.idTensor]}case"TensorArraySizeV3":{const n=I("tensorArrayId",x,e,t),i=t.getTensorArray(n.id);return[$a(i.size(),"int32")]}case"TensorArrayCloseV3":{const n=I("tensorArrayId",x,e,t),i=t.getTensorArray(n.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const n=I("tensorListId",x,e,t),i=I("index",x,e,t),r=I("tensor",x,e,t),a=t.getTensorList(n.id);return a.setItem(i,r),[a.idTensor]}case"TensorListGetItem":{const n=I("tensorListId",x,e,t),i=I("index",x,e,t),r=I("elementShape",x,e,t),a=I("elementDType",x,e,t);return[t.getTensorList(n.id).getItem(i,r,a)]}case"TensorListScatterV2":case"TensorListScatter":{const n=I("indices",x,e,t),i=I("tensor",x,e,t),r=I("elementShape",x,e,t),a=I("numElements",x,e,t),s=a9(i,n,r,a);return t.addTensorList(s),[s.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=I("elementShape",x,e,t),i=I("elementDType",x,e,t);let r;x.op==="TensorListReserve"?r="numElements":r="maxNumElements";const a=I(r,x,e,t),s=x.op==="TensorListReserve"?-1:a,l=r9(n,i,a,s);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const n=I("tensorListId",x,e,t),i=I("indices",x,e,t),r=I("elementShape",x,e,t),a=I("elementDType",x,e,t);return[t.getTensorList(n.id).gather(i,a,r)]}case"TensorListStack":{const n=I("tensorListId",x,e,t),i=I("elementShape",x,e,t),r=I("elementDType",x,e,t),a=I("numElements",x,e,t);return[t.getTensorList(n.id).stack(i,r,a)]}case"TensorListFromTensor":{const n=I("tensor",x,e,t),i=I("elementShape",x,e,t),r=I("elementDType",x,e,t),a=i9(n,i,r);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const n=I("tensorListId",x,e,t),i=t.getTensorList(n.id),r=I("dtype",x,e,t),a=I("elementShape",x,e,t);return[i.concat(r,a)]}case"TensorListPushBack":{const n=I("tensorListId",x,e,t),i=I("tensor",x,e,t),r=t.getTensorList(n.id);return r.pushBack(i),[r.idTensor]}case"TensorListPopBack":{const n=I("tensorListId",x,e,t),i=I("elementShape",x,e,t),r=I("elementDType",x,e,t);return[t.getTensorList(n.id).popBack(i,r)]}case"TensorListSplit":{const n=I("tensor",x,e,t),i=I("elementShape",x,e,t),r=I("lengths",x,e,t),a=s9(n,r,i);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const n=I("tensorListId",x,e,t),i=t.getTensorList(n.id);return[$a(i.size(),"int32")]}case"TensorListResize":{const n=I("tensorListId",x,e,t),i=I("size",x,e,t),r=t.getTensorList(n.id).resize(i);return t.addTensorList(r),[r.idTensor]}default:throw TypeError("Node type "+x.op+" is not implemented")}};function V3(x,e,t){const[n,i]=I("fusedOps",x,e,t),r=n==="biasadd",a=!r,s=i==="prelu",l=n==="fusedbatchnorm",c=I("numArgs",x,e,t);if(r){if(s&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!s&&r&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=I("strides",x,e,t),d=t1(x,e,t),p=I("dataFormat",x,e,t).toUpperCase(),m=I("dilations",x,e,t);let[g,_]=I("args",x,e,t);a&&(_=g,g=void 0);const v=I("leakyreluAlpha",x,e,t);return{stride:h,pad:d,dataFormat:p,dilations:m,biasArg:g,preluArg:_,activationFunc:i,leakyreluAlpha:v}}const l9=(x,e,t,n=Gn)=>{switch(x.op){case"Conv1D":{const i=I("stride",x,e,t),r=I("pad",x,e,t),a=I("dataFormat",x,e,t).toUpperCase(),s=I("dilation",x,e,t);return[n.conv1d(I("x",x,e,t),I("filter",x,e,t),i,r,a,s)]}case"Conv2D":{const i=I("strides",x,e,t),r=t1(x,e,t),a=I("dataFormat",x,e,t).toUpperCase(),s=I("dilations",x,e,t);return[n.conv2d(I("x",x,e,t),I("filter",x,e,t),[i[1],i[2]],r,a,[s[1],s[2]])]}case"_FusedConv2D":{const{stride:i,pad:r,dataFormat:a,dilations:s,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=V3(x,e,t),p=x.name.endsWith("batch_normalization_88/FusedBatchNormV3")||x.name.endsWith("batch_normalization_90/FusedBatchNormV3")?Pe().get("WEBGL_USE_SHAPES_UNIFORMS"):void 0;p&&Pe().set("WEBGL_USE_SHAPES_UNIFORMS",!1);const m=[n.fused.conv2d({x:I("x",x,e,t),filter:I("filter",x,e,t),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[s[1],s[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})];return p&&Pe().set("WEBGL_USE_SHAPES_UNIFORMS",!0),m}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:r,dataFormat:a,dilations:s,biasArg:l,preluArg:c,activationFunc:h,leakyreluAlpha:d}=V3(x,e,t);return[n.fused.depthwiseConv2d({x:I("x",x,e,t),filter:I("filter",x,e,t),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[s[1],s[2]],bias:l,activation:h,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=I("outputShape",x,e,t),r=I("strides",x,e,t),a=t1(x,e,t);return[n.conv2dTranspose(I("x",x,e,t),I("filter",x,e,t),i,[r[1],r[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=I("strides",x,e,t),r=t1(x,e,t),a=I("dilations",x,e,t),s=I("dataFormat",x,e,t).toUpperCase();return[n.depthwiseConv2d(I("input",x,e,t),I("filter",x,e,t),[i[1],i[2]],r,s,[a[1],a[2]])]}case"Conv3D":{const i=I("strides",x,e,t),r=I("pad",x,e,t),a=I("dataFormat",x,e,t).toUpperCase(),s=I("dilations",x,e,t);return[n.conv3d(I("x",x,e,t),I("filter",x,e,t),[i[1],i[2],i[3]],r,a,[s[1],s[2],s[3]])]}case"AvgPool":{const i=I("strides",x,e,t),r=I("pad",x,e,t),a=I("kernelSize",x,e,t);return[n.avgPool(I("x",x,e,t),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPool":{const i=I("strides",x,e,t),r=I("pad",x,e,t),a=I("kernelSize",x,e,t);return[n.maxPool(I("x",x,e,t),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPoolWithArgmax":{const i=I("strides",x,e,t),r=I("pad",x,e,t),a=I("kernelSize",x,e,t),s=I("includeBatchInIndex",x,e,t),{result:l,indexes:c}=n.maxPoolWithArgmax(I("x",x,e,t),[a[1],a[2]],[i[1],i[2]],r,s);return[l,c]}case"AvgPool3D":{const i=I("strides",x,e,t),r=I("pad",x,e,t),a=I("kernelSize",x,e,t);return[n.avgPool3d(I("x",x,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"MaxPool3D":{const i=I("strides",x,e,t),r=I("pad",x,e,t),a=I("kernelSize",x,e,t);return[n.maxPool3d(I("x",x,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"Dilation2D":{const i=I("strides",x,e,t),r=I("pad",x,e,t),a=I("dilations",x,e,t),s=i[1],l=i[2],c=a[1],h=a[2];return[n.dilation2d(I("x",x,e,t),I("filter",x,e,t),[s,l],r,[c,h],"NHWC")]}default:throw TypeError("Node type "+x.op+" is not implemented")}},c9=(x,e,t,n=Gn)=>{switch(x.op){case"Fill":{const i=I("shape",x,e,t),r=I("dtype",x,e,t),a=I("value",x,e,t);return[n.fill(i,a,r)]}case"LinSpace":{const i=I("start",x,e,t),r=I("stop",x,e,t),a=I("num",x,e,t);return[n.linspace(i,r,a)]}case"Multinomial":{const i=I("logits",x,e,t),r=I("numSamples",x,e,t),a=I("seed",x,e,t);return[n.multinomial(i,r,a)]}case"OneHot":{const i=I("indices",x,e,t),r=I("depth",x,e,t),a=I("onValue",x,e,t),s=I("offValue",x,e,t),l=I("dtype",x,e,t);return[n.oneHot(i,r,a,s,l)]}case"Ones":return[n.ones(I("shape",x,e,t),I("dtype",x,e,t))];case"OnesLike":return[n.onesLike(I("x",x,e,t))];case"RandomStandardNormal":return[n.randomStandardNormal(I("shape",x,e,t),I("dtype",x,e,t),I("seed",x,e,t))];case"RandomUniform":return[n.randomUniform(I("shape",x,e,t),I("minval",x,e,t),I("maxval",x,e,t),I("dtype",x,e,t))];case"RandomUniformInt":return[n.randomUniformInt(I("shape",x,e,t),I("minval",x,e,t),I("maxval",x,e,t),I("seed",x,e,t))];case"Range":{const i=I("start",x,e,t),r=I("stop",x,e,t),a=I("step",x,e,t);return[n.range(i,r,a,I("dtype",x,e,t))]}case"TruncatedNormal":{const i=I("shape",x,e,t),r=I("mean",x,e,t),a=I("stdDev",x,e,t),s=I("seed",x,e,t);return[n.truncatedNormal(i,r,a,I("dtype",x,e,t),s)]}case"Zeros":return[n.zeros(I("shape",x,e,t),I("dtype",x,e,t))];case"ZerosLike":return[n.zerosLike(I("x",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}};function g_(x,e,t){const n=I("boxes",x,e,t),i=I("scores",x,e,t),r=I("maxOutputSize",x,e,t),a=I("iouThreshold",x,e,t),s=I("scoreThreshold",x,e,t),l=I("softNmsSigma",x,e,t);return{boxes:n,scores:i,maxOutputSize:r,iouThreshold:a,scoreThreshold:s,softNmsSigma:l}}const u9=async(x,e,t,n,i=Gn)=>{switch(x.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:s,iouThreshold:l,scoreThreshold:c,softNmsSigma:h}=g_(x,e,t),d=await i.image.nonMaxSuppressionWithScoreAsync(r,a,s,l,c,h);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:s,iouThreshold:l,scoreThreshold:c}=g_(x,e,t),h=I("padToMaxOutputSize",x,e,t),d=await i.image.nonMaxSuppressionPaddedAsync(r,a,s,l,c,h);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:s,iouThreshold:l,scoreThreshold:c}=g_(x,e,t);return[await i.image.nonMaxSuppressionAsync(r,a,s,l,c)]}case"Where":{const r=i.cast(I("condition",x,e,t),"bool"),a=[await i.whereAsync(r)];return r.dispose(),a}case"ListDiff":return i.setdiff1dAsync(I("x",x,e,t),I("y",x,e,t));default:throw TypeError("Node type "+x.op+" is not implemented")}},h9=(x,e,t,n=Gn)=>{switch(x.op){case"LowerBound":{const i=I("sortedSequence",x,e,t),r=I("values",x,e,t);return[n.lowerBound(i,r)]}case"TopKV2":{const i=I("x",x,e,t),r=I("k",x,e,t),a=I("sorted",x,e,t),s=n.topk(i,r,a);return[s.values,s.indices]}case"UpperBound":{const i=I("sortedSequence",x,e,t),r=I("values",x,e,t);return[n.upperBound(i,r)]}case"Unique":{const i=I("x",x,e,t),r=n.unique(i);return[r.values,r.indices]}case"UniqueV2":{const i=I("x",x,e,t),r=I("axis",x,e,t),a=n.unique(i,r);return[a.values,a.indices]}default:throw TypeError("Node type "+x.op+" is not implemented")}},d9=(x,e,t,n=Gn)=>{switch(x.op){case"Const":return e[x.name];case"PlaceholderWithDefault":const i=I("default",x,e,t);return[zn(x.name,e,t)||i];case"Placeholder":return[zn(x.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=I("x",x,e,t);return[_o(h)]}case"IdentityN":return I("x",x,e,t).map(h=>_o(h));case"Snapshot":const r=I("x",x,e,t);return[_o(r)];case"Shape":return[n.tensor1d(I("x",x,e,t).shape,"int32")];case"ShapeN":return I("x",x,e,t).map(h=>n.tensor1d(h.shape));case"Size":return[n.scalar(I("x",x,e,t).size,"int32")];case"Rank":return[n.scalar(I("x",x,e,t).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":const a=I("x",x,e,t),s=I("data",x,e,t),l=I("message",x,e,t),c=I("summarize",x,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let h=0;h<s.length;h++)console.log(Array.prototype.slice.call(s[h].dataSync()).slice(0,c));return[a];default:throw TypeError("Node type "+x.op+" is not implemented")}};class f9{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=$a(0),this.tensorMap=new Map,Co(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return $a(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),hi(()=>{const i=Og(t),r=n.length,a=i.length;ye(r===a,()=>"The number of elements doesn't match, keys has "+r+" elements, the values has "+a+" elements.");for(let s=0;s<r;s++){const l=n[s],c=i[s];Co(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return hi(()=>{const i=[];for(let r=0;r<n.length;r++){const a=n[r],s=this.findWithDefault(a,t);i.push(s)}return Yf(i)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype "+this.keyDType+", but got "+e.dtype);if(t.dtype!==this.valueDType)throw new Error("Expect value dtype "+this.valueDType+", but got "+t.dtype)}}const p9=async(x,e,t,n)=>{switch(x.op){case"HashTable":case"HashTableV2":{const i=n.getHashTableHandleByName(x.name);if(i!=null)return[i];{const r=I("keyDType",x,e,t),a=I("valueDType",x,e,t),s=new f9(r,a);return n.addHashTable(x.name,s),[s.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=I("tableHandle",x,e,t,n),r=I("keys",x,e,t),a=I("values",x,e,t);return[await n.getHashTableById(i.id).import(r,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=I("tableHandle",x,e,t,n),r=I("keys",x,e,t),a=I("defaultValue",x,e,t);return[await n.getHashTableById(i.id).find(r,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=I("tableHandle",x,e,t,n);return[n.getHashTableById(i.id).tensorSize()]}default:throw TypeError("Node type "+x.op+" is not implemented")}},m9=(x,e,t,n=Gn)=>{switch(x.op){case"ResizeBilinear":{const i=I("images",x,e,t),r=I("size",x,e,t),a=I("alignCorners",x,e,t),s=I("halfPixelCenters",x,e,t);return[n.image.resizeBilinear(i,[r[0],r[1]],a,s)]}case"ResizeNearestNeighbor":{const i=I("images",x,e,t),r=I("size",x,e,t),a=I("alignCorners",x,e,t),s=I("halfPixelCenters",x,e,t);return[n.image.resizeNearestNeighbor(i,[r[0],r[1]],a,s)]}case"CropAndResize":{const i=I("image",x,e,t),r=I("boxes",x,e,t),a=I("boxInd",x,e,t),s=I("cropSize",x,e,t),l=I("method",x,e,t),c=I("extrapolationValue",x,e,t);return[n.image.cropAndResize(i,r,a,s,l,c)]}case"ImageProjectiveTransformV3":{const i=I("images",x,e,t),r=I("transforms",x,e,t),a=I("outputShape",x,e,t),s=I("fillValue",x,e,t),l=I("interpolation",x,e,t),c=I("fillMode",x,e,t);return[n.image.transform(i,r,l.toLowerCase(),c.toLowerCase(),s,a)]}default:throw TypeError("Node type "+x.op+" is not implemented")}},y9=(x,e,t,n=Gn)=>{switch(x.op){case"Equal":return[n.equal(I("a",x,e,t),I("b",x,e,t))];case"NotEqual":return[n.notEqual(I("a",x,e,t),I("b",x,e,t))];case"Greater":return[n.greater(I("a",x,e,t),I("b",x,e,t))];case"GreaterEqual":return[n.greaterEqual(I("a",x,e,t),I("b",x,e,t))];case"Less":return[n.less(I("a",x,e,t),I("b",x,e,t))];case"LessEqual":return[n.lessEqual(I("a",x,e,t),I("b",x,e,t))];case"LogicalAnd":return[n.logicalAnd(I("a",x,e,t),I("b",x,e,t))];case"LogicalNot":return[n.logicalNot(I("a",x,e,t))];case"LogicalOr":return[n.logicalOr(I("a",x,e,t),I("b",x,e,t))];case"Select":case"SelectV2":return[n.where(I("condition",x,e,t),I("a",x,e,t),I("b",x,e,t))];case"BitwiseAnd":return[n.bitwiseAnd(I("a",x,e,t),I("b",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},g9=(x,e,t,n=Gn)=>{switch(x.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(I("a",x,e,t),I("b",x,e,t),I("transposeA",x,e,t),I("transposeB",x,e,t))];case"Einsum":return[n.einsum(I("equation",x,e,t),...I("tensors",x,e,t))];case"Transpose":return[n.transpose(I("x",x,e,t),I("perm",x,e,t))];case"_FusedMatMul":const[i,r]=I("fusedOps",x,e,t),a=i==="biasadd",s=r==="prelu",l=I("numArgs",x,e,t),c=I("leakyreluAlpha",x,e,t);if(a){if(s&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!s&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,d]=I("args",x,e,t);return[n.fused.matMul({a:I("a",x,e,t),b:I("b",x,e,t),transposeA:I("transposeA",x,e,t),transposeB:I("transposeB",x,e,t),bias:h,activation:r,preluActivationWeights:d,leakyreluAlpha:c})];case"MatrixBandPart":return[n.linalg.bandPart(I("a",x,e,t),I("numLower",x,e,t),I("numUpper",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},v9=(x,e,t,n=Gn)=>{switch(x.op){case"EuclideanNorm":return[n.euclideanNorm(I("x",x,e,t),I("axis",x,e,t),I("keepDims",x,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(I("x",x,e,t),I("mean",x,e,t),I("variance",x,e,t),I("offset",x,e,t),I("scale",x,e,t),I("epsilon",x,e,t))];case"FusedBatchNormV3":return[n.batchNorm(I("x",x,e,t),I("mean",x,e,t),I("variance",x,e,t),I("offset",x,e,t),I("scale",x,e,t),I("epsilon",x,e,t))];case"LRN":return[n.localResponseNormalization(I("x",x,e,t),I("radius",x,e,t),I("bias",x,e,t),I("alpha",x,e,t),I("beta",x,e,t))];case"Softmax":return[n.softmax(I("x",x,e,t))];case"LogSoftmax":return[n.logSoftmax(I("x",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},b9=(x,e,t,n=Gn)=>{switch(x.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:r}=n.raggedGather(I("paramsNestedSplits",x,e,t),I("paramsDenseValues",x,e,t),I("indices",x,e,t),I("outputRaggedRank",x,e,t));return i.concat(r)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:r}=n.raggedRange(I("starts",x,e,t),I("limits",x,e,t),I("splits",x,e,t));return[i,r]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(I("shape",x,e,t),I("values",x,e,t),I("defaultValue",x,e,t),I("rowPartitionTensors",x,e,t),I("rowPartitionTypes",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},_9=(x,e,t,n=Gn)=>{switch(x.op){case"Max":{const s=I("axis",x,e,t),l=I("keepDims",x,e,t);return[n.max(I("x",x,e,t),s,l)]}case"Mean":{const s=I("axis",x,e,t),l=I("keepDims",x,e,t);return[n.mean(I("x",x,e,t),s,l)]}case"Min":{const s=I("axis",x,e,t),l=I("keepDims",x,e,t);return[n.min(I("x",x,e,t),s,l)]}case"Sum":{const s=I("axis",x,e,t),l=I("keepDims",x,e,t);return[n.sum(I("x",x,e,t),s,l)]}case"All":{const s=I("axis",x,e,t),l=I("keepDims",x,e,t);return[n.all(I("x",x,e,t),s,l)]}case"Any":{const s=I("axis",x,e,t),l=I("keepDims",x,e,t);return[n.any(I("x",x,e,t),s,l)]}case"ArgMax":{const s=I("axis",x,e,t);return[n.argMax(I("x",x,e,t),s)]}case"ArgMin":{const s=I("axis",x,e,t);return[n.argMin(I("x",x,e,t),s)]}case"Prod":{const s=I("axis",x,e,t),l=I("keepDims",x,e,t);return[n.prod(I("x",x,e,t),s,l)]}case"Cumprod":{const s=I("axis",x,e,t),l=I("exclusive",x,e,t),c=I("reverse",x,e,t);return[n.cumprod(I("x",x,e,t),s,l,c)]}case"Cumsum":{const s=I("axis",x,e,t),l=I("exclusive",x,e,t),c=I("reverse",x,e,t);return[n.cumsum(I("x",x,e,t),s,l,c)]}case"Bincount":const i=I("x",x,e,t),r=I("weights",x,e,t),a=I("size",x,e,t);return[n.bincount(i,r,a)];case"DenseBincount":{const s=I("x",x,e,t),l=I("weights",x,e,t),c=I("size",x,e,t),h=I("binaryOutput",x,e,t);return[n.denseBincount(s,l,c,h)]}default:throw TypeError("Node type "+x.op+" is not implemented")}},S9=(x,e,t,n=Gn)=>{switch(x.op){case"ConcatV2":case"Concat":{const i=I("n",x,e,t),r=I("axis",x,e,t);let a=I("tensors",x,e,t);return a=a.slice(0,i),[n.concat(a,r)]}case"Gather":{const i=I("x",x,e,t),r=I("indices",x,e,t);return[n.gather(i,n.cast(r,"int32"),0)]}case"GatherV2":{const i=I("axis",x,e,t),r=I("batchDims",x,e,t),a=I("x",x,e,t),s=I("indices",x,e,t);return[n.gather(a,n.cast(s,"int32"),i,r)]}case"Reverse":{const i=I("dims",x,e,t),r=[];for(let s=0;s<i.length;s++)i[s]&&r.push(s);const a=I("x",x,e,t);return[n.reverse(a,r)]}case"ReverseV2":{const i=I("axis",x,e,t),r=I("x",x,e,t);return[n.reverse(r,i)]}case"Slice":{const i=I("begin",x,e,t),r=I("size",x,e,t);return[n.slice(I("x",x,e,t),i,r)]}case"StridedSlice":{const i=I("begin",x,e,t),r=I("end",x,e,t),a=I("strides",x,e,t),s=I("beginMask",x,e,t),l=I("endMask",x,e,t),c=I("ellipsisMask",x,e,t),h=I("newAxisMask",x,e,t),d=I("shrinkAxisMask",x,e,t),p=I("x",x,e,t);return[n.stridedSlice(p,i,r,a,s,l,c,h,d)]}case"Pack":return hi(()=>{const i=I("axis",x,e,t),r=I("tensors",x,e,t),a=r[0].shape,s=n.squeeze(r[0]).shape,l=r.map(c=>{const h=Zx(c.shape,a);if(!h&&!Zx(n.squeeze(c).shape,s))throw new Error("the input tensors shape does not match");return h?c:n.reshape(c,a)});return[n.stack(l,i)]});case"Unpack":{const i=I("axis",x,e,t),r=I("tensor",x,e,t);return n.unstack(r,i)}case"Tile":{const i=I("reps",x,e,t);return[n.tile(I("x",x,e,t),i)]}case"Split":case"SplitV":{const i=I("axis",x,e,t),r=I("numOrSizeSplits",x,e,t),a=I("x",x,e,t);return n.split(a,r,i)}case"ScatterNd":{const i=I("indices",x,e,t),r=I("values",x,e,t),a=I("shape",x,e,t);return[n.scatterND(i,r,a)]}case"GatherNd":{const i=I("x",x,e,t),r=I("indices",x,e,t);return[n.gatherND(i,r)]}case"SparseToDense":{const i=I("sparseIndices",x,e,t),r=I("outputShape",x,e,t),a=I("sparseValues",x,e,t),s=I("defaultValue",x,e,t);return[n.sparseToDense(i,a,r,a.dtype===s.dtype?s:n.cast(s,a.dtype))]}case"TensorScatterUpdate":{const i=I("indices",x,e,t),r=I("values",x,e,t),a=I("tensor",x,e,t);return[n.tensorScatterUpdate(a,i,r)]}default:throw TypeError("Node type "+x.op+" is not implemented")}},T9=(x,e,t,n=Gn)=>{switch(x.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:r,emptyRowIndicator:a,reverseIndexMap:s}=n.sparse.sparseFillEmptyRows(I("indices",x,e,t),I("values",x,e,t),I("denseShape",x,e,t),I("defaultValue",x,e,t));return[i,r,a,s]}case"SparseReshape":{const{outputIndices:i,outputShape:r}=n.sparse.sparseReshape(I("inputIndices",x,e,t),I("inputShape",x,e,t),I("newShape",x,e,t));return[i,r]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(I("data",x,e,t),I("indices",x,e,t),I("segmentIds",x,e,t))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(I("data",x,e,t),I("indices",x,e,t),I("segmentIds",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},w9=(x,e,t,n=Gn)=>{switch(x.op){case"FFT":return[n.fft(I("x",x,e,t))];case"IFFT":return[n.ifft(I("x",x,e,t))];case"RFFT":return[n.rfft(I("x",x,e,t))];case"IRFFT":return[n.irfft(I("x",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},A9=(x,e,t,n=Gn)=>{switch(x.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(I("input",x,e,t),I("pattern",x,e,t),I("rewrite",x,e,t),I("replaceGlobal",x,e,t))];case"StringNGrams":{const{nGrams:i,nGramsSplits:r}=n.string.stringNGrams(I("data",x,e,t),I("dataSplits",x,e,t),I("separator",x,e,t),I("nGramWidths",x,e,t),I("leftPad",x,e,t),I("rightPad",x,e,t),I("padWidth",x,e,t),I("preserveShortSequences",x,e,t));return[i,r]}case"StringSplit":{const{indices:i,values:r,shape:a}=n.string.stringSplit(I("input",x,e,t),I("delimiter",x,e,t),I("skipEmpty",x,e,t));return[i,r,a]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(I("input",x,e,t),I("numBuckets",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}},E9=(x,e,t,n=Gn)=>{switch(x.op){case"Cast":return[n.cast(I("x",x,e,t),I("dtype",x,e,t))];case"ExpandDims":{const i=I("axis",x,e,t);return[n.expandDims(I("x",x,e,t),i)]}case"Squeeze":{const i=I("axis",x,e,t);return[n.squeeze(I("x",x,e,t),i)]}case"Reshape":return[n.reshape(I("x",x,e,t),I("shape",x,e,t))];case"EnsureShape":return[n.ensureShape(I("x",x,e,t),I("shape",x,e,t))];case"MirrorPad":return[n.mirrorPad(I("x",x,e,t),I("padding",x,e,t),I("mode",x,e,t))];case"PadV2":case"Pad":return[n.pad(I("x",x,e,t),I("padding",x,e,t),I("constantValue",x,e,t))];case"SpaceToBatchND":{const i=I("blockShape",x,e,t),r=I("paddings",x,e,t);return[n.spaceToBatchND(I("x",x,e,t),i,r)]}case"BatchToSpaceND":{const i=I("blockShape",x,e,t),r=I("crops",x,e,t);return[n.batchToSpaceND(I("x",x,e,t),i,r)]}case"DepthToSpace":{const i=I("blockSize",x,e,t),r=I("dataFormat",x,e,t).toUpperCase();return[n.depthToSpace(I("x",x,e,t),i,r)]}case"BroadcastTo":return[n.broadcastTo(I("x",x,e,t),I("shape",x,e,t))];case"BroadcastArgs":return[n.broadcastArgs(I("s0",x,e,t),I("s1",x,e,t))];default:throw TypeError("Node type "+x.op+" is not implemented")}};function H3(x,e,t,n,i=hi){const r=((a,s,l)=>{switch(a.category){case"arithmetic":return i(()=>t9(a,s,l));case"basic_math":return i(()=>x9(a,s,l));case"control":return o9(a,s,l);case"convolution":return i(()=>l9(a,s,l));case"creation":return i(()=>c9(a,s,l));case"dynamic":return u9(a,s,l);case"evaluation":return i(()=>h9(a,s,l));case"image":return i(()=>m9(a,s,l));case"graph":return i(()=>d9(a,s,l));case"logical":return i(()=>y9(a,s,l));case"matrices":return i(()=>g9(a,s,l));case"normalization":return i(()=>v9(a,s,l));case"ragged":return i(()=>b9(a,s,l));case"reduction":return i(()=>_9(a,s,l));case"slice_join":return i(()=>S9(a,s,l));case"sparse":return i(()=>T9(a,s,l));case"spectral":return i(()=>w9(a,s,l));case"string":return i(()=>A9(a,s,l));case"transformation":return i(()=>E9(a,s,l));case"hash_table":return p9(a,s,l,n);case"custom":const c=LU(a.op);if(c&&c.customExecutor)return c.customExecutor(new jW(a,s,l));throw TypeError("Custom op "+a.op+" is not registered.");default:throw TypeError("Unknown op '"+a.op+"'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(x,e,t);return yc(r)?r.then(a=>[].concat(a)):[].concat(r)}class G3{constructor(e={},t={},n={},i={},r){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=i,this.parseNodeNameCache=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":t.frameName+"-"+t.iterationId).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function W3(x,e,t,n){const i=new Set,r=[];let a=null,s=null;const l=new Set,c=new Set(Object.keys(x).map(p=>$i(p)[0]));n=n||[];const h=new Set(n.map(p=>$i(p.name)[0])),d=[...e];for(;d.length>0;){const p=d.pop();if((tc(p)||P9(p)||k9(p))&&a==null&&(a=p,s=a.children.map(m=>m.name).filter(m=>i.has(m))),i.add(p.name),t[p.name]==null&&!c.has(p.name)&&!h.has(p.name)){if(p.inputs.length===0){r.push(p.name);continue}p.inputs.forEach(m=>{l.has(m.name)||(l.add(m.name),d.push(m))})}}return{inputs:x,outputs:e,usedNodes:i,missingInputs:r,dynamicNode:a,syncInputs:s}}function M9(x,e){const{usedNodes:t,inputs:n}=e,i=Object.keys(n).map(v=>$i(v)[0]).map(v=>x.nodes[v]),r=x.initNodes||[],a=v=>t.has(typeof v=="string"?v:v.name);function s(v){return[...new Map(v.map(b=>[b.name,b])).values()]}const l=s([...i,...x.weights,...r]).filter(a),c=s([...l,...Object.values(x.nodes)]).filter(a),h=new Map(c.map(v=>[v.name,v])),d={};for(const v of c){d[v.name]=d[v.name]||0;for(const b of v.children)a(b)||(d[b.name]=Number.POSITIVE_INFINITY),d[b.name]=(d[b.name]||0)+1}const p=Object.entries(d).filter(([,v])=>v===0).map(([v])=>v),m=[...p];for(;p.length>0;){const v=p.pop(),b=h.get(v);for(const T of b.children.filter(a))--d[T.name]===0&&(m.push(T.name),p.push(T.name))}const g=m.map(v=>h.get(v)),_=R9(g,l);return C9(_,l),_}function R9(x,e){const t=new Map(x.map(r=>[r.name,r])),n=e.map(r=>r.name),i=new Set(n);for(;n.length>0;){const r=n.pop(),a=t.get(r);for(const s of a.children)!t.has(s.name)||i.has(s.name)||(i.add(s.name),n.push(s.name))}return x.filter(r=>i.has(r.name))}class Fm extends Error{constructor(e){super("NodesExecutionOrderError: "+e)}}function C9(x,e){const t=new Map(x.map((s,l)=>[s.name,l])),n=new Set(e.map(s=>s.name)),i=s=>n.has(typeof s=="string"?s:s.name),r=new Set(x.map(s=>s.name)),a=s=>r.has(typeof s=="string"?s:s.name);for(const s of x){for(const l of s.children.filter(a)){if(!t.has(l.name))throw new Fm("Child "+l.name+" of node "+s.name+" is unreachable.");if(t.get(s.name)>t.get(l.name))throw new Fm("Node "+s.name+" is scheduled to run after its child "+l.name+".")}if(!i(s))for(const l of s.inputs){if(!t.has(l.name))throw new Fm("Input "+l.name+" of node "+s.name+" is unreachable.");if(t.get(l.name)>t.get(s.name))throw new Fm("Node "+s.name+" is scheduled to run before its input "+l.name+".")}}}function N9(x){const e=new Map(x.map((s,l)=>[s.name,l])),t=Number.MAX_SAFE_INTEGER,n=x.map((s,l)=>tc(s)?t:l),i=s=>{const l=n[e.get(s.name)];return l??-1},r=x.map((s,l)=>s.children.map(i).reduce((c,h)=>Math.max(c,h),n[l])),a=new Map;for(let s=0;s<x.length;++s){const l=r[s];if(l===t)continue;const c=x[s],h=x[l];a.has(h.name)||a.set(h.name,[]),a.get(h.name).push(c)}return a}const I9=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),O9=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),D9=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function tc(x){return I9.has(x.op)}function P9(x){return O9.has(x.op)}function k9(x){return D9.has(x.op)}class R1{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(n=>e[n].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?t+":"+e.defaultOutput:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new R1(e.functions[n],this)})}getCompilationKey(e,t){const n=e.map(r=>r.name).sort(),i=t.map(r=>r.name).sort();return n.join(this.SEPARATOR)+"--"+i.join(this.SEPARATOR)}compile(e,t){const n=W3(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:r,syncInputs:a}=n;if(r!=null)throw new Error("This execution contains the node '"+r.name+"', which has the dynamic op '"+r.op+"'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs ["+a+"]");if(i.length>0){const c=t.map(d=>d.name),h=Object.keys(e);throw new Error("Cannot compute the outputs ["+c+"] from the provided inputs ["+h+"]. Missing the following inputs: ["+i+"]")}const s=M9(this.graph,n),l=N9(s);return{orderedNodes:s,nodeLiveUntilMap:l}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return Co(t),t}cloneTensorList(e){return e?e.map(t=>this.cloneAndKeepTensor(t)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=n.map(p=>this.graph.nodes[$i(p)[0]]),r=t.map(p=>$i(p)[0]),a=new Set(r);let s=r.map(p=>this.graph.nodes[p]);s.length===0&&(s=this._outputs);const l=this.getCompilationKey(i,s);let c=this.compiledMap.get(l);c==null&&(c=this.compile(e,s),this.compiledMap.set(l,c));try{this.keepIntermediateTensors=Pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const h={},d={};return hi(()=>{const p=new G3(this.weightMap,h,d,this.functionExecutorMap,this.parseNodeNameCache),m=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(b=>{const[T,E]=$i(b,p),A=[];A[E]=e[b],m[T]=A,this.keepIntermediateTensors&&(this.clonedTensorsMap[T]=this.cloneTensorList(A))});const g=this.getFrozenTensorIds(m),{orderedNodes:_,nodeLiveUntilMap:v}=c;for(const b of _){if(m[b.name])continue;const T=H3(b,m,p,this._resourceManager);if(yc(T))throw new Error("The execution of the op '"+b.op+"' returned a promise. Please use model.executeAsync() instead.");m[b.name]=T,this.keepIntermediateTensors&&(this.clonedTensorsMap[b.name]=this.cloneTensorList(T)),this.checkTensorForDisposalWithNodeLiveUntilInfo(b,m,p,g,a,v.get(b.name))}return this.parent==null&&p.dispose(g),t.map(b=>zn(b,m,p))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,n,i,r,a,s){if(!(tc(t)||a.has(e))){for(const l of n[e])l!=null&&(s[l.id]=(s[l.id]||0)+t.children.length);for(const l of t.inputs){if(tc(l))continue;const c=F3(l.name,n,i);if(c!=null)for(const h of c){if(!h||h.kept||r.has(h.id))continue;const d=s[h.id];d===1?(h.dispose(),delete s[h.id]):d!=null&&s[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,i,r,a){function s(l){return tc(l)||r.has(l.name)}if(!(tc(e)||a==null))for(const l of a){if(s(l))continue;const c=F3(l.name,t,n);for(const h of c)!h||h.kept||i.has(h.id)||h.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,i={},r={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=Pe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(p){this.keepIntermediateTensors=!1,console.warn(p.message)}const a=new G3(this.weightMap,i,r,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const s=await this.executeWithControlFlow(e,a,t,n),l=t.map(p=>zn(p,s,a)),c=l.map(p=>p.id),h=Object.keys(e).map(p=>e[p].id),d=new Set([...c,...h,...this.weightIds]);return Object.values(s).forEach(p=>{p.forEach(m=>{m&&!m.isDisposed&&!d.has(m.id)&&m.dispose()})}),this.parent==null&&a.dispose(d),l}async executeFunctionAsync(e,t,n){const i=e.reduce((r,a,s)=>(r[this.inputs[s].name]=a,r),{});return this._executeAsync(i,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,i){const r=Object.keys(e),a=r.map(A=>this.graph.nodes[$i(A)[0]]),s=n.map(A=>$i(A)[0]),l=new Set(s);let c=s.map(A=>this.graph.nodes[A]);c.length===0&&(c=this._outputs);const{usedNodes:h,missingInputs:d,dynamicNode:p,syncInputs:m}=W3(e,c,this.weightMap,this._initNodes),g=[...a,...this.graph.weights,...this._initNodes||[]].map(A=>({node:A,contexts:t.currentContext})),_=Object.assign({},this.weightMap);Object.keys(e).forEach(A=>{const[M,R]=$i(A),C=[];C[R]=e[A],_[M]=C});const v={},b=this.getFrozenTensorIds(_),T={};for(;g.length>0;){const A=this.processStack(a,g,t,_,T,b,l,v,h);await Promise.all(A)}p==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const E=c.filter(A=>!tc(A)&&!zn(A.name,_,t)).map(A=>A.name);if(E.length>0){let A="";throw p!=null&&(A="Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs ["+m+"]"),new Error("Cannot compute the outputs ["+E+"] from the provided inputs ["+r+"]. Consider providing the following inputs: ["+d+"]. "+A)}return _}processStack(e,t,n,i,r,a,s,l,c){const h=[];for(;t.length>0;){const d=t.pop();n.currentContext=d.contexts;let p="";if(d.node.op==="Enter"&&I("isConstant",d.node,i,n)&&([p]=bo(d.node.name,n)),i[d.node.name]==null){const m=H3(d.node,i,n,this._resourceManager);p||([p]=bo(d.node.name,n));const g=n.currentContext;yc(m)?h.push(m.then(_=>(i[p]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(_)),n.currentContext=g,this.checkTensorForDisposal(p,d.node,i,n,a,s,l),this.processChildNodes(d.node,t,n,i,r,c),_))):(i[p]=m,this.keepIntermediateTensors&&(this.clonedTensorsMap[p]=this.cloneTensorList(m)),this.checkTensorForDisposal(p,d.node,i,n,a,s,l),this.processChildNodes(d.node,t,n,i,r,c))}else this.processChildNodes(d.node,t,n,i,r,c)}return h}processChildNodes(e,t,n,i,r,a){e.children.forEach(s=>{const[l]=bo(s.name,n);r[l]||!a.has(s.name)||(s.op==="Merge"?s.inputNames.some(c=>!!zn(c,i,n))&&(r[l]=!0,t.push({contexts:n.currentContext,node:s})):s.inputNames.every(c=>!!zn(c,i,n))&&(r[l]=!0,t.push({contexts:n.currentContext,node:s})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[i]=$i(t),r=this.graph.nodes[i];if(r.attrParams.shape&&r.attrParams.shape.value){const a=r.attrParams.shape.value,s=a.length===n.shape.length&&n.shape.every((l,c)=>a[c]===-1||a[c]===l);ye(s,()=>"The shape of dict['"+r.name+"'] provided in model.execute(dict) must be ["+a+"], but was ["+n.shape+"]")}r.attrParams.dtype&&r.attrParams.dtype.value&&ye(n.dtype===r.attrParams.dtype.value,()=>"The dtype of dict['"+r.name+"'] provided in model.execute(dict) must be "+r.attrParams.dtype.value+", but was "+n.dtype)})}mapInputs(e){var t,n;const i={};for(const r in e){const a=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[r];a!=null?i[a.name]=e[r]:i[r]=e[r]}return i}checkInputs(e){const t=Object.keys(e).filter(n=>{const[i]=$i(n);return this.graph.nodes[i]==null});if(t.length>0)throw new Error("The dict provided in model.execute(dict) has keys: ["+t+"] that are not part of graph")}mapOutputs(e){return e.map(t=>{var n,i;const r=(i=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||i===void 0?void 0:i[t];return r!=null?r.name:t},{})}checkOutputs(e){e.forEach(t=>{const[n]=$i(t);if(!this.graph.nodes[n])throw new Error("The output '"+t+"' is not found in the graph")})}}class U9{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const F9="?tfjs-format=file",B9="model.json";class L9{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=zk){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new U9}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one ("+t.length+") load handlers for URL '"+[e]+"'");this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return yc(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Rk(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let i=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const r=this.artifacts.userDefinedMetadata;r.signature!=null&&(i=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}if(this.signature=i,this.version=n.versions.producer+"."+n.versions.minConsumer,this.executor=new R1(B3.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const r=B3.Instance.transformGraph(e.modelInitializer);this.initializer=new R1(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error("Cannot find any save handlers for URL '"+e+"'");if(n.length>1)throw new Error("Found more than one ("+n.length+") save handlers for URL '"+e+"'");e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Mr?[e]:e,n={};return t.forEach((i,r)=>n[this.structuredOutputKeys[r]]=i),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof Mr)&&!Array.isArray(e)){const r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(const a in r){const s=r[a];s.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[s.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error("Input tensor count mismatch, the graph model has "+(this.inputNodes.length-n)+" non-resource placeholders, while there are "+e.length+" input tensors provided.");let i=0;return this.inputNodes.reduce((r,a)=>{var s,l,c;const h=(c=(l=(s=this.signature)===null||s===void 0?void 0:s.inputs)===null||l===void 0?void 0:l[a])===null||c===void 0?void 0:c.resourceId;return h!=null?r[a]=this.resourceIdToCapturedInput[h]:r[a]=e[i++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let i=0;i<n.length;i++){const r=n[i],a=t[r];this.resourceIdToCapturedInput[a.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&ZV(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function X3(x,e={},t=zk){if(x==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof x=="string"&&(x=z9(x));const n=new L9(x,e,t);return await n.load(),n}function z9(x){return x.endsWith("/")||(x=x+"/"),""+x+B9+F9}const xc={},Bm={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function V9(x,e){xc[x]=e}function Ja(x,e){if(!(x in xc)||e!=null){const n=G9(x,e);if(n!==null)xc[x]=n;else return console.log("Could not get context for WebGL version",x),null}const t=xc[x];return t==null||t.isContextLost()?(delete xc[x],Ja(x)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),xc[x])}function H9(x){if(!Pe().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&x===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function G9(x,e){if(x!==1&&x!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??H9(x);return t.addEventListener("webglcontextlost",n=>{n.preventDefault(),delete xc[x]},!1),Pe().getBool("SOFTWARE_WEBGL_ENABLED")&&(Bm.failIfMajorPerformanceCaveat=!1),x===1?t.getContext("webgl",Bm)||t.getContext("experimental-webgl",Bm):t.getContext("webgl2",Bm)}var Kf;(function(x){x[x.DENSE=0]="DENSE",x[x.SHARED_BATCH=1]="SHARED_BATCH"})(Kf||(Kf={}));var Nr;(function(x){x[x.RENDER=0]="RENDER",x[x.UPLOAD=1]="UPLOAD",x[x.PIXELS=2]="PIXELS",x[x.DOWNLOAD=3]="DOWNLOAD"})(Nr||(Nr={}));var Vn;(function(x){x[x.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",x[x.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",x[x.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",x[x.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",x[x.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Vn||(Vn={}));function gp(x,e){return[e,x]}function W9(x,e){return x*e}function Lm(x){const e=ut(x),t=Math.ceil(e/4);return YS(t)}function jh(x,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(x/2))]}function X9(x,e){const[t,n]=jh(x,e);return t*n*4}function nE(x,e){const t=x;let n,i,r,a,s,l,c,h,d,p;return Pe().getNumber("WEBGL_VERSION")===2?(n=t.R32F,i=t.R16F,r=t.RGBA16F,a=t.RGBA32F,s=t.RED,c=4,h=1,d=t.HALF_FLOAT,p=t.FLOAT,l=t.RGBA8):(n=x.RGBA,i=x.RGBA,r=x.RGBA,a=t.RGBA,s=x.RGBA,c=4,h=4,d=e!=null?e.HALF_FLOAT_OES:null,p=x.FLOAT,l=x.RGBA),{internalFormatFloat:n,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:a,textureFormatFloat:s,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:h,textureTypeHalfFloat:d,textureTypeFloat:p}}function Nt(x,e){const t=e();return Pe().getBool("DEBUG")&&Y9(x),t}function Y9(x){const e=x.getError();if(e!==x.NO_ERROR)throw new Error("WebGL Error: "+Z9(x,e))}const K9=596e-10,$9=65504;function Q9(x){return!!(Pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||x===0||K9<Math.abs(x)&&Math.abs(x)<$9)}function Z9(x,e){switch(e){case x.NO_ERROR:return"NO_ERROR";case x.INVALID_ENUM:return"INVALID_ENUM";case x.INVALID_VALUE:return"INVALID_VALUE";case x.INVALID_OPERATION:return"INVALID_OPERATION";case x.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case x.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case x.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code "+e}}function zm(x,e){return Go(x,()=>x.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function J9(x,e){const t=Go(x,()=>x.createShader(x.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Nt(x,()=>x.shaderSource(t,e)),Nt(x,()=>x.compileShader(t)),x.getShaderParameter(t,x.COMPILE_STATUS)===!1)throw console.log(x.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function j9(x,e){const t=Go(x,()=>x.createShader(x.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Nt(x,()=>x.shaderSource(t,e)),Nt(x,()=>x.compileShader(t)),Pe().get("ENGINE_COMPILE_ONLY"))return t;if(x.getShaderParameter(t,x.COMPILE_STATUS)===!1)throw HU(e,x.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const q9=/ERROR: [0-9]+:([0-9]+):/g;function HU(x,e){const t=q9.exec(e);if(t==null){console.log("Couldn't parse line number in error: "+e),console.log(x);return}const n=+t[1],i=x.split(`
`),r=i.length.toString().length+2,a=i.map((d,p)=>rh((p+1).toString(),r)+d);let s=0;for(let d=0;d<a.length;d++)s=Math.max(a[d].length,s);const l=a.slice(0,n-1),c=a.slice(n-1,n),h=a.slice(n);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log("%c "+rh(c[0],s),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(h.join(`
`))}function eX(x){return Go(x,()=>x.createProgram(),"Unable to create WebGLProgram.")}function tX(x,e){if(Nt(x,()=>x.linkProgram(e)),!Pe().get("ENGINE_COMPILE_ONLY")&&x.getProgramParameter(e,x.LINK_STATUS)===!1)throw console.log(x.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function v_(x,e){if(Nt(x,()=>x.validateProgram(e)),x.getProgramParameter(e,x.VALIDATE_STATUS)===!1)throw console.log(x.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function xX(x,e){const t=Go(x,()=>x.createBuffer(),"Unable to create WebGLBuffer");return Nt(x,()=>x.bindBuffer(x.ARRAY_BUFFER,t)),Nt(x,()=>x.bufferData(x.ARRAY_BUFFER,e,x.STATIC_DRAW)),t}function nX(x,e){const t=Go(x,()=>x.createBuffer(),"Unable to create WebGLBuffer");return Nt(x,()=>x.bindBuffer(x.ELEMENT_ARRAY_BUFFER,t)),Nt(x,()=>x.bufferData(x.ELEMENT_ARRAY_BUFFER,e,x.STATIC_DRAW)),t}function iX(x){return Go(x,()=>x.createTexture(),"Unable to create WebGLTexture.")}function rX(x,e){const t=Pe().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(x<=0||e<=0){const n="["+x+"x"+e+"]";throw new Error("Requested texture size "+n+" is invalid.")}if(x>t||e>t){const n="["+x+"x"+e+"]",i="["+t+"x"+t+"]";throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+i+".")}}function aX(x){return Go(x,()=>x.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function Y3(x,e,t,n,i,r,a){const s=x.getAttribLocation(e,t);return s===-1?!1:(Nt(x,()=>x.bindBuffer(x.ARRAY_BUFFER,n)),Nt(x,()=>x.vertexAttribPointer(s,i,x.FLOAT,!1,r,a)),Nt(x,()=>x.enableVertexAttribArray(s)),!0)}function sX(x,e,t){hX(x,t),Nt(x,()=>x.activeTexture(x.TEXTURE0+t)),Nt(x,()=>x.bindTexture(x.TEXTURE_2D,e))}function oX(x,e,t){return Go(x,()=>x.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function lX(x,e,t){return x.getUniformLocation(e,t)}function cX(x,e,t,n){Nt(x,()=>sX(x,e,n)),Nt(x,()=>x.uniform1i(t,n))}function b_(x,e,t){Nt(x,()=>x.bindFramebuffer(x.FRAMEBUFFER,t)),Nt(x,()=>x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,e,0))}function K3(x,e){Nt(x,()=>x.bindFramebuffer(x.FRAMEBUFFER,e)),Nt(x,()=>x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,null,0))}function Vm(x){const e=x.checkFramebufferStatus(x.FRAMEBUFFER);if(e!==x.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+uX(x,e))}function uX(x,e){switch(e){case x.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case x.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case x.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case x.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error "+e}}function Go(x,e,t){const n=Nt(x,()=>e());if(n==null)throw new Error(t);return n}function hX(x,e){const t=x.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=e+x.TEXTURE0;if(n<x.TEXTURE0||n>t){const i="[gl.TEXTURE0, gl.TEXTURE"+t+"]";throw new Error("textureUnit must be in "+i+".")}}function Rh(x,e=2){return ut(x.slice(0,x.length-e))}function Ch(x){if(x.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[x.length>1?x[x.length-2]:1,x[x.length-1]]}function Hm(x){let e=[1,1,1];return x.length===0||x.length===1&&x[0]===1||(e=[Rh(x),...Ch(x)]),e}function dX(x,e=!1){let t=Pe().getNumber("WEBGL_MAX_TEXTURE_SIZE"),n=Pe().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");n===1/0&&Pe().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(n=t/2),e&&(t=t*2,n=n*2,x=x.map((s,l)=>l>=x.length-2?jw(x[l]):x[l]),x.length===1&&(x=[2,x[0]])),x.length!==2&&(x=al(x).newShape);let i=ut(x),r=null;x.length<=1&&i<=t?r=[1,i]:x.length===2&&x[0]<=t&&x[1]<=t?r=x:x.length===3&&x[0]*x[1]<=t&&x[2]<=t?r=[x[0]*x[1],x[2]]:x.length===3&&x[0]<=t&&x[1]*x[2]<=t?r=[x[0],x[1]*x[2]]:x.length===4&&x[0]*x[1]*x[2]<=t&&x[3]<=t?r=[x[0]*x[1]*x[2],x[3]]:x.length===4&&x[0]<=t&&x[1]*x[2]*x[3]<=t&&(r=[x[0],x[1]*x[2]*x[3]]);const a=r!=null&&Math.max(...r)>n&&Math.min(...r)<=(e?2:1)&&Math.min(...r)>0;if(r==null||a)if(e){const s=Rh(x);let l=2,c=2;x.length&&([l,c]=Ch(x)),i=s*(l/2)*(c/2),r=YS(i).map(h=>h*2)}else r=YS(i);return r}function Gm(x){return x%2===0}function C1(x,e){if(x=x.slice(-2),e=e.slice(-2),Zx(x,e)||!x.length||!e.length||x[0]===0||x[1]===0||e[0]===0||e[1]===0)return!0;if(x.length!==e.length){const t=x[x.length-1],n=e[e.length-1];if(t===n||Gm(t)&&Gm(n)&&(x[0]===1||e[0]===1))return!0}return x[1]===e[1]&&Gm(x[0])&&Gm(e[0])}let __,S_;function fX(x){if(__==null){const e=Ja(x);__=e.getParameter(e.MAX_TEXTURE_SIZE)}return __}function pX(x){if(S_==null){const e=Ja(x);S_=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,S_)}function mX(x){if(x===0)return 0;let e;const t=Ja(x);return ma(t,"EXT_disjoint_timer_query_webgl2")&&x===2?e=2:ma(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function ma(x,e){return x.getExtension(e)!=null}function $3(x){try{if(Ja(x)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function yX(x){if(x===0)return!1;const e=Ja(x);if(x===1){if(!ma(e,"OES_texture_float"))return!1}else if(!ma(e,"EXT_color_buffer_float"))return!1;return ET(e)}function gX(x){if(x===0)return!1;const e=Ja(x);if(x===1){if(!ma(e,"OES_texture_float")||!ma(e,"WEBGL_color_buffer_float"))return!1}else{if(ma(e,"EXT_color_buffer_float"))return ET(e);const t="EXT_color_buffer_half_float";if(ma(e,t)){const n=e.getExtension(t);return vX(e,n)}return!1}return ET(e)}function ET(x){const e=nE(x),t=x.createTexture();x.bindTexture(x.TEXTURE_2D,t),x.texImage2D(x.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const n=x.createFramebuffer();x.bindFramebuffer(x.FRAMEBUFFER,n),x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,t,0);const i=x.checkFramebufferStatus(x.FRAMEBUFFER)===x.FRAMEBUFFER_COMPLETE;return x.bindTexture(x.TEXTURE_2D,null),x.bindFramebuffer(x.FRAMEBUFFER,null),x.deleteTexture(t),x.deleteFramebuffer(n),i}function vX(x,e){const t=nE(x,e),n=x.createTexture();x.bindTexture(x.TEXTURE_2D,n),x.texImage2D(x.TEXTURE_2D,0,t.internalFormatHalfFloat,1,1,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const i=x.createFramebuffer();x.bindFramebuffer(x.FRAMEBUFFER,i),x.framebufferTexture2D(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,n,0);const r=x.checkFramebufferStatus(x.FRAMEBUFFER)===x.FRAMEBUFFER_COMPLETE;return x.bindTexture(x.TEXTURE_2D,null),x.bindFramebuffer(x.FRAMEBUFFER,null),x.deleteTexture(n),x.deleteFramebuffer(i),r}function bX(x){return x!==2?!1:Ja(x).fenceSync!=null}function GU(x,e){Array.isArray(x)||(x=[x]),x.forEach(t=>{t!=null&&ye(t.dtype!=="complex64",()=>e+" does not support complex64 tensors in the WebGL backend.")})}const zt=Pe();zt.registerFlag("HAS_WEBGL",()=>zt.getNumber("WEBGL_VERSION")>0),zt.registerFlag("WEBGL_VERSION",()=>$3(2)?2:$3(1)?1:0),zt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1),zt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>zt.get("WEBGL_VERSION")===2),zt.registerFlag("WEBGL_CPU_FORWARD",()=>!0),zt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1),zt.registerFlag("WEBGL_PACK",()=>zt.getBool("HAS_WEBGL")),zt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_CLIP",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_REDUCE",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_LAZILY_UNPACK",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_CONV_IM2COL",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>zt.getBool("WEBGL_PACK")),zt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>fX(zt.getNumber("WEBGL_VERSION"))),zt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>pX(zt.getNumber("WEBGL_VERSION"))),zt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const x=zt.getNumber("WEBGL_VERSION");return x===0?0:mX(x)}),zt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>zt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!d3()),zt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>yX(zt.getNumber("WEBGL_VERSION"))),zt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>zt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:zt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE")),zt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>gX(zt.getNumber("WEBGL_VERSION"))),zt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>bX(zt.getNumber("WEBGL_VERSION"))),zt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>zt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0),zt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,x=>{if(typeof x!="number")throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got "+x+".");if(x<0&&x!==-1)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got "+x+".")}),zt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>d3()?1:-1,x=>{if(typeof x!="number")throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+x+".");if(x<0&&x!==-1)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got "+x+".")}),zt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128),zt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1),zt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5),zt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128),zt.registerFlag("WEBGL_EXP_CONV",()=>!1),zt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>zt.getBool("IS_TEST")),zt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0),zt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1),zt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1),zt.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);function fi(){let x,e,t,n,i,r,a,s,l,c;return Pe().getNumber("WEBGL_VERSION")===2?(x="#version 300 es",e="in",t="out",n="in",i="texture",r="outputColor",a="out vec4 outputColor;",s=Pe().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(x="",e="attribute",t="varying",n="varying",i="texture2D",r="gl_FragColor",a="",s=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:x,attribute:e,varyingVs:t,varyingFs:n,texture2D:i,output:r,defineOutput:a,defineSpecialNaN:s,defineSpecialInf:l,defineRound:c}}function Uc(x,e,t="index"){const n=M0(e);return n.map((i,r)=>{const a="int "+x[r]+" = "+t+" / "+i,s=r===n.length-1?"int "+x[r+1]+" = "+t+" - "+x[r]+" * "+i:"index -= "+x[r]+" * "+i;return a+"; "+s+";"}).join("")}function Fg(x,e,t="index"){const n=M0(e);return n.map((i,r)=>{const a="int "+x[r]+" = "+t+" / outShapeStrides["+r+"]",s=r===n.length-1?"int "+x[r+1]+" = "+t+" - "+x[r]+" * outShapeStrides["+r+"]":"index -= "+x[r]+" * outShapeStrides["+r+"]";return a+"; "+s+";"}).join("")}function _X(x,e){const t=x.length,n=x.map(r=>e+"["+r+"]"),i=new Array(t-1);i[t-2]=n[t-1];for(let r=t-3;r>=0;--r)i[r]="("+i[r+1]+" * "+n[r+1]+")";return i}function SX(x,e,t="index"){const n=x.map((r,a)=>a),i=_X(n,e);return i.map((r,a)=>{const s="int "+x[a]+" = "+t+" / "+i[a],l=a===i.length-1?"int "+x[a+1]+" = "+t+" - "+x[a]+" * "+i[a]:"index -= "+x[a]+" * "+i[a];return s+"; "+l+";"}).join("")}function iE(x){const e=M0(x).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * `+e[0]+" + coords.y * "+e[1]+` + coords.z;
  }
`}function rE(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const WU=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`,{getBroadcastDims:XU}=XG;function TX(x,e,t){const n=[];if(x.forEach(p=>{const m=ut(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?n.push("uniform float "+p.name+(m>1?"["+m+"]":"")+";"):(n.push("uniform sampler2D "+p.name+";"),n.push("uniform int offset"+p.name+";")),t.enableShapeUniforms){const{uniformShape:g}=aE(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(g.length){case 1:n.push("uniform int "+p.name+"Shape;");break;case 2:n.push("uniform ivec2 "+p.name+"Shape;");break;case 3:n.push("uniform ivec3 "+p.name+"Shape;");break;case 4:n.push("uniform ivec4 "+p.name+"Shape;");break}n.push("uniform ivec2 "+p.name+"TexShape;")}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:n.push("uniform int outShape;");break;case 2:n.push("uniform ivec2 outShape;"),n.push("uniform int outShapeStrides;");break;case 3:n.push("uniform ivec3 outShape;"),n.push("uniform ivec2 outShapeStrides;");break;case 4:n.push("uniform ivec4 outShape;"),n.push("uniform ivec3 outShapeStrides;");break}n.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{n.push("uniform "+p.type+" "+p.name+(p.arrayIndex?"["+p.arrayIndex+"]":"")+";")});const i=n.join(`
`),r=x.map(p=>wX(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,s=fi(),l=MX(s);let c,h,d=NX(s);return e.isPacked?(c=AX(e.logicalShape,a,t.enableShapeUniforms),h=CX(s)):(c=EX(e.logicalShape,a,t.enableShapeUniforms),h=RX(s)),t.packedInputs&&(d+=PX),[d,l,h,i,c,r,t.userCode].join(`
`)}function qh(x,e=!1){const t=x.shapeInfo.logicalShape;switch(t.length){case 0:return YX(x,e);case 1:return $X(x,e);case 2:return ZX(x,e);case 3:return jX(x,e);case 4:return eY(x,e);case 5:return tY(x);case 6:return xY(x);default:throw new Error(t.length+"-D input sampling is not yet supported")}}function YU(x,e){switch(x.shapeInfo.logicalShape.length){case 0:return XX(x);case 1:return KX(x,e);case 2:return QX(x,e);case 3:return JX(x,e);default:return qX(x,e)}}function wX(x,e,t=!1,n){let i="";t?i+=YU(x,n):i+=qh(x,n);const r=x.shapeInfo.logicalShape,a=e.logicalShape;return r.length<=a.length&&(t?i+=nY(x,e):i+=iY(x,e)),i}function AX(x,e,t){switch(x.length){case 0:return KU();case 1:return kX(x,e,t);case 2:return GX(x,e,t);case 3:return FX(x,e,t);default:return LX(x,e,t)}}function EX(x,e,t){switch(x.length){case 0:return KU();case 1:return UX(x,e,t);case 2:return WX(x,e,t);case 3:return BX(x,e,t);case 4:return zX(x,e,t);case 5:return VX(x,e);case 6:return HX(x,e);default:throw new Error(x.length+"-D output sampling is not yet supported")}}function MX(x){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return `+x.texture2D+`(textureSampler, uv).r;
    }
  `}function RX(x){return`
    void setOutput(float val) {
      `+x.output+` = vec4(val, 0, 0, 0);
    }
  `}function CX(x){return`
    void setOutput(vec4 val) {
      `+x.output+` = val;
    }
  `}function NX(x){return x.version+`
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    `+x.varyingFs+` vec2 resultUV;
    `+x.defineOutput+`
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    `+x.defineSpecialNaN+`
    `+x.defineSpecialInf+`
    `+x.defineRound+`

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    `+IX+`
    `+OX+`
    `+DX+`
  `}const IX=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,OX=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,DX=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,PX=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function KU(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function kX(x,e,t){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return n[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * `+n[1]+`.0);
      }
    `:n[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * `+n[0]+`.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+n[0]+", "+n[1]+`));
      return 2 * (resTexRC.x * `+n[1]+` + resTexRC.y);
    }
  `}function UX(x,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * `+e[1]+`.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * `+e[0]+`.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+e[0]+", "+e[1]+`));
      return resTexRC.x * `+e[1]+` + resTexRC.y;
    }
  `}function FX(x,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(x[2]/2),r=i*Math.ceil(x[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+n[0]+", "+n[1]+`));
      int index = resTexRC.x * `+n[1]+` + resTexRC.y;

      int b = index / `+r+`;
      index -= b * `+r+`;

      int r = 2 * (index / `+i+`);
      int c = imod(index, `+i+`) * 2;

      return ivec3(b, r, c);
    }
  `}function BX(x,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    `+Fg(["r","c","d"],x)+`
    return ivec3(r, c, d);
  }
`;const n=Uc(["r","c","d"],x);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+e[0]+", "+e[1]+`));
      int index = resTexRC.x * `+e[1]+` + resTexRC.y;
      `+n+`
      return ivec3(r, c, d);
    }
  `}function LX(x,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(x[x.length-1]/2),r=i*Math.ceil(x[x.length-2]/2);let a=r,s="",l="b, r, c";for(let c=2;c<x.length-1;c++)a*=x[x.length-c-1],s=`
      int b`+c+" = index / "+a+`;
      index -= b`+c+" * "+a+`;
    `+s,l="b"+c+", "+l;return`
    ivec`+x.length+` getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+n[0]+", "+n[1]+`));
      int index = resTexRC.x * `+n[1]+` + resTexRC.y;

      `+s+`

      int b = index / `+r+`;
      index -= b * `+r+`;

      int r = 2 * (index / `+i+`);
      int c = imod(index, `+i+`) * 2;

      return ivec`+x.length+"("+l+`);
    }
  `}function zX(x,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      `+Fg(["r","c","d","d2"],x)+`
      return ivec4(r, c, d, d2);
    }
  `;const n=Uc(["r","c","d","d2"],x);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+e[0]+", "+e[1]+`));
      int index = resTexRC.x * `+e[1]+` + resTexRC.y;
      `+n+`
      return ivec4(r, c, d, d2);
    }
  `}function VX(x,e){const t=Uc(["r","c","d","d2","d3"],x);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(`+e[0]+`,
                             `+e[1]+`));

      int index = resTexRC.x * `+e[1]+` + resTexRC.y;

      `+t+`

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function HX(x,e){const t=Uc(["r","c","d","d2","d3","d4"],x);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(`+e[0]+", "+e[1]+`));
      int index = resTexRC.x * `+e[1]+` + resTexRC.y;

      `+t+`

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function GX(x,e,t){const n=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Zx(x,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(`+n[0]+", "+n[1]+`));
      }
    `;const i=Math.ceil(x[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+n[0]+", "+n[1]+`));

      int index = resTexRC.x * `+n[1]+` + resTexRC.y;
      int r = 2 * (index / `+i+`);
      int c = imod(index, `+i+`) * 2;

      return ivec2(r, c);
    }
  `}function WX(x,e,t){return Zx(x,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(`+e[0]+", "+e[1]+`));
      }
    `:x[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+e[0]+", "+e[1]+`));
        int index = resTexRC.x * `+e[1]+` + resTexRC.y;
        return ivec2(index, 0);
      }
    `:x[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(`+e[0]+", "+e[1]+`));
        int index = resTexRC.x * `+e[1]+` + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(`+e[0]+", "+e[1]+`));
      int index = resTexRC.x * `+e[1]+` + resTexRC.y;
      int r = index / `+x[1]+`;
      int c = index - r * `+x[1]+`;
      return ivec2(r, c);
    }
  `}function Fc(x){return"offset"+x}function XX(x){const e=x.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),n=fi();return`
    vec4 `+t+`() {
      return `+n.texture2D+"("+e+`, halfCR);
    }
  `}function YX(x,e){const t=x.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(x.shapeInfo.isUniform)return"float "+n+"() {return "+t+";}";const[i,r]=x.shapeInfo.texShape;if(i===1&&r===1)return`
      float `+n+`() {
        return sampleTexture(`+t+`, halfCR);
      }
    `;const a=Fc(t);if(e)return`
    float `+n+`() {
      vec2 uv = uvFromFlat(`+t+"TexShape[0], "+t+"TexShape[1], "+a+`);
      return sampleTexture(`+t+`, uv);
    }
  `;const[s,l]=x.shapeInfo.texShape;return`
    float `+n+`() {
      vec2 uv = uvFromFlat(`+s+", "+l+", "+a+`);
      return sampleTexture(`+t+`, uv);
    }
  `}function KX(x,e){const t=x.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),i=x.shapeInfo.texShape,r=fi();if(e)return`
    vec4 `+n+`(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(`+t+"TexShape[0]) / 2.0), ceil(float("+t+`TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return `+r.texture2D+"("+t+`, uv);
    }
  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 `+n+`(int index) {
      vec2 uv = packedUVfrom1D(
        `+a[0]+", "+a[1]+`, index);
      return `+r.texture2D+"("+t+`, uv);
    }
  `}function $X(x,e){const t=x.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1);if(x.shapeInfo.isUniform)return`
      float `+n+`(int index) {
        `+ed(x)+`
      }
    `;const i=x.shapeInfo.texShape,r=i[0],a=i[1];if(a===1&&r===1)return`
      float `+n+`(int index) {
        return sampleTexture(`+t+`, halfCR);
      }
    `;const s=Fc(t);return a===1?e?`
      float `+n+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+s+") + 0.5) / float("+t+`TexShape[0]));
        return sampleTexture(`+t+`, uv);
      }
    `:`
      float `+n+`(int index) {
        vec2 uv = vec2(0.5, (float(index + `+s+") + 0.5) / "+r+`.0);
        return sampleTexture(`+t+`, uv);
      }
    `:r===1?e?`
      float `+n+`(int index) {
        vec2 uv = vec2((float(index + `+s+") + 0.5) / float("+t+`TexShape[1]), 0.5);
        return sampleTexture(`+t+`, uv);
      }
    `:`
      float `+n+`(int index) {
        vec2 uv = vec2((float(index + `+s+") + 0.5) / "+a+`.0, 0.5);
        return sampleTexture(`+t+`, uv);
      }
    `:e?`
    float `+n+`(int index) {
      vec2 uv = uvFromFlat(`+t+"TexShape[0], "+t+"TexShape[1], index + "+s+`);
      return sampleTexture(`+t+`, uv);
    }
  `:`
    float `+n+`(int index) {
      vec2 uv = uvFromFlat(`+r+", "+a+", index + "+s+`);
      return sampleTexture(`+t+`, uv);
    }
  `}function QX(x,e){const t=x.shapeInfo.logicalShape,n=x.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=x.shapeInfo.texShape,a=r[0],s=r[1],l=fi();if(r!=null&&Zx(t,r))return e?`
      vec4 `+i+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+n+"TexShape[1], "+n+`TexShape[0]);

        return `+l.texture2D+"("+n+`, uv);
      }
    `:`
      vec4 `+i+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+s+".0, "+a+`.0);

        return `+l.texture2D+"("+n+`, uv);
      }
    `;if(e)return`
    vec4 `+i+`(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+n+"TexShape[0]) / 2.0), ceil(float("+n+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+n+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return `+l.texture2D+"("+n+`, uv);
    }
  `;const c=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],h=Math.ceil(t[1]/2);return`
    vec4 `+i+`(int row, int col) {
      vec2 uv = packedUVfrom2D(`+h+", "+c[0]+", "+c[1]+`, row, col);
      return `+l.texture2D+"("+n+`, uv);
    }
  `}function ZX(x,e){const t=x.shapeInfo.logicalShape,n=x.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=x.shapeInfo.texShape;if(r!=null&&Zx(t,r)){if(e)return`
      float `+i+`(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(`+n+"TexShape[1], "+n+`TexShape[0]);
        return sampleTexture(`+n+`, uv);
      }
    `;const p=r[0],m=r[1];return`
    float `+i+`(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(`+m+".0, "+p+`.0);
      return sampleTexture(`+n+`, uv);
    }
  `}const{newShape:a,keptDims:s}=al(t),l=a;if(l.length<t.length){const p=td(x,l),m=["row","col"];return`
      `+qh(p,e)+`
      float `+i+`(int row, int col) {
        return `+i+"("+xd(m,s)+`);
      }
    `}if(x.shapeInfo.isUniform)return`
      float `+i+`(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(`+t[1]+`, 1)));
        `+ed(x)+`
      }
    `;const c=r[0],h=r[1],d=Fc(n);return h===1?e?`
      float `+i+`(int row, int col) {
        float index = dot(vec3(row, col, `+d+"), vec3("+n+`Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(`+n+`TexShape[0]));
        return sampleTexture(`+n+`, uv);
      }
    `:`
    float `+i+`(int row, int col) {
      float index = dot(vec3(row, col, `+d+"), vec3("+t[1]+`, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / `+c+`.0);
      return sampleTexture(`+n+`, uv);
    }
  `:c===1?e?`
      float `+i+`(int row, int col) {
        float index = dot(vec3(row, col, `+d+"), vec3("+n+`Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(`+n+`TexShape[1]), 0.5);
        return sampleTexture(`+n+`, uv);
      }
    `:`
    float `+i+`(int row, int col) {
      float index = dot(vec3(row, col, `+d+"), vec3("+t[1]+`, 1, 1));
      vec2 uv = vec2((index + 0.5) / `+h+`.0, 0.5);
      return sampleTexture(`+n+`, uv);
    }
  `:e?`
      float `+i+`(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+n+"Shape[1] + col + "+d+`;
        vec2 uv = uvFromFlat(`+n+"TexShape[0], "+n+`TexShape[1], index);
        return sampleTexture(`+n+`, uv);
      }
    `:`
  float `+i+`(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * `+t[1]+" + col + "+d+`;
    vec2 uv = uvFromFlat(`+c+", "+h+`, index);
    return sampleTexture(`+n+`, uv);
  }
`}function JX(x,e){const t=x.shapeInfo.logicalShape,n=x.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=x.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(t[0]===1){const p=t.slice(1),m=[1,2],g=td(x,p),_=["b","row","col"];return`
        `+YU(g,e)+`
        vec4 `+i+`(int b, int row, int col) {
          return `+i+"("+xd(_,m)+`);
        }
      `}const s=fi();if(e)return`
    vec4 `+i+`(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(`+n+"TexShape[0]) / 2.0), ceil(float("+n+`TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(`+n+`Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+n+`Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return `+s.texture2D+"("+n+`, uv);
    }
  `;const l=a[0],c=a[1],h=Math.ceil(t[2]/2),d=h*Math.ceil(t[1]/2);return`
    vec4 `+i+`(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        `+l+", "+c+", "+d+", "+h+`, b, row, col);
      return `+s.texture2D+"("+n+`, uv);
    }
  `}function jX(x,e){const t=x.shapeInfo.logicalShape,n=x.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[1]*t[2],a=t[2],{newShape:s,keptDims:l}=al(t),c=s;if(c.length<t.length){const _=td(x,c),v=["row","col","depth"];return`
        `+qh(_,e)+`
        float `+i+`(int row, int col, int depth) {
          return `+i+"("+xd(v,l)+`);
        }
      `}if(x.shapeInfo.isUniform)return`
      float `+i+`(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(`+r+", "+a+`, 1)));
        `+ed(x)+`
      }
    `;const h=x.shapeInfo.texShape,d=h[0],p=h[1],m=x.shapeInfo.flatOffset;if(p===r&&m==null)return e?`
      float `+i+`(int row, int col, int depth) {
        int stride1 = `+n+`Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+n+"TexShape[1], "+n+`TexShape[0]);
        return sampleTexture(`+n+`, uv);
      }
    `:`
        float `+i+`(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(`+a+`, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(`+p+".0, "+d+`.0);
          return sampleTexture(`+n+`, uv);
        }
      `;if(p===a&&m==null)return e?`
      float `+i+`(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(`+n+`Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+n+"TexShape[1], "+n+`TexShape[0]);
        return sampleTexture(`+n+`, uv);
      }
    `:`
    float `+i+`(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(`+t[1]+`, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+p+".0, "+d+`.0);
      return sampleTexture(`+n+`, uv);
    }
  `;const g=Fc(n);return e?`
    float `+i+`(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = `+n+"Shape[1] * "+n+`Shape[2];
      int stride1 = `+n+`Shape[2];
      int index = row * stride0 + col * stride1 + depth + `+g+`;
      vec2 uv = uvFromFlat(`+n+"TexShape[0], "+n+`TexShape[1], index);
      return sampleTexture(`+n+`, uv);
    }
    `:`
      float `+i+`(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * `+r+" + col * "+a+" + depth + "+g+`;
        vec2 uv = uvFromFlat(`+d+", "+p+`, index);
        return sampleTexture(`+n+`, uv);
      }
  `}function qX(x,e){const t=x.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),i=fi();if(e)return`
    vec4 `+n+`(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(`+t+`Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(`+t+`Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= `+t+`Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(`+t+"TexShape[0]) / 2.0), ceil(float("+t+`TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return `+i.texture2D+"("+t+`, uv);
    }
  `;const r=x.shapeInfo.logicalShape,a=r.length,s=x.shapeInfo.texShape,l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],c=l[0],h=l[1],d=Math.ceil(r[a-1]/2);let p=d*Math.ceil(r[a-2]/2),m="int b, int row, int col",g="b * "+p+" + (row / 2) * "+d+" + (col / 2)";for(let _=2;_<a-1;_++)m="int b"+_+", "+m,p*=r[a-_-1],g="b"+_+" * "+p+" + "+g;return`
    vec4 `+n+"("+m+`) {
      int index = `+g+`;
      int texR = index / `+h+`;
      int texC = index - texR * `+h+`;
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+h+", "+c+`);
      return `+i.texture2D+"("+t+`, uv);
    }
  `}function eY(x,e){const t=x.shapeInfo.logicalShape,n=x.name,i="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[3],a=t[2]*r,s=t[1]*a,{newShape:l,keptDims:c}=al(t);if(l.length<t.length){const T=td(x,l),E=["row","col","depth","depth2"];return`
      `+qh(T,e)+`
      float `+i+`(int row, int col, int depth, int depth2) {
        return `+i+"("+xd(E,c)+`);
      }
    `}if(x.shapeInfo.isUniform)return`
      float `+i+`(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(`+s+", "+a+", "+r+`, 1)));
        `+ed(x)+`
      }
    `;const h=x.shapeInfo.flatOffset,d=x.shapeInfo.texShape,p=d[0],m=d[1],g="int stride2 = "+n+"Shape[3];",_="int stride1 = "+n+"Shape[2] * stride2;",v="int stride0 = "+n+"Shape[1] * stride1;";if(m===s&&h==null)return e?`
      float `+i+`(int row, int col, int depth, int depth2) {
        `+g+`
        `+_+`
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+n+"TexShape[1], "+n+`TexShape[0]);
        return sampleTexture(`+n+`, uv);
      }
    `:`
      float `+i+`(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(`+a+", "+r+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+m+".0, "+p+`.0);
        return sampleTexture(`+n+`, uv);
      }
    `;if(m===r&&h==null)return e?`
      float `+i+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+n+"Shape[1] * "+n+"Shape[2], "+n+`Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+n+"TexShape[1], "+n+`TexShape[0]);
        return sampleTexture(`+n+`, uv);
      }
    `:`
      float `+i+`(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(`+t[1]*t[2]+", "+t[2]+`, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+m+".0, "+p+`.0);
        return sampleTexture(`+n+`, uv);
      }
    `;const b=Fc(n);return e?`
    float `+i+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      `+g+`
      `+_+`
      `+v+`
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(`+n+"TexShape[0], "+n+"TexShape[1], index + "+b+`);
      return sampleTexture(`+n+`, uv);
    }
  `:`
    float `+i+`(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+s+" + col * "+a+` +
          depth * `+r+` + depth2;
      vec2 uv = uvFromFlat(`+p+", "+m+", index + "+b+`);
      return sampleTexture(`+n+`, uv);
    }
  `}function tY(x){const e=x.shapeInfo.logicalShape,t=x.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],r=e[3]*i,a=e[2]*r,s=e[1]*a,{newShape:l,keptDims:c}=al(e);if(l.length<e.length){const _=td(x,l),v=["row","col","depth","depth2","depth3"];return`
      `+qh(_)+`
      float `+n+`(int row, int col, int depth, int depth2, int depth3) {
        return `+n+"("+xd(v,c)+`);
      }
    `}if(x.shapeInfo.isUniform)return`
      float `+n+`(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(`+s+", "+a+", "+r+", "+i+`)) +
          depth3;
        `+ed(x)+`
      }
    `;const h=x.shapeInfo.flatOffset,d=x.shapeInfo.texShape,p=d[0],m=d[1];if(m===s&&h==null)return`
      float `+n+`(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(`+a+", "+r+", "+i+`, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+m+".0, "+p+`.0);
        return sampleTexture(`+t+`, uv);
      }
    `;if(m===i&&h==null)return`
      float `+n+`(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(`+e[1]*e[2]*e[3]+`,
               `+e[2]*e[3]+", "+e[3]+`, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+m+".0, "+p+`.0);
        return sampleTexture(`+t+`, uv);
      }
    `;const g=Fc(t);return`
    float `+n+`(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+s+" + col * "+a+" + depth * "+r+` +
          depth2 * `+i+" + depth3 + "+g+`;
      vec2 uv = uvFromFlat(`+p+", "+m+`, index);
      return sampleTexture(`+t+`, uv);
    }
  `}function xY(x){const e=x.shapeInfo.logicalShape,t=x.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:r}=al(e);if(i.length<e.length){const v=td(x,i),b=["row","col","depth","depth2","depth3","depth4"];return`
      `+qh(v)+`
      float `+n+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return `+n+"("+xd(b,r)+`);
      }
    `}const a=e[5],s=e[4]*a,l=e[3]*s,c=e[2]*l,h=e[1]*c;if(x.shapeInfo.isUniform)return`
      float `+n+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(`+h+", "+c+", "+l+", "+s+`)) +
          dot(
            vec2(depth3, depth4),
            vec2(`+a+`, 1)));
        `+ed(x)+`
      }
    `;const d=x.shapeInfo.flatOffset,p=x.shapeInfo.texShape,m=p[0],g=p[1];if(g===h&&d==null)return`
      float `+n+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(`+c+", "+l+", "+s+", "+a+`)) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(`+g+".0, "+m+`.0);
        return sampleTexture(`+t+`, uv);
      }
    `;if(g===a&&d==null)return`
      float `+n+`(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(`+e[1]*e[2]*e[3]*e[4]+`,
               `+e[2]*e[3]*e[4]+`,
               `+e[3]*e[4]+`,
               `+e[4]+`)) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(`+g+".0, "+m+`.0);
        return sampleTexture(`+t+`, uv);
      }
    `;const _=Fc(t);return`
    float `+n+`(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * `+h+" + col * "+c+" + depth * "+l+` +
          depth2 * `+s+" + depth3 * "+a+" + depth4 + "+_+`;
      vec2 uv = uvFromFlat(`+m+", "+g+`, index);
      return sampleTexture(`+t+`, uv);
    }
  `}function ed(x){const e=x.name,t=ut(x.shapeInfo.logicalShape);return t<2?"return "+e+";":`
    for (int i = 0; i < `+t+`; i++) {
      if (i == index) {
        return `+e+`[i];
      }
    }
  `}function nY(x,e){const t=x.name,n=t.charAt(0).toUpperCase()+t.slice(1),i="get"+n+"AtOutCoords",r=x.shapeInfo.logicalShape.length,a=e.logicalShape.length,s=XU(x.shapeInfo.logicalShape,e.logicalShape),l=di(a),c=a-r;let h;const d=["x","y","z","w","u","v"];r===0?h="":a<2&&s.length>=1?h="coords = 0;":h=s.map(v=>"coords."+d[v+c]+" = 0;").join(`
`);let p="";a<2&&r>0?p="coords":p=x.shapeInfo.logicalShape.map((v,b)=>"coords."+d[b+c]).join(", ");let m="return outputValue;";const g=ut(x.shapeInfo.logicalShape)===1,_=ut(e.logicalShape)===1;if(r===1&&!g&&!_)m=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!_)a===1?m=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:m=`
        return vec4(outputValue.x);
      `;else if(s.length){const v=r-2,b=r-1;s.indexOf(v)>-1&&s.indexOf(b)>-1?m="return vec4(outputValue.x);":s.indexOf(v)>-1?m="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":s.indexOf(b)>-1&&(m="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 `+i+`() {
      `+l+` coords = getOutputCoords();
      `+h+`
      vec4 outputValue = get`+n+"("+p+`);
      `+m+`
    }
  `}function iY(x,e){const t=x.name,n=t.charAt(0).toUpperCase()+t.slice(1),i="get"+n+"AtOutCoords",r=e.texShape,a=x.shapeInfo.texShape,s=x.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!x.shapeInfo.isUniform&&s===l&&x.shapeInfo.flatOffset==null&&Zx(a,r))return`
      float `+i+`() {
        return sampleTexture(`+t+`, resultUV);
      }
    `;const c=di(l),h=XU(x.shapeInfo.logicalShape,e.logicalShape),d=l-s;let p;const m=["x","y","z","w","u","v"];s===0?p="":l<2&&h.length>=1?p="coords = 0;":p=h.map(_=>"coords."+m[_+d]+" = 0;").join(`
`);let g="";return l<2&&s>0?g="coords":g=x.shapeInfo.logicalShape.map((_,v)=>"coords."+m[v+d]).join(", "),`
    float `+i+`() {
      `+c+` coords = getOutputCoords();
      `+p+`
      return get`+n+"("+g+`);
    }
  `}function di(x){if(x<=1)return"int";if(x===2)return"ivec2";if(x===3)return"ivec3";if(x===4)return"ivec4";if(x===5)return"ivec5";if(x===6)return"ivec6";throw Error("GPU for rank "+x+" is not yet supported")}function aE(x,e,t){const{newShape:n,keptDims:i}=al(e),r=e.length,a=x&&r===3&&e[0]===1,s=a?e.slice(1):n,l=!x&&r>1&&!Zx(e,t)&&n.length<r||a;return{useSqueezeShape:l,uniformShape:l?s:e,keptDims:i}}function td(x,e){const t=JSON.parse(JSON.stringify(x));return t.shapeInfo.logicalShape=e,t}function xd(x,e){return e.map(t=>x[t]).join(", ")}function rY(x,e,t,n){const i=t.map((h,d)=>{const p={logicalShape:h.shape,texShape:h.isUniform?null:h.texData.texShape,isUniform:h.isUniform,isPacked:h.isUniform?!1:h.texData.isPacked,flatOffset:null};return h.texData!=null&&h.texData.slice!=null&&h.texData.slice.flatOffset>0&&(p.flatOffset=h.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:p}}),r=i.map(h=>h.shapeInfo),a={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},s=TX(i,a,e),l=j9(x.gl,s),c=x.createProgram(l);return Pe().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:s,webGLProgram:c,inShapeInfos:r,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(x.buildVao(c),Object.assign({program:e,fragmentShader:l,source:s,webGLProgram:c,inShapeInfos:r,outShapeInfo:a},$U(x,e,c)))}function $U(x,e,t){const n=[],i=[];let r,a,s,l=null,c=null;c=x.getUniformLocation(t,"NAN",!1),Pe().getNumber("WEBGL_VERSION")===1&&(l=x.getUniformLocation(t,"INFINITY",!1));const h=!1;for(const d of e.variableNames){const p={name:d,uniform:x.getUniformLocation(t,d,h),offset:x.getUniformLocation(t,"offset"+d,h)};e.enableShapeUniforms&&(p.shape=x.getUniformLocation(t,d+"Shape",h),p.texShape=x.getUniformLocation(t,d+"TexShape",h)),n.push(p)}if(e.enableShapeUniforms&&(r=x.getUniformLocation(t,"outShape",h),s=x.getUniformLocation(t,"outShapeStrides",h),a=x.getUniformLocation(t,"outTexShape",h)),e.customUniforms)for(const d of e.customUniforms)i.push(x.getUniformLocation(t,d.name,h));return{variablesLocations:n,customUniformLocations:i,infLoc:l,nanLoc:c,outShapeLocation:r,outShapeStridesLocation:s,outTexShapeLocation:a}}function Q3(x,e){if(x.length!==e.length)throw Error("Binary was compiled with "+x.length+" inputs, but was executed with "+e.length+" inputs");x.forEach((t,n)=>{const i=t.logicalShape,r=e[n],a=r.shape;if(!Zx(i,a))throw Error("Binary was compiled with different shapes than the current args. Shapes "+i+" and "+a+" must match");if(t.isUniform&&r.isUniform)return;const s=t.texShape,l=r.isUniform?null:r.texData.texShape;if(!Zx(s,l))throw Error("Binary was compiled with different texture shapes than the current args. Shape "+s+" and "+l+" must match")})}function aY(x,e,t,n,i){e.program.enableShapeUniforms||(Q3(e.inShapeInfos,t),Q3([e.outShapeInfo],[n]));const r=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?x.setOutputPackedMatrixTexture(r.texture,a[0],a[1]):x.setOutputMatrixTexture(r.texture,a[0],a[1]),x.setProgram(e.webGLProgram),x.bindVertexArray(e.webGLProgram.vao),Pe().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&x.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&x.gl.uniform1f(e.nanLoc,NaN);for(let l=0;l<t.length;++l){const c=t[l],{uniform:h,offset:d,shape:p,texShape:m}=e.variablesLocations[l];if(p){const{uniformShape:g}=aE(e.program.packedInputs,c.shape,c.texData.texShape);switch(g.length){case 1:x.gl.uniform1iv(p,new Int32Array(g));break;case 2:x.gl.uniform2iv(p,new Int32Array(g));break;case 3:x.gl.uniform3iv(p,new Int32Array(g));break;case 4:x.gl.uniform4iv(p,new Int32Array(g));break}}if(m&&x.gl.uniform2i(m,c.texData.texShape[0],c.texData.texShape[1]),h!=null){if(c.isUniform){if(ut(c.shape)<2)x.gl.uniform1f(h,c.uniformValues[0]);else{let g=c.uniformValues;g instanceof Float32Array||(g=new Float32Array(g)),x.gl.uniform1fv(h,g)}continue}c.texData.slice!=null&&d!=null&&x.gl.uniform1i(d,c.texData.slice.flatOffset),x.setInputMatrixTexture(c.texData.texture.texture,h,l)}}const s=e.outShapeLocation;if(s)switch(n.shape.length){case 1:x.gl.uniform1iv(s,new Int32Array(n.shape));break;case 2:x.gl.uniform2iv(s,new Int32Array(n.shape));break;case 3:x.gl.uniform3iv(s,new Int32Array(n.shape));break;case 4:x.gl.uniform4iv(s,new Int32Array(n.shape));break}if(e.outShapeStridesLocation){const l=M0(n.shape);switch(n.shape.length){case 2:x.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:x.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:x.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}if(e.outTexShapeLocation&&x.gl.uniform2i(e.outTexShapeLocation,n.texData.texShape[0],n.texData.texShape[1]),e.program.customUniforms&&i)for(let l=0;l<e.program.customUniforms.length;++l){const c=e.program.customUniforms[l],h=e.customUniformLocations[l],d=i[l];if(c.type==="float")x.gl.uniform1fv(h,d);else if(c.type==="vec2")x.gl.uniform2fv(h,d);else if(c.type==="vec3")x.gl.uniform3fv(h,d);else if(c.type==="vec4")x.gl.uniform4fv(h,d);else if(c.type==="int")x.gl.uniform1iv(h,d);else if(c.type==="ivec2")x.gl.uniform2iv(h,d);else if(c.type==="ivec3")x.gl.uniform3iv(h,d);else if(c.type==="ivec4")x.gl.uniform4iv(h,d);else throw Error("uniform type "+c.type+" is not supported yet.")}x.executeProgram()}function sY(x,e,t){let n="";e.concat(t).forEach(a=>{const s=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(x.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:c,uniformShape:h,keptDims:d}=aE(x.packedInputs,a.shape,l);let p="",m="",g="";if(h.length===1&&x.packedInputs){const M=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];p=(M[0]>1)+"_"+(M[1]>1)}else if(h.length===2&&!x.packedInputs)m=(h[0]>1)+"_"+(h[1]>1);else if(h.length>2&&!x.packedInputs){const M=M0(h);g=(M[0]===l[1])+"_"+(M[M.length-1]===l[1])}const _=a.shape.length,v=h.length===2&&Zx(a.shape,l),b=ut(a.shape)===1,T=wh(a.shape,t.shape),E=!x.packedInputs&&_===t.shape.length&&Zx(l,t.texData.texShape),A=x.packedInputs||h.length>2?"":(l[0]>1)+"_"+(l[1]>1);n+=_+"_"+E+"_"+(c?d:"")+"_"+h.length+"_"+b+"_"+T+"_"+v+"_"+p+"_"+m+"_"+g+"_"+A+"_"+s}else{const l=a.isUniform?"uniform":a.texData.texShape;n+=a.shape+"_"+l+"_"+s}});const i=x.userCode;let r=x.constructor.name;return r+="_"+n+"_"+i+(""+Pe().getNumber("WEBGL_VERSION")),r}function qn(x){return Pe().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&x<=4}class oY{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Kf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=fi();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?Fg(["r","c","d"],e):Uc(["r","c","d"],e))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        `+t.output+` = result;
      }
    `}}class lY{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Kf.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=fi();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        `+(this.enableShapeUniforms?Fg(["r","c","d"],e):Uc(["r","c","d"],e))+`
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        `+t.output+` = result;
      }
    `}}class cY{constructor(e){this.variableNames=["A"],this.outTexUsage=Nr.DOWNLOAD;const t=fi();this.outputShape=e,this.userCode=`
      `+WU+`

      void main() {
        float x = getAAtOutCoords();
        `+t.output+` = encode_float(x);
      }
    `}}class uY{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Nr.DOWNLOAD;const t=fi();this.outputShape=e,this.userCode=`
      `+WU+`

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        `+t.output+` = encode_float(x);
      }
    `}}const hY={R:0,G:1,B:2,A:3};class Z3{constructor(e,t=!1,n="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=fi();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let a="";for(let s=0;s<n.length;s++){const l=n[s];a+=`
          if(offset == `+s+`) {
            result = values[`+hY[l]+`];
          }`}this.userCode=`
      `+(this.enableShapeUniforms?rE():iE(e))+`

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, `+n.length+`);

        flatIndex = idiv(flatIndex, `+n.length+`, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = `+i.texture2D+`(A, uv);
          `+a+`
        }
        `+i.output+" = vec4("+r+`, 0., 0., 0.);
      }
    `}}class dY{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=fi();this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let i="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let s=0;s<=1;s++){const l=a*2+s;i+=`
          localCoords = coords;
          if(localCoords[2] + `+s+" < "+(this.enableShapeUniforms?"outShape[2]":""+e[2])+`) {
          localCoords[2] += `+s+`;
          if (localCoords[1] + `+a+" < "+(this.enableShapeUniforms?"outShape[1]":""+e[1])+`) {
            localCoords[1] += `+a+`;

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = `+n.texture2D+`(A, uv);

            if (offset == 0) {
              result[`+l+`] = values[0];
            } else if (offset == 1) {
              result[`+l+`] = values[1];
            } else if (offset == 2) {
              result[`+l+`] = values[2];
            } else {
              result[`+l+`] = values[3];
            }
          }
        }
        `}this.userCode=`
        `+(this.enableShapeUniforms?rE():iE(e))+`

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          `+i+`

          `+n.output+" = "+r+`;
        }
    `}}function fY(x){const e=fi(),t=e.version+`
    precision highp float;
    `+e.attribute+` vec3 clipSpacePos;
    `+e.attribute+` vec2 uv;
    `+e.varyingVs+` vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return J9(x,t)}function pY(x){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return xX(x,e)}function mY(x){const e=new Uint16Array([0,1,2,2,1,3]);return nX(x,e)}function vp(x,e,t,n,i,r){rX(e,t);const a=iX(x),s=x.TEXTURE_2D;return Nt(x,()=>x.bindTexture(s,a)),Nt(x,()=>x.texParameteri(s,x.TEXTURE_WRAP_S,x.CLAMP_TO_EDGE)),Nt(x,()=>x.texParameteri(s,x.TEXTURE_WRAP_T,x.CLAMP_TO_EDGE)),Nt(x,()=>x.texParameteri(s,x.TEXTURE_MIN_FILTER,x.NEAREST)),Nt(x,()=>x.texParameteri(s,x.TEXTURE_MAG_FILTER,x.NEAREST)),Pe().getNumber("WEBGL_VERSION")===1?Nt(x,()=>x.texImage2D(s,0,n,e,t,0,i,r,null)):Nt(x,()=>x.texStorage2D(s,1,n,e,t)),Nt(x,()=>x.bindTexture(x.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function QU(x){return x.internalFormatFloat}function yY(x,e,t,n){const[i,r]=gp(e,t);return vp(x,i,r,QU(n),n.textureFormatFloat,x.FLOAT)}function ZU(x){return x.internalFormatHalfFloat}function gY(x,e,t,n){const[i,r]=gp(e,t);return vp(x,i,r,ZU(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function JU(x){return x.downloadTextureFormat}function vY(x,e,t,n){const[i,r]=gp(e,t);return vp(x,i,r,JU(n),x.RGBA,x.UNSIGNED_BYTE)}function jU(x){return x.internalFormatPackedFloat}function bY(x,e,t,n){const[i,r]=jh(e,t);return vp(x,i,r,jU(n),x.RGBA,x.FLOAT)}function qU(x){return x.internalFormatPackedHalfFloat}function _Y(x,e,t,n){const[i,r]=jh(e,t);return vp(x,i,r,qU(n),x.RGBA,n.textureTypeHalfFloat)}function SY(x,e,t){return Nt(x,()=>x.bindBuffer(x.ARRAY_BUFFER,t)),Y3(x,e,"clipSpacePos",t,3,20,0)&&Y3(x,e,"uv",t,2,20,12)}function TY(x,e,t,n,i,r){Nt(x,()=>x.bindTexture(x.TEXTURE_2D,e));let a,s,l;i instanceof Uint8Array?(a=new Uint8Array(t*n*4),s=x.UNSIGNED_BYTE,l=x.RGBA):(a=new Float32Array(t*n*4),s=x.FLOAT,l=r.internalFormatPackedFloat),a.set(i),Pe().getNumber("WEBGL_VERSION")===2?Nt(x,()=>x.texSubImage2D(x.TEXTURE_2D,0,0,0,t,n,x.RGBA,s,a)):Nt(x,()=>x.texImage2D(x.TEXTURE_2D,0,l,t,n,0,x.RGBA,s,a)),Nt(x,()=>x.bindTexture(x.TEXTURE_2D,null))}function wY(x,e,t){Nt(x,()=>x.bindTexture(x.TEXTURE_2D,e)),t.data instanceof Uint8Array?Pe().getNumber("WEBGL_VERSION")===2?Nt(x,()=>x.texSubImage2D(x.TEXTURE_2D,0,0,0,t.width,t.height,x.RGBA,x.UNSIGNED_BYTE,t.data)):Nt(x,()=>x.texImage2D(x.TEXTURE_2D,0,x.RGBA,t.width,t.height,0,x.RGBA,x.UNSIGNED_BYTE,t.data)):Pe().getNumber("WEBGL_VERSION")===2?Nt(x,()=>x.texSubImage2D(x.TEXTURE_2D,0,0,0,x.RGBA,x.UNSIGNED_BYTE,t)):Nt(x,()=>x.texImage2D(x.TEXTURE_2D,0,x.RGBA,x.RGBA,x.UNSIGNED_BYTE,t)),Nt(x,()=>x.bindTexture(x.TEXTURE_2D,null))}function AY(x,e,t,n){const i=x.createBuffer();Nt(x,()=>x.bindBuffer(x.PIXEL_PACK_BUFFER,i));const r=4*4*e*t;return Nt(x,()=>x.bufferData(x.PIXEL_PACK_BUFFER,r,x.STREAM_READ)),Nt(x,()=>x.readPixels(0,0,t,e,x.RGBA,x.FLOAT,0)),Nt(x,()=>x.bindBuffer(x.PIXEL_PACK_BUFFER,null)),i}function EY(x,e,t){const n=x,i=new Float32Array(t);return n.bindBuffer(n.PIXEL_PACK_BUFFER,e),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,i),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),i}function MY(x,e,t,n){const[i,r]=gp(e,t),a=4,s=new Uint8Array(W9(e*t,a));return Nt(x,()=>x.readPixels(0,0,i,r,n.downloadTextureFormat,x.UNSIGNED_BYTE,s)),new Float32Array(s.buffer)}function RY(x,e,t,n,i,r,a,s){const l=x,c=new Float32Array(X9(r,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function CY(x,e,t){const n=new Float32Array(e*t*4);return Nt(x,()=>x.readPixels(0,0,t,e,x.RGBA,x.FLOAT,n)),n}class T_{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=Pe().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,V9(t,e)):this.gl=Ja(t),e=this.gl,Pe().getNumber("WEBGL_VERSION")===2){const r=e;this.createVertexArray=()=>Nt(r,()=>r.createVertexArray()),this.bindVertexArray=a=>Nt(r,()=>r.bindVertexArray(a)),this.deleteVertexArray=a=>Nt(r,()=>r.deleteVertexArray(a)),this.getVertexArray=()=>Nt(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){const r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Nt(e,()=>r.createVertexArrayOES()),this.bindVertexArray=a=>Nt(e,()=>r.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Nt(e,()=>r.deleteVertexArrayOES(a)),this.getVertexArray=()=>Nt(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let n="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),Pe().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=zm(this.gl,r),ma(this.gl,a))this.textureHalfFloatExtension=zm(this.gl,a);else if(Pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),ma(this.gl,i))this.colorBufferHalfFloatExtension=zm(this.gl,i);else if(Pe().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",ma(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(ma(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=pY(this.gl),this.indexBuffer=mY(this.gl),this.framebuffer=aX(this.gl),this.textureConfig=nE(this.gl,this.textureHalfFloatExtension)}get debug(){return Pe().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Nt(e,()=>e.finish()),Nt(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Nt(e,()=>e.deleteFramebuffer(this.framebuffer)),Nt(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Nt(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Nt(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),yY(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),gY(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),vY(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),wY(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,i){this.throwIfDisposed(),TY(this.gl,e,t,n,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),_Y(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),bY(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(K3(this.gl,this.framebuffer),this.outputTexture=null),Nt(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,()=>MY(this.gl,t,n,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,n,i,r,a){return RY(this.gl,e,t,n,i,r,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return EY(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const i=AY(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(Pe().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const a=i.clientWaitSync(r,0,0);return a===i.ALREADY_SIGNALED||a===i.CONDITION_SATISFIED},t=r}else Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,()=>CY(this.gl,t,n))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=fY(t));const n=eX(t);Nt(t,()=>t.attachShader(n,this.vertexShader)),Nt(t,()=>t.attachShader(n,e)),tX(t,n);const i=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&v_(t,i),i}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Nt(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),SY(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Nt(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&v_(this.gl,this.program),Nt(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,n=!0){return this.throwIfDisposed(),n?oX(this.gl,e,t):lX(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Nt(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),cX(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[i,r]=jh(t,n);this.setOutputMatrixTextureDriver(e,i,r)}setOutputMatrixWriteRegion(e,t,n,i){this.setOutputMatrixWriteRegionDriver(n,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,n,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&v_(this.gl,this.program),Vm(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Nt(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Nt(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=zm(this.gl,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=n.createQuery();return n.beginQuery(i.TIME_ELAPSED_EXT,r),r}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,n=this.getQueryTimerExtensionWebGL2();t.endQuery(n.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await e3(()=>this.disposed||this.isQueryAvailable(e,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const n=this.gl;return n.getQueryParameter(e,n.QUERY_RESULT)/1e6}else{const n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(e,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const n=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const n=this.getQueryTimerExtensionWebGL1(),i=n.getQueryObjectEXT(e,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=NY(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:n}=this.itemsToPoll[t];n()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in Pe().platform&&(n=Pe().platform.setTimeoutCustom.bind(Pe().platform)),e3(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),b_(this.gl,e,this.framebuffer),this.debug&&Vm(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(b_(this.gl,this.outputTexture,this.framebuffer),this.debug&&Vm(this.gl)):K3(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const i=this.gl;b_(i,e,this.framebuffer),this.debug&&Vm(i),this.outputTexture=e,Nt(i,()=>i.viewport(0,0,t,n)),Nt(i,()=>i.scissor(0,0,t,n))}setOutputMatrixWriteRegionDriver(e,t,n,i){this.throwIfDisposed(),Nt(this.gl,()=>this.gl.scissor(e,t,n,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function NY(x){let e=0;for(;e<x.length&&x[e]();++e);return e-1}function Rx(x,e){Array.isArray(x)||(x=[x]),x.forEach(t=>{t!=null&&ye(t.dtype!=="complex64",()=>e+" does not support complex64 tensors in the CPU backend.")})}function eF(x){const e=new Float32Array(x.length);for(let t=0;t<x.length;++t)e[t]=Math.abs(x[t]);return e}const IY=x=>{const{x:e}=x.inputs,t=x.backend;Rx(e,"abs");let n=new Float32Array(ut(e.shape));const i=t.data.get(e.dataId).values;return n=eF(i),t.makeOutput(n,e.shape,e.dtype)},OY={kernelName:xA,backendName:"cpu",kernelFunc:IY};function nn(x){return(e,t,n,i,r)=>{const a=tn(e,t),s=a.length,l=M0(a),c=ut(a),h=Ir(r,c),d=e.length,p=t.length,m=M0(e),g=M0(t),_=wh(e,a),v=wh(t,a);if(_.length+v.length===0)for(let b=0;b<h.length;++b)h[b]=x(n[b%n.length],i[b%i.length]);else for(let b=0;b<h.length;++b){const T=up(b,s,l),E=T.slice(-d);_.forEach(C=>E[C]=0);const A=bh(E,d,m),M=T.slice(-p);v.forEach(C=>M[C]=0);const R=bh(M,p,g);h[b]=x(n[A],i[R])}return[h,a]}}function bp(x){const{inputs:e,backend:t}=x,{real:n,imag:i}=e,r=t.data.get(n.dataId).values,a=t.data.get(i.dataId).values,s=t.makeTensorInfo(n.shape,"complex64"),l=t.data.get(s.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(n.shape,"float32",r),imag:t.makeTensorInfo(i.shape,"float32",a)},s}function N1(x,e,t="float32"){if(t==="complex64"){const i=N1(x,e,"float32"),r=N1(x,e,"float32");return bp({inputs:{real:i,imag:r},backend:x})}const n=Ms(ut(e),t);return x.makeTensorInfo(e,t,n)}function el(x){const{inputs:e,backend:t}=x,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const DY={kernelName:dg,backendName:"cpu",kernelFunc:el};function sE(x){const{inputs:e,backend:t}=x,{input:n}=e,i=t.data.get(n.dataId).complexTensorInfos.real,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}function tF(x,e,t,n){if(n==="int32"){const i=Int32Array.from(x);return[e,"int32",i]}if(n==="bool"){const i=Rg([0],t),[r,a]=nn((s,l)=>s!==l?1:0)(e,[],x,i,"bool");return[a,"bool",r]}throw new Error("Error in Cast: failed to cast "+t+" to "+n)}function Ec(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{dtype:r}=n;if(r==="complex64"){if(i.dtype==="complex64")return el({inputs:{x:i},backend:t});const h=N1(t,i.shape,i.dtype),d=Ec({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),p=bp({inputs:{real:d,imag:h},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),p}if(i.dtype==="complex64"){const h=sE({inputs:{input:i},backend:t}),d=Ec({inputs:{x:h},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(h),d}if(!JP(i.dtype,r)){const h=el({inputs:{x:i},backend:t});return{dataId:h.dataId,shape:h.shape,dtype:r}}const a=t.data.get(i.dataId).values,[s,l,c]=tF(a,i.shape,i.dtype,r);return t.makeTensorInfo(s,l,c)}const PY={kernelName:sg,backendName:"cpu",kernelFunc:Ec};function Br(x,e,t,n){return t==null?({inputs:i,backend:r})=>{const{a,b:s}=i,l=r;Rx([a,s],x);const c=l.data.get(a.dataId).values,h=l.data.get(s.dataId).values,d=a.dtype==="string"?q2(c):c,p=a.dtype==="string"?q2(h):h,m=n||a.dtype,[g,_]=e(a.shape,s.shape,d,p,m);return l.makeTensorInfo(_,m,g)}:({inputs:i,backend:r})=>{const{a,b:s}=i,l=r;if(a.dtype==="complex64"||s.dtype==="complex64"){const c=Ec({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,m=l.data.get(d.dataId).values,g=l.data.get(p.dataId).values,_=Ec({inputs:{x:s},backend:l,attrs:{dtype:"complex64"}}),v=l.data.get(_.dataId),b=v.complexTensorInfos.real,T=v.complexTensorInfos.imag,E=l.data.get(b.dataId).values,A=l.data.get(T.dataId).values,[M,R,C]=t(a.shape,s.shape,m,g,E,A),k=l.makeTensorInfo(C,"float32",M),P=l.makeTensorInfo(C,"float32",R),N=bp({inputs:{real:k,imag:P},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(_),l.disposeIntermediateTensorInfo(k),l.disposeIntermediateTensorInfo(P),N}else{const c=l.data.get(a.dataId).values,h=l.data.get(s.dataId).values,d=n||a.dtype,[p,m]=e(a.shape,s.shape,c,h,d);return l.makeTensorInfo(m,d,p)}}}function oE(x){return(e,t,n,i,r,a)=>{const s=tn(e,t),l=ut(s),c=s.length,h=M0(s),d=Ir("float32",l),p=Ir("float32",l),m=wh(e,s),g=wh(t,s),_=Mh(n,i),v=Mh(r,a),b=e.length,T=M0(e),E=t.length,A=M0(t);if(m.length+g.length===0)for(let M=0;M<d.length;M++){const R=M%_.length,C=M%v.length,k=x(_[R*2],_[R*2+1],v[C*2],v[C*2+1]);d[M]=k.real,p[M]=k.imag}else for(let M=0;M<d.length;M++){const R=up(M,c,h),C=R.slice(-b);m.forEach(te=>C[te]=0);const k=bh(C,b,T),P=R.slice(-E);g.forEach(te=>P[te]=0);const N=bh(P,E,A),G=x(_[k*2],_[k*2+1],v[N*2],v[N*2+1]);d[M]=G.real,p[M]=G.imag}return[d,p,s]}}const xF=nn((x,e)=>x+e),kY=oE((x,e,t,n)=>({real:x+t,imag:e+n})),$f=Br(hp,xF,kY),UY={kernelName:hp,backendName:"cpu",kernelFunc:$f};function FY(x,e,t,n,i){const r=ut(n),a=Ms(i,t);for(let s=0;s<x.length;s++){const l=x[s];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(r>0?a[l]+=e[s]:a[l]+=1)}return a}function BY(x,e,t,n=!1){const i=x.shape[0],r=x.shape[1],a=kx([i,t],e.dtype);for(let s=0;s<i;s++)for(let l=0;l<r;l++){const c=x.get(s,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(n?a.set(1,s,c):e.size>0?a.set(a.get(s,c)+e.get(s,l),s,c):a.set(a.get(s,c)+1,s,c))}return a}const LY=nn((x,e)=>x&e);function Os(x){return(e,t,n)=>{const i=fn(t,e.length);for(let r=0;r<e.length;++r)i[r]=x(e[r],n);return i}}function cl(x,e,t){const n=Os(e);return nF(x,n)}function nF(x,e,t){return({inputs:n,attrs:i,backend:r})=>{const{x:a}=n;Rx(a,x);const s=r,l=s.data.get(a.dataId).values;let c;if(a.dtype==="string"){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");c=q2(l)}else c=l;const h=a.dtype,d=e(c,h,i);return s.makeTensorInfo(a.shape,h,d)}}const zY=Os(x=>Math.ceil(x));function iF(x,e,t,n){const i=fn(t,ut(e));if(n&&t!=="string"){let r=0;x.forEach(a=>{const s=ut(a.shape);i.set(a.vals,r),r+=s})}else{let r=0;x.forEach(a=>{const s=t==="string"?q2(a.vals):a.vals;let l=0;for(let c=0;c<a.shape[0];++c){const h=c*e[1]+r;for(let d=0;d<a.shape[1];++d)i[h+d]=s[l++]}r+=a.shape[1]})}return i}const VY=nn((x,e)=>x===e?1:0),HY=Os(x=>Math.exp(x)),GY=Os(x=>Math.expm1(x)),rF=Os(x=>Math.floor(x)),WY=nF(ug,rF),XY={kernelName:ug,backendName:"cpu",kernelFunc:WY},YY=nn((x,e)=>Math.floor(x/e));function KY(x,e,t,n,i,r,a,s,l){const c=kx([n,r],t);for(let h=0;h<n;h++){const d=[];let p=0;for(let m=0;m<i;m++){const g=x[h*i+m];p+=g*a[m],d.push(g)}if(p<0||p>=l/r)throw new Error("Invalid indices: "+d+" does not index into "+s);for(let m=0;m<r;m++)c.values[h*r+m]=e.get(...e.indexToLoc(p*r+m))}return c}function aF(x,e,t){const n=kx(t,x.dtype);for(let i=0;i<n.size;++i){const r=n.indexToLoc(i).slice(),a=r[0],s=r[2],l=e.locToIndex([a,s]);r[2]=e.values[l];const c=x.locToIndex(r);0<=c&&c<x.values.length&&(n.values[i]=x.values[c])}return n}const $Y=nn((x,e)=>x>e?1:0),sF=nn((x,e)=>x>=e?1:0),QY=Br(hg,sF,null,"bool"),ZY={kernelName:hg,backendName:"cpu",kernelFunc:QY},oF=nn((x,e)=>x<e?1:0),JY=Br(pA,oF,null,"bool"),jY={kernelName:pA,backendName:"cpu",kernelFunc:JY},lF=nn((x,e)=>x<=e?1:0),qY=Br(fg,lF,null,"bool"),eK={kernelName:fg,backendName:"cpu",kernelFunc:qY};function tK(x,e,t){const n=(e-x)/(t-1),i=Ms(t,"float32");i[0]=x;for(let r=1;r<i.length;r++)i[r]=i[r-1]+n;return i}const xK=Os(x=>Math.log(x));function cF(x,e,t,n){const i=Ir(n,ut(t));for(let r=0;r<i.length;++r){const a=r*e;let s=x[a];for(let l=0;l<e;++l){const c=x[a+l];(Number.isNaN(c)||c>s)&&(s=c)}i[r]=s}return i}const uF=nn((x,e)=>Math.max(x,e)),nK=Br(mg,uF),iK={kernelName:mg,backendName:"cpu",kernelFunc:nK},hF=nn((x,e)=>Math.min(x,e)),rK=Br(yg,hF),aK={kernelName:yg,backendName:"cpu",kernelFunc:rK},lE=nn((x,e)=>x*e),sK=oE((x,e,t,n)=>({real:x*t-e*n,imag:x*n+e*t})),oK=Br(gg,lE,sK),lK={kernelName:gg,backendName:"cpu",kernelFunc:oK};function dF(x,e,t){const n=dp(-1,t);return lE([],e,n,x,t)}function cK(x){const{inputs:e,backend:t}=x,{x:n}=e;Rx(n,"neg");const i=t.data.get(n.dataId).values,[r,a]=dF(i,n.shape,n.dtype);return t.makeTensorInfo(a,n.dtype,r)}const uK={kernelName:_A,backendName:"cpu",kernelFunc:cK},hK=nn((x,e)=>x!==e?1:0);function cE(x,e,t,n,i){const r=e.length,a=ut(e),s=M0(e),l=M0(i),c=Ir(t,ut(i));for(let h=0;h<a;++h){const d=up(h,r,s),p=new Array(d.length);for(let g=0;g<p.length;g++)p[g]=d[n[g]];const m=bh(p,r,l);c[m]=x[h]}return c}function uE(x){const{inputs:e,attrs:t,backend:n}=x,{x:i}=e,{perm:r}=t;Rx(i,"transpose");const a=i.shape.length,s=new Array(a);for(let h=0;h<s.length;h++)s[h]=i.shape[r[h]];const l=n.data.get(i.dataId).values,c=cE(l,i.shape,i.dtype,r,s);return{dataId:n.write(c,s,i.dtype),shape:s,dtype:i.dtype}}const dK={kernelName:Df,backendName:"cpu",kernelFunc:uE};function fK(x,e,t,n){const[i,r]=Is(x,n),a=Rs(e,"int32"),s=Ms(ut(i),a),l=ut(r);for(let c=0;c<s.length;++c){const h=c*l;let d=1;for(let p=0;p<l;++p)d*=t[h+p];s[c]=d}return{outVals:s,outShape:i,outDtype:a}}function pK(x,e,t){x.forEach((n,i)=>{if(n<0||n>=t){const r=up(i,e.length,M0(e)).join(",");throw new Error("indices["+r+"] = "+n+" is not in [0, "+t+")")}})}function mK(x,e){for(let t=0;t<x.length;++t){const n=x[t],i=t===x.length-1?e:x[t+1].length;if(n.length===0)throw new Error("Ragged splits may not be empty");if(n[0]<0)throw new Error("Ragged splits must be non-negative");if(n[n.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<n.length;++r)if(n[r-1]>n[r])throw new Error("Ragged splits must be sorted in ascending order")}}function yK(x,e,t,n){const i=[];let r=0;const a=e.length-1+t.length,s=new Array(a).fill(null).map(()=>[0]);mK(t,n);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const h=e[c+1];for(let d=1;d<l+1;++d)s[c].push(d*h)}for(let c=0;c<x.length;++c){let h=x[c],d=x[c]+1;for(let p=0;p<t.length;++p){const m=t[p],g=p+e.length-1;if(g>=0){const _=s[g],v=_[_.length-1]-m[h];for(let b=h;b<d;++b)s[g].push(m[b+1]+v)}h=m[h],d=m[d]}d!==h&&(i.push([h,d]),r+=d-h)}return{outSplits:s,valueSlices:i,numValues:r}}function gK(x){const e=[];for(let t=0;t<x.length;++t){const n=x[t].length,i=fn("int32",n);e.push(i),x[t].forEach((r,a)=>i[a]=r)}return e}function J3(x,e){const t=x.slice(0,e);for(;t.length<e;)t.push(1);for(let n=e;n<x.length;n++)t[e-1]*=x[n];return t}function vK(x,e,t,n,i,r){const a=J3(e,2)[1],s=J3(r,2)[1];let l=0;for(const c of t)for(let h=c[0];h<c[1];++h){for(let d=0;d<n;++d)i[l*s+d]=x[h*a+d];++l}}function bK(x,e,t,n,i){const r=e.slice();r[0]=i;const a=fn(t,ut(r)),s=x.length,l=s===0?0:s/e[0];return vK(x,e,n,l,a,r),[a,r]}function _K(x,e,t,n,i,r,a,s){if(x.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(pK(r,a,l),n.length===0)throw new Error("params.rank must be nonzero");const c=n[0],{outSplits:h,valueSlices:d,numValues:p}=yK(r,a,x,c),m=gK(h),g=bK(t,n,i,d,p);return[m,g[0],g[1]]}const j3=2147483647;function SK(x,e,t,n,i,r,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const s=e.length===0,l=i.length===0,c=a.length===0,h=[];s||h.push(e[0]),l||h.push(i[0]),c||h.push(a[0]);for(let v=1;v<h.length;++v)if(h[v]!==h[v-1])throw new Error("starts, limits, and deltas must have the same shape");const d=h.length===0?1:h[0],p=fn("int32",d+1);p[0]=0;for(let v=0;v<d;++v){const b=s?x[0]:x[v],T=l?n[0]:n[v],E=c?r[0]:r[v];if(E===0)throw new Error("Requires delta != 0");let A;if(E>0&&T<b||E<0&&T>b)A=0;else if(A=Math.ceil(Math.abs((T-b)/E)),A>j3)throw new Error("Requires ((limit - start) / delta) <= "+j3);p[v+1]=p[v]+A}const m=p[d],g=fn(t,m);let _=0;for(let v=0;v<d;++v){const b=p[v+1]-p[v];let T=s?x[0]:x[v];const E=c?r[0]:r[v];for(let A=0;A<b;++A)g[_++]=T,T+=E}return[p,g]}var xa=Ha;class I1{constructor(e,t,n,i,r,a,s,l,c,h){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=i,this.valuesDType=r,this.defaultValue=a,this.defaultValueShape=s,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=TU(h),this.raggedRank=wU(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===xa.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===xa.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case xa.VALUE_ROWIDS:return I1.getMaxWidthValueRowID(t);case xa.ROW_SPLITS:return I1.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type "+xa[this.getRowPartitionTypeByDimension(e-1)])}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let n=0;for(let i=0;i<t-1;++i){const r=e[i+1]-e[i];r>n&&(n=r)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let n=0,i=e[0],r=0;for(let a=1;a<t;++a){const s=e[a];s!==i&&(i=s,r=Math.max(a-n,r),n=a)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t,n=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return eI(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;AU(n,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=SU(this.raggedRank,i,t);r[0]<0&&(r[0]=e);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(e,t,n){const i=Math.min(e,n),r=[];let a=0;for(let s=0;s<i;++s,a+=t)r.push(a);for(let s=i;s<e;++s)r.push(-1);return ye(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,n,i){const r=e.length,a=[];for(let s=0;s<r-1;++s){const l=e[s+1]-e[s];let c=Math.min(i,l),h=t[s];h===-1&&(c=0);for(let d=0;d<c;++d)a.push(h),h+=n;for(let d=0;d<l-c;++d)a.push(-1)}if(r>0&&a.length!==e[r-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,n,i){const r=e.length,a=[];if(r===0)return[];let s=0,l=e[0];if(l>=t.length)throw new Error("Got currentValueRowId="+l+", which is not less than "+t.length);let c=t[l];a.push(c);for(let h=1;h<r;++h){const d=e[h];if(d===l)c>=0&&(++s,s<i?c+=n:c=-1);else{if(s=0,l=d,d>=t.length)throw new Error("Got nextValueRowId="+d+" which is not less than "+t.length);c=t[d]}a.push(c)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,n,i){const r=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case xa.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,i);case xa.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: "+(r.length-1)+" > "+t.length);return this.calculateOutputIndexRowSplit(r,t,n,i);default:throw new Error("Unsupported partition type: "+xa[a])}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case xa.FIRST_DIM_SIZE:return e[0];case xa.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case xa.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+xa[t])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let a=n.length-2;a>=0;--a)n[a]=n[a+1]*t[a+1];const i=eI(t,!1),r=fn(this.valuesDType,ut(i));if(n[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let s=1;s<=this.raggedRank;++s)a=this.calculateOutputIndex(s-1,a,n[s],t[s]);this.setOutput(this.raggedRank,a,r,i)}return[i,r]}setOutput(e,t,n,i){if(n.length===0)return;const r=this.values,a=n;let s=i.slice();s=s.slice(e+1);const l=ut(s),c=t.length;let h=this.defaultValue;if(h.length!==l&&h.length!==1){const g=this.defaultValueShape;hi(()=>{const _=x0(h,g);h=qy(_,s).dataSync()})}let d=0,p=0,m=0;for(let g=0;g<=c;++g){let _=g<c?t[g]:-1;if(_===m){++m;continue}if(p<m){const v=r.subarray(d*l),b=a.subarray(p*l),T=(m-p)*l;q3(b,v,T)}if(g>=c){const v=n.length;_=Math.floor(v/l)}if(_>m)if(this.defaultValue.length===1)a.subarray(m*l,_*l).fill(this.defaultValue[0]),m=_;else for(;_>m;){const v=a.slice(m*l);q3(v,h,l),++m}_<0?(d=g+1,p=m):(d=g,p=m,m=p+1)}}}function q3(x,e,t){for(let n=0;n<t;n++)x[n]=e[n]}function eI(x,e){const t=[];for(let n of x){if(n<0){if(!e)throw new Error("Dimension "+n+" must be >= 0");if(n<-1)throw new Error("Dimension "+n+" must be >= -1");n=-1}t.push(n)}return t}function TK(x,e,t,n,i,r,a,s,l,c){return new I1(x,e,t,n,i,r,a,s,l,c).compute()}function fF(x,e,t,n){const i=x===e,r=x<e&&t<0,a=e<x&&t>1;if(i||r||a)return Ms(0,n);const s=Math.abs(Math.ceil((e-x)/t)),l=Ms(s,n);e<x&&t===1&&(t=-1),l[0]=x;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}const wK=Os(x=>1/Math.sqrt(x));function AK(x,e,t,n,i,r,a,s,l,c){const h=[n/i,i],d=x.values,p=e.values;if(n===0)return kx(t,e.dtype);const m=l instanceof vc?l:kx(h,e.dtype);typeof l=="string"||typeof l=="number"?m.values.fill(l):typeof l=="boolean"&&m.values.fill(+l);for(let g=0;g<r;g++){const _=[];let v=0;for(let b=0;b<a;b++){const T=d[g*a+b];_.push(T),v+=T*s[b]}if(v<0||v>=n/i)throw new Error("Invalid indices: "+_+" does not index into "+t);for(let b=0;b<i;b++)c?m.values[v*i+b]+=p[g*i+b]:m.values[v*i+b]=e.rank===0?p[0]:p[g*i+b]}return m}const EK=Os(x=>1/(1+Math.exp(-x))),pF=cl(Tg,x=>1/(1+Math.exp(-x))),MK={kernelName:Tg,backendName:"cpu",kernelFunc:pF};function mF(x,e,t,n,i){const r=HA(n,e,t),a=ut(t),s=M0(n);if(r){const d=GA(e,s);return i==="string"?x.slice(d,d+a):x.subarray(d,d+a)}const l=i==="string"?q2(x):x,c=kx(n,i,l),h=kx(t,i);for(let d=0;d<h.size;++d){const p=h.indexToLoc(d),m=p.map((g,_)=>g+e[_]);h.set(c.get(...m),...p)}return i==="string"?BU(h.values):h.values}function yF(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{begin:r,size:a}=n;Rx(i,"slice");const[s,l]=WA(i,r,a);zA(i,s,l);const c=t.data.get(i.dataId).values,h=mF(c,s,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,h)}const RK={kernelName:RA,backendName:"cpu",kernelFunc:yF};function CK(x,e,t,n,i,r,a){const s=e[0],l=r[0],c=new Array(l),h=new Array(s),d=e[1];if(l===0){if(s!==0)throw new Error(MU(s));const v=fn(t,0),b=fn(i,0);return[v,[0,d],b,c,h]}let p=!0,m=0;const g=new Array(l).fill(0);for(let v=0;v<s;++v){const b=x[v*d];if(b<0)throw new Error(RU(v,b));if(b>=l)throw new Error(CU(v,b,l));++g[b],p=p&&b>=m,m=b}let _=!0;for(let v=0;v<l;++v){const b=g[v]===0;c[v]=b,_=_&&!b,g[v]=Math.max(g[v],1),v>0&&(g[v]+=g[v-1])}if(_&&p){const v=x,b=n;for(let T=0;T<s;++T)h[T]=T;return[v,[s,d],b,c,h]}else{const v=g[l-1],b=fn(t,v*d),T=fn(i,v),E=new Array(l).fill(0);for(let A=0;A<s;++A){const M=x[A*d],R=E[M],C=(M===0?0:g[M-1])+R;E[M]++;for(let k=0;k<d;++k)b[C*d+k]=x[A*d+k];T[C]=n[A],h[A]=C}for(let A=0;A<l;++A)if(E[A]===0){const M=A===0?0:g[A-1];b[M*d+0]=A;for(let R=1;R<d;++R)b[M*d+R]=0;T[M]=a}return[b,[v,d],T,c,h]}}function NK(x,e,t,n,i){const r=ut(n),a=e[0],s=i.length,l=[];let c=1,h=-1;for(let _=0;_<s;++_){const v=i[_];if(v===-1){if(h!==-1)throw new Error(NU(h,_));h=_,l.push(1)}else{if(v<0)throw new Error(IU(_,v));c*=v,l.push(v)}}if(h!==-1){if(c<=0)throw new Error(OU());const _=Math.trunc(r/c);if(c*_!==r)throw new Error(DU(n,l));l[h]=_}if(ut(l)!==r)throw new Error(PU(n,l));const d=n.length,p=[];if(d>0){p[d-1]=1;for(let _=d-2;_>=0;--_)p[_]=p[_+1]*n[_+1]}const m=[];if(s>0){m[s-1]=1;for(let _=s-2;_>=0;--_)m[_]=m[_+1]*l[_+1]}const g=fn(t,a*s);for(let _=0;_<a;++_){let v=0;for(let b=0;b<d;++b)v+=x[_*d+b]*p[b];for(let b=0;b<s;++b)g[_*s+b]=Math.trunc(v/m[b]),v%=m[b]}return[g,[a,s],l]}function IK(x,e,t,n,i,r=!1,a=0){const s=n.length,l=[e[0],x.length/e[0]],c=l[1],h=s>0?i[s-1]+1:0;if(h<0)throw new Error(fT());const d=e.slice();d[0]=h;const p=d.reduce((T,E)=>T*E,1),m=fn(t,p);if(s===0)return h>0&&m.fill(a),[m,d];if(h<=0)throw new Error(fT());let g=0,_=1,v=0,b=i[g];for(;;){let T=0;if(_<s){if(T=i[_],b===T){++_;continue}if(b>=T)throw new Error(kU())}if(b<0||b>=h)throw new Error(UU(b,h));b>v&&m.fill(a,v*c,b*c);for(let E=g;E<_;++E){const A=n[E];if(A<0||A>=l[0])throw new Error(FU(E,n[E],l[0]));for(let M=0;M<c;M++)m[b*c+M]+=x[A*c+M]}if(r)for(let E=0;E<c;E++)m[b*c+E]/=_-g;if(g=_,++_,v=b+1,b=T,_>s)break}return v<h&&m.fill(a,v*c,h*c),[m,d]}const OK=Os(x=>Math.sqrt(x)),DK=cl(wg,x=>Math.sqrt(x)),PK={kernelName:wg,backendName:"cpu",kernelFunc:DK},kK=nn((x,e)=>{const t=x-e;return t*t}),UK=Os((x,e)=>{const{pattern:t,replaceGlobal:n,rewrite:i}=e;return x.replace(new RegExp(t,n?"g":""),i)});function gF(x,e,t,n){const i=kx(x,e.dtype);for(let r=0;r<i.size;r++){const a=i.indexToLoc(r),s=new Array(a.length);for(let l=0;l<s.length;l++)s[l]=a[l]*t[l]+n[l];i.set(e.get(...s),...a)}return i}class FK{constructor(e,t,n,i,r,a){this.separator=X2(e),this.nGramWidths=t,this.leftPad=X2(n),this.rightPad=X2(i),this.padWidth=r,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,i,r,a){for(let s=0;s<r;++s){const l=this.getPadWidth(a),c=Math.max(0,l-s),h=Math.max(0,l-(r-(s+1))),d=a-(c+h),p=t+(c>0?0:s-l);let m=0;m+=c*this.leftPad.length;for(let T=0;T<d;++T)m+=e[p+T].length;m+=h*this.rightPad.length;const g=c+h+d-1;m+=g*this.separator.length,n[i+s]=new Uint8Array(m);const _=n[i+s];let v=0;const b=T=>T.forEach(E=>_[v++]=E);for(let T=0;T<c;++T)b(this.leftPad),b(this.separator);for(let T=0;T<d-1;++T)b(e[p+T]),b(this.separator);if(d>0){b(e[p+d-1]);for(let T=0;T<h;++T)b(this.separator),b(this.rightPad)}else{for(let T=0;T<h-1;++T)b(this.rightPad),b(this.separator);b(this.rightPad)}}}compute(e,t){const n=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error("First split value must be 0, got "+l);for(let c=1;c<i;++c){let h=t[c]>=l;if(h=h&&t[c]<=n,!h)throw new Error("Invalid split value "+t[c]+", must be in ["+l+", "+n+"]");l=t[c]}if(l!==n)throw new Error("Last split value must be data size. Expected "+n+", got "+l)}const r=i-1,a=fn("int32",i);if(n===0||i===0){const l=new Array(n);for(let c=0;c<=r;++c)a[c]=0;return[l,a]}a[0]=0;for(let l=1;l<=r;++l){const c=t[l]-t[l-1];let h=0;this.nGramWidths.forEach(d=>{h+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&h===0&&(h=1),a[l]=a[l-1]+h}const s=new Array(a[r]);for(let l=0;l<r;++l){const c=t[l];let h=a[l];if(this.nGramWidths.forEach(d=>{const p=t[l+1]-t[l],m=this.getNumNGrams(p,d);this.createNGrams(e,c,s,h,m,d),h+=m}),this.preserveShort&&h===a[l]){const d=t[l+1]-t[l];if(d===0)continue;const p=d+2*this.padWidth;this.createNGrams(e,c,s,h,1,p)}}return[s,a]}}function BK(x,e,t,n,i,r,a,s){return new FK(t,n,i,r,a,s).compute(x,e)}function LK(x,e,t,n){if(!x.length)return;if(e.length===0){for(let r=0;r<x.length;++r)n.push(x.subarray(r,r+1));return}if(e.length===1){const r=e[0];let a=x.indexOf(r);for(;a!==-1;){const s=x.subarray(0,a);(!t||s.length!==0)&&n.push(s),x=x.subarray(a+1),a=x.indexOf(r)}(!t||x.length!==0)&&n.push(x);return}let i=0;for(let r=0;r<x.length+1;r++)if(r===x.length||e.indexOf(x[r])!==-1){const a=x.subarray(i,r);(!t||a.length!==0)&&n.push(a),i=r+1}}function zK(x,e,t){const n=x.length,i=[];let r=0,a=0;const s=new Array(n);for(let p=0;p<n;++p){const m=i.length;LK(x[p],e,t,i);const g=i.length-m;s[p]=g,r+=g,a=Math.max(a,g)}const l=fn("int32",r*2),c=new Array(r),h=[n,a];let d=0;for(let p=0;p<n;++p)for(let m=0;m<s[p];++m)l[d*2]=p,l[d*2+1]=m,c[d]=i[d],++d;return[l,c,h]}function VK(x,e){const t=fn("int32",x.length);for(let n=0;n<x.length;++n)t[n]=CV(x[n]).modulo(e).getLowBitsUnsigned();return t}const vF=nn((x,e)=>x-e),HK=oE((x,e,t,n)=>({real:x-t,imag:e-n})),GK=Br(Ag,vF,HK),WK={kernelName:Ag,backendName:"cpu",kernelFunc:GK};function bF(x,e){const t=new Array(x.rank);for(let i=0;i<t.length;i++)t[i]=x.shape[i]*e[i];const n=kx(t,x.dtype);for(let i=0;i<n.values.length;++i){const r=n.indexToLoc(i),a=new Array(x.rank);for(let l=0;l<a.length;l++)a[l]=r[l]%x.shape[l];const s=x.locToIndex(a);n.values[i]=x.values[s]}return n}const Mf=(x,e)=>{const t=e.value-x.value;return t===0?x.index-e.index:t};function _F(x,e,t=0,n=x.length-1){for(;n>t;){if(n-t>600){const s=n-t+1,l=e-t+1,c=Math.log(s),h=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*h*(s-h)/s)*Math.sign(l-s/2),p=Math.max(t,Math.floor(e-l*h/s+d)),m=Math.min(n,Math.floor(e+(s-l)*h/s+d));_F(x,e,p,m)}const i=x[e];let r=t,a=n;for(nf(x,t,e),Mf(x[n],i)>0&&nf(x,t,n);r<a;){for(nf(x,r,a),r++,a--;Mf(x[r],i)<0;)r=r+1;for(;Mf(x[a],i)>0;)a=a-1}Mf(x[t],i)===0?nf(x,t,a):(a=a+1,nf(x,a,n)),a<=e&&(t=a+1),e<=a&&(n=a-1)}}function XK(x,e,t,n,i){const r=e[e.length-1],[a,s]=[x.length/r,r],l=Ir(t,a*n),c=Ir("int32",a*n);for(let d=0;d<a;d++){const p=d*s,m=x.subarray(p,p+s);let g=new Array(m.length);m.forEach((T,E)=>g[E]={value:T,index:E}),n<g.length&&(_F(g,n),g=g.slice(0,n)),i&&g.sort(Mf);const _=d*n,v=l.subarray(_,_+n),b=c.subarray(_,_+n);for(let T=0;T<n;T++)v[T]=g[T].value,b[T]=g[T].index}const h=e.slice();return h[h.length-1]=n,[kx(h,t,l),kx(h,"int32",c)]}function YK(x,e,t,n){const i=Ri(e,t)[0],r=[1,t[0],1];for(let g=0;g<i;g++)r[0]*=t[g];r[1]=t[i];for(let g=i+1;g<t.length;g++)r[2]*=t[g];const a=new Map,s=new Int32Array(t[i]),l=new vc(r,n,x),c=[],h=r[0]===1&&r[2]===1;for(let g=0;g<t[i];g++){let _;if(h)_=x[g].toString();else{const b=[];for(let T=0;T<r[0];T++)for(let E=0;E<r[2];E++)b.push(l.get(T,g,E));_=b.join(",")}const v=a.get(_);if(v!=null)s[g]=v;else{const b=a.size;a.set(_,b),s[g]=b,c.push(g)}}const d=r.slice();d[1]=a.size;const p=new vc(d,n);c.forEach((g,_)=>{for(let v=0;v<r[0];v++)for(let b=0;b<r[2];b++)p.set(l.get(v,g,b),v,_,b)});const m=t.slice();return m[i]=d[1],{outputValues:p.values,outputShape:m,indices:s}}var KK=Object.freeze({__proto__:null,addImpl:xF,bincountImpl:FY,bincountReduceImpl:BY,bitwiseAndImpl:LY,castImpl:tF,ceilImpl:zY,concatImpl:iF,equalImpl:VY,expImpl:HY,expm1Impl:GY,floorDivImpl:YY,floorImpl:rF,gatherNdImpl:KY,gatherV2Impl:aF,greaterEqualImpl:sF,greaterImpl:$Y,lessEqualImpl:lF,lessImpl:oF,linSpaceImpl:tK,logImpl:xK,maxImpl:cF,maximumImpl:uF,minimumImpl:hF,multiplyImpl:lE,negImpl:dF,notEqualImpl:hK,prodImpl:fK,raggedGatherImpl:_K,raggedRangeImpl:SK,raggedTensorToTensorImpl:TK,rangeImpl:fF,rsqrtImpl:wK,scatterImpl:AK,sigmoidImpl:EK,simpleAbsImpl:eF,sliceImpl:mF,sparseFillEmptyRowsImpl:CK,sparseReshapeImpl:NK,sparseSegmentReductionImpl:IK,sqrtImpl:OK,squaredDifferenceImpl:kK,staticRegexReplaceImpl:UK,stridedSliceImpl:gF,stringNGramsImpl:BK,stringSplitImpl:zK,stringToHashBucketFastImpl:VK,subImpl:vF,tileImpl:bF,topKImpl:XK,transposeImpl:cE,uniqueImpl:YK});const{addImpl:$K,bincountImpl:Xle,bincountReduceImpl:Yle,bitwiseAndImpl:Kle,castImpl:QK,ceilImpl:$le,concatImpl:ZK,equalImpl:Qle,expImpl:Zle,expm1Impl:Jle,floorImpl:JK,gatherNdImpl:jle,gatherV2Impl:jK,greaterImpl:qle,greaterEqualImpl:qK,lessImpl:e$,lessEqualImpl:t$,linSpaceImpl:ece,logImpl:tce,maxImpl:x$,maximumImpl:n$,minimumImpl:i$,multiplyImpl:r$,negImpl:a$,notEqualImpl:s$,prodImpl:xce,raggedGatherImpl:nce,raggedRangeImpl:ice,raggedTensorToTensorImpl:rce,rangeImpl:o$,rsqrtImpl:ace,scatterImpl:sce,sigmoidImpl:l$,simpleAbsImpl:SF,sliceImpl:c$,sparseFillEmptyRowsImpl:oce,sparseReshapeImpl:lce,sparseSegmentReductionImpl:cce,sqrtImpl:u$,staticRegexReplaceImpl:uce,stridedSliceImpl:h$,stringNGramsImpl:hce,stringSplitImpl:dce,stringToHashBucketFastImpl:fce,subImpl:d$,tileImpl:f$,topKImpl:pce,transposeImpl:hE,uniqueImpl:mce}=KK;function TF(x,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>x+"."+t)}function tl(x,e){return e===1?[x]:TF(x,e)}function p$(x,e){if(x===1)return"rc";let t="";for(let n=0;n<x;n++)t+=e[n],n<x-1&&(t+=",");return t}class m${constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=qn(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=tl("rc",this.rank),n=di(this.rank),i=this.getOutOfBoundsCondition(t),r=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          `+n+` rc = getOutputCoords();

          if(`+i+`) {
            setOutput(vec4(0));
          } else {
            `+r+`

            setOutput(vec4(`+a+`));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let i=0;i<=1;i++){let r=(n===0?"r":"rp1")+", "+(i===0?"c":"cp1");for(let a=2;a<this.rank;a++)r=e[e.length-1-a]+","+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return"rc > "+(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+=e[n]+" >= "+(this.enableShapeUniforms?"outShape["+n+"]":this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape["+this.rank+" - 1]":this.outputShape[this.rank-1],i=this.enableShapeUniforms?"outShape["+this.rank+" - 2]":this.outputShape[this.rank-2];return`
      int r = `+t[0]+`;
      int c = `+t[1]+`;
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= `+n+`;
      bool rEdge = rp1 >= `+i+`;
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?"getA(rc), (rc + 1 >= "+(this.enableShapeUniforms?"outShape":this.outputShape[0])+" ? 0. : getA(rc + 1)), 0, 0":"getA("+t[0]+`),
            cEdge ? 0. : getA(`+t[1]+`),
            rEdge ? 0. : getA(`+t[2]+`),
            rEdge || cEdge ? 0. : getA(`+t[3]+")"}}class wF{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);let n="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),n+=`
        `+r+`
        `+(i>0?"if(thisRC.y < rows && thisRC.z < cols){":"")+`
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[`+i+`] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        `+(i>0?"}":"")+`
      `}this.userCode=`
      `+y$(t,this.enableShapeUniforms)+`
      `+(this.enableShapeUniforms?rE():iE(e))+`

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = `+(this.enableShapeUniforms?"outShape[1]":e[1])+`;
        int cols = `+(this.enableShapeUniforms?"outShape[2]":e[2])+`;

        `+n+`

        setOutput(result);
      }
    `}}function y$(x,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      `+(e?SX(["r","c","d"],"inputShape"):Uc(["r","c","d"],x))+`
      return ivec3(r, c, d);
    }
  `}class g${constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const i=xI(t,n),r=nI(e,i,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const a=tI(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[r].pop();return this.usedTextures[r].push(l),l}let s;return i===Vn.PACKED_2X2_FLOAT32?s=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===Vn.PACKED_2X2_FLOAT16?s=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===Vn.UNPACKED_FLOAT32?s=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===Vn.UNPACKED_FLOAT16?s=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===Vn.PACKED_4X1_UNSIGNED_BYTE&&(s=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(s),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),s}releaseTexture(e,t,n,i){if(this.freeTextures==null)return;const r=xI(n,i),a=nI(t,r,i);a in this.freeTextures||(this.freeTextures[a]=[]);const s=tI(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=Pe().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=s):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=s),this.numUsedTextures--;const c=this.usedTextures[a],h=c&&c.indexOf(e);if(h==null||h<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[h]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",this.numFreeTextures+" / "+this.numUsedTextures,"("+e+")");const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: "+this._numBytesAllocated),console.log("Bytes unused: "+this._numBytesFree+" ("+Math.round(100*t)+"%)")}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function v$(x,e){const t=x;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F||e===x.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error("Unknown internal format "+e)}function tI(x,e,t,n,i){const r=b$(e,n);let a;if(i){const[l,c]=jh(x[0],x[1]);a=l*c}else{const[l,c]=gp(x[0],x[1]);a=l*c}const s=v$(t,r);return a*s}function b$(x,e){switch(x){case Vn.PACKED_2X2_FLOAT32:return jU(e);case Vn.PACKED_2X2_FLOAT16:return qU(e);case Vn.UNPACKED_FLOAT32:return QU(e);case Vn.UNPACKED_FLOAT16:return ZU(e);case Vn.PACKED_4X1_UNSIGNED_BYTE:return JU(e);default:throw new Error("Unknown physical texture type "+x)}}function _$(x){return Pe().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?x?Vn.PACKED_2X2_FLOAT32:Vn.UNPACKED_FLOAT32:x?Vn.PACKED_2X2_FLOAT16:Vn.UNPACKED_FLOAT16}function xI(x,e){if(x===Nr.UPLOAD)return Vn.PACKED_2X2_FLOAT32;if(x===Nr.RENDER||x==null)return _$(e);if(x===Nr.DOWNLOAD||x===Nr.PIXELS)return Vn.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type "+x)}function nI(x,e,t){return x[0]+"_"+x[1]+"_"+e+"_"+t}class No{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        `+t+`
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const _p="if (isnan(x)) return x;",S$="return x;",iI="return abs(x);",T$="return (x >= 0.0) ? x : (exp(x) - 1.0);",w$=_p+`
  return (x < 0.0) ? 0.0 : x;
`,A$=_p+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,U2="return x;",E$="return 1.0 / (1.0 + exp(-1.0 * x));",M$="return x;",R$=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,C$=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,N$=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,I$="return 1.0 / (1.0 + exp(-1.0 * x));";class H2{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        `+t+`
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}class O${constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);const t=e.length,n=tl("rc",t),i=di(t),r=p$(t,n),a=n.slice(-2),s=t<=1?"rc":"vec2("+a.join(",")+")";this.userCode=`
      void main() {
        `+i+` rc = getOutputCoords();
        vec4 packedInput = getA(`+r+`);

        setOutput(getChannel(packedInput, `+s+`));
      }
    `}}const D$=bU,P$=1e-7,k$=1e-4,w_={};function U$(x){return x in w_||(w_[x]={}),w_[x]}const F$=Pe().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),B$=600;function L$(){return Pe().global.screen==null?1024:Pe().global.screen.height*Pe().global.screen.width*window.devicePixelRatio*B$/1024/1024}class Sp extends Jw{nextDataId(){return Sp.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!Pe().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof T_)t=e;else{const n=Ja(Pe().getNumber("WEBGL_VERSION"),e);t=new T_(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const n=Ja(Pe().getNumber("WEBGL_VERSION"));t=new T_(n),this.binaryCache=U$(Pe().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new g$(this.gpgpu),this.numMBBeforeWarning=L$(),this.texData=new QP(this,ua())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,i,r,a){const s=this.makeTensorInfo(t,n),l=this.texData.get(s.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,r]},l.texShape=[i,r];const c=Hm(t),h=new Z3(c,!1,a),d=this.runWebGLProgram(h,[s],n,[[i,r]]);return d.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(s),d.dataId}write(e,t,n){if((Pe().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||Pe().getBool("DEBUG"))&&this.checkNumericalProblems(e),n==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:n,values:e,usage:Nr.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,n,i,r){if(Pe().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:i,values:t,usage:Nr.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:i,complexTensorInfos:r,slice:a,shape:s,isPacked:l}=t;if(a!=null){let p;l?p=new H2(s,U2):p=new No(s,U2);const m=this.runWebGLProgram(p,[{dataId:e,shape:s,dtype:i}],i),g=this.readSync(m.dataId);return this.disposeIntermediateTensorInfo(m),g}if(n!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return n;const c=this.activeTimers!=null;let h;c&&(h=Ar());let d;if(i==="complex64"){const p=this.readSync(r.real.dataId),m=this.readSync(r.imag.dataId);d=Mh(p,m)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Ar()-h),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const g=this.pendingRead.get(e);return new Promise(_=>g.push(_))}const t=this.texData.get(e),{values:n,shape:i,slice:r,dtype:a,complexTensorInfos:s,isPacked:l}=t;if(r!=null){let g;l?g=new H2(i,U2):g=new No(i,U2);const _=this.runWebGLProgram(g,[{dataId:e,shape:i,dtype:a}],a),v=this.read(_.dataId);return this.disposeIntermediateTensorInfo(_),v}if(n!=null)return this.convertAndCacheOnCPU(e);if(Pe().getBool("DEBUG")&&!Pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&Pe().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,h;if(a!=="complex64"&&Pe().get("WEBGL_BUFFER_SUPPORTED")){h=this.decode(e);const g=this.texData.get(h.dataId);c=this.gpgpu.createBufferFromTexture(g.texture.texture,...Lm(i))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(a==="complex64"){const g=await Promise.all([this.read(s.real.dataId),this.read(s.imag.dataId)]),_=g[0],v=g[1];d=Mh(_,v)}else if(c==null)d=this.getValuesFromTexture(e);else{const g=ut(i);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,g)}if(h!=null&&this.disposeIntermediateTensorInfo(h),c!=null){const g=this.gpgpu.gl;Nt(g,()=>g.deleteBuffer(c))}const p=this.convertAndCacheOnCPU(e,d),m=this.pendingRead.get(e);return this.pendingRead.delete(e),m.forEach(g=>g(p)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&ua().removeDataId(e,this),this.pendingDeletes--),p}readToGPU(e,t={}){const n=this.texData.get(e),{values:i,shape:r,slice:a,dtype:s,isPacked:l,texture:c}=n;if(s==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let m;l?m=new H2(r,U2):m=new No(r,U2);const g=this.runWebGLProgram(m,[{dataId:e,shape:r,dtype:s}],s),_=this.readToGPU(g,t);return this.disposeIntermediateTensorInfo(g),_}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const h=this.decode(e,t.customTexShape),d=ua().makeTensorFromTensorInfo(h),p=this.texData.get(h.dataId);return Object.assign({tensorRef:d},p.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const n=t.map(i=>Sh(i));return kx(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return kx(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const n=e[t];if(!Q9(n))throw Pe().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error("The value "+n+" cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'"):Error("The value "+n+" cannot be represented on this device.")}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:i}=this.texData.get(e),r=ut(t);if(Pe().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const p=this.decode(e),m=this.texData.get(p.dataId),g=this.gpgpu.downloadMatrixFromPackedTexture(m.texture.texture,...Lm(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(p),g}const a=Pe().getBool("WEBGL_PACK")&&i===!0,s=a?Hm(t):t,l=a?new uY(s):new cY(s),c=this.runWebGLProgram(l,[{shape:s,dtype:n,dataId:e}],"float32"),h=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(h.texture.texture,h.texShape[0],h.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=gc(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=gc(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const s={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(r);s.kernelMs=F5(l),s.getExtraProfileInfo=()=>l.map((c,h)=>({name:a[h],ms:c})).map(c=>c.name+": "+c.ms).join(", ")}else s.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,s})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ar(),endMs:null}}endTimer(e){return Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ar(),e)}async getQueryTime(e){if(Pe().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return n!=null&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:i,usage:r,isPacked:a,slice:s}=this.texData.get(e),l=s&&s.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,n),this.textureManager.releaseTexture(t,i,r,a)));const h=this.texData.get(e);h.texture=null,h.texShape=null,h.isPacked=!1,h.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=F$){return Pe().getBool("WEBGL_CPU_FORWARD")&&e.every(n=>this.texData.get(n.dataId).texture==null&&ut(n.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){wo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return D$(e.shape,t)}packedUnaryOp(e,t,n){const i=new H2(e.shape,t),r=this.compileAndRun(i,[e],n);return ua().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=SF(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,iI,e.dtype);const t=new No(e.shape,iI),n=this.compileAndRun(t,[e]);return ua().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let i;if(t==="string"&&n!=null&&n.length>0&&cp(n[0])){const r=n.map(a=>X2(a));i=this.write(r,e,t)}else i=this.write(n,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,n){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new O$(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new m$(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[Rh(e.shape),...Ch(e.shape)],i={dtype:e.dtype,shape:n,dataId:e.dataId},r=[Rh(t),...Ch(t)],a=new wF(r,n),s=!0,l=[n],c=this.runWebGLProgram(a,[i],e.dtype,l,s);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:i,shape:r,dtype:a}=n;if(t!=null){const p=ut(r),m=t[0]*t[1]*4;ye(p<=m,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const s=Hm(r);let l;i?l=new lY(s):l=new oY(s);const c=!0,h=[t??Lm(s)],d=this.runWebGLProgram(l,[{shape:s,dtype:a,dataId:e}],a,h,c,t);return{dtype:a,shape:r,dataId:d.dataId}}runWebGLProgram(e,t,n,i,r=!1,a){const s=this.makeTensorInfo(e.outputShape,n),l=this.texData.get(s.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Kf.DENSE){const b=a??Lm(e.outputShape);l.texShape=b.map(T=>T*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),ut(s.shape)===0)return l.values=Ir(s.dtype,0),s;const c=[],h=t.map(b=>{if(b.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let T=this.texData.get(b.dataId);if(T.texture==null){if(!e.packedInputs&&ut(b.shape)<=Pe().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:b.shape,texData:null,isUniform:!0,uniformValues:T.values};e.packedInputs&&(T.isPacked=!0,T.shape=b.shape)}if(this.uploadToGPU(b.dataId),!!T.isPacked!=!!e.packedInputs)b=T.isPacked?this.unpackTensor(b):this.packTensor(b),c.push(b),T=this.texData.get(b.dataId);else if(T.isPacked&&!C1(T.shape,b.shape)){const E=b,A=b.shape;b.shape=T.shape,b=this.packedReshape(b,A),c.push(b),T=this.texData.get(b.dataId),E.shape=A}return{shape:b.shape,texData:T,isUniform:!1}});this.uploadToGPU(s.dataId);const d={shape:s.shape,texData:l,isUniform:!1},p=sY(e,h,d),m=this.getAndSaveBinary(p,()=>rY(this.gpgpu,e,h,d)),g=this.activeTimers!=null;let _;g&&(_=this.startTimer()),Pe().get("ENGINE_COMPILE_ONLY")||aY(this.gpgpu,m,h,d,i),c.forEach(b=>this.disposeIntermediateTensorInfo(b)),g&&(_=this.endTimer(_),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(_)}));const v=Pe().getNumber("WEBGL_FLUSH_THRESHOLD");if(v>0){const b=Ar();b-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=b)}if(!Pe().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&r===!1){const b=this.unpackTensor(s);return this.disposeIntermediateTensorInfo(s),b}return s}compileAndRun(e,t,n,i,r=!1){return n=n||t[0].dtype,this.runWebGLProgram(e,t,n,i,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(Pe().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=hi(()=>{if(!Pe().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=Pe().getBool("DEBUG");Pe().set("DEBUG",!1);const t=this.abs($a(1e-8)).dataSync()[0];if(Pe().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?P$:k$}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:i,values:r,texture:a,usage:s,isPacked:l}=t;if(a!=null)return;const c=this.activeTimers!=null;let h;c&&(h=Ar());let d=t.texShape;if(d==null&&(d=dX(n,l),t.texShape=d),r!=null){const p=Hm(n);let m,g=d[1],_=d[0];const v=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(l||!v)&&([g,_]=jh(d[0],d[1])),l?m=new dY(p,v):m=new Z3(p,v);const b=v?[_,g]:d,T=this.makeTensorInfo(b,i),E=this.texData.get(T.dataId);v?E.usage=Nr.PIXELS:E.usage=Nr.UPLOAD,E.texShape=b,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(T.dataId),g,_,r);const A=[[_,g]],M=this.runWebGLProgram(m,[T],i,A,!0),R=this.texData.get(M.dataId);t.texShape=R.texShape,t.isPacked=R.isPacked,t.usage=R.usage,Pe().get("ENGINE_COMPILE_ONLY")?this.disposeData(M.dataId):(t.texture=R.texture,t.values=null,this.texData.delete(M.dataId)),this.disposeIntermediateTensorInfo(T),c&&(this.uploadWaitMs+=Ar()-h)}else{const p=this.acquireTexture(d,s,i,l);t.texture=p}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:i}=n;return t!=null&&(n.values=z$(t,i)),n.values}acquireTexture(e,t,n,i){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: "+r+" MB, most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*b1(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(r){throw r}});e.push(n)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await dG(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(HU(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:i,nanLoc:r,outShapeLocation:a,outShapeStridesLocation:s,outTexShapeLocation:l}=$U(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=i,e.nanLoc=r,e.outShapeLocation=a,e.outShapeStridesLocation=s,e.outTexShapeLocation=l}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:i,height:r,width:a,channels:s}=e,l=ua().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,t,n,r,a,s);return ua().makeTensorFromDataId(c,t,n,l)}}Sp.nextDataId=0;function z$(x,e){if(e==="float32"||e==="complex64")return x;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(x.length):new Uint8Array(x.length);for(let n=0;n<t.length;++n)t[n]=Math.round(x[n]);return t}else throw new Error("Unknown dtype "+e)}_k()&&Ak("webgl",()=>new Sp,2);const rI="return abs(x);";function V$(x){const{inputs:e,backend:t}=x,{x:n}=e;if(t.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){const r=t.texData.get(n.dataId),a=SF(r.values);return t.makeTensorInfo(n.shape,n.dtype,a)}let i;return Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new H2(n.shape,rI):i=new No(n.shape,rI),t.runWebGLProgram(i,[n],n.dtype)}const H$={kernelName:xA,backendName:"webgl",kernelFunc:V$},dE=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class O1{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=tn(t,n),this.enableShapeUniforms=qn(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        `+e+`
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}const nd=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class fE{constructor(e,t,n,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=tn(t,n);const r=this.outputShape.length;this.enableShapeUniforms=qn(r);let a="";if(i)if(r===0||ut(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          `+di(r)+` coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= `+this.outputShape[0]+` ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const s=tl("coords",r);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (`+s[r-2]+" + 1) >= outShape["+r+` - 2];
            bool nextColOutOfBounds =
              (`+s[r-1]+" + 1) >= outShape["+r+` - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (`+s[r-2]+" + 1) >= "+this.outputShape[r-2]+`;
            bool nextColOutOfBounds =
              (`+s[r-1]+" + 1) >= "+this.outputShape[r-1]+`;
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        `+e+`
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        `+a+`

        setOutput(result);
      }
    `}}function _a(x){const{inputs:e,backend:t}=x,{x:n}=e;return t.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const G$={kernelName:dg,backendName:"webgl",kernelFunc:_a};function Tp(x){const{inputs:e,backend:t}=x,{real:n,imag:i}=e,r=t.makeTensorInfo(n.shape,"complex64"),a=t.texData.get(r.dataId),s=_a({inputs:{x:n},backend:t}),l=_a({inputs:{x:i},backend:t});return a.complexTensorInfos={real:s,imag:l},r}const W$="return (a < 0.) ? b * a : a;",X$=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`,AF="return (a < 0.) ? b * a : a;",EF=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function Y$(x){const{inputs:e,backend:t}=x,{x:n,alpha:i}=e,r=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new fE(EF,n.shape,i.shape):new O1(AF,n.shape,i.shape);return t.runWebGLProgram(r,[n,i],"float32")}const K$={kernelName:wA,backendName:"webgl",kernelFunc:Y$},pE="if (isnan(x)) return x;";function ul({opSnippet:x,packedOpSnippet:e,cpuKernelImpl:t,dtype:n}){return({inputs:i,backend:r})=>{const{x:a}=i,s=r,l=n||a.dtype;if(s.shouldExecuteOnCPU([a])&&t!=null){const d=s.texData.get(a.dataId),p=t(d.values,l);return s.makeTensorInfo(a.shape,l,p)}const c=Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let h;return c?h=new H2(a.shape,e):h=new No(a.shape,x),s.runWebGLProgram(h,[a],l)}}function Lr({opSnippet:x,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:n=!1,cpuKernelImpl:i,dtype:r}){return({inputs:a,backend:s})=>{const{a:l,b:c}=a,h=s;if(n&&l.dtype==="complex64"){const g=h.texData.get(l.dataId),_=h.texData.get(c.dataId),[v,b]=[[g.complexTensorInfos.real,_.complexTensorInfos.real],[g.complexTensorInfos.imag,_.complexTensorInfos.imag]].map(E=>{const[A,M]=E,R={dataId:A.dataId,dtype:A.dtype,shape:l.shape},C={dataId:M.dataId,dtype:M.dtype,shape:c.shape},k=new O1(x,l.shape,c.shape);return h.runWebGLProgram(k,[R,C],Rs(A.dtype,M.dtype))}),T=Tp({inputs:{real:v,imag:b},backend:h});return h.disposeIntermediateTensorInfo(v),h.disposeIntermediateTensorInfo(b),T}const d=r||Rs(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||h.shouldExecuteOnCPU([l,c]))&&i!=null){const g=h.texData.get(l.dataId).values,_=h.texData.get(c.dataId).values,v=l.dtype==="string"?q2(g):g,b=l.dtype==="string"?q2(_):_,[T,E]=i(l.shape,c.shape,v,b,d),A=h.makeTensorInfo(E,d),M=h.texData.get(A.dataId);return M.values=T,A}const p=Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let m;return p?m=new fE(e,l.shape,c.shape,t):m=new O1(x,l.shape,c.shape),h.runWebGLProgram(m,[l,c],d)}}function Qf(x,e=!1){if(x==="linear")return e?M$:S$;if(x==="relu")return e?C$:w$;if(x==="elu")return e?R$:T$;if(x==="relu6")return e?N$:A$;if(x==="prelu")return e?EF:AF;if(x==="leakyrelu")return e?X$:W$;if(x==="sigmoid")return e?I$:E$;throw new Error("Activation "+x+" has not been implemented for the WebGL backend.")}const aI="return a + b;",$$=Lr({opSnippet:aI,packedOpSnippet:aI,supportsComplex:!0,cpuKernelImpl:$K}),Q$={kernelName:hp,backendName:"webgl",kernelFunc:$$};class Z${constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,a)=>"T"+a);const n=[];this.variableNames.forEach(r=>{n.push("float v"+r+" = get"+r+"AtOutCoords();")});const i=this.variableNames.map(r=>"v"+r).join(" + ");this.userCode=`
      void main() {
        `+n.join(`
        `)+`

        float result = `+i+`;
        setOutput(result);
      }
    `}}class J${constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,a)=>"T"+a);const n=[];this.variableNames.forEach(r=>{n.push("vec4 v"+r+" = get"+r+"AtOutCoords();")});const i=this.variableNames.map(r=>"v"+r).join(" + ");this.userCode=`
      void main() {
        `+n.join(`
        `)+`

        vec4 result = `+i+`;
        setOutput(result);
      }
    `}}function x1(x){const{inputs:e,backend:t}=x,n=e;if(n.length===1)return _a({inputs:{x:n[0]},backend:t});if(n.length>Pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const s=Math.floor(n.length/2),l=x1({inputs:n.slice(0,s),backend:t}),c=x1({inputs:n.slice(s),backend:t});return x1({inputs:[l,c],backend:t})}const i=n.map(s=>s.dtype).reduce((s,l)=>Rs(s,l)),r=n.map(s=>s.shape),a=Pe().getBool("WEBGL_PACK")?new J$(n[0].shape,r):new Z$(n[0].shape,r);return t.runWebGLProgram(a,n,i)}const j$={kernelName:nA,backendName:"webgl",kernelFunc:x1},q$=dE+`
  return atan(a, b);
`,eQ=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nd+`
  return result;
`,tQ=Lr({opSnippet:q$,packedOpSnippet:eQ}),xQ={kernelName:ag,backendName:"webgl",kernelFunc:tQ};class MF{constructor(e,t,n,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&n)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,s=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,m=e.padInfo.top,g=e.padInfo.left;this.outputShape=e.outShape;const _=t==="avg",v="((batch  * "+e.inHeight+" + xR) * "+e.inWidth+" + xC) * "+e.inChannels+" + d",b="(xR * "+e.inWidth+" + xC) * "+e.inChannels+" + d";let T="0.0";if(_||(T="-1.0 / 1e-20"),n){const k=">=";this.userCode=`
        const ivec2 strides = ivec2(`+s+", "+l+`);
        const ivec2 pads = ivec2(`+m+", "+g+`);

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < `+d+`;
              wR += `+c+`) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= `+e.inHeight+`) {
              continue;
            }

            for (int wC = 0; wC < `+p+`;
                wC += `+h+`) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= `+e.inWidth+`) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value `+k+` currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = `+(i?r?v:b:"wR * "+p+" + wC")+`;
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let A=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";t==="avg"&&(A="avgValue / max(count, 1.0)");const M=Math.floor(a/4)*4,R=a%4,C=`
      if (`+_+`) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = `+E+`(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(`+s+", "+l+`);
      const ivec2 pads = ivec2(`+m+", "+g+`);
      const float initializationValue = `+T+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= `+e.inWidth+`) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(`+T+`);
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < `+d+`;
            wR += `+c+`) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= `+e.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+M+`; wC += 4) {
            int xC = xCCorner + wC * `+h+`;

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+h+`, d),
              getValue(batch, xR, xC + 2 * `+h+`, d),
              getValue(batch, xR, xC + 3 * `+h+`, d)
            );

            `+C+`
          }

          int xC = xCCorner + `+M+`;
          if (`+(R===1)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            `+C+`
          } else if (`+(R===2)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+h+`, d),
              initializationValue,
              initializationValue
            );

            `+C+`
          } else if (`+(R===3)+`) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + `+h+`, d),
              getValue(batch, xR, xC + 2 * `+h+`, d),
              initializationValue
            );

            `+C+`
          }
        }
        setOutput(`+A+`);
      }
    `}}function nQ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e;GU(i,"avgPool");const{filterSize:r,strides:a,pad:s,dimRoundingMode:l}=n,c=1;ye(Fr(a,c),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+c+"'");const h=yp(i.shape,r,a,c,s,l);if(h.filterWidth===1&&h.filterHeight===1&&Zx(h.inShape,h.outShape))return _a({inputs:{x:i},backend:t});const d=new MF(h,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const iQ={kernelName:iA,backendName:"webgl",kernelFunc:nQ};class RF{constructor(e,t,n,i=!1,r=!1,a=!1,s=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=qn(this.outputShape.length);const h=i?e[1]:e[2],d=Math.ceil(h/2),p=i?"i * 2, rc.y":"rc.y, i * 2",m=r?"rc.z, i * 2":"i * 2, rc.z",g=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],_=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",b="";s&&(l?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+s+`
        }`:c?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+s+`
        }`:v=`vec4 activation(vec4 x) {
          `+s+`
        }`,b="result = activation(result);");const T=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let E="rc.x",A="rc.x";e[0]<t[0]?E="imod(rc.x, "+e[0]+")":t[0]<e[0]&&(A="imod(rc.x, "+t[0]+")"),this.userCode=`
      `+v+`
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = `+d+`.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = `+E+`;
        int batchB = `+A+`;
        for (int i = 0; i < `+d+`; i++) {
          vec4 a = getMatrixA(batchA, `+p+`);
          vec4 b = getMatrixB(batchB, `+m+`);

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (`+g[0]+" * "+_[0]+`);
          result += (`+g[1]+" * "+_[1]+`);
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        `+T+`

        `+b+`

        setOutput(result);
      }
    `}}const sI={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class oI{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=tn(t,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        `+e+`
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}const lI="return a * b;";function CF(x){const{inputs:e,backend:t}=x,{a:n,b:i}=e,r=Rs(n.dtype,i.dtype);if(n.dtype==="complex64"){const s=t.texData.get(n.dataId),l=t.texData.get(i.dataId),c=new oI(sI.REAL,n.shape,i.shape),h=new oI(sI.IMAG,n.shape,i.shape),d=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:n.shape},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],p=t.runWebGLProgram(c,d,"float32"),m=t.runWebGLProgram(h,d,"float32"),g=Tp({inputs:{real:p,imag:m},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),g}if(t.shouldExecuteOnCPU([n,i])){const s=t.texData.get(n.dataId),l=t.texData.get(i.dataId),[c,h]=r$(n.shape,i.shape,s.values,l.values,r),d=t.makeTensorInfo(h,r),p=t.texData.get(d.dataId);return p.values=c,d}let a;return Pe().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new fE(lI,n.shape,i.shape):a=new O1(lI,n.shape,i.shape),t.runWebGLProgram(a,[n,i],r)}const rQ={kernelName:gg,backendName:"webgl",kernelFunc:CF};function aQ(x,e,t){const n=[Rh(x.shape),...Ch(x.shape)],i={dtype:x.dtype,shape:n,dataId:x.dataId},r=[Rh(e),...Ch(e)],a=new wF(r,n),s=!0,l=[n],c=t.runWebGLProgram(a,[i],x.dtype,l,s);return{dataId:c.dataId,shape:e,dtype:c.dtype}}function S0(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{shape:r}=n,a=t,s=ut(i.shape),l=ZP(r,s),c=ut(l);ye(s===c,()=>"The new shape ("+l+") has "+c+" elements and the old shape ("+i.shape+") has "+s+" elements. The new shape and old shape must have the same number of elements.");const h=a.texData.get(i.dataId);return h.isPacked&&!C1(i.shape,l)&&!(h.texture!==null&&C1(h.shape,l))?aQ(i,l,a):(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const sQ={kernelName:EA,backendName:"webgl",kernelFunc:S0};class cI{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:i,inSize:r,outSize:a}=e;this.outputShape=[i,a];const s=Math.floor(n/4)*4,l=n%4;let c="sumValue += dot(values, ones);";if(t!=null){const d=1/t;c="sumValue += dot(values * "+(v1(d)?d.toPrecision(2):d)+", ones);"}let h="";r%n>0&&(h=`
        if (inIdx < 0 || inIdx >= `+r+`) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+h+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+n+`;

        float sumValue = 0.0;

        for (int i = 0; i < `+s+`; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+c+`
        }

        int inIdx = inOffset + `+s+`;
        if (`+(l===1)+`) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          `+c+`
        } else if (`+(l===2)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          `+c+`
        } else if (`+(l===3)+`) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          `+c+`
        }
        setOutput(sumValue);
      }
    `}}class oQ{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:i,inSize:r,outSize:a}=e;this.outputShape=[i,a];let s="0.0",l="";t==="prod"?s="1.0":t==="min"?(s="1.0 / 1e-20",l="min"):t==="max"&&(s="-1.0 / 1e-20",l="max");let c=t+"("+t+"("+t+"(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const h=Math.floor(n/4)*4,d=n%4;let p=`
      if (`+(t==="sum")+`) {
        sumValue += dot(values, ones);
      } else if (`+(t==="prod")+`) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = `+l+`(values, minMaxValue);
        if (`+(t==="min")+" || "+(t==="max")+`) {
          minMaxValue = `+l+`(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,m="vec4";t==="all"?(s="1.0",p=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,m="bvec4"):t==="any"&&(s="0.0",p=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,m="bvec4");let g="";r%n>0&&(g=`
        if (inIdx < 0 || inIdx >= `+r+`) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = `+s+`;
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        `+g+`
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * `+n+`;

        vec4 minMaxValue = vec4(`+s+`);
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < `+h+`; i += 4) {
          int inIdx = inOffset + i;
          `+m+" values = "+m+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          `+p+`
        }

        int inIdx = inOffset + `+h+`;
        if (`+(d===1)+`) {
          `+m+" values = "+m+`(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          `+p+`
        } else if (`+(d===2)+`) {
          `+m+" values = "+m+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          `+p+`
        } else if (`+(d===3)+`) {
          `+m+" values = "+m+`(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          `+p+`
        }
        setOutput(`+c+`);
      }
    `}}function lQ(x){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:x[1],n=EU(t);e.push({inSize:t,windowSize:n,outSize:Math.ceil(t/n)})}return e}function Bg(x,e,t,n){const i=lQ(x.shape);let r=x;for(let a=0;a<i.length;a++){const{inSize:s,windowSize:l,outSize:c}=i[a];let h,d;t==="mean"?h=a===0?new cI({windowSize:l,inSize:s,batchSize:x.shape[0],outSize:c},s):new cI({windowSize:l,inSize:s,batchSize:x.shape[0],outSize:c}):h=new oQ({windowSize:l,inSize:s,batchSize:x.shape[0],outSize:c},t),d=r,r=n.runWebGLProgram(h,[r],e),d.dataId!==x.dataId&&n.disposeIntermediateTensorInfo(d)}return r}class cQ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[t[a]];this.outputShape=n,this.rank=n.length;const i=di(this.rank),r=uQ(t);this.userCode=`
    void main() {
      `+i+` resRC = getOutputCoords();
      setOutput(getA(`+r+`));
    }
    `}}function uQ(x){const e=x.length;if(e>6)throw Error("Transpose for rank "+e+" is not yet supported");const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(e);for(let i=0;i<x.length;i++)n[x[i]]=t[i];return n.join()}class hQ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let h=0;h<n.length;h++)n[h]=e[t[h]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank "+this.rank+" is not yet supported.");const i=di(this.rank),r=TF("rc",this.rank),a=new Array(this.rank);for(let h=0;h<t.length;h++)a[t[h]]=r[h];const s="vec2("+a.slice(-2).join()+")",l="++"+r[this.rank-1]+" < "+n[this.rank-1],c="getChannel(getA("+a.join()+"), "+s+")";this.userCode=`
    void main() {
      `+i+` rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = `+c+`;
      if(`+l+`) {
        result[1] = `+c+`;
      }
      --`+r[this.rank-1]+`;
      if(++`+r[this.rank-2]+" < "+n[this.rank-2]+`) {
        result[2] = `+c+`;
        if(`+l+`) {
          result[3] = `+c+`;
        }
      }
      setOutput(result);
    }
    `}}function Lg(x,e,t){const n=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hQ(x.shape,e):new cQ(x.shape,e);return t.runWebGLProgram(n,[x],x.dtype)}function dQ(x,e,t,n){const i=e,r=x.shape.length,a=Ri(i,x.shape);let s=a;const l=ol(s,r),c=l!=null;let h=x;c&&(h=Lg(x,l,n),s=ll(s.length,r)),sl("sum",s,r);const[d,p]=Is(h.shape,s);let m=d;t&&(m=Ho(d,a));const g=ut(p),_=ut(x.shape)/g,v=S0({inputs:{x:h},attrs:{shape:[_,g]},backend:n}),b=VV(x.dtype),T=Bg(v,b,"sum",n),E=S0({inputs:{x:T},attrs:{shape:m},backend:n});return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(T),c&&n.disposeIntermediateTensorInfo(h),E}function NF(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{axis:r,keepDims:a}=n;return dQ(i,r,a,t)}const fQ={kernelName:CA,backendName:"webgl",kernelFunc:NF};function D1(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{perm:r}=n,a=t,s=i.shape.length,l=new Array(s);for(let h=0;h<l.length;h++)l[h]=i.shape[r[h]];let c;if(a.shouldExecuteOnCPU([i])){const h=a.texData.get(i.dataId).values,d=hE(h,i.shape,i.dtype,r,l);c=a.makeTensorInfo(l,i.dtype);const p=a.texData.get(c.dataId);p.values=d}else c=Lg(i,r,a);return c}const pQ={kernelName:Df,backendName:"webgl",kernelFunc:D1},IF=1e3;function P1({a:x,b:e,transposeA:t,transposeB:n,backend:i,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:s=0,activation:l=null}){const c=x.shape.length,h=e.shape.length,d=t?x.shape[c-2]:x.shape[c-1],p=n?e.shape[h-1]:e.shape[h-2],m=t?x.shape[c-1]:x.shape[c-2],g=n?e.shape[h-2]:e.shape[h-1],_=x.shape.slice(0,-2),v=e.shape.slice(0,-2),b=ut(_),T=ut(v),E=tn(x.shape.slice(0,-2),e.shape.slice(0,-2)).concat([m,g]);ye(d===p,()=>"Error in matMul: inner shapes ("+d+") and ("+p+") of Tensors with shapes "+x.shape+" and "+e.shape+" and transposeA="+t+" and transposeB="+n+" must match.");const A=t?[b,d,m]:[b,m,d],M=n?[T,g,p]:[T,p,g],R=S0({inputs:{x},backend:i,attrs:{shape:A}}),C=S0({inputs:{x:e},backend:i,attrs:{shape:M}}),k=[R,C],P=Math.max(b,T),N=t?R.shape[1]:R.shape[2],G=r!=null,te=a!=null,j=l==="leakyrelu",xe=l!=null?Qf(l,!0):null,ae=G||te||j||xe!=null;let H;if((m===1||g===1)&&N>IF&&ae===!1){let q=R,be=C;t&&(q=D1({inputs:{x:R},backend:i,attrs:{perm:[0,2,1]}}),k.push(q)),n&&(be=D1({inputs:{x:C},backend:i,attrs:{perm:[0,2,1]}}),k.push(be));const K=g!==1,se=g===1;let ge=q;K&&(ge=S0({inputs:{x:q},backend:i,attrs:{shape:[P,N,1]}}),k.push(ge));const Me=g===1?2:1;let le=be;se&&(le=S0({inputs:{x:be},backend:i,attrs:{shape:[P,1,N]}}),k.push(le));const Se=CF({inputs:{a:ge,b:le},backend:i});H=NF({inputs:{x:Se},backend:i,attrs:{axis:Me,keepDims:!0}}),k.push(Se)}else{const q=Rs(x.dtype,e.dtype),be=new RF(A,M,[P,m,g],t,n,G,xe,te,j),K=[R,C];if(r!=null&&K.push(r),te&&K.push(a),j){const se=i.makeTensorInfo([],"float32",dp(s,"float32"));K.push(se),k.push(se)}H=i.runWebGLProgram(be,K,q)}const re=S0({inputs:{x:H},backend:i,attrs:{shape:E}});k.push(H);for(const q of k)i.disposeIntermediateTensorInfo(q);return re}function mQ(x){const{inputs:e,backend:t,attrs:n}=x,{a:i,b:r}=e,{transposeA:a,transposeB:s}=n;return P1({a:i,b:r,transposeA:a,transposeB:s,backend:t})}const yQ={kernelName:rA,backendName:"webgl",kernelFunc:mQ},gQ="return float(a != b);",vQ=Lr({opSnippet:gQ,cpuKernelImpl:s$,dtype:"bool"});function mE(x){const{inputs:e,backend:t}=x,{input:n}=e,i=t.texData.get(n.dataId);return _a({inputs:{x:i.complexTensorInfos.real},backend:t})}const bQ="return float(int(x));";function _Q(x,e){const t=new No(x.shape,bQ),n=e.runWebGLProgram(t,[x],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function MT(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{dtype:r}=n;if(r==="complex64"){if(i.dtype==="complex64")return _a({inputs:{x:i},backend:t});const a=wc(i.shape),s=MT({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=Tp({inputs:{real:s,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(s),l}if(i.dtype==="complex64"){const a=mE({inputs:{input:i},backend:t}),s=MT({inputs:{x:a},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(a),s}if(!JP(i.dtype,r)){const a=_a({inputs:{x:i},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const a=t.texData.get(i.dataId).values,[s,l,c]=QK(a,i.shape,i.dtype,r);return t.makeTensorInfo(s,l,c)}if(r==="int32")return _Q(i,t);if(r==="bool"){const a=t.makeTensorInfo([],"bool",Ir("bool",1)),s=vQ({inputs:{a:i,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),s}throw new Error("Error in Cast: failed to cast "+i.dtype+" to "+r)}const SQ={kernelName:sg,backendName:"webgl",kernelFunc:MT};class TQ{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}class wQ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}function AQ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{clipValueMin:r,clipValueMax:a}=n;let s;Pe().getBool("WEBGL_PACK_CLIP")?s=new wQ(i.shape):s=new TQ(i.shape);const l=[[r],[a]];return t.runWebGLProgram(s,[i],i.dtype,l)}const EQ={kernelName:og,backendName:"webgl",kernelFunc:AQ};class MQ{constructor(e){this.outputShape=[],this.outputShape=As(e,1),this.variableNames=e.map((a,s)=>"T"+s);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const n=["if (yC < "+t[0]+") setOutput(getT0(yR, yC));"];for(let a=1;a<t.length;a++){const s=t[a-1];n.push("else if (yC < "+t[a]+") setOutput(getT"+a+"(yR, yC-"+s+"));")}const i=t.length,r=t[t.length-1];n.push("else setOutput(getT"+i+"(yR, yC-"+r+"));"),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        `+n.join(`
        `)+`
      }
    `}}class RQ{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=As(e,t);const n=this.outputShape,i=n.length,r=di(i),a=tl("coords",i),s=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((_,v)=>"T"+v);const l=new Array(e.length-1);l[0]=e[0][t];for(let _=1;_<l.length;_++)l[_]=l[_-1]+e[_][t];const c=s[t],h=s.slice(-2),d=s.join();let p="if ("+c+" < "+l[0]+`) {
        return getChannel(
            getT0(`+d+"), vec2("+h.join()+`));
        }`;for(let _=1;_<l.length;_++){const v=l[_-1];p+=`
        if (`+c+" < "+l[_]+"  && "+c+" >= "+l[_-1]+`) {
          return getChannel(
            getT`+_+"("+Wm(s,c,v)+`),
            vec2(`+Wm(h,c,v)+`));
        }`}const m=l.length,g=l[l.length-1];p+=`
        return getChannel(
          getT`+m+"("+Wm(s,c,g)+`),
          vec2(`+Wm(h,c,g)+"));",this.userCode=`
      float getValue(`+s.map(_=>"int "+_)+`) {
        `+p+`
      }

      void main() {
        `+r+` coords = getOutputCoords();
        vec4 result = vec4(getValue(`+a+`), 0., 0., 0.);

        `+a[i-1]+" = "+a[i-1]+` + 1;
        if (`+a[i-1]+" < "+n[i-1]+`) {
          result.g = getValue(`+a+`);
        }

        `+a[i-2]+" = "+a[i-2]+` + 1;
        if (`+a[i-2]+" < "+n[i-2]+`) {
          result.a = getValue(`+a+`);
        }

        `+a[i-1]+" = "+a[i-1]+` - 1;
        if (`+a[i-2]+" < "+n[i-2]+` &&
            `+a[i-1]+" < "+n[i-1]+`) {
          result.b = getValue(`+a+`);
        }
        setOutput(result);
      }
    `}}function Wm(x,e,t){const n=x.indexOf(e);return x.map((i,r)=>r===n?i+" - "+t:i).join()}function OF(x){const{inputs:e,backend:t}=x,{input:n}=e,i=t.texData.get(n.dataId);return _a({inputs:{x:i.complexTensorInfos.imag},backend:t})}function Rf(x,e,t){const n=x[0].dtype;if(n==="complex64"){const m=x.map(T=>mE({inputs:{input:T},backend:t})),g=x.map(T=>OF({inputs:{input:T},backend:t})),_=Rf(m,e,t),v=Rf(g,e,t),b=Tp({inputs:{real:_,imag:v},backend:t});return m.forEach(T=>t.disposeIntermediateTensorInfo(T)),g.forEach(T=>t.disposeIntermediateTensorInfo(T)),t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(v),b}let i=t.shouldExecuteOnCPU(x);if(n==="string"&&(i=!0),i){const m=x.map(A=>{const M=[-1,ut(A.shape.slice(e))];return S0({inputs:{x:A},backend:t,attrs:{shape:M}})}),g=m.map(A=>({vals:t.readSync(A.dataId),shape:A.shape})),_=As(m.map(A=>A.shape),1),v=m[0].shape[0]===1,b=ZK(g,_,n,v),T=As(x.map(A=>A.shape),e),E=t.makeTensorInfo(T,n,b);return m.forEach(A=>t.disposeIntermediateTensorInfo(A)),E}const r=x.filter(m=>ut(m.shape)>0),a=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const m=a?new No(x[0].shape,U2):new H2(x[0].shape,U2);return t.runWebGLProgram(m,x,n)}const s=Pe().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>s){const m=[];for(let _=0;_<r.length;_+=s){const v=r.slice(_,_+s);m.push(Rf(v,e,t))}const g=Rf(m,e,t);for(const _ of m)t.disposeIntermediateTensorInfo(_);return g}if(a){const m=new RQ(r.map(g=>g.shape),e);return t.runWebGLProgram(m,r,n)}const{tensors2D:l,outShape:c}=CQ(r,e,t),h=new MQ(l.map(m=>m.shape)),d=t.runWebGLProgram(h,l,n);l.forEach(m=>t.disposeIntermediateTensorInfo(m));const p=S0({inputs:{x:d},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(d),p}function CQ(x,e,t){const n=As(x.map(i=>i.shape),e);return{tensors2D:x.map(i=>S0({inputs:{x:i},attrs:{shape:[-1,ut(i.shape.slice(e))]},backend:t})),outShape:n}}function DF(x){const{inputs:e,backend:t,attrs:n}=x,{axis:i}=n,r=Ri(i,e[0].shape)[0],a=e.map(c=>c.shape);jA(a,r);const s=As(e.map(c=>c.shape),r);if(ut(s)===0)return t.makeTensorInfo(s,e[0].dtype,[]);const l=e.filter(c=>ut(c.shape)>0);return l.length===1?_a({inputs:{x:l[0]},backend:t}):Rf(l,r,t)}const NQ={kernelName:aA,backendName:"webgl",kernelFunc:DF};class PF{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,s=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,h=e.dilationHeight,d=e.dilationWidth,p=e.filterHeight,m=e.filterWidth,g=Math.floor(e.inChannels/4)*4,_=e.inChannels%4,v=e.dataFormat==="channelsLast",b=v?1:2,T=v?2:3,E=v?3:1;let A="",M="";n&&(i?A=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+n+`
        }`:r?A=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+n+`
        }`:A=`
          float activation(float x) {
            `+n+`
          }
        `,M="result = activation(result);");const R=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+A+`

      const ivec2 strides = ivec2(`+l+", "+c+`);
      const ivec2 pads = ivec2(`+a+", "+s+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[`+E+`];

        ivec2 xRCCorner =
            ivec2(coords[`+b+"], coords["+T+`]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+p+`; wR++) {
          int xR = xRCorner + wR * `+h+`;

          if (xR < 0 || xR >= `+e.inHeight+`) {
            continue;
          }

          for (int wC = 0; wC < `+m+`; wC++) {
            int xC = xCCorner + wC * `+d+`;

            if (xC < 0 || xC >= `+e.inWidth+`) {
              continue;
            }

            for (int d1 = 0; d1 < `+g+`; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (`+v+`) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (`+(_===1)+`) {

              if (`+v+`) {
                dotProd +=
                    getX(batch, xR, xC, `+g+`) *
                    getW(wR, wC, `+g+`, d2);
              } else {
                dotProd +=
                    getX(batch, `+g+`, xR, xC) *
                    getW(wR, wC, `+g+`, d2);
              }

            } else if (`+(_===2)+`) {
              vec2 wValues = vec2(
                getW(wR, wC, `+g+`, d2),
                getW(wR, wC, `+g+` + 1, d2)
              );

              if (`+v+`) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, `+g+`),
                  getX(batch, xR, xC, `+g+` + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, `+g+`, xR, xC),
                  getX(batch, `+g+` + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (`+(_===3)+`) {
              vec3 wValues = vec3(
                getW(wR, wC, `+g+`, d2),
                getW(wR, wC, `+g+` + 1, d2),
                getW(wR, wC, `+g+` + 2, d2)
              );

              if (`+v+`) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, `+g+`),
                  getX(batch, xR, xC, `+g+` + 1),
                  getX(batch, xR, xC, `+g+` + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, `+g+`, xR, xC),
                  getX(batch, `+g+` + 1, xR, xC),
                  getX(batch, `+g+` + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        `+R+`
        `+M+`
        setOutput(result);
      }
    `}}class kF{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qn(this.outputShape.length);const a=e.padInfo.left,s=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,h=e.filterWidth,d=h;let p=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<h;v++)p+=`
           vec4 xTexelC`+v*2+`;
           int xTexelC`+v*2+`Ready;
           vec4 xTexelC`+(v*2+1)+`;
           int xTexelC`+(v*2+1)+`Ready;
           vec4 xC`+v+";";p+=`
     for (int r = 0; r < `+c+`; r++) {
      for (int d1 = 0; d1 < `+e.inChannels+`; d1 += 2) {
       `;for(let v=0;v<h;v++)p+=`
           xTexelC`+v*2+` = vec4(0.0);
           xTexelC`+v*2+`Ready = 0;
           xTexelC`+(v*2+1)+` = vec4(0.0);
           xTexelC`+(v*2+1)+`Ready = 0;
           xC`+v+" = vec4(0.0);";p+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(d+1)/2;v++){const b=v*2;if(p+=`
           xC = xCCorner + `+b*l+`;
           `,s===1){if(b<h&&(a%2===1?(p+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+b+`Ready == 0) {
                   xTexelC`+b+` = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+b+`.zw = vec2(0.0);
                   }
                   xTexelC`+b+`Ready = 1;
                 }
               `,l===1&&b>0?p+=`
                 xC`+b+" = vec4(xTexelC"+(b-2)+".zw, xTexelC"+b+`.xy);
                 `:p+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC`+b+" = vec4(previous.zw, xTexelC"+b+`.xy);
                   } else {
                     xC`+b+" = vec4(0.0, 0.0, xTexelC"+b+`.xy);
                   }
                   `):p+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC`+b+`Ready == 0) {
                   xTexelC`+b+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+b+`.zw = vec2(0.0);
                   }
                   xTexelC`+b+`Ready = 1;
                 }

                 xC`+b+" = xTexelC"+b+`;
                 `,b+1<h)){const T=a%2===0?jw(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(p+=`
                   xCOffset = xC + imod(pads[1], 2) + `+T+`;

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(b+1)+`Ready == 0) {
                     xTexelC`+(b+1)+` = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC`+(b+1)+`.zw = vec2(0.0);
                     }
                     xTexelC`+(b+1)+`Ready = 1;
                   }
                   `,l>1?p+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC`+(b+1)+" = vec4(previous.zw, xTexelC"+(b+1)+`.xy);
                     } else {
                      xC`+(b+1)+" = vec4(0.0, 0.0, xTexelC"+(b+1)+`.xy);
                     }
                     `:p+=`
                     xC`+(b+1)+" = vec4(xTexelC"+b+".zw, xTexelC"+(b+1)+`.xy);
                     `):T===1?p+=`
                     xC`+(b+1)+" = xTexelC"+b+`;
                     `:p+=`
                     xCOffset = xC + `+T+`;

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(b+1)+`Ready == 0) {
                       xTexelC`+(b+1)+` = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC`+(b+1)+`.zw = vec2(0.0);
                       }
                       xTexelC`+(b+1)+`Ready = 1;
                     }

                     xC`+(b+1)+" = xTexelC"+(b+1)+`;
                     `}}else b<h&&(a%2===1?(p+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+b+`Ready == 0) {
                   xTexelC`+b+` = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+b+`.zw = vec2(0.0);
                   }
                   xTexelC`+b+`Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(b+1)+`Ready == 0) {
                   xTexelC`+(b+1)+` = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC`+(b+1)+`.zw = vec2(0.0);
                   }
                   xTexelC`+(b+1)+`Ready = 1;
                 }

                 xC`+b+" = vec4(xTexelC"+b+".zw, xTexelC"+(b+1)+`.zw);
               `,b+1<h&&(p+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC`+(b+1)+" = vec4(xTexelC"+(b+1)+`.xy, final.xy);
                 `)):(p+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC`+b+`Ready == 0) {
                   xTexelC`+b+` = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC`+b+`.zw = vec2(0.0);
                   }
                   xTexelC`+b+`Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(b+1)+`Ready == 0) {
                   xTexelC`+(b+1)+` = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC`+(b+1)+`.zw = vec2(0.);
                   }
                   xTexelC`+(b+1)+`Ready = 1;
                 }

                 xC`+b+` = vec4(
                   xTexelC`+b+".xy, xTexelC"+(b+1)+`.xy);
               `,b+1<h&&(p+=`
                   xC`+(b+1)+" = vec4(xTexelC"+b+".zw, xTexelC"+(b+1)+`.zw);
                 `)));b<h&&(p+=`
             wTexel = getW(r, `+b+`, d1, d2);
             dotProd += xC`+b+`.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < `+e.inChannels+`) {
               dotProd += xC`+b+`.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,b+1<h&&(p+=`
               wTexel = getW(r, `+(b+1)+`, d1, d2);
               dotProd += xC`+(b+1)+`.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < `+e.inChannels+`) {
                 dotProd += xC`+(b+1)+`.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}p+=`
     }
   `,p+=`
     }
   `,p+=`
     }
   `;let m="",g="";n&&(i?m=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           `+n+`
         }`:r?m=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           `+n+`
         }`:m=`vec4 activation(vec4 x) {
           `+n+`
         }`,g="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       `+m+`

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         `+p+`

         vec4 result = dotProd - vec4(0.000000000000001);
         `+_+`
         `+g+`
         setOutput(result);
       }
     `}}class IQ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=qn(this.outputShape.length);const{dataFormat:n}=t,i=fi(),r=n==="channelsLast",a=r?1:2,s=r?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < "+e[2]+" && pos < "+e[1]+") {";let c="";for(let h=0;h<=1;h++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + `+d+`;
          pos = rc.y + `+h+`;

          `+l+`
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[`+a+`] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[`+s+`] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (`+r+`) {
                  innerDims = vec2(d1, ch);
                  result[`+(h*2+d)+`] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[`+(h*2+d)+`] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        `+c+`

        `+i.output+` = result;
      }
    `}}function k1(x,e){const t=x.length;return t>=3?e?[...x.slice(0,-3),x[t-3]*x[t-2],x[t-1]]:[...x.slice(0,-3),x[t-3],x[t-2]*x[t-1]]:!e&&t===1&&x[0]>1?[x[0],1]:null}function UF({x,filter:e,convInfo:t,backend:n,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:s=null}){const l=x.shape,c=n.texData.get(x.dataId),h=t.inChannels,d=l[0]*l[1]*l[2],p=t.outChannels,m=t.dataFormat==="channelsLast",g=!1,_=!1;let v;const b=[];if(r!=null){const T=k1(r.shape,m);T!=null&&(r=S0({inputs:{x:r},backend:n,attrs:{shape:T}}),b.push(r))}if(i!=null){const T=k1(i.shape,m);T!=null&&(i=S0({inputs:{x:i},backend:n,attrs:{shape:T}}),b.push(i))}if(!((d===1||p===1)&&h>IF)&&c.isPacked&&m&&c.texture!=null&&l[2]%2!==0&&Zx(c.shape.slice(-3),l.slice(-3))){const T=l[0]*l[1]*(l[2]+1),E={dataId:x.dataId,shape:[1,T,t.inChannels],dtype:x.dtype},A=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,ye(C1(c.shape,E.shape),()=>"packed reshape "+c.shape+" to "+E.shape+" isn't free");const M=S0({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}});b.push(M);const R=P1({a:E,b:M,backend:n,transposeA:g,transposeB:_,bias:i,activation:s,preluActivationWeights:r,leakyreluAlpha:a}),C=n.texData.get(R.dataId);ye(C.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=A,C.shape=t.outShape,v=_a({inputs:{x:R},backend:n}),v.shape=t.outShape,b.push(R)}else{const T=t.outHeight*t.outWidth,E=S0({inputs:{x},backend:n,attrs:{shape:m?[t.batchSize,T,t.inChannels]:[t.batchSize,t.inChannels,T]}}),A=S0({inputs:{x:e},backend:n,attrs:{shape:[1,t.inChannels,t.outChannels]}}),M=P1({a:m?E:A,b:m?A:E,transposeA:!m,transposeB:_,backend:n,bias:i,activation:s,preluActivationWeights:r,leakyreluAlpha:a});v=S0({inputs:{x:M},backend:n,attrs:{shape:t.outShape}}),b.push(E),b.push(A),b.push(M)}for(const T of b)n.disposeIntermediateTensorInfo(T);return v}function FF({x,filter:e,convInfo:t,backend:n,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:s=null}){const{filterWidth:l,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:m}=t,g=m==="channelsLast",_=l*c*h,v=p*d,b=[t.batchSize,_,v],T=!0,E=!1,A=[];if(r!=null){const q=k1(r.shape,g);q!=null&&(r=S0({inputs:{x:r},backend:n,attrs:{shape:q}}),A.push(r))}if(i!=null){const q=k1(i.shape,g);q!=null&&(i=S0({inputs:{x:i},backend:n,attrs:{shape:q}}),A.push(i))}const M=S0({inputs:{x:e},backend:n,attrs:{shape:[1,_,ut(e.shape)/_]}});A.push(M);const R=new IQ(b,t),C=[x.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],k=n.runWebGLProgram(R,[x],"float32",C),P=S0({inputs:{x:k},backend:n,attrs:{shape:b}});A.push(k),A.push(P);const N=i!=null,G=r!=null,te=s==="leakyrelu",j=s?Qf(s,!0):null,xe=new RF(g?P.shape:M.shape,g?M.shape:P.shape,g?[t.batchSize,v,t.outChannels]:[t.batchSize,t.outChannels,v],T,E,N,j,G,te),ae=g?[P,M]:[M,P];if(i&&ae.push(i),G&&ae.push(r),te){const q=n.makeTensorInfo([],"float32",dp(a,"float32"));ae.push(q),A.push(q)}const H=n.runWebGLProgram(xe,ae,"float32"),re=S0({inputs:{x:H},backend:n,attrs:{shape:t.outShape}});A.push(H);for(const q of A)n.disposeIntermediateTensorInfo(q);return re}function OQ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r}=e,{strides:a,pad:s,dataFormat:l,dilations:c,dimRoundingMode:h}=n,d=kc(l),p=Ur(i.shape,r.shape,a,c,s,h,!1,d);let m;if(p.filterHeight===1&&p.filterWidth===1&&p.dilationHeight===1&&p.dilationWidth===1&&p.strideHeight===1&&p.strideWidth===1&&(p.padInfo.type==="SAME"||p.padInfo.type==="VALID"))m=UF({x:i,filter:r,convInfo:p,backend:t});else if(p.strideWidth<=2&&d==="channelsLast"&&Pe().getBool("WEBGL_EXP_CONV")){const _=new kF(p),v=[[p.padInfo.top,p.padInfo.left],[p.strideHeight,p.strideWidth],[p.dilationHeight,p.dilationWidth],[p.inHeight,p.inWidth]];m=t.runWebGLProgram(_,[i,r],"float32",v)}else if(Pe().getBool("WEBGL_CONV_IM2COL"))m=FF({x:i,filter:r,convInfo:p,backend:t});else{const _=new PF(p);m=t.runWebGLProgram(_,[i,r],"float32")}const g=S0({inputs:{x:m},backend:t,attrs:{shape:p.outShape}});return t.disposeIntermediateTensorInfo(m),g}const DQ={kernelName:sA,backendName:"webgl",kernelFunc:OQ};class PQ{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,i=e.strideHeight,r=e.strideWidth,a=e.dataFormat==="channelsLast",s=t-1-e.padInfo.top,l=n-1-e.padInfo.left,c=a?1:2,h=a?2:3,d=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(`+s+", "+l+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[`+d+`];

        ivec2 dyCorner = ivec2(coords[`+c+"], coords["+h+`]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < `+t+`; wR++) {
          float dyR = float(dyRCorner + wR) / `+i+`.0;

          if (dyR < 0.0 || dyR >= `+e.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = `+t+` - 1 - wR;

          for (int wC = 0; wC < `+n+`; wC++) {
            float dyC = float(dyCCorner + wC) / `+r+`.0;

            if (dyC < 0.0 || dyC >= `+e.outWidth+`.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = `+n+` - 1 - wC;

            for (int d2 = 0; d2 < `+e.outChannels+`; d2++) {

              if (`+a+`) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class kQ{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=qn(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,i=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(`+i+", "+r+`);

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < `+t+`; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= `+e.outHeight+`.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = `+t+` - 1 - wR;

          for (int wC = 0; wC < `+n+`; wC++) {
            int wCPerm = `+n+` - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < `+e.outWidth+`.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < `+e.outWidth+`.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < `+e.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < `+e.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < `+e.outChannels+`; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}function UQ(x){const{inputs:e,backend:t,attrs:n}=x,{dy:i,filter:r}=e,{inputShape:a,strides:s,pad:l,dataFormat:c,dimRoundingMode:h}=n,d=kc(c),p=Ur(a,r.shape,s,1,l,h,!1,d);if(Pe().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&d==="channelsLast"){const m=[[p.strideHeight,p.strideWidth]],g=new kQ(p);return t.runWebGLProgram(g,[i,r],"float32",m)}else{const m=new PQ(p);return t.runWebGLProgram(m,[i,r],"float32")}}const FQ={kernelName:oA,backendName:"webgl",kernelFunc:UQ},BQ=pE+`
  return cos(x);
`,LQ=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  `+nd+`
  return result;
`,zQ=ul({opSnippet:BQ,packedOpSnippet:LQ}),VQ={kernelName:lg,backendName:"webgl",kernelFunc:zQ};class HQ{constructor(e,t,n,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,s,l,c]=e,[h]=t,[d,p]=n;this.outputShape=[h,d,p,c];const m=i==="bilinear"?1:0,[g,_]=[s-1+".0",l-1+".0"],[v,b,T]=d>1?[""+(s-1)/(d-1),"(y2-y1) * height_ratio","y1*"+g+" + float(y)*(height_scale)"]:["0.0","0.0","0.5 * (y1+y2) * "+g],[E,A,M]=p>1?[""+(l-1)/(p-1),"(x2-x1) * width_ratio","x1*"+_+" + float(x)*(width_scale)"]:["0.0","0.0","0.5 * (x1+x2) * "+_];this.userCode=`
      const float height_ratio = float(`+v+`);
      const float width_ratio = float(`+E+`);
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= `+a+`) {
          return;
        }

        float height_scale = `+b+`;
        float width_scale = `+A+`;

        float in_y = `+T+`;
        if( in_y < 0.0 || in_y > `+g+` ) {
          setOutput(float(`+r+`));
          return;
        }
        float in_x = `+M+`;
        if( in_x < 0.0 || in_x > `+_+` ) {
          setOutput(float(`+r+`));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(`+m+` == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}const GQ=x=>{const{inputs:e,backend:t,attrs:n}=x,{image:i,boxes:r,boxInd:a}=e,{cropSize:s,method:l,extrapolationValue:c}=n,h=new HQ(i.shape,r.shape,s,l,c);return t.runWebGLProgram(h,[i,r,a],"float32")},WQ={kernelName:lA,backendName:"webgl",kernelFunc:GQ};class XQ{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = `+this.getHeightCoordString()+`;
      int w = `+this.getWidthCoordString()+`;
      int d = `+this.getDepthCoordString()+`;

      int in_h = h / `+t+`;
      int offset_h = imod(h, `+t+`);
      int in_w = w / `+t+`;
      int offset_w = imod(w, `+t+`);
      int offset_d = (offset_h * `+t+` + offset_w) *
        `+this.getOutputDepthSize()+`;
      int in_d = d + offset_d;

      float result = `+this.getInputSamplingString()+`;
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}function YQ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{blockSize:r,dataFormat:a}=n,s=i.shape[0],l=a==="NHWC"?i.shape[1]:i.shape[2],c=a==="NHWC"?i.shape[2]:i.shape[3],h=a==="NHWC"?i.shape[3]:i.shape[1],d=l*r,p=c*r,m=h/(r*r),g=a==="NHWC"?[s,d,p,m]:[s,m,d,p],_=new XQ(g,r,a);return t.runWebGLProgram(_,[i],i.dtype)}const KQ={kernelName:cA,backendName:"webgl",kernelFunc:YQ};class BF{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qn(this.outputShape.length);const a=e.filterHeight,s=e.filterWidth,l=e.outChannels/e.inChannels;let c="",h="";n&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          `+n+`
        }`:r?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          `+n+`
        }`:c=`
          float activation(float x) {
            `+n+`
          }
        `,h="result = activation(result);");const d=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+c+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+l+`;
        int q = d2 - d1 * `+l+`;

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < `+a+`; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < `+s+`; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        `+d+`
        `+h+`
        setOutput(result);
      }
    `}}class LF{constructor(e,t=!1,n=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=qn(this.outputShape.length);const a=e.outChannels/e.inChannels,s=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=d;let m=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let b=0;b<d;b++)m+=`
          vec4 xTexelC`+b*2+`;
          int xTexelC`+b*2+`Ready;
          vec4 xTexelC`+(b*2+1)+`;
          int xTexelC`+(b*2+1)+`Ready;
          vec4 xC`+b+";";m+=`
    for (int r = 0; r < `+h+`; r++) {
      `;for(let b=0;b<d;b++)m+=`
          xTexelC`+b*2+` = vec4(0.0);
          xTexelC`+b*2+`Ready = 0;
          xTexelC`+(b*2+1)+` = vec4(0.0);
          xTexelC`+(b*2+1)+`Ready = 0;
          xC`+b+" = vec4(0.0);";m+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let b=0;b<(p+1)/2;b++){const T=b*2;if(m+=`
          xC = xCCorner + `+T*c+`;
          `,l===1){if(T<d&&(s%2===1?(m+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+T+`Ready == 0) {
                  xTexelC`+T+` = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+T+`.zw = vec2(0.0);
                  }
                  xTexelC`+T+`Ready = 1;
                }
              `,c===1&&T>0?m+=`
                xC`+T+" = vec4(xTexelC"+(T-2)+".zw, xTexelC"+T+`.xy);
                `:m+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC`+T+" = vec4(previous.zw, xTexelC"+T+`.xy);
                  } else {
                    xC`+T+" = vec4(0.0, 0.0, xTexelC"+T+`.xy);
                  }
                  `):m+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC`+T+`Ready == 0) {
                  xTexelC`+T+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+T+`.zw = vec2(0.0);
                  }
                  xTexelC`+T+`Ready = 1;
                }

                xC`+T+" = xTexelC"+T+`;
                `,T+1<d)){const E=s%2===0?jw(c):c;c%2===0&&s%2===1||c%2!==0&&s%2!==1?(m+=`
                  xCOffset = xC + imod(pads[1], 2) + `+E+`;

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(T+1)+`Ready == 0) {
                    xTexelC`+(T+1)+` = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC`+(T+1)+`.zw = vec2(0.0);
                    }
                    xTexelC`+(T+1)+`Ready = 1;
                  }
                  `,c>1?m+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC`+(T+1)+" = vec4(previous.zw, xTexelC"+(T+1)+`.xy);
                    } else {
                     xC`+(T+1)+" = vec4(0.0, 0.0, xTexelC"+(T+1)+`.xy);
                    }
                    `:m+=`
                    xC`+(T+1)+" = vec4(xTexelC"+T+".zw, xTexelC"+(T+1)+`.xy);
                    `):E===1?m+=`
                    xC`+(T+1)+" = xTexelC"+T+`;
                    `:m+=`
                    xCOffset = xC + `+E+`;

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(T+1)+`Ready == 0) {
                      xTexelC`+(T+1)+` = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC`+(T+1)+`.zw = vec2(0.0);
                      }
                      xTexelC`+(T+1)+`Ready = 1;
                    }

                    xC`+(T+1)+" = xTexelC"+(T+1)+`;
                    `}}else T<d&&(s%2===1?(m+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+T+`Ready == 0) {
                  xTexelC`+T+` = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+T+`.zw = vec2(0.0);
                  }
                  xTexelC`+T+`Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC`+(T+1)+`Ready == 0) {
                  xTexelC`+(T+1)+` = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC`+(T+1)+`.zw = vec2(0.0);
                  }
                  xTexelC`+(T+1)+`Ready = 1;
                }

                xC`+T+" = vec4(xTexelC"+T+".zw, xTexelC"+(T+1)+`.zw);
              `,T+1<d&&(m+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC`+(T+1)+" = vec4(xTexelC"+(T+1)+`.xy, final.xy);
                `)):(m+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC`+T+`Ready == 0) {
                  xTexelC`+T+` = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC`+T+`.zw = vec2(0.0);
                  }
                  xTexelC`+T+`Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC`+(T+1)+`Ready == 0) {
                  xTexelC`+(T+1)+` = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC`+(T+1)+`.zw = vec2(0.);
                  }
                  xTexelC`+(T+1)+`Ready = 1;
                }

                xC`+T+` = vec4(
                  xTexelC`+T+".xy, xTexelC"+(T+1)+`.xy);
              `,T+1<d&&(m+=`
                  xC`+(T+1)+" = vec4(xTexelC"+T+".zw, xTexelC"+(T+1)+`.zw);
                `)));T<d&&(m+=`
            wTexel = getW(r, `+T+`, d1, q);
            dotProd += xC`+T+` * vec4(wTexel.xz, wTexel.xz);
          `,T+1<d&&(m+=`
              wTexel = getW(r, `+(T+1)+`, d1, q);
              dotProd += xC`+(T+1)+` * vec4(wTexel.xz, wTexel.xz);
            `))}m+=`
    }
  `,m+=`
      }
    `;let g="",_="";n&&(i?g=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          `+n+`
        }`:r?g=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          `+n+`
        }`:g=`vec4 activation(vec4 x) {
          `+n+`
        }`,_="result = activation(result);");const v=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      `+g+`

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / `+a+`;
        int q = d2 - d1 * `+a+`;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        `+m+`

        vec4 result = dotProd - vec4(0.000000000000001);
        `+v+`
        `+_+`
        setOutput(result);
      }
    `}}function $Q(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r}=e,{strides:a,pad:s,dilations:l,dimRoundingMode:c}=n;let h=l;h==null&&(h=[1,1]),ye(Fr(a,h),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+h+"'");const d=Ur(i.shape,r.shape,a,h,s,c,!0);let p;Pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?p=new LF(d):p=new BF(d);const m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return t.runWebGLProgram(p,[i,r],"float32",m)}const QQ={kernelName:uA,backendName:"webgl",kernelFunc:$Q};function RT(x){const{inputs:e,attrs:t,backend:n}=x,{dim:i}=t,{input:r}=e,a=r.shape.length,s=r.shape.slice();let l=i;return i<0&&(ye(-(a+1)<=i,()=>"Axis must be in the interval ["+-(a+1)+", "+a+"]"),l=a+i+1),s.splice(l,0,1),S0({inputs:{x:r},backend:n,attrs:{shape:s}})}const ZQ={kernelName:hA,backendName:"webgl",kernelFunc:RT};class JQ{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}function yE(x){const{backend:e,attrs:t}=x,{shape:n,value:i}=t;let{dtype:r}=t;if(r=r||Qh(i),r==="string"){const a=fn(r,ut(n));return a.fill(i),e.makeTensorInfo(n,r,a)}else{const a=new JQ(n,i),s=[[i]];return e.runWebGLProgram(a,[],r,s)}}const jQ={kernelName:dA,backendName:"webgl",kernelFunc:yE},uI="return floor(x);",qQ=ul({opSnippet:uI,packedOpSnippet:uI,cpuKernelImpl:JK}),eZ={kernelName:ug,backendName:"webgl",kernelFunc:qQ};class tZ{constructor(e){this.variableNames=["A"];const t=fi(),[n,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(`+i+".0, "+n+`.0);

        vec4 values = `+t.texture2D+`(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}class xZ{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=fi(),[n,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(`+i+".0, "+n+`.0);
            vec4 values = `+t.texture2D+`(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        `+t.output+` = result;
      }
    `}}const nZ={kernelName:QS,backendName:"webgl",kernelFunc:iZ};let pu,A_=Pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function iZ(x){const{inputs:e,backend:t,attrs:n}=x;let{pixels:i}=e;const{numChannels:r}=n,a=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,s=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],h=[c,l],d=[c,l,r];if(s||a){const _=Pe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(pu==null||_!==A_)&&(A_=_,pu=document.createElement("canvas").getContext("2d",{willReadFrequently:A_})),pu.canvas.width=l,pu.canvas.height=c,pu.drawImage(i,0,0,l,c),i=pu.canvas}const p=t.makeTensorInfo(h,"int32");t.texData.get(p.dataId).usage=Nr.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(p.dataId),i);const m=Pe().getBool("WEBGL_PACK")?new xZ(d):new tZ(d),g=t.runWebGLProgram(m,[p],"int32");return t.disposeData(p.dataId),g}function rZ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r,bias:a,preluActivationWeights:s}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=n,_=kc(h),v=Ur(i.shape,r.shape,l,d,c,p,!1,_);let b;const T=[],E=a!=null,A=s!=null,M=m==="leakyrelu",R=()=>{const k=[i,r],P=(N,G)=>{if(G==="NCHW"&&N.shape.length===1&&N.shape[0]!==1){const te=S0({inputs:{x:N},backend:t,attrs:{shape:[N.shape[0],1,1]}});return T.push(te),te}return N};if(E&&k.push(P(a,h)),A&&k.push(P(s,h)),M){const N=t.makeTensorInfo([],"float32",dp(g,"float32"));k.push(N),T.push(N)}return k};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))b=UF({x:i,filter:r,convInfo:v,backend:t,bias:a,activation:m,preluActivationWeights:s,leakyreluAlpha:g});else if(v.strideWidth<=2&&_==="channelsLast"&&Pe().getBool("WEBGL_EXP_CONV")){const k=m?Qf(m,!0):null,P=new kF(v,E,k,A,M),N=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],G=R();b=t.runWebGLProgram(P,G,"float32",N)}else if(Pe().getBool("WEBGL_CONV_IM2COL"))b=FF({x:i,filter:r,convInfo:v,backend:t,bias:a,activation:m,preluActivationWeights:s,leakyreluAlpha:g});else{const k=m?Qf(m,!1):null,P=new PF(v,E,k,A,M),N=R();b=t.runWebGLProgram(P,N,"float32")}const C=S0({inputs:{x:b},backend:t,attrs:{shape:v.outShape}});return T.push(b),T.forEach(k=>t.disposeIntermediateTensorInfo(k)),C}const aZ={kernelName:S1,backendName:"webgl",kernelFunc:rZ};function sZ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r,bias:a,preluActivationWeights:s}=e,{strides:l,pad:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:m}=n,g=[];let _=h;_==null&&(_=[1,1]),ye(Fr(l,_),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+l+" and dilations '"+_+"'");const v=Ur(i.shape,r.shape,l,_,c,d,!0),b=Pe().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,T=p?Qf(p,b):null,E=[i,r],A=a!=null,M=s!=null,R=p==="leakyrelu";if(A&&E.push(a),M&&E.push(s),R){const N=t.makeTensorInfo([],"float32",dp(m,"float32"));E.push(N),g.push(N)}let C;b?C=new LF(v,A,T,M,R):C=new BF(v,A,T,M,R);const k=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],P=t.runWebGLProgram(C,E,"float32",k);return g.forEach(N=>t.disposeIntermediateTensorInfo(N)),P}const oZ={kernelName:T1,backendName:"webgl",kernelFunc:sZ};class lZ{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=di(this.rank),i=cZ(e);this.userCode=`
      void main() {
        `+n+` resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < `+e[2]+`) ? 1.0 : 0.0;
        setOutput(inBounds * getA(`+i+`));
      }
    `}}function cZ(x,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let i=0;i<x.length;i++)i===2?n.push("index"):n.push(""+t[i]);return n.join()}function uZ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,indices:r}=e,{axis:a,batchDims:s}=n,l=Ri(a,i.shape)[0];if(Pe().get("DEBUG")){const T=t.readSync(r.dataId),E=i.shape[l];for(let A=0;A<T.length;++A){const M=T[A];ye(M<=E-1&&M>=0,()=>"GatherV2: the index value "+M+" is not in [0, "+(E-1)+"]")}}const c=tE(i,r,l,s),h=ut(r.shape),d=[],p=S0({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),m=S0({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,h/c.batchSize]}});d.push(p),d.push(m);const g=[c.batchSize,c.outerSize,h/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const T=t.bufferSync(m),E=t.bufferSync(p),A=jK(E,T,g);return d.forEach(M=>t.disposeIntermediateTensorInfo(M)),t.makeTensorInfo(c.outputShape,A.dtype,A.values)}const _=new lZ(p.shape,g),v=t.runWebGLProgram(_,[p,m],p.dtype);d.push(v);const b=S0({inputs:{x:v},backend:t,attrs:{shape:c.outputShape}});return d.forEach(T=>t.disposeIntermediateTensorInfo(T)),b}const hZ={kernelName:fA,backendName:"webgl",kernelFunc:uZ},dZ="return float(a >= b);",fZ=`
  return vec4(greaterThanEqual(a, b));
`,pZ=Lr({opSnippet:dZ,packedOpSnippet:fZ,dtype:"bool",cpuKernelImpl:qK}),mZ={kernelName:hg,backendName:"webgl",kernelFunc:pZ},yZ="return float(a < b);",gZ=`
  return vec4(lessThan(a, b));
`,vZ=Lr({opSnippet:yZ,packedOpSnippet:gZ,cpuKernelImpl:e$,dtype:"bool"}),bZ={kernelName:pA,backendName:"webgl",kernelFunc:vZ},_Z="return float(a <= b);",SZ=`
  return vec4(lessThanEqual(a, b));
`,TZ=Lr({opSnippet:_Z,packedOpSnippet:SZ,cpuKernelImpl:t$,dtype:"bool"}),wZ={kernelName:fg,backendName:"webgl",kernelFunc:TZ},AZ="return float(a >= 1.0 && b >= 1.0);",EZ=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,MZ=Lr({opSnippet:AZ,packedOpSnippet:EZ,dtype:"bool"}),RZ={kernelName:pg,backendName:"webgl",kernelFunc:MZ},CZ="return float(a >= 1.0 || b >= 1.0);",NZ=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,IZ=Lr({opSnippet:CZ,packedOpSnippet:NZ,dtype:"bool"}),OZ={kernelName:mA,backendName:"webgl",kernelFunc:IZ};function DZ(x,e,t,n){const i=ut(e),r=ut(x.shape)/i,a=S0({inputs:{x},attrs:{shape:[r,i]},backend:n}),s=Bg(a,x.dtype,"max",n),l=S0({inputs:{x:s},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),l}function PZ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{reductionIndices:r,keepDims:a}=n,s=i.shape.length,l=Ri(r,i.shape);let c=l;const h=ol(c,s),d=h!=null,p=t.shouldExecuteOnCPU([i]);let m=i;if(d){if(p){const T=t.texData.get(m.dataId).values,E=new Array(s);for(let R=0;R<E.length;R++)E[R]=i.shape[h[R]];const A=hE(T,i.shape,i.dtype,h,E);m=t.makeTensorInfo(E,i.dtype);const M=t.texData.get(m.dataId);M.values=A}else m=Lg(i,h,t);c=ll(c.length,s)}sl("max",c,s);const[g,_]=Is(m.shape,c);let v=g;a&&(v=Ho(g,l));let b;if(p){const T=t.texData.get(m.dataId).values,E=x$(T,ut(_),v,i.dtype);b=t.makeTensorInfo(v,i.dtype);const A=t.texData.get(b.dataId);A.values=E}else b=DZ(m,_,v,t);return d&&t.disposeIntermediateTensorInfo(m),b}const kZ={kernelName:yA,backendName:"webgl",kernelFunc:PZ};function UZ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e;GU(i,"maxPool");const{filterSize:r,strides:a,pad:s,dimRoundingMode:l}=n,c=1;ye(Fr(a,c),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+c+"'");const h=yp(i.shape,r,a,c,s,l);if(h.filterWidth===1&&h.filterHeight===1&&Zx(h.inShape,h.outShape))return _a({inputs:{x:i},backend:t});const d=new MF(h,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const FZ={kernelName:gA,backendName:"webgl",kernelFunc:UZ},BZ=dE+`
  return max(a, b);
`,LZ=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nd+`
  return result;
`,zZ=Lr({opSnippet:BZ,packedOpSnippet:LZ,cpuKernelImpl:n$}),VZ={kernelName:mg,backendName:"webgl",kernelFunc:zZ};function HZ(x,e,t,n){const i=ut(e),r=ut(x.shape)/i,a=S0({inputs:{x},attrs:{shape:[r,i]},backend:n}),s=Bg(a,"float32","mean",n),l=S0({inputs:{x:s},attrs:{shape:t},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(s),l}const GZ={kernelName:vA,backendName:"webgl",kernelFunc:({inputs:x,attrs:e,backend:t})=>{const{x:n}=x,{keepDims:i,axis:r}=e,a=t,s=n.shape.length,l=Ri(r,n.shape);let c=l;const h=ol(c,s),d=h!=null,p=a.shouldExecuteOnCPU([n]),m=[];let g=n;if(d){if(p){const E=a.texData.get(g.dataId).values,A=new Array(s);for(let C=0;C<A.length;C++)A[C]=n.shape[h[C]];const M=hE(E,n.shape,n.dtype,h,A);g=a.makeTensorInfo(A,n.dtype);const R=a.texData.get(g.dataId);R.values=M}else g=Lg(n,h,a);m.push(g),c=ll(c.length,s)}sl("sum",c,s);const[_,v]=Is(g.shape,c);let b=_;i&&(b=Ho(_,l));const T=HZ(g,v,b,a);for(const E of m)a.disposeIntermediateTensorInfo(E);return T}};function WZ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{axis:r,keepDims:a}=n,s=i.shape.length,l=Ri(r,i.shape);let c=l;const h=ol(c,s);let d=i;h!=null&&(d=D1({inputs:{x:i},backend:t,attrs:{perm:h}}),c=ll(c.length,i.shape.length)),sl("min",c,s);const[p,m]=Is(d.shape,c),g=ut(m),_=S0({inputs:{x:d},backend:t,attrs:{shape:[-1,g]}}),v=Bg(_,_.dtype,"min",t);let b;if(a){const T=Ho(p,l);b=S0({inputs:{x:v},backend:t,attrs:{shape:T}})}else b=S0({inputs:{x:v},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(_),t.disposeIntermediateTensorInfo(v),h!=null&&t.disposeIntermediateTensorInfo(d),b}const XZ={kernelName:bA,backendName:"webgl",kernelFunc:WZ},YZ=dE+`
  return min(a, b);
`,KZ=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+nd+`
  return result;
`,$Z=Lr({opSnippet:YZ,packedOpSnippet:KZ,cpuKernelImpl:i$}),QZ={kernelName:yg,backendName:"webgl",kernelFunc:$Z},ZZ=_p+`
  return -x;
`,JZ=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function jZ(x){const{inputs:e,backend:t}=x,{x:n}=e;if(t.shouldExecuteOnCPU([n])){const r=t.texData.get(n.dataId),[a,s]=a$(r.values,n.shape,n.dtype);return t.makeTensorInfo(s,n.dtype,a)}let i;return Pe().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new H2(n.shape,JZ):i=new No(n.shape,ZZ),t.runWebGLProgram(i,[n],n.dtype)}const qZ={kernelName:_A,backendName:"webgl",kernelFunc:jZ};function eJ(x){const{inputs:e,backend:t,attrs:n}=x,{axis:i}=n;if(e.length===1)return RT({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,a=e[0].dtype;e.forEach(h=>{qw(r,h.shape,"All tensors passed to stack must have matching shapes"),ye(a===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const s=[],l=e.map(h=>{const d=RT({inputs:{input:h},backend:t,attrs:{dim:i}});return s.push(d),d}),c=DF({inputs:l,backend:t,attrs:{axis:i}});return s.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const tJ={kernelName:SA,backendName:"webgl",kernelFunc:eJ};class xJ{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,h)=>c[0]+e[h]+c[1]);const i=e.length,r=di(i),a=t.map(c=>c[0]).join(","),s=t.map((c,h)=>c[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = `+a+`;
        int end = `+s+`;

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      `+r+" start = "+r+"("+a+`);
      `+r+" end = "+r+"("+s+`);

      void main() {
        `+r+` outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          `+r+` coords = outC - start;
          setOutput(getX(`+l+`));
        }
      }
    `}}class nJ{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((_,v)=>_[0]+e[v]+_[1]);const i=e.length,r=di(i),a=t.map(_=>_[0]).join(","),s=t.map((_,v)=>_[0]+e[v]).join(","),l=tl("rc",i),c=tl("source",i),h=l[i-1]+" < "+this.outputShape[i-1],d=i===1?"source":"vec2("+c.slice(-2).join()+")",p=[r+" rc = outputLoc;",l[i-1]+` += 1;
       if(`+h+`) {
      `,i===1?"":`}
       rc = outputLoc;
       `+l[i-2]+` += 1;
       if(`+l[i-2]+" < "+this.outputShape[i-2]+") {",i===1?"":"  "+l[i-1]+` += 1;
         if(`+h+") {"],m=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let g="";for(let _=0,v=i===1?2:4;_<v;_++)g+=`
        `+p[_]+`
        if (`+m+`) {
          result[`+_+`] = float(value);
        } else {
          `+r+` source = rc - start;
          result[`+_+"] = getChannel(getX("+c.join()+"), "+d+`);
        }
      `;g+=i===1?"} ":"}}",this.userCode=`
      const `+r+" start = "+r+"("+a+`);
      const `+r+" end = "+r+"("+s+`);

      void main() {
        `+r+` outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        `+g+`
        setOutput(result);
      }
    `}}const iJ=x=>{const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{paddings:r,constantValue:a}=n;if(ut(i.shape)===0){const c=r.map((h,d)=>h[0]+i.shape[d]+h[1]);return yE({backend:t,attrs:{shape:c,value:a,dtype:i.dtype}})}const s=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nJ(i.shape,r,a):new xJ(i.shape,r,a),l=[[a]];return t.runWebGLProgram(s,[i],i.dtype,l)},rJ={kernelName:TA,backendName:"webgl",kernelFunc:iJ},aJ=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,sJ=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+nd+`
  return result;
`,oJ=Lr({opSnippet:aJ,packedOpSnippet:sJ}),lJ={kernelName:vg,backendName:"webgl",kernelFunc:oJ},cJ=x=>{const{backend:e,attrs:t}=x,{start:n,stop:i,step:r,dtype:a}=t,s=o$(n,i,r,a);return e.makeTensorInfo([s.length],a,s)},uJ={kernelName:AA,backendName:"webgl",kernelFunc:cJ},hJ=`
if (a == b) {
  return 1.0;
};
return a / b;`,dJ=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,fJ=Lr({opSnippet:hJ,packedOpSnippet:dJ,checkOutOfBounds:!0}),pJ={kernelName:cg,backendName:"webgl",kernelFunc:fJ},mJ=_p+`
  return (x < 0.0) ? 0.0 : x;
`,yJ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,gJ=ul({opSnippet:mJ,packedOpSnippet:yJ}),vJ={kernelName:bg,backendName:"webgl",kernelFunc:gJ},bJ=_p+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,_J=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,SJ=ul({opSnippet:bJ,packedOpSnippet:_J}),TJ={kernelName:_g,backendName:"webgl",kernelFunc:SJ};class wJ{constructor(e,t,n,i,r){this.variableNames=["A"],this.outputShape=[];const[a,s,l,c]=e;this.outputShape=[a,t,n,c];const h=[i&&t>1?s-1:s,i&&n>1?l-1:l],d=[i&&t>1?t-1:t,i&&n>1?n-1:n];let p;r?p="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          `+h[0]/d[0]+`,
          `+h[1]/d[1]+`);
      const vec2 inputShapeRC = vec2(`+s+".0, "+l+`.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = `+p+`;

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}class AJ{constructor(e,t,n,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,s,l,c]=e;this.outputShape=[a,t,n,c];const h=[i&&t>1?s-1:s,i&&n>1?l-1:l],d=[i&&t>1?t-1:t,i&&n>1?n-1:n];let p;r?p="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          `+h[0]/d[0]+`,
          `+h[1]/d[1]+`,
          `+h[1]/d[1]+`);
      const vec3 inputShapeRC = vec3(`+s+".0, "+l+`.0,
                                     `+l+`.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = `+p+`;

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < `+(c-1)+`;
        bool hasNextRow = coords.z < `+(n-1)+`;

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}function EJ(x){const{inputs:e,backend:t,attrs:n}=x,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:s}=n,[l,c]=s,h=Pe().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new AJ(i.shape,l,c,r,a):new wJ(i.shape,l,c,r,a);return t.runWebGLProgram(h,[i],"float32")}const MJ={kernelName:MA,backendName:"webgl",kernelFunc:EJ};class RJ{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],i=e[2];this.outputShape=e;let r="";typeof t=="number"?r="float outputValue = "+t.toFixed(2)+";":r=`
        vec3 fill = vec3(`+t.join(",")+`);
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          `+r+`
          if(coordX >= 0 && coordX < `+i+" && coordY >= 0 && coordY < "+n+`) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}const CJ={kernelName:DA,backendName:"webgl",kernelFunc:({inputs:x,attrs:e,backend:t})=>{const{image:n}=x,{radians:i,fillValue:r,center:a}=e,s=t,l=new RJ(n.shape,r),[c,h]=eE(a,n.shape[1],n.shape[2]),d=[[c,h,Math.sin(i),Math.cos(i)]];return s.runWebGLProgram(l,[n],n.dtype,d)}},NJ=pE+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,IJ=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,OJ=ul({opSnippet:NJ,packedOpSnippet:IJ,cpuKernelImpl:l$}),DJ={kernelName:Tg,backendName:"webgl",kernelFunc:OJ},PJ=pE+`
  return sin(x);
`,kJ=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  `+nd+`
  return result;
`,UJ=ul({opSnippet:PJ,packedOpSnippet:kJ}),FJ={kernelName:Sg,backendName:"webgl",kernelFunc:UJ};class BJ{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=di(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=LJ(this.rank);let i;const r=e.map((a,s)=>"sourceLoc."+CT[s]+" = start["+s+"] + coords."+CT[s]+";");i=`
        `+t+` sourceLoc;
        `+t+` coords = getOutputCoords();
        `+r.join(`
`)+`
      `,this.userCode=`
      void main() {
        `+i+`
        setOutput(getSource(`+n+`));
      }
    `}}const CT=["x","y","z","w","u","v"];function LJ(x){if(x===1)return"sourceLoc";if(x<=6)return CT.slice(0,x).map(e=>"sourceLoc."+e).join(",");throw Error("Slicing for rank "+x+" is not yet supported")}class zJ{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=di(this.rank),n=tl("coords",this.rank),i=tl("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":"vec2("+i.slice(-2).join()+")",a="getChannel(getSource("+i.join()+"), "+r+")",s=`
      result.x = `+a+`;
      if (++`+n[this.rank-1]+" < "+e[this.rank-1]+`) {
        ++`+i[this.rank-1]+`;
        result.y = `+a+`;
        --`+i[this.rank-1]+`;
      }
    `,l=this.rank===1?"":`
      --`+n[this.rank-1]+`;
      if (++`+n[this.rank-2]+" < "+e[this.rank-2]+`) {
        ++`+i[this.rank-2]+`;
        result.z = `+a+`;
        if (++`+n[this.rank-1]+" < "+e[this.rank-1]+`) {
          ++`+i[this.rank-1]+`;
          result.w = `+a+`;
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            `+t+"("+e.map((h,d)=>"start["+d+"]").join()+");":e.map((h,d)=>i[d]+" = "+n[d]+" + start["+d+"];").join(`
`);this.userCode=`
      void main() {
        `+t+` coords = getOutputCoords();
        `+t+` sourceLoc;
        `+c+`
        vec4 result = vec4(0.);
        `+s+`
        `+l+`
        setOutput(result);
      }
    `}}function VJ(x,e,t,n){const i=n.texData.get(x.dataId),r=n.makeTensorInfo(t,x.dtype),a=n.texData.get(r.dataId);Object.assign(a,i),a.refCount=1,a.shape=t,a.dtype=x.dtype;let s=GA(e,M0(x.shape));i.slice&&(s+=i.slice.flatOffset),a.slice={flatOffset:s,origDataId:i.slice&&i.slice.origDataId||x.dataId};const l=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,l+1),r}function zF(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{begin:r,size:a}=n,[s,l]=WA(i,r,a);if(zA(i,s,l),ut(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const d=t.texData.get(i.dataId),p=c$(d.values,s,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,p)}const{isPacked:c}=t.texData.get(i.dataId),h=HA(i.shape,s,l);if(c||!h){const d=Pe().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new zJ(l):new BJ(l),p=[s];return t.runWebGLProgram(d,[i],i.dtype,p)}return t.uploadToGPU(i.dataId),VJ(i,s,l,t)}const HJ={kernelName:RA,backendName:"webgl",kernelFunc:zF},hI="return sqrt(x);",GJ=ul({opSnippet:hI,packedOpSnippet:hI,cpuKernelImpl:u$}),WJ={kernelName:wg,backendName:"webgl",kernelFunc:GJ},XJ="return x * x;",YJ=ul({opSnippet:XJ}),KJ={kernelName:nk,backendName:"webgl",kernelFunc:YJ};class $J{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const i=n.length,r=di(n.length),a=di(n.length);let s="";if(i===1)s="coords * strides + begin";else{let l=0;s=n.map((c,h)=>(l++,n.length===1?"coords * strides["+h+"] + begin["+h+"]":"coords["+(l-1)+"] * strides["+h+"] + begin["+h+"]")).join(",")}this.userCode=`
      `+r+" begin = "+r+"("+e+`);
      `+r+" strides = "+r+"("+t+`);

      void main() {
        `+a+` coords = getOutputCoords();
        setOutput(getX(`+s+`));
      }
    `}}function QJ(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{begin:r,end:a,strides:s,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=n,{finalShapeSparse:m,finalShape:g,isIdentity:_,sliceDim0:v,isSimpleSlice:b,begin:T,end:E,strides:A}=XA(i.shape,r,a,s,l,c,h,d,p);let M;if(_)M=S0({inputs:{x:i},backend:t,attrs:{shape:g}});else if(v||b){ye(i.shape.length>=1,()=>"Input must have rank at least 1, got: "+i.shape.length);const C=VA(T,E,A),k=zF({inputs:{x:i},backend:t,attrs:{begin:T,size:C}});M=S0({inputs:{x:k},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(k)}else if(t.shouldExecuteOnCPU([i])){const C=t.readSync(i.dataId),k=kx(i.shape,i.dtype,C),P=h$(m,k,A,T);M=t.makeTensorInfo(g,i.dtype,P.values)}else{const C=new $J(T,A,m);M=t.runWebGLProgram(C,[i],i.dtype)}const R=S0({inputs:{x:M},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(M),R}const ZJ={kernelName:NA,backendName:"webgl",kernelFunc:QJ},dI="return a - b;",JJ=Lr({opSnippet:dI,packedOpSnippet:dI,supportsComplex:!0,cpuKernelImpl:d$}),jJ={kernelName:Ag,backendName:"webgl",kernelFunc:JJ};class qJ{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let a=0;a<n.length;a++)n[a]=e[a]*t[a];this.outputShape=n,this.rank=n.length;const i=di(this.rank),r=ej(e);this.userCode=`
      void main() {
        `+i+` resRC = getOutputCoords();
        setOutput(getA(`+r+`));
      }
    `}}function ej(x){const e=x.length;if(e>5)throw Error("Tile for rank "+e+" is not yet supported");if(e===1)return"imod(resRC, "+x[0]+")";const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let i=0;i<x.length;i++)n.push("imod("+t[i]+", "+x[i]+")");return n.join()}function tj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{reps:r}=n;if(i.dtype==="string"||i.shape.length>5){const s=t.readSync(i.dataId),l=i.dtype==="string"?s.map(d=>Sh(d)):s,c=kx(i.shape,i.dtype,l),h=f$(c,r);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const a=new qJ(i.shape,r);return t.runWebGLProgram(a,[i],i.dtype)}const xj={kernelName:Eg,backendName:"webgl",kernelFunc:tj};class nj{constructor(e,t,n,i,r,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const s=n==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(`+l+` == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+l+` == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (`+l+` == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < `+e+" && 0 <= coordX && coordX < "+t+`) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(`+r+`);
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(`+r+`);
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(`+t+`));
                float mapY = mapCoord(inY, float(`+e+`));

                if (`+s+` == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}function ij(x){const{inputs:e,backend:t,attrs:n}=x,{image:i,transforms:r}=e,{interpolation:a,fillMode:s,fillValue:l,outputShape:c}=n,[h,d,p,m]=i.shape,[g,_]=c??[d,p],v=[h,g,_,m],b=new nj(d,p,a,s,l,v);return t.runWebGLProgram(b,[i,r],"float32")}const rj={kernelName:IA,backendName:"webgl",kernelFunc:ij};function NT(x){const{inputs:e,backend:t}=x,{x:n}=e;if(n.dtype==="complex64"){const i=mE({inputs:{input:n},backend:t}),r=NT({inputs:{x:i},backend:t}),a=OF({inputs:{input:n},backend:t}),s=NT({inputs:{x:a},backend:t}),l=Tp({inputs:{real:r,imag:s},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(s),l}else return yE({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:t})}const aj={kernelName:OA,backendName:"webgl",kernelFunc:NT};function sj(x){const{inputs:e,backend:t,attrs:n}=x,{a:i,b:r,bias:a,preluActivationWeights:s}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=n;return P1({a:i,b:r,transposeA:l,transposeB:c,backend:t,bias:a,preluActivationWeights:s,leakyreluAlpha:d,activation:h})}const oj={kernelName:_1,backendName:"webgl",kernelFunc:sj},lj=bU;class U1 extends Jw{nextDataId(){return U1.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new QP(this,ua())}write(e,t,n){this.firstUse&&(this.firstUse=!1,Pe().get("IS_NODE")&&wo(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:n,refCount:1}),i}makeTensorInfo(e,t,n){let i;if(t==="string"&&n!=null&&n.length>0&&cp(n[0])){const r=n.map(a=>X2(a));i=this.write(r,e,t)}else i=this.write(n,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,n,i,r){this.data.set(e,{values:t,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if(t==="complex64"){const i=this.readSync(n.real.dataId),r=this.readSync(n.imag.dataId);return Mh(i,r)}return G5(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const n=t.map(i=>Sh(i));return kx(e.shape,e.dtype,n)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return kx(e.shape,e.dtype,t)}makeOutput(e,t,n){return ua().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);n!=null&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Ar();return e(),{kernelMs:Ar()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Rx([e],"where");const t=this.readSync(e.dataId);return lj(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}U1.nextDataId=0,Ak("cpu",()=>new U1,1);function cj(x){const{inputs:e,backend:t}=x,n=e;Rx(e,"addN");const i=n.map(s=>t.data.get(s.dataId).values),r=kx(n[0].shape,n[0].dtype),a=r.values;for(let s=0;s<n.length;s++){const l=i[s];for(let c=0;c<a.length;c++)a[c]+=l[c]}return t.makeTensorInfo(r.shape,r.dtype,r.values)}const uj={kernelName:nA,backendName:"cpu",kernelFunc:cj},hj=nn((x,e)=>Math.atan2(x,e)),dj=Br(ag,hj),fj={kernelName:ag,backendName:"cpu",kernelFunc:dj};function VF(x,e,t,n,i,r){const a=i.strideHeight,s=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,h=i.effectiveFilterHeight,d=i.effectiveFilterWidth,p=i.padInfo.top,m=i.padInfo.left,g=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,_=kx(i.outShape,t),v=_.values,b=i.outShape[1]*i.outShape[2]*i.outShape[3],T=i.outShape[2]*i.outShape[3],E=i.outShape[3];for(let A=0;A<i.batchSize;++A){const M=A*b,R=A*n[0];for(let C=0;C<i.inChannels;++C)for(let k=0;k<i.outHeight;++k){const P=k*a-p,N=Math.max(0,P),G=Math.min(i.inHeight,h+P),te=M+k*T;for(let j=0;j<i.outWidth;++j){const xe=j*s-m,ae=Math.max(0,xe),H=Math.min(i.inWidth,d+xe);let re=g,q=0,be=0;for(let se=N;se<G;se+=l){const ge=R+se*n[1];for(let Me=ae;Me<H;Me+=c){const le=ge+Me*n[2],Se=x[le+C];r==="max"&&Se>re?re=Se:r==="avg"&&(q+=Se,be++)}if(isNaN(re))break}const K=te+j*E+C;v[K]=r==="avg"?q/be:re}}}return _}function pj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e;Rx(i,"avgPool");const{filterSize:r,strides:a,pad:s,dimRoundingMode:l}=n,c=1;ye(Fr(a,c),()=>"Error in avgPool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+c+"'");const h=yp(i.shape,r,a,c,s,l);let d;if(h.filterWidth===1&&h.filterHeight===1&&Zx(h.inShape,h.outShape))d=el({inputs:{x:i},backend:t});else{const p=t.data.get(i.dataId).values,m=M0(i.shape),g=VF(p,i.shape,i.dtype,m,h,"avg");d=t.makeTensorInfo(h.outShape,i.dtype,g.values)}return d}const mj={kernelName:iA,backendName:"cpu",kernelFunc:pj};function Dr(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{shape:r}=n,a=ut(i.shape),s=ZP(r,a),l=ut(s);ye(a===l,()=>"The new shape ("+s+") has "+l+" elements and the old shape ("+i.shape+") has "+a+" elements. The new shape and old shape must have the same number of elements."),t.incRef(i.dataId);const c=t.data.get(i.dataId);if(c.complexTensorInfos!=null){const h=c.complexTensorInfos.real,d=c.complexTensorInfos.imag;h.shape=s,d.shape=s}return{dataId:i.dataId,shape:s,dtype:i.dtype}}const yj={kernelName:EA,backendName:"cpu",kernelFunc:Dr};function HF(x){const{inputs:e,backend:t,attrs:n}=x,{a:i,b:r}=e,{transposeA:a,transposeB:s}=n;Rx([i,r],"matMul");const l=i.shape.length,c=r.shape.length,h=a?i.shape[l-2]:i.shape[l-1],d=s?r.shape[c-1]:r.shape[c-2],p=a?i.shape[l-1]:i.shape[l-2],m=s?r.shape[c-2]:r.shape[c-1],g=i.shape.slice(0,-2),_=r.shape.slice(0,-2),v=ut(g),b=ut(_),T=tn(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([p,m]);ye(h===d,()=>"Error in matMul: inner shapes ("+h+") and ("+d+") of Tensors with shapes "+i.shape+" and "+r.shape+" and transposeA="+a+" and transposeB="+s+" must match.");const E=a?[v,h,p]:[v,p,h],A=s?[b,m,d]:[b,d,m],M=Dr({inputs:{x:i},backend:t,attrs:{shape:E}}),R=Dr({inputs:{x:r},backend:t,attrs:{shape:A}}),C=a?M.shape[1]:M.shape[2],k=a?M.shape[2]:M.shape[1],P=s?R.shape[1]:R.shape[2],N=Math.max(v,b),G=t.data.get(M.dataId).values,te=t.data.get(R.dataId).values,j=M0(M.shape),xe=M0(R.shape),[ae,H,re]=a?[j[0],1,j[1]]:[j[0],j[1],1],[q,be,K]=s?[1,xe[1],xe[0]]:[xe[1],1,xe[0]],se=k*P,ge=kx([N,k,P],M.dtype),Me=ge.values,le=t.blockSize;for(let Se=0;Se<N;Se++){const Fe=Se%v,Qe=Se%b;for(let qe=0;qe<k;qe+=le){const Et=Math.min(qe+le,k);for(let Tt=0;Tt<P;Tt+=le){const Bt=Math.min(Tt+le,P);for(let Q=0;Q<C;Q+=le){const rt=Math.min(Q+le,C);for(let He=qe;He<Et;He++)for(let at=Tt;at<Bt;at++){let Ue=0;for(let bt=Q;bt<rt;bt++){const ht=G[Fe*ae+He*H+bt*re],dt=te[bt*q+at*be+Qe*K];Ue+=ht*dt}Me[Se*se+(He*P+at)]+=Ue}}}}}return t.disposeIntermediateTensorInfo(M),t.disposeIntermediateTensorInfo(R),t.makeTensorInfo(T,ge.dtype,ge.values)}const gj={kernelName:rA,backendName:"cpu",kernelFunc:HF},vj=cl(og,(x,e)=>{const t=e;return x>t.clipValueMax?t.clipValueMax:x<t.clipValueMin?t.clipValueMin:x}),bj={kernelName:og,backendName:"cpu",kernelFunc:vj};function GF(x){const{inputs:e,backend:t}=x,{input:n}=e,i=t.data.get(n.dataId).complexTensorInfos.imag,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}function F1(x){const{inputs:e,backend:t,attrs:n}=x,{axis:i}=n,r=Ri(i,e[0].shape)[0],a=e.map(_=>_.shape);jA(a,r);let s=As(e.map(_=>_.shape),r);if(ut(s)===0)return t.makeTensorInfo(s,e[0].dtype,[]);const l=e.filter(_=>ut(_.shape)>0);if(l.length===1)return el({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const _=l.map(A=>sE({inputs:{input:A},backend:t})),v=l.map(A=>GF({inputs:{input:A},backend:t})),b=F1({inputs:_,backend:t,attrs:{axis:r}}),T=F1({inputs:v,backend:t,attrs:{axis:r}}),E=bp({inputs:{real:b,imag:T},backend:t});return _.forEach(A=>t.disposeIntermediateTensorInfo(A)),v.forEach(A=>t.disposeIntermediateTensorInfo(A)),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(T),E}const c=l.map(_=>{const v=[-1,ut(_.shape.slice(r))];return Dr({inputs:{x:_},backend:t,attrs:{shape:v}})}),h=c.map(_=>({vals:t.data.get(_.dataId).values,shape:_.shape}));s=As(c.map(_=>_.shape),1);const d=c[0].shape[0]===1,p=iF(h,s,e[0].dtype,d),m=As(l.map(_=>_.shape),r),g=t.makeTensorInfo(m,e[0].dtype,p);return c.forEach(_=>t.disposeIntermediateTensorInfo(_)),g}const _j={kernelName:aA,backendName:"cpu",kernelFunc:F1};function WF(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r}=e,{strides:a,pad:s,dataFormat:l,dilations:c,dimRoundingMode:h}=n;Rx([i,r],"conv2d");const d=kc(l),p=Ur(i.shape,r.shape,a,c,s,h,!1,d),m=p.filterHeight,g=p.filterWidth,_=p.dilationHeight,v=p.dilationWidth,b=p.padInfo.left,T=p.padInfo.top,E=p.dataFormat==="channelsLast",A=new vc(p.outShape,i.dtype),M=M0(i.shape),R=M0(r.shape),C=M[0],k=E?M[1]:M[2],P=E?M[2]:1,N=E?1:M[1],G=A.strides[0],te=E?A.strides[1]:A.strides[2],j=E?A.strides[2]:1,xe=E?1:A.strides[1],ae=t.data.get(i.dataId).values,H=t.data.get(r.dataId).values,re=A.values;for(let q=0;q<p.batchSize;++q){const be=q*C,K=q*G;for(let se=0;se<p.outHeight;++se){const ge=K+se*te,Me=se*p.strideHeight-T;for(let le=0;le<m;++le){const Se=Me+le*_;if(Se<0||Se>=p.inHeight)continue;const Fe=le*R[0],Qe=be+Se*k;for(let qe=0;qe<p.outWidth;++qe){const Et=ge+qe*j,Tt=qe*p.strideWidth-b;for(let Bt=0;Bt<g;++Bt){const Q=Tt+Bt*v;if(Q<0||Q>=p.inWidth)continue;const rt=Fe+Bt*R[1],He=Qe+Q*P;let at=rt;for(let Ue=0;Ue<p.inChannels;++Ue){const bt=ae[He+Ue*N];for(let ht=0;ht<p.outChannels;++ht)re[Et+ht*xe]+=bt*H[at+ht];at+=p.outChannels}}}}}}return t.makeTensorInfo(A.shape,A.dtype,re)}const Sj={kernelName:sA,backendName:"cpu",kernelFunc:WF};function Tj(x){const{inputs:e,backend:t,attrs:n}=x,{dy:i,filter:r}=e,{inputShape:a,strides:s,pad:l,dataFormat:c,dimRoundingMode:h}=n;Rx([i,r],"conv2dBackpropInput");const d=M0(r.shape),p=M0(i.shape);let m=kc(c);const g=Ur(a,r.shape,s,1,l,h,!1,m),_=new vc(g.inShape,"float32"),v=_.values,b=t.data.get(i.dataId).values,T=t.data.get(r.dataId).values,[E,A,M]=d,{batchSize:R,filterHeight:C,filterWidth:k,inChannels:P,inHeight:N,inWidth:G,outChannels:te,outHeight:j,outWidth:xe,strideHeight:ae,strideWidth:H}=g;m=g.dataFormat;const re=C-1-g.padInfo.top,q=k-1-g.padInfo.left,be=m==="channelsLast",K=_.strides[0],se=be?_.strides[1]:_.strides[2],ge=be?_.strides[2]:1,Me=be?1:_.strides[1],le=p[0],Se=be?p[1]:p[2],Fe=be?p[2]:1,Qe=be?1:p[1];for(let qe=0;qe<R;++qe)for(let Et=0;Et<P;++Et)for(let Tt=0;Tt<N;++Tt){const Bt=Tt-re,Q=Math.max(0,Math.ceil(Bt/ae)),rt=Math.min(j,(C+Bt)/ae);for(let He=0;He<G;++He){const at=He-q,Ue=Math.max(0,Math.ceil(at/H)),bt=Math.min(xe,(k+at)/H);let ht=0;for(let Z=Q;Z<rt;++Z){const V=Z*ae-Bt;for(let _e=Ue;_e<bt;++_e){const Ge=_e*H-at,Re=le*qe+Se*Z+Fe*_e,Ve=E*(C-1-V)+A*(k-1-Ge)+M*Et;for(let _t=0;_t<te;++_t){const Ce=b[Re+Qe*_t],pt=T[Ve+_t];ht+=Ce*pt}}}const dt=K*qe+se*Tt+ge*He+Me*Et;v[dt]=ht}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const wj={kernelName:oA,backendName:"cpu",kernelFunc:Tj},Aj=cl(lg,x=>Math.cos(x)),Ej={kernelName:lg,backendName:"cpu",kernelFunc:Aj};function Mj(x){const{inputs:e,backend:t,attrs:n}=x,{image:i,boxes:r,boxInd:a}=e,{cropSize:s,method:l,extrapolationValue:c}=n,[h,d,p,m]=i.shape,g=r.shape[0],[_,v]=s,b=kx([g,_,v,m],"float32"),T=t.data.get(r.dataId).values,E=t.data.get(a.dataId).values,A=t.data.get(i.dataId).values,M=M0(i.shape),R=M0(b.shape);for(let C=0;C<g;C++){const k=C*4,P=T[k],N=T[k+1],G=T[k+2],te=T[k+3],j=E[C];if(j>=h)continue;const xe=_>1?(G-P)*(d-1)/(_-1):0,ae=v>1?(te-N)*(p-1)/(v-1):0;for(let H=0;H<_;H++){const re=_>1?P*(d-1)+H*xe:.5*(P+G)*(d-1);if(re<0||re>d-1){for(let q=0;q<v;q++)for(let be=0;be<m;be++){const K=be+q*R[2]+H*R[1]+C*R[0];b.values[K]=c}continue}if(l==="bilinear"){const q=Math.floor(re),be=Math.ceil(re),K=re-q;for(let se=0;se<v;se++){const ge=v>1?N*(p-1)+se*ae:.5*(N+te)*(p-1);if(ge<0||ge>p-1){for(let Fe=0;Fe<m;Fe++){const Qe=Fe+se*R[2]+H*R[1]+C*R[0];b.values[Qe]=c}continue}const Me=Math.floor(ge),le=Math.ceil(ge),Se=ge-Me;for(let Fe=0;Fe<m;Fe++){let Qe=Fe+Me*M[2]+q*M[1]+j*M[0];const qe=A[Qe];Qe=Fe+le*M[2]+q*M[1]+j*M[0];const Et=A[Qe];Qe=Fe+Me*M[2]+be*M[1]+j*M[0];const Tt=A[Qe];Qe=Fe+le*M[2]+be*M[1]+j*M[0];const Bt=A[Qe],Q=qe+(Et-qe)*Se,rt=Tt+(Bt-Tt)*Se;Qe=Fe+se*R[2]+H*R[1]+C*R[0],b.values[Qe]=Q+(rt-Q)*K}}}else for(let q=0;q<v;++q){const be=v>1?N*(p-1)+q*ae:.5*(N+te)*(p-1);if(be<0||be>p-1){for(let ge=0;ge<m;ge++){const Me=ge+q*R[2]+H*R[1]+C*R[0];b.values[Me]=c}continue}const K=Math.round(be),se=Math.round(re);for(let ge=0;ge<m;ge++){const Me=ge+K*M[2]+se*M[1]+j*M[0],le=ge+q*R[2]+H*R[1]+C*R[0];b.values[le]=A[Me]}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const Rj={kernelName:lA,backendName:"cpu",kernelFunc:Mj};function Cj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{blockSize:r,dataFormat:a}=n;ye(a==="NHWC",()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got "+a);const s=i.shape[0],l=i.shape[1],c=i.shape[2],h=i.shape[3],d=l*r,p=c*r,m=h/(r*r),g=t.data.get(i.dataId).values,_=new Float32Array(s*d*p*m);let v=0;for(let b=0;b<s;++b)for(let T=0;T<d;++T){const E=Math.floor(T/r),A=T%r;for(let M=0;M<p;++M){const R=Math.floor(M/r),C=M%r,k=(A*r+C)*m;for(let P=0;P<m;++P){const N=P+k+h*(R+c*(E+l*b));_[v++]=g[N]}}}return t.makeTensorInfo([s,d,p,m],i.dtype,_)}const Nj={kernelName:cA,backendName:"cpu",kernelFunc:Cj};function XF(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r}=e,{strides:a,pad:s,dilations:l,dimRoundingMode:c}=n;Rx([i,r],"depthwiseConv2DNative");const h=M0(i.shape),d=M0(r.shape);let p=l;p==null&&(p=[1,1]),ye(Fr(a,p),()=>"Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+p+"'");const m=Ur(i.shape,r.shape,a,p,s,c,!0),{filterHeight:g,filterWidth:_,dilationHeight:v,dilationWidth:b,padInfo:T}=m,E=T.left,A=T.top,M=m.outChannels/m.inChannels,R=new vc(m.outShape,i.dtype),C=t.data.get(i.dataId).values,k=t.data.get(r.dataId).values,P=R.values;for(let N=0;N<m.batchSize;++N){const G=N*h[0],te=N*R.strides[0];for(let j=0;j<m.outHeight;++j){const xe=te+j*R.strides[1],ae=j*m.strideHeight-A;for(let H=0;H<g;++H){const re=ae+H*v;if(re<0||re>=m.inHeight)continue;const q=H*d[0],be=G+re*h[1];for(let K=0;K<m.outWidth;++K){const se=xe+K*R.strides[2],ge=K*m.strideWidth-E;for(let Me=0;Me<_;++Me){const le=ge+Me*b;if(le<0||le>=m.inWidth)continue;const Se=q+Me*d[1],Fe=be+le*m.inChannels;let Qe=se,qe=Se;for(let Et=0;Et<m.inChannels;++Et){const Tt=C[Fe+Et];for(let Bt=0;Bt<M;++Bt)P[Qe+Bt]+=Tt*k[qe+Bt];Qe+=M,qe+=M}}}}}}return t.makeTensorInfo(R.shape,R.dtype,R.values)}const Ij={kernelName:uA,backendName:"cpu",kernelFunc:XF};function IT(x){const{inputs:e,backend:t,attrs:n}=x,{input:i}=e,{dim:r}=n,a=i.shape.length,s=i.shape.slice();let l=r;return r<0&&(ye(-(a+1)<=r,()=>"Axis must be in the interval ["+-(a+1)+", "+a+"]"),l=a+r+1),s.splice(l,0,1),Dr({inputs:{x:i},backend:t,attrs:{shape:s}})}const Oj={kernelName:hA,backendName:"cpu",kernelFunc:IT};function YF(x){const{backend:e,attrs:t}=x,{shape:n,value:i,dtype:r}=t,a=r||Qh(i),s=fn(a,ut(n));return Pj(s,i),e.makeTensorInfo(n,a,s)}const Dj={kernelName:dA,backendName:"cpu",kernelFunc:YF};function Pj(x,e,t){x.fill(e)}const kj=cl(xk,x=>x>=0?x:Math.exp(x)-1);function Uj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{alpha:r}=n;Rx([i],"leakyRelu");const a=ut(i.shape),s=t.data.get(i.dataId).values,l=Ir("float32",a);for(let c=0;c<s.length;c++)l[c]=s[c]<0?r*s[c]:s[c];return t.makeTensorInfo(i.shape,"float32",l)}const Fj=nn((x,e)=>x<0?e*x:x);function KF(x){const{inputs:e,backend:t}=x,{x:n,alpha:i}=e;Rx([n,i],"prelu");const r=t.data.get(n.dataId).values,a=t.data.get(i.dataId).values,[s,l]=Fj(n.shape,i.shape,r,a,"float32");return t.makeTensorInfo(l,"float32",s)}const Bj={kernelName:wA,backendName:"cpu",kernelFunc:KF},$F=cl(bg,x=>Math.max(0,x)),Lj={kernelName:bg,backendName:"cpu",kernelFunc:$F},QF=cl(_g,x=>Math.min(Math.max(0,x),6)),zj={kernelName:_g,backendName:"cpu",kernelFunc:QF};function B1(x,e,t,n,i){if(t==="linear")return el({inputs:{x:e},backend:x});if(t==="relu")return $F({inputs:{x:e},backend:x});if(t==="elu")return kj({inputs:{x:e},backend:x});if(t==="relu6")return QF({inputs:{x:e},backend:x});if(t==="prelu")return KF({inputs:{x:e,alpha:n},backend:x});if(t==="leakyrelu")return Uj({inputs:{x:e},backend:x,attrs:{alpha:i}});if(t==="sigmoid")return pF({inputs:{x:e},backend:x});throw new Error("Activation "+t+" has not been implemented for the CPU backend.")}function Vj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r,bias:a,preluActivationWeights:s}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=n;let _=WF({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(a){const v=_;if(h==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const b=Dr({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});_=$f({inputs:{a:_,b},backend:t}),t.disposeIntermediateTensorInfo(b)}else _=$f({inputs:{a:_,b:a},backend:t});t.disposeIntermediateTensorInfo(v)}if(m){const v=_;if(h==="NCHW"&&m==="prelu"&&s.shape.length===1&&s.shape[0]!==1){const b=Dr({inputs:{x:s},backend:t,attrs:{shape:[s.shape[0],1,1]}});_=B1(t,_,m,b,g),t.disposeIntermediateTensorInfo(b)}else _=B1(t,_,m,s,g);t.disposeIntermediateTensorInfo(v)}return _}const Hj={kernelName:S1,backendName:"cpu",kernelFunc:Vj};function Gj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,filter:r,bias:a,preluActivationWeights:s}=e,{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p,activation:m,leakyreluAlpha:g}=n;let _=XF({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:h,dilations:d,dimRoundingMode:p}});if(a){const v=_;_=$f({inputs:{a:_,b:a},backend:t}),t.disposeIntermediateTensorInfo(v)}if(m){const v=_;_=B1(t,_,m,s,g),t.disposeIntermediateTensorInfo(v)}return _}const Wj={kernelName:T1,backendName:"cpu",kernelFunc:Gj};function Xj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i,indices:r}=e,{axis:a,batchDims:s}=n;Rx([i,r],"gatherV2");const l=Ri(a,i.shape)[0],c=t.data.get(r.dataId).values,h=i.shape[l];for(let A=0;A<c.length;++A){const M=c[A];ye(M<=h-1&&M>=0,()=>"GatherV2: the index value "+M+" is not in [0, "+(h-1)+"]")}let d=s;s==null&&(d=0);const p=ut(r.shape),m=tE(i,r,l,d),g=Dr({inputs:{x:i},backend:t,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),_=Dr({inputs:{x:r},backend:t,attrs:{shape:[m.batchSize,p/m.batchSize]}}),v=[m.batchSize,m.outerSize,p/m.batchSize,m.sliceSize],b=t.bufferSync(_),T=t.bufferSync(g),E=aF(T,b,v);return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(m.outputShape,E.dtype,E.values)}const Yj={kernelName:fA,backendName:"cpu",kernelFunc:Xj},Kj=nn((x,e)=>x&&e),$j=Br(pg,Kj,null,"bool"),Qj={kernelName:pg,backendName:"cpu",kernelFunc:$j},Zj=nn((x,e)=>x||e),Jj=Br(mA,Zj,null,"bool"),jj={kernelName:mA,backendName:"cpu",kernelFunc:Jj};function qj(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{reductionIndices:r,keepDims:a}=n,s=t;let l=i.shape;const c=l.length,h=Ri(r,l);let d=h;const p=ol(d,c);let m=s.data.get(i.dataId).values;if(p!=null){const A=new Array(c);for(let M=0;M<A.length;M++)A[M]=l[p[M]];m=cE(m,l,i.dtype,p,A),d=ll(d.length,c),l=A}Rx(i,"max"),sl("max",d,c);const[g,_]=Is(l,d),v=ut(_),b=cF(m,v,g,i.dtype),T=s.write(b,g,i.dtype);let E=g;return a&&(E=Ho(g,h)),{dataId:T,shape:E,dtype:i.dtype}}const eq={kernelName:yA,backendName:"cpu",kernelFunc:qj};function tq(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e;Rx(i,"maxPool");const{filterSize:r,strides:a,pad:s,dimRoundingMode:l}=n,c=1;ye(Fr(a,c),()=>"Error in maxPool: Either strides or dilations must be 1. Got strides "+a+" and dilations '"+c+"'");const h=yp(i.shape,r,a,c,s,l);let d;if(h.filterWidth===1&&h.filterHeight===1&&Zx(h.inShape,h.outShape))d=el({inputs:{x:i},backend:t});else{const p=t.data.get(i.dataId).values,m=M0(i.shape),g=VF(p,i.shape,i.dtype,m,h,"max");d=t.makeTensorInfo(h.outShape,i.dtype,g.values)}return d}const xq={kernelName:gA,backendName:"cpu",kernelFunc:tq},nq=nn((x,e)=>x/e),ZF=Br(cg,nq),iq={kernelName:cg,backendName:"cpu",kernelFunc:ZF};function JF(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{axis:r,keepDims:a}=n;Rx(i,"sum");let s;i.dtype==="bool"?s=Ec({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):s=el({inputs:{x:i},backend:t});const l=s.shape.length,c=Ri(r,s.shape),h=ol(c,l);let d=c,p=s;h!=null&&(p=uE({inputs:{x:s},backend:t,attrs:{perm:h}}),d=ll(d.length,l)),sl("sum",d,p.shape.length);const[m,g]=Is(p.shape,d),_=Rs(p.dtype,"int32");let v=N1(t,m,_);const b=ut(g),T=t.data.get(v.dataId).values,E=t.data.get(p.dataId).values;for(let A=0;A<T.length;++A){const M=A*b;let R=0;for(let C=0;C<b;++C)R+=E[M+C];T[A]=R}if(a){const A=Ho(v.shape,c),M=v;v=Dr({inputs:{x:v},backend:t,attrs:{shape:A}}),t.disposeIntermediateTensorInfo(M)}return t.disposeIntermediateTensorInfo(s),h!=null&&t.disposeIntermediateTensorInfo(p),v}const rq={kernelName:CA,backendName:"cpu",kernelFunc:JF};function aq(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{axis:r,keepDims:a}=n,s=Ri(r,i.shape),l=Is(i.shape,s)[1],c=ut(l),h=[],d=t.makeTensorInfo([],"float32",new Float32Array([c]));h.push(d);const p=Ec({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});h.push(p);const m=ZF({inputs:{a:p,b:d},backend:t});h.push(m);const g=JF({inputs:{x:m},backend:t,attrs:{axis:r,keepDims:a}});return h.forEach(_=>t.disposeIntermediateTensorInfo(_)),g}const sq={kernelName:vA,backendName:"cpu",kernelFunc:aq};function oq(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{axis:r,keepDims:a}=n;Rx(i,"min");const s=Ri(r,i.shape);let l=s;const c=ol(l,i.shape.length);let h=i;c!=null&&(h=uE({inputs:{x:i},backend:t,attrs:{perm:c}}),l=ll(l.length,i.shape.length)),sl("min",l,h.shape.length);const[d,p]=Is(h.shape,l),m=ut(p),g=Ms(ut(d),h.dtype),_=t.data.get(h.dataId).values;for(let b=0;b<g.length;++b){const T=b*m;let E=_[T];for(let A=0;A<m;++A){const M=_[T+A];(Number.isNaN(M)||M<E)&&(E=M)}g[b]=E}c!=null&&t.disposeIntermediateTensorInfo(h);const v=t.makeTensorInfo(d,h.dtype,g);if(a){const b=Ho(d,s),T=Dr({inputs:{x:v},backend:t,attrs:{shape:b}});return t.disposeIntermediateTensorInfo(v),T}return v}const lq={kernelName:bA,backendName:"cpu",kernelFunc:oq};function cq(x){const{inputs:e,backend:t,attrs:n}=x,{axis:i}=n;if(e.length===1)return IT({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,a=e[0].dtype;e.forEach(h=>{qw(r,h.shape,"All tensors passed to stack must have matching shapes"),ye(a===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const s=[],l=e.map(h=>{const d=IT({inputs:{input:h},backend:t,attrs:{dim:i}});return s.push(d),d}),c=F1({inputs:l,backend:t,attrs:{axis:i}});return s.forEach(h=>t.disposeIntermediateTensorInfo(h)),c}const uq={kernelName:SA,backendName:"cpu",kernelFunc:cq};function hq(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{paddings:r,constantValue:a}=n;Rx(i,"pad");const s=r.map((b,T)=>b[0]+i.shape[T]+b[1]),l=r.map(b=>b[0]),c=t.data.get(i.dataId).values,h=ut(i.shape),d=i.shape.length,p=M0(i.shape),m=ut(s),g=s.length,_=M0(s),v=Ir(i.dtype,m);a!==0&&v.fill(a);for(let b=0;b<h;b++){const T=up(b,d,p).map((A,M)=>A+l[M]),E=bh(T,g,_);v[E]=c[b]}return{dataId:t.write(v,s,i.dtype),shape:s,dtype:i.dtype}}const dq={kernelName:TA,backendName:"cpu",kernelFunc:hq},fq=nn((x,e)=>Math.pow(x,e)),pq=Br(vg,fq),mq={kernelName:vg,backendName:"cpu",kernelFunc:pq};function yq(x){const{backend:e,attrs:t}=x,{start:n,stop:i,dtype:r,step:a}=t,s=fF(n,i,a,r);return e.makeTensorInfo([s.length],r,s)}const gq={kernelName:AA,backendName:"cpu",kernelFunc:yq};function vq(x){const{inputs:e,backend:t,attrs:n}=x,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:s}=n;Rx(i,"resizeBilinear");const l=M0(i.shape),[c,h]=s,[d,p,m,g]=i.shape,_=t.data.get(i.dataId).values,v=new Float32Array(ut([d,c,h,g])),b=[r&&c>1?p-1:p,r&&h>1?m-1:m],T=[r&&c>1?c-1:c,r&&h>1?h-1:h];let E=0;const A=b[0]/T[0],M=b[1]/T[1];for(let R=0;R<d;R++)for(let C=0;C<c;C++){let k;a?k=A*(C+.5)-.5:k=A*C;const P=Math.max(0,Math.floor(k)),N=k-P,G=Math.min(p-1,Math.ceil(k)),te=R*l[0]+P*l[1],j=R*l[0]+G*l[1];for(let xe=0;xe<h;xe++){let ae;a?ae=M*(xe+.5)-.5:ae=M*xe;const H=Math.max(0,Math.floor(ae)),re=ae-H,q=Math.min(m-1,Math.ceil(ae)),be=te+H*l[2],K=j+H*l[2],se=te+q*l[2],ge=j+q*l[2];for(let Me=0;Me<g;Me++){const le=_[be+Me],Se=_[K+Me],Fe=_[se+Me],Qe=_[ge+Me],qe=le+(Fe-le)*re,Et=Se+(Qe-Se)*re,Tt=qe+(Et-qe)*N;v[E++]=Tt}}}return t.makeTensorInfo([d,c,h,g],"float32",v)}const bq={kernelName:MA,backendName:"cpu",kernelFunc:vq},_q={kernelName:DA,backendName:"cpu",kernelFunc:({inputs:x,attrs:e,backend:t})=>{const{image:n}=x,{radians:i,fillValue:r,center:a}=e,s=t,l=Ir(n.dtype,ut(n.shape)),[c,h,d,p]=n.shape,[m,g]=eE(a,h,d),_=255,v=Math.sin(i),b=Math.cos(i),T=s.data.get(n.dataId).values;for(let E=0;E<c;E++){const A=E*d*h*p;for(let M=0;M<h;M++){const R=M*(d*p);for(let C=0;C<d;C++){const k=C*p;for(let P=0;P<p;P++){const N=[c,M,C,P],G=N[2],te=N[1];let j=(G-m)*b-(te-g)*v,xe=(G-m)*v+(te-g)*b;j=Math.round(j+m),xe=Math.round(xe+g);let ae=r;if(typeof r!="number"&&(P===3?ae=_:ae=r[P]),j>=0&&j<d&&xe>=0&&xe<h){const re=xe*(d*p),q=j*p,be=A+re+q+P;ae=T[be]}const H=A+R+k+P;l[H]=ae}}}}return{dataId:s.write(l,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}},Sq=cl(Sg,x=>Math.sin(x)),Tq={kernelName:Sg,backendName:"cpu",kernelFunc:Sq},wq={kernelName:nk,backendName:"cpu",kernelFunc:({inputs:x,backend:e})=>{const{x:t}=x,n=e;Rx(t,"square");const i=n.data.get(t.dataId).values,r=new Float32Array(i.length);for(let a=0;a<i.length;++a){const s=i[a];r[a]=s*s}return{dataId:n.write(r,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};function Aq(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{begin:r,end:a,strides:s,beginMask:l,endMask:c,ellipsisMask:h,newAxisMask:d,shrinkAxisMask:p}=n;Rx(i,"stridedSlice");const{finalShapeSparse:m,finalShape:g,isIdentity:_,sliceDim0:v,isSimpleSlice:b,begin:T,end:E,strides:A}=XA(i.shape,r,a,s,l,c,h,d,p);let M;if(_)M=Dr({inputs:{x:i},backend:t,attrs:{shape:g}});else if(v||b){ye(i.shape.length>=1,()=>"Input must have rank at least 1, got: "+i.shape.length);const R=VA(T,E,A),C=yF({inputs:{x:i},backend:t,attrs:{begin:T,size:R}});M=Dr({inputs:{x:C},backend:t,attrs:{shape:g}}),t.disposeIntermediateTensorInfo(C)}else{const R=t.bufferSync(i),C=gF(m,R,A,T);M=t.makeTensorInfo(g,C.dtype,C.values)}return M}const Eq={kernelName:NA,backendName:"cpu",kernelFunc:Aq};function Mq(x){const{inputs:e,backend:t,attrs:n}=x,{x:i}=e,{reps:r}=n;Rx(i,"tile");const a=bF(t.bufferSync(i),r);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const Rq={kernelName:Eg,backendName:"cpu",kernelFunc:Mq};function Cq(x){const{inputs:e,attrs:t,backend:n}=x,{image:i,transforms:r}=e,{interpolation:a,fillMode:s,fillValue:l,outputShape:c}=t,[h,d,p,m]=i.shape,[g,_]=c??[d,p],v=[h,g,_,m],b=M0(i.shape),T=b[0],E=b[1],A=b[2],M=M0(v),R=M[0],C=M[1],k=M[2],P=Ir(i.dtype,ut(v));P.fill(l);const N=n.data.get(i.dataId).values,G=n.data.get(r.dataId).values;for(let te=0;te<h;++te){const j=r.shape[0]===1?G:G.subarray(te*8,te*8+8);for(let xe=0;xe<g;++xe)for(let ae=0;ae<_;++ae)for(let H=0;H<m;++H){let re;const q=j[6]*ae+j[7]*xe+1;if(q===0)continue;const be=(j[0]*ae+j[1]*xe+j[2])/q,K=(j[3]*ae+j[4]*xe+j[5])/q,se=fI(be,p,s),ge=fI(K,d,s);switch(a){case"nearest":re=kq(N,d,p,T,E,A,te,ge,se,H,l);break;case"bilinear":re=Uq(N,d,p,T,E,A,te,ge,se,H,l);break;default:throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got "+a)}const Me=te*R+xe*C+ae*k+H;P[Me]=re}return n.makeTensorInfo(v,i.dtype,P)}return{dataId:n.write(P,v,i.dtype),shape:i.shape,dtype:i.dtype}}const Nq={kernelName:IA,backendName:"cpu",kernelFunc:Cq};function fI(x,e,t){switch(t){case"reflect":return Iq(x,e);case"wrap":return Oq(x,e);case"nearest":return Pq(x,e);case"constant":default:return Dq(x)}}function Iq(x,e){let t=x;if(t<0)if(e<=1)t=0;else{const n=2*e;t<n&&(t=n*Math.trunc(-t/n)+t),t=t<-e?t+n:-t-1}else if(t>e-1)if(e<=1)t=0;else{const n=2*e;t-=n*Math.trunc(t/n),t>=e&&(t=n-t-1)}return mc(0,t,e-1)}function Oq(x,e){let t=x;if(t<0)if(e<=1)t=0;else{const n=e-1;t+=e*(Math.trunc(-t/n)+1)}else if(t>e-1)if(e<=1)t=0;else{const n=e-1;t-=e*Math.trunc(t/n)}return mc(0,t,e-1)}function Dq(x,e){return x}function Pq(x,e){return mc(0,x,e-1)}function Cf(x,e,t,n,i,r,a,s,l,c,h){const d=a*n+s*i+l*r+c;return 0<=s&&s<e&&0<=l&&l<t?x[d]:h}function kq(x,e,t,n,i,r,a,s,l,c,h){const d=Math.round(s),p=Math.round(l);return Cf(x,e,t,n,i,r,a,d,p,c,h)}function Uq(x,e,t,n,i,r,a,s,l,c,h){const d=Math.floor(s),p=Math.floor(l),m=d+1,g=p+1,_=(g-l)*Cf(x,e,t,n,i,r,a,d,p,c,h)+(l-p)*Cf(x,e,t,n,i,r,a,d,g,c,h),v=(g-l)*Cf(x,e,t,n,i,r,a,m,p,c,h)+(l-p)*Cf(x,e,t,n,i,r,a,m,g,c,h);return(m-s)*_+(s-d)*v}function OT(x){const{inputs:e,backend:t}=x,{x:n}=e;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){const i=sE({inputs:{input:n},backend:t}),r=OT({inputs:{x:i},backend:t}),a=GF({inputs:{input:n},backend:t}),s=OT({inputs:{x:a},backend:t}),l=bp({inputs:{real:r,imag:s},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(s),l}else return YF({backend:t,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}const Fq={kernelName:OA,backendName:"cpu",kernelFunc:OT};function Bq(x){const{inputs:e,backend:t,attrs:n}=x,{a:i,b:r,bias:a,preluActivationWeights:s}=e,{transposeA:l,transposeB:c,activation:h,leakyreluAlpha:d}=n;let p,m,g;const _=[];p=HF({inputs:{a:i,b:r},attrs:{transposeA:l,transposeB:c},backend:t}),a&&(m=$f({inputs:{a:p,b:a},backend:t}),_.push(p),p=m),h&&(g=B1(t,p,h,s,d),_.push(p),p=g);for(const v of _)t.disposeIntermediateTensorInfo(v);return p}const Lq={kernelName:_1,backendName:"cpu",kernelFunc:Bq};Je(H$),Je(Q$),Je(j$),Je(xQ),Je(iQ),Je(yQ),Je(SQ),Je(EQ),Je(NQ),Je(DQ),Je(FQ),Je(VQ),Je(WQ),Je(KQ),Je(QQ),Je(ZQ),Je(jQ),Je(eZ),Je(nZ),Je(aZ),Je(oZ),Je(hZ),Je(mZ),Je(G$),Je(bZ),Je(wZ),Je(RZ),Je(OZ),Je(kZ),Je(FZ),Je(VZ),Je(GZ),Je(XZ),Je(QZ),Je(rQ),Je(qZ),Je(tJ),Je(rJ),Je(lJ),Je(K$),Je(uJ),Je(pJ),Je(vJ),Je(TJ),Je(sQ),Je(MJ),Je(CJ),Je(DJ),Je(FJ),Je(HJ),Je(WJ),Je(KJ),Je(ZJ),Je(jJ),Je(fQ),Je(xj),Je(rj),Je(pQ),Je(aj),Je(oj),Je(OY),Je(UY),Je(uj),Je(fj),Je(mj),Je(gj),Je(PY),Je(bj),Je(_j),Je(Sj),Je(wj),Je(Ej),Je(Rj),Je(Nj),Je(Ij),Je(Oj),Je(Dj),Je(XY),Je(Hj),Je(Wj),Je(Yj),Je(ZY),Je(DY),Je(jY),Je(eK),Je(Qj),Je(jj),Je(eq),Je(xq),Je(iK),Je(sq),Je(lq),Je(aK),Je(lK),Je(uK),Je(uq),Je(dq),Je(mq),Je(Bj),Je(gq),Je(iq),Je(Lj),Je(zj),Je(yj),Je(bq),Je(_q),Je(MK),Je(Tq),Je(RK),Je(PK),Je(wq),Je(Eq),Je(WK),Je(rq),Je(Rq),Je(Nq),Je(dK),Je(Fq),Je(Lq);class zq{constructor(){this.bodyTracks=[],this.poseFilters=[],this.angle=15/180*Math.PI,this.ratio=1920/1080,this.near=1,this.poseScore=.6,this.alignScore=.9,this.alignVisibility=.9,this.skipCount=2,this.skipMax=2}async process(e,t){var n,i;if(this.bodyTracks.length<1&&this.skipCount<this.skipMax)return this.skipCount++,[];this.skipCount=0;const r=hi(()=>{const p=Or(x8(e,3),"float32"),m=Eh(Va(p,255*.5),1);return ZA(m,0)}),[a,s]=[r.shape[1],r.shape[2]];if(this.bodyTracks.length===0){const p=await((n=this.bodyDetector)==null?void 0:n.process(r))||[];this.bodyTracks=p.map(m=>({center:m.points[0],top:m.points[1]})),this.bodyTracks.forEach(()=>this.poseFilters.push(new aW))}const l=this.bodyTracks.length>0?((i=this.poseDetector)==null?void 0:i.process(r,this.bodyTracks))||[]:[];l.forEach((p,m)=>{var g;if(t!==void 0){const _=s/a,v=p.top[0]-p.center[0],b=(p.top[1]-p.center[1])/_,T=Math.sqrt(v*v+b*b)*2*(1+_)*.5;l[m]=this.poseFilters[m].filter(p,t,1/T)}(g=this.poseAligner)==null||g.alignPoints(l[m].keypoints)}),r.dispose();let c=[],h=[],d=[];for(let p=0;p<this.bodyTracks.length;p++){const m={center:[this.bodyTracks[p].center[0]*s,this.bodyTracks[p].center[1]*a],top:[this.bodyTracks[p].top[0]*s,this.bodyTracks[p].top[1]*a]};let g={center:[l[p].center[0]*s,l[p].center[1]*a],top:[l[p].top[0]*s,l[p].top[1]*a]};const _=[m,g].map(v=>{const{center:b,top:T}=v,E=[T[0]-b[0],T[1]-b[1]],A=Math.sqrt(E[0]*E[0]+E[1]*E[1]);return[[b[0]-A,b[1]-A],[b[0]+A,b[1]+A]]});sW(_[0],_[1])>.5&&l[p].score>this.poseScore&&(c.push({center:[...l[p].center],top:[...l[p].top]}),h.push(this.poseFilters[p]),d.push(l[p]))}return this.bodyTracks=c,this.poseFilters=h,d}setCamera(e,t,n=1){var i;this.angle=e,this.ratio=t,this.near=n,(i=this.poseAligner)==null||i.setCamera(e,t,n)}async init(e,t="./",n=!1,i=!1,r="webgl"){const a=await lW(e,t,n),s=new a.ParseLoader(t);if(n||(await s.remove("pose.wasm"),await s.remove("poseutils.wasm")),!await s.loadDict(["pose.wasm","poseutils.wasm"])||!await s.load("pose.wasm")||!s.parse())return;Pe().set("WEBGL_USE_SHAPES_UNIFORMS",!0),QV(),await JV(r);const l={weightUrlConverter:async p=>p,fetchFunc:async p=>{const m=new Blob([s.file(p)]);return fetch(URL.createObjectURL(m))}},c=await X3("bodymodel.def",l),h=await X3("posemodel.def",l);if(this.bodyDetector=new eW(c),this.poseDetector=new xW(h,i),!await s.load("poseutils.wasm"))return;const d=await cW({wasmBinary:s.data()});s.delete(),d.PoseAligner.prototype.alignPoints=function(p){const m=new d.VectorFloat,g=new d.VectorFloat,_=new d.VectorFloat,v=new d.VectorFloat;p.forEach(T=>{m.push_back(T.pixel[0]),m.push_back(T.pixel[1]),m.push_back(T.pixel[2]),g.push_back(T.metric[0]),g.push_back(T.metric[1]),g.push_back(T.metric[2]),_.push_back(T.score),v.push_back(T.visibility)});const b=this.align(m,g,_,v);p.forEach((T,E)=>{T.metric=[b.get(E*3),b.get(E*3+1),b.get(E*3+2)]}),m.delete(),g.delete(),_.delete(),v.delete(),b.delete()},this.poseModule=d,this.poseAligner=new this.poseModule.PoseAligner,this.poseAligner.setThresh(this.alignScore,this.alignVisibility)}reset(){var e;this.bodyTracks=[],this.poseFilters=[],this.skipCount=this.skipMax,(e=this.poseDetector)==null||e.reset()}async prepare(){var e,t;Pe().set("ENGINE_COMPILE_ONLY",!0),await((e=this.bodyDetector)==null?void 0:e.prepare()),await((t=this.poseDetector)==null?void 0:t.prepare());const n=kA();n instanceof Sp&&(n.checkCompileCompletion(),n.getUniformLocations()),Pe().set("ENGINE_COMPILE_ONLY",!1)}dispose(){var e,t,n;this.reset(),(e=this.bodyDetector)==null||e.dispose(),delete this.bodyDetector,(t=this.poseDetector)==null||t.dispose(),delete this.poseDetector,(n=this.poseAligner)==null||n.delete(),delete this.poseAligner}}var Vq=(x=>(x[x.EyeR=0]="EyeR",x[x.EyeL=1]="EyeL",x[x.Nose=2]="Nose",x[x.Mouth=3]="Mouth",x[x.EarR=4]="EarR",x[x.EarL=5]="EarL",x))(Vq||{});(()=>{var x=typeof document<"u"&&document.currentScript?document.currentScript.src:void 0;return function(e={}){var t=e,n,i;t.ready=new Promise((D,U)=>{n=D,i=U});var r=Object.assign({},t),a=!0,s="";function l(D){return t.locateFile?t.locateFile(D,s):s+D}typeof document<"u"&&document.currentScript&&(s=document.currentScript.src),x&&(s=x),s.startsWith("blob:")?s="":s=s.substr(0,s.replace(/[?#].*/,"").lastIndexOf("/")+1),t.print||console.log.bind(console);var c=t.printErr||console.error.bind(console);Object.assign(t,r),r=null,t.arguments&&t.arguments,t.thisProgram&&t.thisProgram,t.quit&&t.quit;var h;t.wasmBinary&&(h=t.wasmBinary);var d,p=!1,m,g,_,v,b,T,E,A;function M(){var D=d.buffer;t.HEAP8=m=new Int8Array(D),t.HEAP16=_=new Int16Array(D),t.HEAPU8=g=new Uint8Array(D),t.HEAPU16=v=new Uint16Array(D),t.HEAP32=b=new Int32Array(D),t.HEAPU32=T=new Uint32Array(D),t.HEAPF32=E=new Float32Array(D),t.HEAPF64=A=new Float64Array(D)}var R=[],C=[],k=[];function P(){if(t.preRun)for(typeof t.preRun=="function"&&(t.preRun=[t.preRun]);t.preRun.length;)te(t.preRun.shift());qe(R)}function N(){qe(C)}function G(){if(t.postRun)for(typeof t.postRun=="function"&&(t.postRun=[t.postRun]);t.postRun.length;)xe(t.postRun.shift());qe(k)}function te(D){R.unshift(D)}function j(D){C.unshift(D)}function xe(D){k.unshift(D)}var ae=0,H=null;function re(D){var U;ae++,(U=t.monitorRunDependencies)==null||U.call(t,ae)}function q(D){var U;if(ae--,(U=t.monitorRunDependencies)==null||U.call(t,ae),ae==0&&H){var X=H;H=null,X()}}function be(D){var U;(U=t.onAbort)==null||U.call(t,D),D="Aborted("+D+")",c(D),p=!0,D+=". Build with -sASSERTIONS for more info.";var X=new WebAssembly.RuntimeError(D);throw i(X),X}var K="data:application/octet-stream;base64,",se=D=>D.startsWith(K),ge;ge="faceutils.wasm",se(ge)||(ge=l(ge));function Me(D){if(D==ge&&h)return new Uint8Array(h);throw"both async and sync fetching of the wasm failed"}function le(D){return!h&&a&&typeof fetch=="function"?fetch(D,{credentials:"same-origin"}).then(U=>{if(!U.ok)throw"failed to load wasm binary file at '"+D+"'";return U.arrayBuffer()}).catch(()=>Me(D)):Promise.resolve().then(()=>Me(D))}function Se(D,U,X){return le(D).then(J=>WebAssembly.instantiate(J,U)).then(X,J=>{c("failed to asynchronously prepare wasm: "+J),be(J)})}function Fe(D,U,X,J){return!D&&typeof WebAssembly.instantiateStreaming=="function"&&!se(U)&&typeof fetch=="function"?fetch(U,{credentials:"same-origin"}).then(ue=>{var pe=WebAssembly.instantiateStreaming(ue,X);return pe.then(J,function(ve){return c("wasm streaming compile failed: "+ve),c("falling back to ArrayBuffer instantiation"),Se(U,X,J)})}):Se(U,X,J)}function Qe(){var D={a:Hs};function U(J,ue){return ei=J.exports,d=ei.y,M(),Ft=ei.C,j(ei.z),q(),ei}re();function X(J){U(J.instance)}if(t.instantiateWasm)try{return t.instantiateWasm(D,U)}catch(J){c("Module.instantiateWasm callback failed with error: "+J),i(J)}return Fe(h,ge,D,X).catch(i),{}}var qe=D=>{for(;D.length>0;)D.shift()(t)};t.noExitRuntime;class Et{constructor(U){this.excPtr=U,this.ptr=U-24}set_type(U){T[this.ptr+4>>2]=U}get_type(){return T[this.ptr+4>>2]}set_destructor(U){T[this.ptr+8>>2]=U}get_destructor(){return T[this.ptr+8>>2]}set_caught(U){U=U?1:0,m[this.ptr+12]=U}get_caught(){return m[this.ptr+12]!=0}set_rethrown(U){U=U?1:0,m[this.ptr+13]=U}get_rethrown(){return m[this.ptr+13]!=0}init(U,X){this.set_adjusted_ptr(0),this.set_type(U),this.set_destructor(X)}set_adjusted_ptr(U){T[this.ptr+16>>2]=U}get_adjusted_ptr(){return T[this.ptr+16>>2]}get_exception_ptr(){var U=L(this.get_type());if(U)return T[this.excPtr>>2];var X=this.get_adjusted_ptr();return X!==0?X:this.excPtr}}var Tt=0,Bt=(D,U,X)=>{var J=new Et(D);throw J.init(U,X),Tt=D,Tt},Q={},rt=D=>{for(;D.length;){var U=D.pop(),X=D.pop();X(U)}};function He(D){return this.fromWireType(T[D>>2])}var at={},Ue={},bt={},ht,dt=D=>{throw new ht(D)},Z=(D,U,X)=>{D.forEach(function(we){bt[we]=U});function J(we){var $e=X(we);$e.length!==D.length&&dt("Mismatched type converter count");for(var st=0;st<D.length;++st)gt(D[st],$e[st])}var ue=new Array(U.length),pe=[],ve=0;U.forEach((we,$e)=>{Ue.hasOwnProperty(we)?ue[$e]=Ue[we]:(pe.push(we),at.hasOwnProperty(we)||(at[we]=[]),at[we].push(()=>{ue[$e]=Ue[we],++ve,ve===pe.length&&J(ue)}))}),pe.length===0&&J(ue)},V=D=>{var U=Q[D];delete Q[D];var X=U.elements,J=X.length,ue=X.map(we=>we.getterReturnType).concat(X.map(we=>we.setterArgumentType)),pe=U.rawConstructor,ve=U.rawDestructor;Z([D],ue,we=>(X.forEach(($e,st)=>{var ot=we[st],Gt=$e.getter,r0=$e.getterContext,c0=we[st+J],F0=$e.setter,Y0=$e.setterContext;$e.read=b0=>ot.fromWireType(Gt(r0,b0)),$e.write=(b0,z0)=>{var Vx=[];F0(Y0,b0,c0.toWireType(Vx,z0)),rt(Vx)}}),[{name:U.name,fromWireType:$e=>{for(var st=new Array(J),ot=0;ot<J;++ot)st[ot]=X[ot].read($e);return ve($e),st},toWireType:($e,st)=>{if(J!==st.length)throw new TypeError("Incorrect number of tuple elements for "+U.name+": expected="+J+", actual="+st.length);for(var ot=pe(),Gt=0;Gt<J;++Gt)X[Gt].write(ot,st[Gt]);return $e!==null&&$e.push(ve,ot),ot},argPackAdvance:i0,readValueFromPointer:He,destructorFunction:ve}]))},_e={},Ge=D=>{var U=_e[D];delete _e[D];var X=U.rawConstructor,J=U.rawDestructor,ue=U.fields,pe=ue.map(ve=>ve.getterReturnType).concat(ue.map(ve=>ve.setterArgumentType));Z([D],pe,ve=>{var we={};return ue.forEach(($e,st)=>{var ot=$e.fieldName,Gt=ve[st],r0=$e.getter,c0=$e.getterContext,F0=ve[st+ue.length],Y0=$e.setter,b0=$e.setterContext;we[ot]={read:z0=>Gt.fromWireType(r0(c0,z0)),write:(z0,Vx)=>{var Tn=[];Y0(b0,z0,F0.toWireType(Tn,Vx)),rt(Tn)}}}),[{name:U.name,fromWireType:$e=>{var st={};for(var ot in we)st[ot]=we[ot].read($e);return J($e),st},toWireType:($e,st)=>{for(var ot in we)if(!(ot in st))throw new TypeError('Missing field: "'+ot+'"');var Gt=X();for(ot in we)we[ot].write(Gt,st[ot]);return $e!==null&&$e.push(J,Gt),Gt},argPackAdvance:i0,readValueFromPointer:He,destructorFunction:J}]})},Re=(D,U,X,J,ue)=>{},Ve=()=>{for(var D=new Array(256),U=0;U<256;++U)D[U]=String.fromCharCode(U);_t=D},_t,Ce=D=>{for(var U="",X=D;g[X];)U+=_t[g[X++]];return U},pt,et=D=>{throw new pt(D)};function tt(D,U,X={}){var J=U.name;if(D||et('type "'+J+'" must have a positive integer typeid pointer'),Ue.hasOwnProperty(D)){if(X.ignoreDuplicateRegistrations)return;et("Cannot register type '"+J+"' twice")}if(Ue[D]=U,delete bt[D],at.hasOwnProperty(D)){var ue=at[D];delete at[D],ue.forEach(pe=>pe())}}function gt(D,U,X={}){if(!("argPackAdvance"in U))throw new TypeError("registerType registeredInstance requires argPackAdvance");return tt(D,U,X)}var i0=8,Ht=(D,U,X,J)=>{U=Ce(U),gt(D,{name:U,fromWireType:function(ue){return!!ue},toWireType:function(ue,pe){return pe?X:J},argPackAdvance:i0,readValueFromPointer:function(ue){return this.fromWireType(g[ue])},destructorFunction:null})},St=D=>({count:D.count,deleteScheduled:D.deleteScheduled,preservePointerOnDelete:D.preservePointerOnDelete,ptr:D.ptr,ptrType:D.ptrType,smartPtr:D.smartPtr,smartPtrType:D.smartPtrType}),Ut=D=>{function U(X){return X.$$.ptrType.registeredClass.name}et(U(D)+" instance already deleted")},t0=!1,p0=D=>{},de=D=>{D.smartPtr?D.smartPtrType.rawDestructor(D.smartPtr):D.ptrType.registeredClass.rawDestructor(D.ptr)},ft=D=>{D.count.value-=1;var U=D.count.value===0;U&&de(D)},Xe=(D,U,X)=>{if(U===X)return D;if(X.baseClass===void 0)return null;var J=Xe(D,U,X.baseClass);return J===null?null:X.downcast(J)},Ze={},lt=()=>Object.keys(Cx).length,Wt=()=>{var D=[];for(var U in Cx)Cx.hasOwnProperty(U)&&D.push(Cx[U]);return D},Qt=[],D0=()=>{for(;Qt.length;){var D=Qt.pop();D.$$.deleteScheduled=!1,D.delete()}},P0,s0=D=>{P0=D,Qt.length&&P0&&P0(D0)},rn=()=>{t.getInheritedInstanceCount=lt,t.getLiveInheritedInstances=Wt,t.flushPendingDeletes=D0,t.setDelayFunction=s0},Cx={},ax=(D,U)=>{for(U===void 0&&et("ptr should not be undefined");D.baseClass;)U=D.upcast(U),D=D.baseClass;return U},L0=(D,U)=>(U=ax(D,U),Cx[U]),R0=(D,U)=>{(!U.ptrType||!U.ptr)&&dt("makeClassHandle requires ptr and ptrType");var X=!!U.smartPtrType,J=!!U.smartPtr;return X!==J&&dt("Both smartPtrType and smartPtr must be specified"),U.count={value:1},q0(Object.create(D,{$$:{value:U,writable:!0}}))};function Wn(D){var U=this.getPointee(D);if(!U)return this.destructor(D),null;var X=L0(this.registeredClass,U);if(X!==void 0){if(X.$$.count.value===0)return X.$$.ptr=U,X.$$.smartPtr=D,X.clone();var J=X.clone();return this.destructor(D),J}function ue(){return this.isSmartPointer?R0(this.registeredClass.instancePrototype,{ptrType:this.pointeeType,ptr:U,smartPtrType:this,smartPtr:D}):R0(this.registeredClass.instancePrototype,{ptrType:this,ptr:D})}var pe=this.registeredClass.getActualType(U),ve=Ze[pe];if(!ve)return ue.call(this);var we;this.isConst?we=ve.constPointerType:we=ve.pointerType;var $e=Xe(U,this.registeredClass,we.registeredClass);return $e===null?ue.call(this):this.isSmartPointer?R0(we.registeredClass.instancePrototype,{ptrType:we,ptr:$e,smartPtrType:this,smartPtr:D}):R0(we.registeredClass.instancePrototype,{ptrType:we,ptr:$e})}var q0=D=>typeof FinalizationRegistry>"u"?(q0=U=>U,D):(t0=new FinalizationRegistry(U=>{ft(U.$$)}),q0=U=>{var X=U.$$,J=!!X.smartPtr;if(J){var ue={$$:X};t0.register(U,ue,U)}return U},p0=U=>t0.unregister(U),q0(D)),Fx=()=>{Object.assign(gn.prototype,{isAliasOf(D){if(!(this instanceof gn)||!(D instanceof gn))return!1;var U=this.$$.ptrType.registeredClass,X=this.$$.ptr;D.$$=D.$$;for(var J=D.$$.ptrType.registeredClass,ue=D.$$.ptr;U.baseClass;)X=U.upcast(X),U=U.baseClass;for(;J.baseClass;)ue=J.upcast(ue),J=J.baseClass;return U===J&&X===ue},clone(){if(this.$$.ptr||Ut(this),this.$$.preservePointerOnDelete)return this.$$.count.value+=1,this;var D=q0(Object.create(Object.getPrototypeOf(this),{$$:{value:St(this.$$)}}));return D.$$.count.value+=1,D.$$.deleteScheduled=!1,D},delete(){this.$$.ptr||Ut(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&et("Object already scheduled for deletion"),p0(this),ft(this.$$),this.$$.preservePointerOnDelete||(this.$$.smartPtr=void 0,this.$$.ptr=void 0)},isDeleted(){return!this.$$.ptr},deleteLater(){return this.$$.ptr||Ut(this),this.$$.deleteScheduled&&!this.$$.preservePointerOnDelete&&et("Object already scheduled for deletion"),Qt.push(this),Qt.length===1&&P0&&P0(D0),this.$$.deleteScheduled=!0,this}})};function gn(){}var mi=(D,U)=>Object.defineProperty(U,"name",{value:D}),yi=(D,U,X)=>{if(D[U].overloadTable===void 0){var J=D[U];D[U]=function(...ue){return D[U].overloadTable.hasOwnProperty(ue.length)||et("Function '"+X+"' called with an invalid number of arguments ("+ue.length+") - expects one of ("+D[U].overloadTable+")!"),D[U].overloadTable[ue.length].apply(this,ue)},D[U].overloadTable=[],D[U].overloadTable[J.argCount]=J}},Gr=(D,U,X)=>{t.hasOwnProperty(D)?(et("Cannot register public name '"+D+"' twice"),yi(t,D,D),t.hasOwnProperty(X)&&et("Cannot register multiple overloads of a function with the same number of arguments ("+X+")!"),t[D].overloadTable[X]=U):t[D]=U},Ii=48,Oi=57,vn=D=>{if(D===void 0)return"_unknown";D=D.replace(/[^a-zA-Z0-9_]/g,"$");var U=D.charCodeAt(0);return U>=Ii&&U<=Oi?"_"+D:D};function Y(D,U,X,J,ue,pe,ve,we){this.name=D,this.constructor=U,this.instancePrototype=X,this.rawDestructor=J,this.baseClass=ue,this.getActualType=pe,this.upcast=ve,this.downcast=we,this.pureVirtualFunctions=[]}var ce=(D,U,X)=>{for(;U!==X;)U.upcast||et("Expected null or instance of "+X.name+", got an instance of "+U.name),D=U.upcast(D),U=U.baseClass;return D};function Ne(D,U){if(U===null)return this.isReference&&et("null is not a valid "+this.name),0;U.$$||et('Cannot pass "'+Wr(U)+'" as a '+this.name),U.$$.ptr||et("Cannot pass deleted object as a pointer of type "+this.name);var X=U.$$.ptrType.registeredClass,J=ce(U.$$.ptr,X,this.registeredClass);return J}function Ie(D,U){var X;if(U===null)return this.isReference&&et("null is not a valid "+this.name),this.isSmartPointer?(X=this.rawConstructor(),D!==null&&D.push(this.rawDestructor,X),X):0;(!U||!U.$$)&&et('Cannot pass "'+Wr(U)+'" as a '+this.name),U.$$.ptr||et("Cannot pass deleted object as a pointer of type "+this.name),!this.isConst&&U.$$.ptrType.isConst&&et("Cannot convert argument of type "+(U.$$.smartPtrType?U.$$.smartPtrType.name:U.$$.ptrType.name)+" to parameter type "+this.name);var J=U.$$.ptrType.registeredClass;if(X=ce(U.$$.ptr,J,this.registeredClass),this.isSmartPointer)switch(U.$$.smartPtr===void 0&&et("Passing raw pointer to smart pointer is illegal"),this.sharingPolicy){case 0:U.$$.smartPtrType===this?X=U.$$.smartPtr:et("Cannot convert argument of type "+(U.$$.smartPtrType?U.$$.smartPtrType.name:U.$$.ptrType.name)+" to parameter type "+this.name);break;case 1:X=U.$$.smartPtr;break;case 2:if(U.$$.smartPtrType===this)X=U.$$.smartPtr;else{var ue=U.clone();X=this.rawShare(X,Lx.toHandle(()=>ue.delete())),D!==null&&D.push(this.rawDestructor,X)}break;default:et("Unsupporting sharing policy")}return X}function fe(D,U){if(U===null)return this.isReference&&et("null is not a valid "+this.name),0;U.$$||et('Cannot pass "'+Wr(U)+'" as a '+this.name),U.$$.ptr||et("Cannot pass deleted object as a pointer of type "+this.name),U.$$.ptrType.isConst&&et("Cannot convert argument of type "+U.$$.ptrType.name+" to parameter type "+this.name);var X=U.$$.ptrType.registeredClass,J=ce(U.$$.ptr,X,this.registeredClass);return J}var ct=()=>{Object.assign(wt.prototype,{getPointee(D){return this.rawGetPointee&&(D=this.rawGetPointee(D)),D},destructor(D){var U;(U=this.rawDestructor)==null||U.call(this,D)},argPackAdvance:i0,readValueFromPointer:He,fromWireType:Wn})};function wt(D,U,X,J,ue,pe,ve,we,$e,st,ot){this.name=D,this.registeredClass=U,this.isReference=X,this.isConst=J,this.isSmartPointer=ue,this.pointeeType=pe,this.sharingPolicy=ve,this.rawGetPointee=we,this.rawConstructor=$e,this.rawShare=st,this.rawDestructor=ot,!ue&&U.baseClass===void 0?J?(this.toWireType=Ne,this.destructorFunction=null):(this.toWireType=fe,this.destructorFunction=null):this.toWireType=Ie}var It=(D,U,X)=>{t.hasOwnProperty(D)||dt("Replacing nonexistent public symbol"),t[D].overloadTable!==void 0&&X!==void 0?t[D].overloadTable[X]=U:(t[D]=U,t[D].argCount=X)},Ct=(D,U,X)=>{var J=t["dynCall_"+D];return J(U,...X)},Kt=[],Ft,Dt=D=>{var U=Kt[D];return U||(D>=Kt.length&&(Kt.length=D+1),Kt[D]=U=Ft.get(D)),U},Zt=(D,U,X=[])=>{if(D.includes("j"))return Ct(D,U,X);var J=Dt(U)(...X);return J},v0=(D,U)=>(...X)=>Zt(D,U,X),h0=(D,U)=>{D=Ce(D);function X(){return D.includes("j")?v0(D,U):Dt(U)}var J=X();return typeof J!="function"&&et("unknown function pointer with signature "+D+": "+U),J},sx=(D,U)=>{var X=mi(U,function(J){this.name=U,this.message=J;var ue=new Error(J).stack;ue!==void 0&&(this.stack=this.toString()+`
`+ue.replace(/^Error(:[^\n]*)?\n/,""))});return X.prototype=Object.create(D.prototype),X.prototype.constructor=X,X.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},X},d0,Ot=D=>{var U=z(D),X=Ce(U);return In(U),X},$0=(D,U)=>{var X=[],J={};function ue(pe){if(!J[pe]&&!Ue[pe]){if(bt[pe]){bt[pe].forEach(ue);return}X.push(pe),J[pe]=!0}}throw U.forEach(ue),new d0(D+": "+X.map(Ot).join([", "]))},y0=(D,U,X,J,ue,pe,ve,we,$e,st,ot,Gt,r0)=>{ot=Ce(ot),pe=h0(ue,pe),we&&(we=h0(ve,we)),st&&(st=h0($e,st)),r0=h0(Gt,r0);var c0=vn(ot);Gr(c0,function(){$0("Cannot construct "+ot+" due to unbound types",[J])}),Z([D,U,X],J?[J]:[],F0=>{var Y0;F0=F0[0];var b0,z0;J?(b0=F0.registeredClass,z0=b0.instancePrototype):z0=gn.prototype;var Vx=mi(ot,function(...qo){if(Object.getPrototypeOf(this)!==Tn)throw new pt("Use 'new' to construct "+ot);if(sn.constructor_body===void 0)throw new pt(ot+" has no accessible constructor");var bl=sn.constructor_body[qo.length];if(bl===void 0)throw new pt("Tried to invoke ctor of "+ot+" with invalid number of parameters ("+qo.length+") - expected ("+Object.keys(sn.constructor_body).toString()+") parameters instead!");return bl.apply(this,qo)}),Tn=Object.create(z0,{constructor:{value:Vx}});Vx.prototype=Tn;var sn=new Y(ot,Vx,Tn,r0,b0,pe,we,st);sn.baseClass&&((Y0=sn.baseClass).__derivedClasses!=null||(Y0.__derivedClasses=[]),sn.baseClass.__derivedClasses.push(sn));var Kn=new wt(ot,sn,!0,!1,!1),Kr=new wt(ot+"*",sn,!1,!1,!1),zc=new wt(ot+" const*",sn,!1,!0,!1);return Ze[D]={pointerType:Kr,constPointerType:zc},It(c0,Vx),[Kn,Kr,zc]})},U0=(D,U)=>{for(var X=[],J=0;J<D;J++)X.push(T[U+J*4>>2]);return X};function gi(D){for(var U=1;U<D.length;++U)if(D[U]!==null&&D[U].destructorFunction===void 0)return!0;return!1}function Bx(D,U,X,J,ue,pe){var ve=U.length;ve<2&&et("argTypes array size mismatch! Must at least get return value and 'this' types!");var we=U[1]!==null&&X!==null,$e=gi(U),st=U[0].name!=="void",ot=ve-2,Gt=new Array(ot),r0=[],c0=[],F0=function(...Y0){Y0.length!==ot&&et("function "+D+" called with "+Y0.length+" arguments, expected "+ot),c0.length=0;var b0;r0.length=we?2:1,r0[0]=ue,we&&(b0=U[1].toWireType(c0,this),r0[1]=b0);for(var z0=0;z0<ot;++z0)Gt[z0]=U[z0+2].toWireType(c0,Y0[z0]),r0.push(Gt[z0]);var Vx=J(...r0);function Tn(sn){if($e)rt(c0);else for(var Kn=we?1:2;Kn<U.length;Kn++){var Kr=Kn===1?b0:Gt[Kn-2];U[Kn].destructorFunction!==null&&U[Kn].destructorFunction(Kr)}if(st)return U[0].fromWireType(sn)}return Tn(Vx)};return mi(D,F0)}var Di=(D,U,X,J,ue,pe)=>{var ve=U0(U,X);ue=h0(J,ue),Z([],[D],we=>{we=we[0];var $e="constructor "+we.name;if(we.registeredClass.constructor_body===void 0&&(we.registeredClass.constructor_body=[]),we.registeredClass.constructor_body[U-1]!==void 0)throw new pt("Cannot register multiple constructors with identical number of parameters ("+(U-1)+") for class '"+we.name+"'! Overload resolution is currently only performed using the parameter count, not actual type info!");return we.registeredClass.constructor_body[U-1]=()=>{$0("Cannot construct "+we.name+" due to unbound types",ve)},Z([],ve,st=>(st.splice(1,0,null),we.registeredClass.constructor_body[U-1]=Bx($e,st,null,ue,pe),[])),[]})},Q0=D=>{D=D.trim();const U=D.indexOf("(");return U!==-1?D.substr(0,U):D},bn=(D,U,X,J,ue,pe,ve,we,$e)=>{var st=U0(X,J);U=Ce(U),U=Q0(U),pe=h0(ue,pe),Z([],[D],ot=>{ot=ot[0];var Gt=ot.name+"."+U;U.startsWith("@@")&&(U=Symbol[U.substring(2)]),we&&ot.registeredClass.pureVirtualFunctions.push(U);function r0(){$0("Cannot call "+Gt+" due to unbound types",st)}var c0=ot.registeredClass.instancePrototype,F0=c0[U];return F0===void 0||F0.overloadTable===void 0&&F0.className!==ot.name&&F0.argCount===X-2?(r0.argCount=X-2,r0.className=ot.name,c0[U]=r0):(yi(c0,U,Gt),c0[U].overloadTable[X-2]=r0),Z([],st,Y0=>{var b0=Bx(Gt,Y0,ot,pe,ve);return c0[U].overloadTable===void 0?(b0.argCount=X-2,c0[U]=b0):c0[U].overloadTable[X-2]=b0,[]}),[]})},vi=(D,U,X)=>(D instanceof Object||et(X+' with invalid "this": '+D),D instanceof U.registeredClass.constructor||et(X+' incompatible with "this" of type '+D.constructor.name),D.$$.ptr||et("cannot call emscripten binding method "+X+" on deleted object"),ce(D.$$.ptr,D.$$.ptrType.registeredClass,U.registeredClass)),T0=(D,U,X,J,ue,pe,ve,we,$e,st)=>{U=Ce(U),ue=h0(J,ue),Z([],[D],ot=>{ot=ot[0];var Gt=ot.name+"."+U,r0={get(){$0("Cannot access "+Gt+" due to unbound types",[X,ve])},enumerable:!0,configurable:!0};return $e?r0.set=()=>$0("Cannot access "+Gt+" due to unbound types",[X,ve]):r0.set=c0=>et(Gt+" is a read-only property"),Object.defineProperty(ot.registeredClass.instancePrototype,U,r0),Z([],$e?[X,ve]:[X],c0=>{var F0=c0[0],Y0={get(){var z0=vi(this,ot,Gt+" getter");return F0.fromWireType(ue(pe,z0))},enumerable:!0};if($e){$e=h0(we,$e);var b0=c0[1];Y0.set=function(z0){var Vx=vi(this,ot,Gt+" setter"),Tn=[];$e(st,Vx,b0.toWireType(Tn,z0)),rt(Tn)}}return Object.defineProperty(ot.registeredClass.instancePrototype,U,Y0),[]}),[]})},Xn=[],Nx=[],Pi=D=>{D>9&&--Nx[D+1]===0&&(Nx[D]=void 0,Xn.push(D))},bi=()=>Nx.length/2-5-Xn.length,Ko=()=>{Nx.push(0,1,void 0,1,null,1,!0,1,!1,1),t.count_emval_handles=bi},Lx={toValue:D=>(D||et("Cannot use deleted val. handle = "+D),Nx[D]),toHandle:D=>{switch(D){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:{const U=Xn.pop()||Nx.length;return Nx[U]=D,Nx[U+1]=1,U}}}},ki={name:"emscripten::val",fromWireType:D=>{var U=Lx.toValue(D);return Pi(D),U},toWireType:(D,U)=>Lx.toHandle(U),argPackAdvance:i0,readValueFromPointer:He,destructorFunction:null},yl=D=>gt(D,ki),Wr=D=>{if(D===null)return"null";var U=typeof D;return U==="object"||U==="array"||U==="function"?D.toString():""+D},$o=(D,U)=>{switch(U){case 4:return function(X){return this.fromWireType(E[X>>2])};case 8:return function(X){return this.fromWireType(A[X>>3])};default:throw new TypeError("invalid float width ("+U+"): "+D)}},Fs=(D,U,X)=>{U=Ce(U),gt(D,{name:U,fromWireType:J=>J,toWireType:(J,ue)=>ue,argPackAdvance:i0,readValueFromPointer:$o(U,X),destructorFunction:null})},gl=(D,U,X)=>{switch(U){case 1:return X?J=>m[J]:J=>g[J];case 2:return X?J=>_[J>>1]:J=>v[J>>1];case 4:return X?J=>b[J>>2]:J=>T[J>>2];default:throw new TypeError("invalid integer width ("+U+"): "+D)}},vl=(D,U,X,J,ue)=>{U=Ce(U);var pe=ot=>ot;if(J===0){var ve=32-8*X;pe=ot=>ot<<ve>>>ve}var we=U.includes("unsigned"),$e=(ot,Gt)=>{},st;we?st=function(ot,Gt){return $e(Gt,this.name),Gt>>>0}:st=function(ot,Gt){return $e(Gt,this.name),Gt},gt(D,{name:U,fromWireType:pe,toWireType:st,argPackAdvance:i0,readValueFromPointer:gl(U,X,J!==0),destructorFunction:null})},rs=(D,U,X)=>{var J=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],ue=J[U];function pe(ve){var we=T[ve>>2],$e=T[ve+4>>2];return new ue(m.buffer,$e,we)}X=Ce(X),gt(D,{name:X,fromWireType:pe,argPackAdvance:i0,readValueFromPointer:pe},{ignoreDuplicateRegistrations:!0})},as=(D,U,X,J)=>{if(!(J>0))return 0;for(var ue=X,pe=X+J-1,ve=0;ve<D.length;++ve){var we=D.charCodeAt(ve);if(we>=55296&&we<=57343){var $e=D.charCodeAt(++ve);we=65536+((we&1023)<<10)|$e&1023}if(we<=127){if(X>=pe)break;U[X++]=we}else if(we<=2047){if(X+1>=pe)break;U[X++]=192|we>>6,U[X++]=128|we&63}else if(we<=65535){if(X+2>=pe)break;U[X++]=224|we>>12,U[X++]=128|we>>6&63,U[X++]=128|we&63}else{if(X+3>=pe)break;U[X++]=240|we>>18,U[X++]=128|we>>12&63,U[X++]=128|we>>6&63,U[X++]=128|we&63}}return U[X]=0,X-ue},_n=(D,U,X)=>as(D,g,U,X),nr=D=>{for(var U=0,X=0;X<D.length;++X){var J=D.charCodeAt(X);J<=127?U++:J<=2047?U+=2:J>=55296&&J<=57343?(U+=4,++X):U+=3}return U},Ui=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Qo=(D,U,X)=>{for(var J=U+X,ue=U;D[ue]&&!(ue>=J);)++ue;if(ue-U>16&&D.buffer&&Ui)return Ui.decode(D.subarray(U,ue));for(var pe="";U<ue;){var ve=D[U++];if(!(ve&128)){pe+=String.fromCharCode(ve);continue}var we=D[U++]&63;if((ve&224)==192){pe+=String.fromCharCode((ve&31)<<6|we);continue}var $e=D[U++]&63;if((ve&240)==224?ve=(ve&15)<<12|we<<6|$e:ve=(ve&7)<<18|we<<12|$e<<6|D[U++]&63,ve<65536)pe+=String.fromCharCode(ve);else{var st=ve-65536;pe+=String.fromCharCode(55296|st>>10,56320|st&1023)}}return pe},zx=(D,U)=>D?Qo(g,D,U):"",Zo=(D,U)=>{U=Ce(U);var X=U==="std::string";gt(D,{name:U,fromWireType(J){var ue=T[J>>2],pe=J+4,ve;if(X)for(var we=pe,$e=0;$e<=ue;++$e){var st=pe+$e;if($e==ue||g[st]==0){var ot=st-we,Gt=zx(we,ot);ve===void 0?ve=Gt:(ve+="\0",ve+=Gt),we=st+1}}else{for(var r0=new Array(ue),$e=0;$e<ue;++$e)r0[$e]=String.fromCharCode(g[pe+$e]);ve=r0.join("")}return In(J),ve},toWireType(J,ue){ue instanceof ArrayBuffer&&(ue=new Uint8Array(ue));var pe,ve=typeof ue=="string";ve||ue instanceof Uint8Array||ue instanceof Uint8ClampedArray||ue instanceof Int8Array||et("Cannot pass non-string to std::string"),X&&ve?pe=nr(ue):pe=ue.length;var we=us(4+pe+1),$e=we+4;if(T[we>>2]=pe,X&&ve)_n(ue,$e,pe+1);else if(ve)for(var st=0;st<pe;++st){var ot=ue.charCodeAt(st);ot>255&&(In($e),et("String has UTF-16 code units that do not fit in 8 bits")),g[$e+st]=ot}else for(var st=0;st<pe;++st)g[$e+st]=ue[st];return J!==null&&J.push(In,we),we},argPackAdvance:i0,readValueFromPointer:He,destructorFunction(J){In(J)}})},ir=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,_i=(D,U)=>{for(var X=D,J=X>>1,ue=J+U/2;!(J>=ue)&&v[J];)++J;if(X=J<<1,X-D>32&&ir)return ir.decode(g.subarray(D,X));for(var pe="",ve=0;!(ve>=U/2);++ve){var we=_[D+ve*2>>1];if(we==0)break;pe+=String.fromCharCode(we)}return pe},Bs=(D,U,X)=>{if(X!=null||(X=2147483647),X<2)return 0;X-=2;for(var J=U,ue=X<D.length*2?X/2:D.length,pe=0;pe<ue;++pe){var ve=D.charCodeAt(pe);_[U>>1]=ve,U+=2}return _[U>>1]=0,U-J},Ma=D=>D.length*2,Fi=(D,U)=>{for(var X=0,J="";!(X>=U/4);){var ue=b[D+X*4>>2];if(ue==0)break;if(++X,ue>=65536){var pe=ue-65536;J+=String.fromCharCode(55296|pe>>10,56320|pe&1023)}else J+=String.fromCharCode(ue)}return J},Ls=(D,U,X)=>{if(X!=null||(X=2147483647),X<4)return 0;for(var J=U,ue=J+X-4,pe=0;pe<D.length;++pe){var ve=D.charCodeAt(pe);if(ve>=55296&&ve<=57343){var we=D.charCodeAt(++pe);ve=65536+((ve&1023)<<10)|we&1023}if(b[U>>2]=ve,U+=4,U+4>ue)break}return b[U>>2]=0,U-J},ss=D=>{for(var U=0,X=0;X<D.length;++X){var J=D.charCodeAt(X);J>=55296&&J<=57343&&++X,U+=4}return U},Jo=(D,U,X)=>{X=Ce(X);var J,ue,pe,ve;U===2?(J=_i,ue=Bs,ve=Ma,pe=we=>v[we>>1]):U===4&&(J=Fi,ue=Ls,ve=ss,pe=we=>T[we>>2]),gt(D,{name:X,fromWireType:we=>{for(var $e=T[we>>2],st,ot=we+4,Gt=0;Gt<=$e;++Gt){var r0=we+4+Gt*U;if(Gt==$e||pe(r0)==0){var c0=r0-ot,F0=J(ot,c0);st===void 0?st=F0:(st+="\0",st+=F0),ot=r0+U}}return In(we),st},toWireType:(we,$e)=>{typeof $e!="string"&&et("Cannot pass non-string to C++ string type "+X);var st=ve($e),ot=us(4+st+U);return T[ot>>2]=st/U,ue($e,ot+4,st+U),we!==null&&we.push(In,ot),ot},argPackAdvance:i0,readValueFromPointer:He,destructorFunction(we){In(we)}})},os=(D,U,X,J,ue,pe)=>{Q[D]={name:Ce(U),rawConstructor:h0(X,J),rawDestructor:h0(ue,pe),elements:[]}},ls=(D,U,X,J,ue,pe,ve,we,$e)=>{Q[D].elements.push({getterReturnType:U,getter:h0(X,J),getterContext:ue,setterArgumentType:pe,setter:h0(ve,we),setterContext:$e})},zs=(D,U,X,J,ue,pe)=>{_e[D]={name:Ce(U),rawConstructor:h0(X,J),rawDestructor:h0(ue,pe),fields:[]}},an=(D,U,X,J,ue,pe,ve,we,$e,st)=>{_e[D].fields.push({fieldName:Ce(U),getterReturnType:X,getter:h0(J,ue),getterContext:pe,setterArgumentType:ve,setter:h0(we,$e),setterContext:st})},rr=(D,U)=>{U=Ce(U),gt(D,{isVoid:!0,name:U,argPackAdvance:0,fromWireType:()=>{},toWireType:(X,J)=>{}})},cs=(D,U)=>{var X=Ue[D];return X===void 0&&et(U+" has unknown type "+Ot(D)),X},Xr=(D,U)=>{D=cs(D,"_emval_take_value");var X=D.readValueFromPointer(U);return Lx.toHandle(X)},jo=()=>{be("")},Vs=(D,U,X)=>g.copyWithin(D,U,U+X),Yn=()=>2147483648,Sn=D=>{var U=d.buffer,X=(D-U.byteLength+65535)/65536;try{return d.grow(X),M(),1}catch{}},Yr=D=>{var U=g.length;D>>>=0;var X=Yn();if(D>X)return!1;for(var J=($e,st)=>$e+(st-$e%st)%st,ue=1;ue<=4;ue*=2){var pe=U*(1+.2/ue);pe=Math.min(pe,D+100663296);var ve=Math.min(X,J(Math.max(D,pe),65536)),we=Sn(ve);if(we)return!0}return!1};ht=t.InternalError=class extends Error{constructor(D){super(D),this.name="InternalError"}},Ve(),pt=t.BindingError=class extends Error{constructor(D){super(D),this.name="BindingError"}},Fx(),rn(),ct(),d0=t.UnboundTypeError=sx(Error,"UnboundTypeError"),Ko();var Hs={b:Bt,h:V,x:Ge,q:Re,v:Ht,l:y0,g:Di,c:bn,f:T0,u:yl,n:Fs,e:vl,a:rs,m:Zo,j:Jo,i:os,d:ls,o:zs,k:an,w:rr,p:Xr,r:jo,t:Vs,s:Yr},ei=Qe(),In=D=>(In=ei.A)(D),us=D=>(us=ei.B)(D),z=D=>(z=ei.D)(D),L=D=>(L=ei.E)(D),ne;H=function D(){ne||Te(),ne||(H=D)};function Te(){if(ae>0||(P(),ae>0))return;function D(){ne||(ne=!0,t.calledRun=!0,!p&&(N(),n(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),G()))}t.setStatus?(t.setStatus("Running..."),setTimeout(function(){setTimeout(function(){t.setStatus("")},1),D()},1)):D()}if(t.preInit)for(typeof t.preInit=="function"&&(t.preInit=[t.preInit]);t.preInit.length>0;)t.preInit.pop()();return Te(),e.ready}})();var pI;(x=>(x.add=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]],x.sub=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]],x.cross=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],x.dot=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2],x.lerp=(e,t,n)=>[e[0]+(t[0]-e[0])*n,e[1]+(t[1]-e[1])*n,e[2]+(t[2]-e[2])*n],x.scale=(e,t)=>[e[0]*t,e[1]*t,e[2]*t],x.scaleInPlace=(e,t)=>(e[0]*=t,e[1]*=t,e[2]*=t,e),x.negate=e=>[-e[0],-e[1],-e[2]],x.negateInPlace=e=>(e[0]=-e[0],e[1]=-e[1],e[2]=-e[2],e),x.normalize=e=>(0,x.scale)(e,1/(0,x.length)(e)),x.normalizeInPlace=e=>(0,x.scaleInPlace)(e,1/(0,x.length)(e)),x.normalizeToLen=(e,t)=>(0,x.scale)(e,t/(0,x.length)(e)),x.normalizeToLenInPlace=(e,t)=>(0,x.scaleInPlace)(e,t/(0,x.length)(e)),x.lengthSqr=e=>e[0]**2+e[1]**2+e[2]**2,x.length=e=>Math.sqrt(e[0]**2+e[1]**2+e[2]**2)))(pI||(pI={}));var Mc=typeof self<"u"?self:{};function Bl(){throw Error("Invalid UTF8")}function mI(x,e){return e=String.fromCharCode.apply(null,e),x==null?e:x+e}let Xm,E_;const Hq=typeof TextDecoder<"u";let yI;const Gq=typeof TextEncoder<"u";function jF(x){if(Gq)x=(yI||(yI=new TextEncoder)).encode(x);else{let t=0;const n=new Uint8Array(3*x.length);for(let i=0;i<x.length;i++){var e=x.charCodeAt(i);if(e<128)n[t++]=e;else{if(e<2048)n[t++]=e>>6|192;else{if(e>=55296&&e<=57343){if(e<=56319&&i<x.length){const r=x.charCodeAt(++i);if(r>=56320&&r<=57343){e=1024*(e-55296)+r-56320+65536,n[t++]=e>>18|240,n[t++]=e>>12&63|128,n[t++]=e>>6&63|128,n[t++]=63&e|128;continue}i--}e=65533}n[t++]=e>>12|224,n[t++]=e>>6&63|128}n[t++]=63&e|128}}x=t===n.length?n:n.subarray(0,t)}return x}var gE,L1;e:{for(var gI=["CLOSURE_FLAGS"],M_=Mc,R_=0;R_<gI.length;R_++)if((M_=M_[gI[R_]])==null){L1=null;break e}L1=M_}var Zf,vI=L1&&L1[610401301];gE=vI!=null&&vI;const bI=Mc.navigator;function DT(x){return!!gE&&!!Zf&&Zf.brands.some(({brand:e})=>e&&e.indexOf(x)!=-1)}function da(x){var e;return(e=Mc.navigator)&&(e=e.userAgent)||(e=""),e.indexOf(x)!=-1}function B2(){return!!gE&&!!Zf&&Zf.brands.length>0}function C_(){return B2()?DT("Chromium"):(da("Chrome")||da("CriOS"))&&!(!B2()&&da("Edge"))||da("Silk")}function vE(x){return vE[" "](x),x}Zf=bI&&bI.userAgentData||null,vE[" "]=function(){};var Wq=!B2()&&(da("Trident")||da("MSIE"));!da("Android")||C_(),C_(),da("Safari")&&(C_()||!B2()&&da("Coast")||!B2()&&da("Opera")||!B2()&&da("Edge")||(B2()?DT("Microsoft Edge"):da("Edg/"))||B2()&&DT("Opera"));var qF={},Nf=null;function Xq(x){const e=x.length;let t=3*e/4;t%3?t=Math.floor(t):"=.".indexOf(x[e-1])!=-1&&(t="=.".indexOf(x[e-2])!=-1?t-2:t-1);const n=new Uint8Array(t);let i=0;return function(r,a){function s(c){for(;l<r.length;){const h=r.charAt(l++),d=Nf[h];if(d!=null)return d;if(!/^[\s\xa0]*$/.test(h))throw Error("Unknown base64 encoding at char: "+h)}return c}e4();let l=0;for(;;){const c=s(-1),h=s(0),d=s(64),p=s(64);if(p===64&&c===-1)break;a(c<<2|h>>4),d!=64&&(a(h<<4&240|d>>2),p!=64&&a(d<<6&192|p))}}(x,function(r){n[i++]=r}),i!==t?n.subarray(0,i):n}function e4(){if(!Nf){Nf={};var x="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),e=["+/=","+/","-_=","-_.","-_"];for(let t=0;t<5;t++){const n=x.concat(e[t].split(""));qF[t]=n;for(let i=0;i<n.length;i++){const r=n[i];Nf[r]===void 0&&(Nf[r]=i)}}}}var t4=typeof Uint8Array<"u",x4=!Wq&&typeof btoa=="function";function _I(x){if(!x4){var e;e===void 0&&(e=0),e4(),e=qF[e];var t=Array(Math.floor(x.length/3)),n=e[64]||"";let l=0,c=0;for(;l<x.length-2;l+=3){var i=x[l],r=x[l+1],a=x[l+2],s=e[i>>2];i=e[(3&i)<<4|r>>4],r=e[(15&r)<<2|a>>6],a=e[63&a],t[c++]=s+i+r+a}switch(s=0,a=n,x.length-l){case 2:a=e[(15&(s=x[l+1]))<<2]||n;case 1:x=x[l],t[c]=e[x>>2]+e[(3&x)<<4|s>>4]+a+n}return t.join("")}for(e="",t=0,n=x.length-10240;t<n;)e+=String.fromCharCode.apply(null,x.subarray(t,t+=10240));return e+=String.fromCharCode.apply(null,t?x.subarray(t):x),btoa(e)}const SI=/[-_.]/g,Yq={"-":"+",_:"/",".":"="};function Kq(x){return Yq[x]||""}function n4(x){if(!x4)return Xq(x);SI.test(x)&&(x=x.replace(SI,Kq)),x=atob(x);const e=new Uint8Array(x.length);for(let t=0;t<x.length;t++)e[t]=x.charCodeAt(t);return e}function wp(x){return t4&&x!=null&&x instanceof Uint8Array}var Nh={};function Rc(){return TI||(TI=new Po(null,Nh))}function bE(x){i4(Nh);var e=x.g;return(e=e==null||wp(e)?e:typeof e=="string"?n4(e):null)==null?e:x.g=e}var Po=class{h(){return new Uint8Array(bE(this)||0)}constructor(x,e){if(i4(e),this.g=x,x!=null&&x.length===0)throw Error("ByteString should be constructed with non-empty values")}};let TI,N_;function i4(x){if(x!==Nh)throw Error("illegal external caller")}function r4(x,e){x.__closure__error__context__984382||(x.__closure__error__context__984382={}),x.__closure__error__context__984382.severity=e}function a4(x){return r4(x=Error(x),"warning"),x}var zg=typeof Symbol=="function"&&typeof Symbol()=="symbol",$q=new Set;function Ap(x,e,t=!1,n=!1){return x=typeof Symbol=="function"&&typeof Symbol()=="symbol"?n&&Symbol.for&&x?Symbol.for(x):x!=null?Symbol(x):Symbol():e,t&&$q.add(x),x}var Qq=Ap("jas",void 0,!0,!0),wI=Ap(void 0,"0di"),I_=Ap(void 0,"2ex"),of=Ap(void 0,"1oa",!0),Ih=Ap(void 0,Symbol(),!0);const qt=zg?Qq:"Ga",s4={Ga:{value:0,configurable:!0,writable:!0,enumerable:!1}},o4=Object.defineProperties;function Vg(x,e){zg||qt in x||o4(x,s4),x[qt]|=e}function dn(x,e){zg||qt in x||o4(x,s4),x[qt]=e}function id(x){return Vg(x,34),x}function Zq(x,e){dn(e,-30975&(0|x))}function PT(x,e){dn(e,-30941&(34|x))}function _E(){return typeof BigInt=="function"}function qi(x){return Array.prototype.slice.call(x)}var SE,Ep={},l4={};function AI(x){return!(!x||typeof x!="object"||x.Ia!==l4)}function TE(x){return x!==null&&typeof x=="object"&&!Array.isArray(x)&&x.constructor===Object}function wE(x,e){if(x!=null){if(typeof x=="string")x=x?new Po(x,Nh):Rc();else if(x.constructor!==Po)if(wp(x))x=x.length?new Po(new Uint8Array(x),Nh):Rc();else{if(!e)throw Error();x=void 0}}return x}function z1(x){return!(!Array.isArray(x)||x.length)&&!!(1&(0|x[qt]))}const EI=[];function hl(x){if(2&x)throw Error()}dn(EI,55),SE=Object.freeze(EI);class V1{constructor(e,t,n){this.l=0,this.g=e,this.h=t,this.m=n}next(){if(this.l<this.g.length){const e=this.g[this.l++];return{done:!1,value:this.h?this.h.call(this.m,e):e}}return{done:!0,value:void 0}}[Symbol.iterator](){return new V1(this.g,this.h,this.m)}}function AE(x){return Ih?x[Ih]:void 0}var Jq=Object.freeze({});function Hg(x){return x.Qa=!0,x}var jq=Hg(x=>typeof x=="number"),MI=Hg(x=>typeof x=="string"),qq=Hg(x=>typeof x=="boolean"),Gg=typeof Mc.BigInt=="function"&&typeof Mc.BigInt(0)=="bigint",kT=Hg(x=>Gg?x>=tee&&x<=nee:x[0]==="-"?RI(x,eee):RI(x,xee));const eee=Number.MIN_SAFE_INTEGER.toString(),tee=Gg?BigInt(Number.MIN_SAFE_INTEGER):void 0,xee=Number.MAX_SAFE_INTEGER.toString(),nee=Gg?BigInt(Number.MAX_SAFE_INTEGER):void 0;function RI(x,e){if(x.length>e.length)return!1;if(x.length<e.length||x===e)return!0;for(let t=0;t<x.length;t++){const n=x[t],i=e[t];if(n>i)return!1;if(n<i)return!0}}const iee=typeof Uint8Array.prototype.slice=="function";let H1,yx=0,$x=0;function CI(x){const e=x>>>0;yx=e,$x=(x-e)/4294967296>>>0}function Oh(x){if(x<0){CI(-x);const[e,t]=CE(yx,$x);yx=e>>>0,$x=t>>>0}else CI(x)}function EE(x){const e=H1||(H1=new DataView(new ArrayBuffer(8)));e.setFloat32(0,+x,!0),$x=0,yx=e.getUint32(0,!0)}function ME(x,e){const t=4294967296*e+(x>>>0);return Number.isSafeInteger(t)?t:Jf(x,e)}function RE(x,e){const t=2147483648&e;return t&&(e=~e>>>0,(x=1+~x>>>0)==0&&(e=e+1>>>0)),typeof(x=ME(x,e))=="number"?t?-x:x:t?"-"+x:x}function Jf(x,e){if(x>>>=0,(e>>>=0)<=2097151)var t=""+(4294967296*e+x);else _E()?t=""+(BigInt(e)<<BigInt(32)|BigInt(x)):(x=(16777215&x)+6777216*(t=16777215&(x>>>24|e<<8))+6710656*(e=e>>16&65535),t+=8147497*e,e*=2,x>=1e7&&(t+=x/1e7>>>0,x%=1e7),t>=1e7&&(e+=t/1e7>>>0,t%=1e7),t=e+NI(t)+NI(x));return t}function NI(x){return x=String(x),"0000000".slice(x.length)+x}function Wg(x){if(x.length<16)Oh(Number(x));else if(_E())x=BigInt(x),yx=Number(x&BigInt(4294967295))>>>0,$x=Number(x>>BigInt(32)&BigInt(4294967295));else{const e=+(x[0]==="-");$x=yx=0;const t=x.length;for(let n=e,i=(t-e)%6+e;i<=t;n=i,i+=6){const r=Number(x.slice(n,i));$x*=1e6,yx=1e6*yx+r,yx>=4294967296&&($x+=Math.trunc(yx/4294967296),$x>>>=0,yx>>>=0)}if(e){const[n,i]=CE(yx,$x);yx=n,$x=i}}}function CE(x,e){return e=~e,x?x=1+~x:e+=1,[x,e]}const NE=typeof BigInt=="function"?BigInt.asIntN:void 0,ree=typeof BigInt=="function"?BigInt.asUintN:void 0,oh=Number.isSafeInteger,Xg=Number.isFinite,G1=Math.trunc;function dl(x){return x==null||typeof x=="number"?x:x==="NaN"||x==="Infinity"||x==="-Infinity"?Number(x):void 0}function c4(x){return x==null||typeof x=="boolean"?x:typeof x=="number"?!!x:void 0}const aee=/^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;function Yg(x){switch(typeof x){case"bigint":return!0;case"number":return Xg(x);case"string":return aee.test(x);default:return!1}}function rd(x){if(x==null)return x;if(typeof x=="string"&&x)x=+x;else if(typeof x!="number")return;return Xg(x)?0|x:void 0}function u4(x){if(x==null)return x;if(typeof x=="string"&&x)x=+x;else if(typeof x!="number")return;return Xg(x)?x>>>0:void 0}function II(x){if(x[0]==="-")return!1;const e=x.length;return e<20||e===20&&Number(x.substring(0,6))<184467}function IE(x){return x=G1(x),oh(x)||(Oh(x),x=RE(yx,$x)),x}function OE(x){var e=G1(Number(x));if(oh(e))return String(e);if((e=x.indexOf("."))!==-1&&(x=x.substring(0,e)),e=x.length,!(x[0]==="-"?e<20||e===20&&Number(x.substring(0,7))>-922337:e<19||e===19&&Number(x.substring(0,6))<922337))if(Wg(x),x=yx,2147483648&(e=$x))if(_E())x=""+(BigInt(0|e)<<BigInt(32)|BigInt(x>>>0));else{const[t,n]=CE(x,e);x="-"+Jf(t,n)}else x=Jf(x,e);return x}function W1(x){return x==null?x:typeof x=="bigint"?(kT(x)?x=Number(x):(x=NE(64,x),x=kT(x)?Number(x):String(x)),x):Yg(x)?typeof x=="number"?IE(x):OE(x):void 0}function see(x){if(x==null)return x;var e=typeof x;if(e==="bigint")return String(ree(64,x));if(Yg(x)){if(e==="string")return e=G1(Number(x)),oh(e)&&e>=0?x=String(e):((e=x.indexOf("."))!==-1&&(x=x.substring(0,e)),II(x)||(Wg(x),x=Jf(yx,$x))),x;if(e==="number")return(x=G1(x))>=0&&oh(x)?x:function(t){if(t<0){Oh(t);var n=Jf(yx,$x);return t=Number(n),oh(t)?t:n}return II(n=String(t))?n:(Oh(t),ME(yx,$x))}(x)}}function h4(x){if(typeof x!="string")throw Error();return x}function ad(x){if(x!=null&&typeof x!="string")throw Error();return x}function Dh(x){return x==null||typeof x=="string"?x:void 0}function DE(x,e,t,n){if(x!=null&&typeof x=="object"&&x.W===Ep)return x;if(!Array.isArray(x))return t?2&n?((x=e[wI])||(id((x=new e).u),x=e[wI]=x),e=x):e=new e:e=void 0,e;let i=t=0|x[qt];return i===0&&(i|=32&n),i|=2&n,i!==t&&dn(x,i),new e(x)}function oee(x,e,t){if(e)e:{if(!Yg(e=x))throw a4("int64");switch(typeof e){case"string":e=OE(e);break e;case"bigint":if(x=e=NE(64,e),MI(x)){if(!/^\s*(?:-?[1-9]\d*|0)?\s*$/.test(x))throw Error(String(x))}else if(jq(x)&&!Number.isSafeInteger(x))throw Error(String(x));e=Gg?BigInt(e):qq(e)?e?"1":"0":MI(e)?e.trim()||"0":String(e);break e;default:e=IE(e)}}else e=W1(x);return typeof(t=(x=e)==null?t?0:void 0:x)=="string"&&oh(e=+t)?e:t}const lee={};let cee=function(){try{return vE(new class extends Map{constructor(){super()}}),!1}catch{return!0}}();class O_{constructor(){this.g=new Map}get(e){return this.g.get(e)}set(e,t){return this.g.set(e,t),this.size=this.g.size,this}delete(e){return e=this.g.delete(e),this.size=this.g.size,e}clear(){this.g.clear(),this.size=this.g.size}has(e){return this.g.has(e)}entries(){return this.g.entries()}keys(){return this.g.keys()}values(){return this.g.values()}forEach(e,t){return this.g.forEach(e,t)}[Symbol.iterator](){return this.entries()}}const uee=cee?(Object.setPrototypeOf(O_.prototype,Map.prototype),Object.defineProperties(O_.prototype,{size:{value:0,configurable:!0,enumerable:!0,writable:!0}}),O_):class extends Map{constructor(){super()}};function OI(x){return x}function D_(x){if(2&x.L)throw Error("Cannot mutate an immutable Map")}var Sa=class extends uee{constructor(x,e,t=OI,n=OI){super();let i=0|x[qt];i|=64,dn(x,i),this.L=i,this.S=e,this.R=t,this.Y=this.S?hee:n;for(let r=0;r<x.length;r++){const a=x[r],s=t(a[0],!1,!0);let l=a[1];e?l===void 0&&(l=null):l=n(a[1],!1,!0,void 0,void 0,i),super.set(s,l)}}na(x=DI){if(this.size!==0)return this.X(x)}X(x=DI){const e=[],t=super.entries();for(var n;!(n=t.next()).done;)(n=n.value)[0]=x(n[0]),n[1]=x(n[1]),e.push(n);return e}clear(){D_(this),super.clear()}delete(x){return D_(this),super.delete(this.R(x,!0,!1))}entries(){var x=this.ma();return new V1(x,dee,this)}keys(){return this.Ha()}values(){var x=this.ma();return new V1(x,Sa.prototype.get,this)}forEach(x,e){super.forEach((t,n)=>{x.call(e,this.get(n),n,this)})}set(x,e){return D_(this),(x=this.R(x,!0,!1))==null?this:e==null?(super.delete(x),this):super.set(x,this.Y(e,!0,!0,this.S,!1,this.L))}Na(x){const e=this.R(x[0],!1,!0);x=x[1],x=this.S?x===void 0?null:x:this.Y(x,!1,!0,void 0,!1,this.L),super.set(e,x)}has(x){return super.has(this.R(x,!1,!1))}get(x){x=this.R(x,!1,!1);const e=super.get(x);if(e!==void 0){var t=this.S;return t?((t=this.Y(e,!1,!0,t,this.ra,this.L))!==e&&super.set(x,t),t):e}}ma(){return Array.from(super.keys())}Ha(){return super.keys()}[Symbol.iterator](){return this.entries()}};function hee(x,e,t,n,i,r){return x=DE(x,n,t,r),i&&(x=$g(x)),x}function DI(x){return x}function dee(x){return[x,this.get(x)]}let PI,UT,kI;function UI(){return PI||(PI=new Sa(id([]),void 0,void 0,void 0,lee))}function PE(x,e,t,n,i){if(x!=null){if(Array.isArray(x))x=z1(x)?void 0:i&&2&(0|x[qt])?x:kE(x,e,t,n!==void 0,i);else if(TE(x)){const r={};for(let a in x)r[a]=PE(x[a],e,t,n,i);x=r}else x=e(x,n);return x}}function kE(x,e,t,n,i){const r=n||t?0|x[qt]:0,a=n?!!(32&r):void 0;n=qi(x);for(let s=0;s<n.length;s++)n[s]=PE(n[s],e,t,a,i);return t&&((x=AE(x))&&(n[Ih]=qi(x)),t(r,n)),n}function fee(x){return PE(x,d4,void 0,void 0,!1)}function d4(x){return x.W===Ep?x.toJSON():x instanceof Sa?x.na(fee):function(e){switch(typeof e){case"number":return isFinite(e)?e:String(e);case"bigint":return kT(e)?Number(e):String(e);case"boolean":return e?1:0;case"object":if(e)if(Array.isArray(e)){if(z1(e))return}else{if(wp(e))return _I(e);if(e instanceof Po){const t=e.g;return t==null?"":typeof t=="string"?t:e.g=_I(t)}if(e instanceof Sa)return e.na()}}return e}(x)}function f4(x){return kE(x,d4,void 0,void 0,!1)}function K2(x,e,t){return x=p4(x,e[0],e[1],t?1:2),e!==UT&&t&&Vg(x,16384),x}function p4(x,e,t,n){if(x==null){var i=96;t?(x=[t],i|=512):x=[],e&&(i=-33521665&i|(1023&e)<<15)}else{if(!Array.isArray(x))throw Error("narr");if(2048&(i=0|x[qt]))throw Error("farr");if(64&i)return x;if(n===1||n===2||(i|=64),t&&(i|=512,t!==x[0]))throw Error("mid");e:{if(n=(t=x).length){const r=n-1;if(TE(t[r])){if((e=r-(512&(i|=256)?0:-1))>=1024)throw Error("pvtlmt");i=-33521665&i|(1023&e)<<15;break e}}if(e){if((e=Math.max(e,n-(512&i?0:-1)))>1024)throw Error("spvt");i=-33521665&i|(1023&e)<<15}}}return dn(x,i),x}function FT(x,e,t=PT){if(x!=null){if(t4&&x instanceof Uint8Array)return e?x:new Uint8Array(x);if(Array.isArray(x)){var n=0|x[qt];return 2&n?x:(e&&(e=n===0||!!(32&n)&&!(64&n||!(16&n))),e?(dn(x,-12293&(34|n)),x):kE(x,FT,4&n?PT:t,!0,!0))}return x.W===Ep?x=2&(n=0|(t=x.u)[qt])?x:new x.constructor(Kg(t,n,!0)):x instanceof Sa&&!(2&x.L)&&(t=id(x.X(FT)),x=new Sa(t,x.S,x.R,x.Y)),x}}function Kg(x,e,t){const n=t||2&e?PT:Zq,i=!!(32&e);return x=function(r,a,s){const l=qi(r);var c=l.length;const h=256&a?l[c-1]:void 0;for(c+=h?-1:0,a=512&a?1:0;a<c;a++)l[a]=s(l[a]);if(h){a=l[a]={};for(const d in h)a[d]=s(h[d])}return(r=AE(r))&&(l[Ih]=qi(r)),l}(x,e,r=>FT(r,i,n)),Vg(x,32|(t?2:0)),x}function $g(x){const e=x.u,t=0|e[qt];return 2&t?new x.constructor(Kg(e,t,!1)):x}function Ph(x,e){return Wo(x=x.u,0|x[qt],e)}function Wo(x,e,t,n){if(t===-1)return null;var i=t+(512&e?0:-1);const r=x.length-1;return i>=r&&256&e?x[r][t]:n&&256&e&&(e=x[r][t])!=null?(x[i]!=null&&I_!=null&&((i=(x=N_??(N_={}))[I_]||0)>=4||(x[I_]=i+1,r4(x=Error(),"incident"),function(a){Mc.setTimeout(()=>{throw a},0)}(x))),e):i<=r?x[i]:void 0}function wx(x,e,t){const n=x.u;let i=0|n[qt];return hl(i),Wx(n,i,e,t),x}function Wx(x,e,t,n){const i=512&e?0:-1,r=t+i;var a=x.length-1;return r>=a&&256&e?(x[a][t]=n,e):r<=a?(x[r]=n,256&e&&t in(x=x[a])&&delete x[t],e):(n!==void 0&&(t>=(a=e>>15&1023||536870912)?n!=null&&(x[a+i]={[t]:n},dn(x,e|=256)):x[r]=n),e)}function n1(x,e){let t=0|(x=x.u)[qt];const n=Wo(x,t,e),i=dl(n);return i!=null&&i!==n&&Wx(x,t,e,i),i}function m4(x){let e=0|(x=x.u)[qt];const t=Wo(x,e,1),n=wE(t,!0);return n!=null&&n!==t&&Wx(x,e,1,n),n}function sc(){return Jq===void 0?2:4}function oc(x,e,t,n,i){const r=x.u,a=2&(x=0|r[qt])?1:n;i=!!i;let s=0|(n=UE(r,x,e))[qt];if(!(4&s)){4&s&&(n=qi(n),s=ko(s,x),x=Wx(r,x,e,n));let l=0,c=0;for(;l<n.length;l++){const h=t(n[l]);h!=null&&(n[c++]=h)}c<l&&(n.length=c),s=FE(s,x),t=-4097&(20|s),s=t&=-8193,dn(n,s),2&s&&Object.freeze(n)}return a===1||a===4&&32&s?Io(s)||(i=s,s|=2,s!==i&&dn(n,s),Object.freeze(n)):(a===2&&Io(s)&&(n=qi(n),s=ko(s,x),s=$2(s,x,i),dn(n,s),x=Wx(r,x,e,n)),Io(s)||(e=s,s=$2(s,x,i),s!==e&&dn(n,s))),n}function UE(x,e,t,n){return x=Wo(x,e,t,n),Array.isArray(x)?x:SE}function FE(x,e){return x===0&&(x=ko(x,e)),1|x}function Io(x){return!!(2&x)&&!!(4&x)||!!(2048&x)}function y4(x){x=qi(x);for(let e=0;e<x.length;e++){const t=x[e]=qi(x[e]);Array.isArray(t[1])&&(t[1]=id(t[1]))}return x}function BT(x,e,t,n){let i=0|(x=x.u)[qt];hl(i),Wx(x,i,e,(n==="0"?Number(t)===0:t===n)?void 0:t)}function sd(x,e,t,n,i){hl(e);var r=!(!(64&e)&&16384&e);const a=(i=UE(x,e,t,i))!==SE;if(r||!a){let s=r=a?0|i[qt]:0;(!a||2&s||Io(s)||4&s&&!(32&s))&&(i=qi(i),s=ko(s,e),e=Wx(x,e,t,i)),s=-13&FE(s,e),s=$2(n?-17&s:16|s,e,!0),s!==r&&dn(i,s)}return i}function P_(x,e){var t=iB;return LE(BE(x=x.u),x,0|x[qt],t)===e?e:-1}function BE(x){var e;if(zg)return(e=x[of])!=null?e:x[of]=new Map;if(of in x)return x[of];const t=new Map;return Object.defineProperty(x,of,{value:t}),t}function g4(x,e,t,n){const i=BE(x),r=LE(i,x,e,t);return r!==n&&(r&&(e=Wx(x,e,r)),i.set(t,n)),e}function LE(x,e,t,n){let i=x.get(n);if(i!=null)return i;i=0;for(let r=0;r<n.length;r++){const a=n[r];Wo(e,t,a)!=null&&(i!==0&&(t=Wx(e,t,i)),i=a)}return x.set(n,i),i}function zE(x,e,t,n){let i,r=0|x[qt];if((n=Wo(x,r,t,n))!=null&&n.W===Ep)return(e=$g(n))!==n&&Wx(x,r,t,e),e.u;if(Array.isArray(n)){const a=0|n[qt];i=2&a?K2(Kg(n,a,!1),e,!0):64&a?n:K2(i,e,!0)}else i=K2(void 0,e,!0);return i!==n&&Wx(x,r,t,i),i}function v4(x,e,t,n){let i=0|(x=x.u)[qt];return(e=DE(n=Wo(x,i,t,n),e,!1,i))!==n&&e!=null&&Wx(x,i,t,e),e}function G0(x,e,t,n=!1){if((e=v4(x,e,t,n))==null)return e;if(!(2&(n=0|(x=x.u)[qt]))){const i=$g(e);i!==e&&Wx(x,n,t,e=i)}return e}function b4(x,e,t,n,i,r,a){x=x.u;var s=!!(2&e);const l=s?1:i;r=!!r,a&&(a=!s);var c=0|(i=UE(x,e,n))[qt];if(!(s=!!(4&c))){var h=i,d=e;const p=!!(2&(c=FE(c,e)));p&&(d|=2);let m=!p,g=!0,_=0,v=0;for(;_<h.length;_++){const b=DE(h[_],t,!1,d);if(b instanceof t){if(!p){const T=!!(2&(0|b.u[qt]));m&&(m=!T),g&&(g=T)}h[v++]=b}}v<_&&(h.length=v),c|=4,c=g?16|c:-17&c,dn(h,c=m?8|c:-9&c),p&&Object.freeze(h)}if(a&&!(8&c||!i.length&&(l===1||l===4&&32&c))){for(Io(c)&&(i=qi(i),c=ko(c,e),e=Wx(x,e,n,i)),t=i,a=c,h=0;h<t.length;h++)(c=t[h])!==(d=$g(c))&&(t[h]=d);a|=8,dn(t,a=t.length?-17&a:16|a),c=a}return l===1||l===4&&32&c?Io(c)||(e=c,(c|=!i.length||16&c&&(!s||32&c)?2:2048)!==e&&dn(i,c),Object.freeze(i)):(l===2&&Io(c)&&(dn(i=qi(i),c=$2(c=ko(c,e),e,r)),e=Wx(x,e,n,i)),Io(c)||(n=c,(c=$2(c,e,r))!==n&&dn(i,c))),i}function Bo(x,e,t){const n=0|x.u[qt];return b4(x,n,e,t,sc(),!1,!(2&n))}function n0(x,e,t,n){return n==null&&(n=void 0),wx(x,t,n)}function Pf(x,e,t,n){n==null&&(n=void 0);e:{let i=0|(x=x.u)[qt];if(hl(i),n==null){const r=BE(x);if(LE(r,x,i,t)!==e)break e;r.set(t,0)}else i=g4(x,i,t,e);Wx(x,i,e,n)}}function ko(x,e){return-2049&(x=32|(2&e?2|x:-3&x))}function $2(x,e,t){return 32&e&&t||(x&=-33),x}function X1(x,e,t,n){const i=0|x.u[qt];hl(i),x=b4(x,i,t,e,2,!0),n=n??new t,x.push(n),x[qt]=2&(0|n.u[qt])?-9&x[qt]:-17&x[qt]}function ya(x,e){return rd(Ph(x,e))}function Ta(x,e){return Dh(Ph(x,e))}function qx(x,e){var t;return(t=n1(x,e))!=null?t:0}function jf(x,e,t){if(t!=null&&typeof t!="boolean")throw x=typeof t,Error("Expected boolean but got "+(x!="object"?x:t?Array.isArray(t)?"array":x:"null")+": "+t);wx(x,e,t)}function Cs(x,e,t){if(t!=null){if(typeof t!="number"||!Xg(t))throw a4("int32");t|=0}wx(x,e,t)}function $t(x,e,t){if(t!=null&&typeof t!="number")throw Error("Value of float/double field must be a number, found "+typeof t+": "+t);wx(x,e,t)}function Y1(x,e,t){{const a=x.u;let s=0|a[qt];if(hl(s),t==null)Wx(a,s,e);else{var n=x=0|t[qt],i=Io(x),r=i||Object.isFrozen(t);for(i||(x=0),r||(t=qi(t),n=0,x=$2(x=ko(x,s),s,!0),r=!1),x|=21,i=0;i<t.length;i++){const l=t[i],c=h4(l);Object.is(l,c)||(r&&(t=qi(t),n=0,x=$2(x=ko(x,s),s,!0),r=!1),t[i]=c)}x!==n&&(r&&(t=qi(t),x=$2(x=ko(x,s),s,!0)),dn(t,x)),Wx(a,s,e,t)}}}function Qg(x,e,t){hl(0|x.u[qt]),oc(x,e,Dh,2,!0).push(h4(t))}function _4(x,e){return Error("Invalid wire type: "+x+" (at position "+e+")")}function VE(){return Error("Failed to read varint, encoding is invalid.")}function S4(x,e){return Error("Tried to read past the end of the data "+e+" > "+x)}function HE(x){if(typeof x=="string")return{buffer:n4(x),N:!1};if(Array.isArray(x))return{buffer:new Uint8Array(x),N:!1};if(x.constructor===Uint8Array)return{buffer:x,N:!1};if(x.constructor===ArrayBuffer)return{buffer:new Uint8Array(x),N:!1};if(x.constructor===Po)return{buffer:bE(x)||new Uint8Array(0),N:!0};if(x instanceof Uint8Array)return{buffer:new Uint8Array(x.buffer,x.byteOffset,x.byteLength),N:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function GE(x,e){let t,n=0,i=0,r=0;const a=x.h;let s=x.g;do t=a[s++],n|=(127&t)<<r,r+=7;while(r<32&&128&t);for(r>32&&(i|=(127&t)>>4),r=3;r<32&&128&t;r+=7)t=a[s++],i|=(127&t)<<r;if(dc(x,s),t<128)return e(n>>>0,i>>>0);throw VE()}function WE(x){let e=0,t=x.g;const n=t+10,i=x.h;for(;t<n;){const r=i[t++];if(e|=r,(128&r)==0)return dc(x,t),!!(127&e)}throw VE()}function xl(x){const e=x.h;let t=x.g,n=e[t++],i=127&n;if(128&n&&(n=e[t++],i|=(127&n)<<7,128&n&&(n=e[t++],i|=(127&n)<<14,128&n&&(n=e[t++],i|=(127&n)<<21,128&n&&(n=e[t++],i|=n<<28,128&n&&128&e[t++]&&128&e[t++]&&128&e[t++]&&128&e[t++]&&128&e[t++])))))throw VE();return dc(x,t),i}function Lo(x){return xl(x)>>>0}function LT(x){var e=x.h;const t=x.g,n=e[t],i=e[t+1],r=e[t+2];return e=e[t+3],dc(x,x.g+4),(n<<0|i<<8|r<<16|e<<24)>>>0}function zT(x){var e=LT(x);x=2*(e>>31)+1;const t=e>>>23&255;return e&=8388607,t==255?e?NaN:x*(1/0):t==0?1401298464324817e-60*x*e:x*Math.pow(2,t-150)*(e+8388608)}function pee(x){return xl(x)}function k_(x,e,{ba:t=!1}={}){x.ba=t,e&&(e=HE(e),x.h=e.buffer,x.m=e.N,x.j=0,x.l=x.h.length,x.g=x.j)}function dc(x,e){if(x.g=e,e>x.l)throw S4(x.l,e)}function T4(x,e){if(e<0)throw Error("Tried to read a negative byte length: "+e);const t=x.g,n=t+e;if(n>x.l)throw S4(e,x.l-t);return x.g=n,t}function w4(x,e){if(e==0)return Rc();var t=T4(x,e);return x.ba&&x.m?t=x.h.subarray(t,t+e):(x=x.h,t=t===(e=t+e)?new Uint8Array(0):iee?x.slice(t,e):new Uint8Array(x.subarray(t,e))),t.length==0?Rc():new Po(t,Nh)}Sa.prototype.toJSON=void 0,Sa.prototype.Ia=l4;var FI=[];function A4(x){var e=x.g;if(e.g==e.l)return!1;x.l=x.g.g;var t=Lo(x.g);if(e=t>>>3,!((t&=7)>=0&&t<=5))throw _4(t,x.l);if(e<1)throw Error("Invalid field number: "+e+" (at position "+x.l+")");return x.m=e,x.h=t,!0}function i1(x){switch(x.h){case 0:x.h!=0?i1(x):WE(x.g);break;case 1:dc(x=x.g,x.g+8);break;case 2:if(x.h!=2)i1(x);else{var e=Lo(x.g);dc(x=x.g,x.g+e)}break;case 5:dc(x=x.g,x.g+4);break;case 3:for(e=x.m;;){if(!A4(x))throw Error("Unmatched start-group tag: stream EOF");if(x.h==4){if(x.m!=e)throw Error("Unmatched end-group tag");break}i1(x)}break;default:throw _4(x.h,x.l)}}function Mp(x,e,t){const n=x.g.l,i=Lo(x.g),r=x.g.g+i;let a=r-n;if(a<=0&&(x.g.l=r,t(e,x,void 0,void 0,void 0),a=r-x.g.g),a)throw Error("Message parsing ended unexpectedly. Expected to read "+i+" bytes, instead read "+(i-a)+" bytes, either the data ended unexpectedly or the message misreported its own length");return x.g.g=r,x.g.l=n,e}function XE(x){var e=Lo(x.g),t=T4(x=x.g,e);if(x=x.h,Hq){var n,i=x;(n=E_)||(n=E_=new TextDecoder("utf-8",{fatal:!0})),e=t+e,i=t===0&&e===i.length?i:i.subarray(t,e);try{var r=n.decode(i)}catch(s){if(Xm===void 0){try{n.decode(new Uint8Array([128]))}catch{}try{n.decode(new Uint8Array([97])),Xm=!0}catch{Xm=!1}}throw!Xm&&(E_=void 0),s}}else{e=(r=t)+e,t=[];let s,l=null;for(;r<e;){var a=x[r++];a<128?t.push(a):a<224?r>=e?Bl():(s=x[r++],a<194||(192&s)!=128?(r--,Bl()):t.push((31&a)<<6|63&s)):a<240?r>=e-1?Bl():(s=x[r++],(192&s)!=128||a===224&&s<160||a===237&&s>=160||(192&(n=x[r++]))!=128?(r--,Bl()):t.push((15&a)<<12|(63&s)<<6|63&n)):a<=244?r>=e-2?Bl():(s=x[r++],(192&s)!=128||s-144+(a<<28)>>30!=0||(192&(n=x[r++]))!=128||(192&(i=x[r++]))!=128?(r--,Bl()):(a=(7&a)<<18|(63&s)<<12|(63&n)<<6|63&i,a-=65536,t.push(55296+(a>>10&1023),56320+(1023&a)))):Bl(),t.length>=8192&&(l=mI(l,t),t.length=0)}r=mI(l,t)}return r}function E4(x){const e=Lo(x.g);return w4(x.g,e)}function Zg(x,e,t){var n=Lo(x.g);for(n=x.g.g+n;x.g.g<n;)t.push(e(x.g))}var Ym=[];function mee(x){return x}let lh;function qa(x,e,t){e.g?e.m(x,e.g,e.h,t):e.m(x,e.h,t)}var Yt=class{constructor(x,e){this.u=p4(x,e)}toJSON(){const x=!lh;try{return x&&(lh=f4),M4(this)}finally{x&&(lh=void 0)}}l(){var x=Qee;return x.g?x.l(this,x.g,x.h,!0):x.l(this,x.h,x.defaultValue,!0)}clone(){const x=this.u;return new this.constructor(Kg(x,0|x[qt],!1))}N(){return!!(2&(0|this.u[qt]))}};function M4(x){var e=x.u;{e=(x=lh(e))!==e;let c=x.length;if(c){var t=x[c-1],n=TE(t);n?c--:t=void 0;var i=x;if(n){e:{var r,a=t,s=!1;if(a)for(let h in a)isNaN(+h)?(r??(r={}))[h]=a[h]:(n=a[h],Array.isArray(n)&&(z1(n)||AI(n)&&n.size===0)&&(n=null),n==null&&(s=!0),n!=null&&((r??(r={}))[h]=n));if(s||(r=a),r)for(let h in r){s=r;break e}s=null}a=s==null?t!=null:s!==t}for(;c>0&&((r=i[c-1])==null||z1(r)||AI(r)&&r.size===0);c--)var l=!0;(i!==x||a||l)&&(e?(l||a||s)&&(i.length=c):i=Array.prototype.slice.call(i,0,c),s&&i.push(s)),l=i}else l=x}return l}function BI(x){return x?/^\d+$/.test(x)?(Wg(x),new VT(yx,$x)):null:LI||(LI=new VT(0,0))}Yt.prototype.W=Ep,Yt.prototype.toString=function(){try{return lh=mee,M4(this).toString()}finally{lh=void 0}};var VT=class{constructor(x,e){this.h=x>>>0,this.g=e>>>0}};let LI;function zI(x){return x?/^-?\d+$/.test(x)?(Wg(x),new HT(yx,$x)):null:VI||(VI=new HT(0,0))}var HT=class{constructor(x,e){this.h=x>>>0,this.g=e>>>0}};let VI;function ch(x,e,t){for(;t>0||e>127;)x.g.push(127&e|128),e=(e>>>7|t<<25)>>>0,t>>>=7;x.g.push(e)}function od(x,e){for(;e>127;)x.g.push(127&e|128),e>>>=7;x.g.push(e)}function Jg(x,e){if(e>=0)od(x,e);else{for(let t=0;t<9;t++)x.g.push(127&e|128),e>>=7;x.g.push(1)}}function qf(x,e){x.g.push(e>>>0&255),x.g.push(e>>>8&255),x.g.push(e>>>16&255),x.g.push(e>>>24&255)}function kh(x,e){e.length!==0&&(x.l.push(e),x.h+=e.length)}function zr(x,e,t){od(x.g,8*e+t)}function YE(x,e){return zr(x,e,2),e=x.g.end(),kh(x,e),e.push(x.h),e}function KE(x,e){var t=e.pop();for(t=x.h+x.g.length()-t;t>127;)e.push(127&t|128),t>>>=7,x.h++;e.push(t),x.h++}function jg(x,e,t){zr(x,e,2),od(x.g,t.length),kh(x,x.g.end()),kh(x,t)}function K1(x,e,t,n){t!=null&&(e=YE(x,e),n(t,x),KE(x,e))}function es(){const x=class{constructor(){throw Error()}};return Object.setPrototypeOf(x,x.prototype),x}var $E=es(),R4=es(),QE=es(),ZE=es(),C4=es(),N4=es(),JE=es(),I4=es(),O4=es(),ld=class{constructor(x,e,t){this.g=x,this.h=e,x=$E,this.l=!!x&&t===x||!1}};function qg(x,e){return new ld(x,e,$E)}function D4(x,e,t,n,i){K1(x,t,k4(e,n),i)}const yee=qg(function(x,e,t,n,i){return x.h===2&&(Mp(x,zE(e,n,t),i),!0)},D4),gee=qg(function(x,e,t,n,i){return x.h===2&&(Mp(x,zE(e,n,t,!0),i),!0)},D4);var ev=Symbol(),jE=Symbol(),HI=Symbol(),GI=Symbol();let GT,WT;function Bc(x,e,t,n){var i=n[x];if(i)return i;(i={}).Pa=n,i.V=function(d){switch(typeof d){case"boolean":return UT||(UT=[0,void 0,!0]);case"number":return d>0?void 0:d===0?kI||(kI=[0,void 0]):[-d,void 0];case"string":return[0,d];case"object":return d}}(n[0]);var r=n[1];let a=1;r&&r.constructor===Object&&(i.ga=r,typeof(r=n[++a])=="function"&&(i.la=!0,GT!=null||(GT=r),WT!=null||(WT=n[a+1]),r=n[a+=2]));const s={};for(;r&&Array.isArray(r)&&r.length&&typeof r[0]=="number"&&r[0]>0;){for(var l=0;l<r.length;l++)s[r[l]]=r;r=n[++a]}for(l=1;r!==void 0;){let d;typeof r=="number"&&(l+=r,r=n[++a]);var c=void 0;if(r instanceof ld?d=r:(d=yee,a--),d==null?void 0:d.l){r=n[++a],c=n;var h=a;typeof r=="function"&&(r=r(),c[h]=r),c=r}for(h=l+1,typeof(r=n[++a])=="number"&&r<0&&(h-=r,r=n[++a]);l<h;l++){const p=s[l];c?t(i,l,d,c,p):e(i,l,d,p)}}return n[x]=i}function P4(x){return Array.isArray(x)?x[0]instanceof ld?x:[gee,x]:[x,void 0]}function k4(x,e){return x instanceof Yt?x.u:Array.isArray(x)?K2(x,e,!1):void 0}function qE(x,e,t,n){const i=t.g;x[e]=n?(r,a,s)=>i(r,a,s,n):i}function eM(x,e,t,n,i){const r=t.g;let a,s;x[e]=(l,c,h)=>r(l,c,h,s||(s=Bc(jE,qE,eM,n).V),a||(a=tM(n)),i)}function tM(x){let e=x[HI];if(e!=null)return e;const t=Bc(jE,qE,eM,x);return e=t.la?(n,i)=>GT(n,i,t):(n,i)=>{const r=0|n[qt];for(;A4(i)&&i.h!=4;){var a=i.m,s=t[a];if(s==null){var l=t.ga;l&&(l=l[a])&&(l=vee(l))!=null&&(s=t[a]=l)}s!=null&&s(i,n,a)||(a=(s=i).l,i1(s),s.fa?s=void 0:(l=s.g.g-a,s.g.g=a,s=w4(s.g,l)),a=n,s&&((l=a[Ih])?l.push(s):a[Ih]=[s]))}return 16384&r&&id(n),!0},x[HI]=e}function vee(x){const e=(x=P4(x))[0].g;if(x=x[1]){const t=tM(x),n=Bc(jE,qE,eM,x).V;return(i,r,a)=>e(i,r,a,n,t)}return e}function tv(x,e,t){x[e]=t.h}function xv(x,e,t,n){let i,r;const a=t.h;x[e]=(s,l,c)=>a(s,l,c,r||(r=Bc(ev,tv,xv,n).V),i||(i=U4(n)))}function U4(x){let e=x[GI];if(!e){const t=Bc(ev,tv,xv,x);e=(n,i)=>F4(n,i,t),x[GI]=e}return e}function F4(x,e,t){for(var n=0|x[qt],i=512&n?0:-1,r=x.length,a=512&n?1:0,s=r+(256&n?-1:0);a<s;a++){const l=x[a];if(l==null)continue;const c=a-i,h=WI(t,c);h&&h(e,l,c)}if(256&n){n=x[r-1];for(const l in n)i=+l,Number.isNaN(i)||(r=n[i])!=null&&(s=WI(t,i))&&s(e,r,i)}if(x=AE(x))for(kh(e,e.g.end()),t=0;t<x.length;t++)kh(e,bE(x[t])||new Uint8Array(0))}function WI(x,e){var t=x[e];if(t)return t;if((t=x.ga)&&(t=t[e])){var n=(t=P4(t))[0].h;if(t=t[1]){const i=U4(t),r=Bc(ev,tv,xv,t).V;t=x.la?WT(r,i):(a,s,l)=>n(a,s,l,r,i)}else t=n;return x[e]=t}}function cd(x,e){if(Array.isArray(e)){var t=0|e[qt];if(4&t)return e;for(var n=0,i=0;n<e.length;n++){const r=x(e[n]);r!=null&&(e[i++]=r)}return i<n&&(e.length=i),dn(e,-12289&(5|t)),2&t&&Object.freeze(e),e}}function Ci(x,e,t){return new ld(x,e,t)}function ud(x,e,t){return new ld(x,e,t)}function Ni(x,e,t){Wx(x,0|x[qt],e,t)}var bee=qg(function(x,e,t,n,i){return x.h===2&&(x=Mp(x,K2([void 0,void 0],n,!0),i),hl(n=0|e[qt]),(i=Wo(e,n,t))instanceof Sa?(2&i.L)!=0?((i=i.X()).push(x),Wx(e,n,t,i)):i.Na(x):Array.isArray(i)?(2&(0|i[qt])&&Wx(e,n,t,i=y4(i)),i.push(x)):Wx(e,n,t,[x]),!0)},function(x,e,t,n,i){if(e instanceof Sa)e.forEach((r,a)=>{K1(x,t,K2([a,r],n,!1),i)});else if(Array.isArray(e))for(let r=0;r<e.length;r++){const a=e[r];Array.isArray(a)&&K1(x,t,K2(a,n,!1),i)}});function B4(x,e,t){if(e=function(n){if(n==null)return n;const i=typeof n;if(i==="bigint")return String(NE(64,n));if(Yg(n)){if(i==="string")return OE(n);if(i==="number")return IE(n)}}(e),e!=null&&(typeof e=="string"&&zI(e),e!=null))switch(zr(x,t,0),typeof e){case"number":x=x.g,Oh(e),ch(x,yx,$x);break;case"bigint":t=BigInt.asUintN(64,e),t=new HT(Number(t&BigInt(4294967295)),Number(t>>BigInt(32))),ch(x.g,t.h,t.g);break;default:t=zI(e),ch(x.g,t.h,t.g)}}function L4(x,e,t){(e=rd(e))!=null&&e!=null&&(zr(x,t,0),Jg(x.g,e))}function z4(x,e,t){(e=c4(e))!=null&&(zr(x,t,0),x.g.g.push(e?1:0))}function V4(x,e,t){(e=Dh(e))!=null&&jg(x,t,jF(e))}function H4(x,e,t,n,i){K1(x,t,k4(e,n),i)}function G4(x,e,t){(e=e==null||typeof e=="string"||wp(e)||e instanceof Po?e:void 0)!=null&&jg(x,t,HE(e).buffer)}function W4(x,e,t){return(x.h===5||x.h===2)&&(e=sd(e,0|e[qt],t,!1,!1),x.h==2?Zg(x,zT,e):e.push(zT(x.g)),!0)}var So=Ci(function(x,e,t){if(x.h!==1)return!1;var n=x.g;x=LT(n);const i=LT(n);n=2*(i>>31)+1;const r=i>>>20&2047;return x=4294967296*(1048575&i)+x,Ni(e,t,r==2047?x?NaN:n*(1/0):r==0?5e-324*n*x:n*Math.pow(2,r-1075)*(x+4503599627370496)),!0},function(x,e,t){(e=dl(e))!=null&&(zr(x,t,1),x=x.g,(t=H1||(H1=new DataView(new ArrayBuffer(8)))).setFloat64(0,+e,!0),yx=t.getUint32(0,!0),$x=t.getUint32(4,!0),qf(x,yx),qf(x,$x))},es()),pn=Ci(function(x,e,t){return x.h===5&&(Ni(e,t,zT(x.g)),!0)},function(x,e,t){(e=dl(e))!=null&&(zr(x,t,5),x=x.g,EE(e),qf(x,yx))},JE),_ee=ud(W4,function(x,e,t){if((e=cd(dl,e))!=null)for(let a=0;a<e.length;a++){var n=x,i=t,r=e[a];r!=null&&(zr(n,i,5),n=n.g,EE(r),qf(n,yx))}},JE),xM=ud(W4,function(x,e,t){if((e=cd(dl,e))!=null&&e.length){zr(x,t,2),od(x.g,4*e.length);for(let n=0;n<e.length;n++)t=x.g,EE(e[n]),qf(t,yx)}},JE),nl=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,GE(x.g,RE)),!0)},B4,N4),U_=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,(x=GE(x.g,RE))===0?void 0:x),!0)},B4,N4),See=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,GE(x.g,ME)),!0)},function(x,e,t){if((e=see(e))!=null&&(typeof e=="string"&&BI(e),e!=null))switch(zr(x,t,0),typeof e){case"number":x=x.g,Oh(e),ch(x,yx,$x);break;case"bigint":t=BigInt.asUintN(64,e),t=new VT(Number(t&BigInt(4294967295)),Number(t>>BigInt(32))),ch(x.g,t.h,t.g);break;default:t=BI(e),ch(x.g,t.h,t.g)}},es()),Qx=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,xl(x.g)),!0)},L4,ZE),nv=ud(function(x,e,t){return(x.h===0||x.h===2)&&(e=sd(e,0|e[qt],t,!1,!1),x.h==2?Zg(x,xl,e):e.push(xl(x.g)),!0)},function(x,e,t){if((e=cd(rd,e))!=null&&e.length){t=YE(x,t);for(let n=0;n<e.length;n++)Jg(x.g,e[n]);KE(x,t)}},ZE),th=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,(x=xl(x.g))===0?void 0:x),!0)},L4,ZE),Px=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,WE(x.g)),!0)},z4,R4),uh=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,(x=WE(x.g))===!1?void 0:x),!0)},z4,R4),oi=ud(function(x,e,t){return x.h===2&&(x=XE(x),sd(e,0|e[qt],t,!1).push(x),!0)},function(x,e,t){if((e=cd(Dh,e))!=null)for(let a=0;a<e.length;a++){var n=x,i=t,r=e[a];r!=null&&jg(n,i,jF(r))}},QE),L2=Ci(function(x,e,t){return x.h===2&&(Ni(e,t,(x=XE(x))===""?void 0:x),!0)},V4,QE),j0=Ci(function(x,e,t){return x.h===2&&(Ni(e,t,XE(x)),!0)},V4,QE),Mn=function(x,e,t=$E){return new ld(x,e,t)}(function(x,e,t,n,i){return x.h===2&&(n=K2(void 0,n,!0),sd(e,0|e[qt],t,!0).push(n),Mp(x,n,i),!0)},function(x,e,t,n,i){if(Array.isArray(e))for(let r=0;r<e.length;r++)H4(x,e[r],t,n,i)}),rx=qg(function(x,e,t,n,i,r){return x.h===2&&(g4(e,0|e[qt],r,t),Mp(x,e=zE(e,n,t),i),!0)},H4),X4=Ci(function(x,e,t){return x.h===2&&(Ni(e,t,E4(x)),!0)},G4,I4),Tee=ud(function(x,e,t){return(x.h===0||x.h===2)&&(e=sd(e,0|e[qt],t,!1,!1),x.h==2?Zg(x,Lo,e):e.push(Lo(x.g)),!0)},function(x,e,t){if((e=cd(u4,e))!=null)for(let a=0;a<e.length;a++){var n=x,i=t,r=e[a];r!=null&&(zr(n,i,0),od(n.g,r))}},C4),wee=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,(x=Lo(x.g))===0?void 0:x),!0)},function(x,e,t){(e=u4(e))!=null&&e!=null&&(zr(x,t,0),od(x.g,e))},C4),wa=Ci(function(x,e,t){return x.h===0&&(Ni(e,t,xl(x.g)),!0)},function(x,e,t){(e=rd(e))!=null&&(e=parseInt(e,10),zr(x,t,0),Jg(x.g,e))},O4);class Aee{constructor(e,t){this.h=e,this.g=t,this.l=G0,this.m=n0,this.defaultValue=void 0}}function ts(x,e){return new Aee(x,e)}function fl(x,e){return(t,n)=>{if(Ym.length){const r=Ym.pop();r.o(n),k_(r.g,t,n),t=r}else t=new class{constructor(r,a){if(FI.length){const s=FI.pop();k_(s,r,a),r=s}else r=new class{constructor(s,l){this.h=null,this.m=!1,this.g=this.l=this.j=0,k_(this,s,l)}clear(){this.h=null,this.m=!1,this.g=this.l=this.j=0,this.ba=!1}}(r,a);this.g=r,this.l=this.g.g,this.h=this.m=-1,this.o(a)}o({fa:r=!1}={}){this.fa=r}}(t,n);try{const r=new x,a=r.u;tM(e)(a,t);var i=r}finally{t.g.clear(),t.m=-1,t.h=-1,Ym.length<100&&Ym.push(t)}return i}}function iv(x){return function(){const e=new class{constructor(){this.l=[],this.h=0,this.g=new class{constructor(){this.g=[]}length(){return this.g.length}end(){const a=this.g;return this.g=[],a}}}};F4(this.u,e,Bc(ev,tv,xv,x)),kh(e,e.g.end());const t=new Uint8Array(e.h),n=e.l,i=n.length;let r=0;for(let a=0;a<i;a++){const s=n[a];t.set(s,r),r+=s.length}return e.l=[t],t}}var XI=class extends Yt{constructor(x){super(x)}},YI=[0,L2,Ci(function(x,e,t){return x.h===2&&(Ni(e,t,(x=E4(x))===Rc()?void 0:x),!0)},function(x,e,t){if(e!=null){if(e instanceof Yt){const n=e.Ra;return void(n&&(e=n(e),e!=null&&jg(x,t,HE(e).buffer)))}if(Array.isArray(e))return}G4(x,e,t)},I4)],Y4=[0,Qx,wa,Px,-1,nv,wa,-1],Eee=class extends Yt{constructor(x){super(x)}},K4=[0,Px,j0,Px,wa,-1,ud(function(x,e,t){return(x.h===0||x.h===2)&&(e=sd(e,0|e[qt],t,!1,!1),x.h==2?Zg(x,pee,e):e.push(xl(x.g)),!0)},function(x,e,t){if((e=cd(rd,e))!=null&&e.length){t=YE(x,t);for(let n=0;n<e.length;n++)Jg(x.g,e[n]);KE(x,t)}},O4),j0,-1,[0,Px,-1],wa,Px,-1],$4=[0,j0,-2],KI=class extends Yt{constructor(x){super(x)}},Q4=[0],Z4=[0,Qx,Px,1,Px,-3],Pr=class extends Yt{constructor(x){super(x,2)}},mn={};mn[336783863]=[0,j0,Px,-1,Qx,[0,[1,2,3,4,5,6,7,8],rx,Q4,rx,K4,rx,$4,rx,Z4,rx,Y4,rx,[0,j0,-2],rx,[0,j0,wa],rx,[0,wa,j0]],[0,j0],Px,[0,[1,3],[2,4],rx,[0,nv],-1,rx,[0,oi],-1,Mn,[0,j0,-1]],j0];var $I=[0,U_,-1,uh,-3,U_,nv,L2,th,U_,-1,uh,th,uh,-2,L2];function Vr(x,e){BT(x,2,ad(e),"")}function Ax(x,e){Qg(x,3,e)}function k0(x,e){Qg(x,4,e)}var Mi=class extends Yt{constructor(x){super(x,500)}o(x){return n0(this,0,7,x)}},kf=[-1,{}],QI=[0,j0,1,kf],ZI=[0,j0,oi,kf];function Hr(x,e){X1(x,1,Mi,e)}function Mx(x,e){Qg(x,10,e)}function X0(x,e){Qg(x,15,e)}var xr=class extends Yt{constructor(x){super(x,500)}o(x){return n0(this,0,1001,x)}},J4=[-500,Mn,[-500,L2,-1,oi,-3,[-2,mn,Px],Mn,YI,th,-1,QI,ZI,Mn,[0,L2,uh],L2,$I,th,oi,987,oi],4,Mn,[-500,j0,-1,[-1,{}],998,j0],Mn,[-500,j0,oi,-1,[-2,{},Px],997,oi,-1],th,Mn,[-500,j0,oi,kf,998,oi],oi,th,QI,ZI,Mn,[0,L2,-1,kf],oi,-2,$I,L2,-1,uh,[0,uh,wee],978,kf,Mn,YI];xr.prototype.g=iv(J4);var Mee=fl(xr,J4),Ree=class extends Yt{constructor(x){super(x)}},j4=class extends Yt{constructor(x){super(x)}g(){return Bo(this,Ree,1)}},q4=[0,Mn,[0,Qx,pn,j0,-1]],rv=fl(j4,q4),Cee=class extends Yt{constructor(x){super(x)}},Nee=class extends Yt{constructor(x){super(x)}},F_=class extends Yt{constructor(x){super(x)}h(){return G0(this,Cee,2)}g(){return Bo(this,Nee,5)}},eB=fl(class extends Yt{constructor(x){super(x)}},[0,oi,nv,xM,[0,wa,[0,Qx,-3],[0,pn,-3],[0,Qx,-1,[0,Mn,[0,Qx,-2]]],Mn,[0,pn,-1,j0,pn]],j0,-1,nl,Mn,[0,Qx,pn],oi,nl]),tB=class extends Yt{constructor(x){super(x)}},hh=fl(class extends Yt{constructor(x){super(x)}},[0,Mn,[0,pn,-4]]),xB=class extends Yt{constructor(x){super(x)}},Rp=fl(class extends Yt{constructor(x){super(x)}},[0,Mn,[0,pn,-4]]),Iee=class extends Yt{constructor(x){super(x)}},Oee=[0,Qx,-1,xM,wa],nB=class extends Yt{constructor(x){super(x)}};nB.prototype.g=iv([0,pn,-4,nl]);var Dee=class extends Yt{constructor(x){super(x)}},Pee=fl(class extends Yt{constructor(x){super(x)}},[0,Mn,[0,1,Qx,j0,q4],nl]),JI=class extends Yt{constructor(x){super(x)}},kee=class extends Yt{constructor(x){super(x)}oa(){const x=m4(this);return x??Rc()}},Uee=class extends Yt{constructor(x){super(x)}},iB=[1,2],Fee=fl(class extends Yt{constructor(x){super(x)}},[0,Mn,[0,iB,rx,[0,xM],rx,[0,X4],Qx,j0],nl]),nM=class extends Yt{constructor(x){super(x)}},rB=[0,j0,Qx,pn,oi,-1],jI=class extends Yt{constructor(x){super(x)}},Bee=[0,Px,-1],qI=class extends Yt{constructor(x){super(x)}},r1=[1,2,3,4,5],$1=class extends Yt{constructor(x){super(x)}g(){return m4(this)!=null}h(){return Ta(this,2)!=null}},Ux=class extends Yt{constructor(x){super(x)}g(){var x;return(x=c4(Ph(this,2)))!=null?x:!1}},aB=[0,X4,j0,[0,Qx,nl,-1],[0,See,nl]],xn=[0,aB,Px,[0,r1,rx,Z4,rx,K4,rx,Y4,rx,Q4,rx,$4],wa],av=class extends Yt{constructor(x){super(x)}},iM=[0,xn,pn,-1,Qx],Lee=ts(502141897,av);mn[502141897]=iM;var zee=fl(class extends Yt{constructor(x){super(x)}},[0,[0,wa,-1,_ee,Tee],Oee]),sB=class extends Yt{constructor(x){super(x)}},oB=class extends Yt{constructor(x){super(x)}},rM=[0,xn,pn,[0,xn],Px],lB=[0,xn,iM,rM,pn,[0,[0,aB]]],Vee=ts(508968150,oB);mn[508968150]=lB,mn[508968149]=rM;var cB=class extends Yt{constructor(x){super(x)}},Hee=ts(513916220,cB);mn[513916220]=[0,xn,lB,Qx];var mu=class extends Yt{constructor(x){super(x)}h(){return G0(this,nM,2)}g(){wx(this,2)}},uB=[0,xn,rB];mn[478825465]=uB;var Gee=class extends Yt{constructor(x){super(x)}},hB=class extends Yt{constructor(x){super(x)}},aM=class extends Yt{constructor(x){super(x)}},sM=class extends Yt{constructor(x){super(x)}},dB=class extends Yt{constructor(x){super(x)}},eO=[0,xn,[0,xn],uB,-1],fB=[0,xn,pn,Qx],oM=[0,xn,pn],pB=[0,xn,fB,oM,pn],Wee=ts(479097054,dB);mn[479097054]=[0,xn,pB,eO],mn[463370452]=eO,mn[464864288]=fB;var Xee=ts(462713202,sM);mn[462713202]=pB,mn[474472470]=oM;var Yee=class extends Yt{constructor(x){super(x)}},mB=class extends Yt{constructor(x){super(x)}},yB=class extends Yt{constructor(x){super(x)}},gB=class extends Yt{constructor(x){super(x)}},lM=[0,xn,pn,-1,Qx],XT=[0,xn,pn,Px];gB.prototype.g=iv([0,xn,oM,[0,xn],iM,rM,lM,XT]);var vB=class extends Yt{constructor(x){super(x)}},Kee=ts(456383383,vB);mn[456383383]=[0,xn,rB];var bB=class extends Yt{constructor(x){super(x)}},$ee=ts(476348187,bB);mn[476348187]=[0,xn,Bee];var _B=class extends Yt{constructor(x){super(x)}},tO=class extends Yt{constructor(x){super(x)}},SB=[0,wa,-1],Qee=ts(458105876,class extends Yt{constructor(x){super(x)}g(){var x=this.u;const e=0|x[qt],t=2&e;return x=function(n,i,r){var a=tO;const s=2&i;let l=!1;if(r==null){if(s)return UI();r=[]}else if(r.constructor===Sa){if((2&r.L)==0||s)return r;r=r.X()}else Array.isArray(r)?l=!!(2&(0|r[qt])):r=[];if(s){if(!r.length)return UI();l||(l=!0,id(r))}else l&&(l=!1,r=y4(r));return l||(64&(0|r[qt])?r[qt]&=-33:32&i&&Vg(r,32)),Wx(n,i,2,a=new Sa(r,a,oee,void 0)),a}(x,e,Wo(x,e,2)),!t&&tO&&(x.ra=!0),x}});mn[458105876]=[0,SB,bee,[!0,nl,[0,j0,-1,oi]]];var cM=class extends Yt{constructor(x){super(x)}},TB=ts(458105758,cM);mn[458105758]=[0,xn,j0,SB];var wB=class extends Yt{constructor(x){super(x)}},Zee=ts(443442058,wB);mn[443442058]=[0,xn,j0,Qx,pn,oi,-1,Px,pn],mn[514774813]=lM;var AB=class extends Yt{constructor(x){super(x)}},Jee=ts(516587230,AB);function YT(x,e){return e=e?e.clone():new nM,x.displayNamesLocale!==void 0?wx(e,1,ad(x.displayNamesLocale)):x.displayNamesLocale===void 0&&wx(e,1),x.maxResults!==void 0?Cs(e,2,x.maxResults):"maxResults"in x&&wx(e,2),x.scoreThreshold!==void 0?$t(e,3,x.scoreThreshold):"scoreThreshold"in x&&wx(e,3),x.categoryAllowlist!==void 0?Y1(e,4,x.categoryAllowlist):"categoryAllowlist"in x&&wx(e,4),x.categoryDenylist!==void 0?Y1(e,5,x.categoryDenylist):"categoryDenylist"in x&&wx(e,5),e}function uM(x,e=-1,t=""){return{categories:x.map(n=>{var i,r,a,s,l,c,h;return{index:(r=(i=ya(n,1))!=null?i:0)!=null?r:-1,score:(a=qx(n,2))!=null?a:0,categoryName:(l=(s=Ta(n,3))!=null?s:"")!=null?l:"",displayName:(h=(c=Ta(n,4))!=null?c:"")!=null?h:""}}),headIndex:e,headName:t}}function EB(x){var e,t,n,i,r,a,s,l,c,h,d,p,m,g=oc(x,3,dl,sc()),_=oc(x,2,rd,sc()),v=oc(x,1,Dh,sc()),b=oc(x,9,Dh,sc());const T={categories:[],keypoints:[]};for(let E=0;E<g.length;E++)T.categories.push({score:g[E],index:(e=_[E])!=null?e:-1,categoryName:(t=v[E])!=null?t:"",displayName:(n=b[E])!=null?n:""});if((g=(i=G0(x,F_,4))==null?void 0:i.h())&&(T.boundingBox={originX:(r=ya(g,1))!=null?r:0,originY:(a=ya(g,2))!=null?a:0,width:(s=ya(g,3))!=null?s:0,height:(l=ya(g,4))!=null?l:0,angle:0}),(c=G0(x,F_,4))==null?void 0:c.g().length)for(const E of G0(x,F_,4).g())T.keypoints.push({x:(h=n1(E,1))!=null?h:0,y:(d=n1(E,2))!=null?d:0,score:(p=n1(E,4))!=null?p:0,label:(m=Ta(E,3))!=null?m:""});return T}function sv(x){var e,t,n,i;const r=[];for(const a of Bo(x,xB,1))r.push({x:(e=qx(a,1))!=null?e:0,y:(t=qx(a,2))!=null?t:0,z:(n=qx(a,3))!=null?n:0,visibility:(i=qx(a,4))!=null?i:0});return r}function Uf(x){var e,t,n,i;const r=[];for(const a of Bo(x,tB,1))r.push({x:(e=qx(a,1))!=null?e:0,y:(t=qx(a,2))!=null?t:0,z:(n=qx(a,3))!=null?n:0,visibility:(i=qx(a,4))!=null?i:0});return r}function xO(x){return Array.from(x,e=>e>127?e-256:e)}function nO(x,e){if(x.length!==e.length)throw Error("Cannot compute cosine similarity between embeddings of different sizes ("+x.length+" vs. "+e.length+").");let t=0,n=0,i=0;for(let r=0;r<x.length;r++)t+=x[r]*e[r],n+=x[r]*x[r],i+=e[r]*e[r];if(n<=0||i<=0)throw Error("Cannot compute cosine similarity on embedding with 0 norm.");return t/Math.sqrt(n*i)}mn[516587230]=[0,xn,lM,XT,pn],mn[518928384]=XT;function MB(){var x=navigator;return typeof OffscreenCanvas<"u"&&(!function(e=navigator){return(e=e.userAgent).includes("Safari")&&!e.includes("Chrome")}(x)||!!((x=x.userAgent.match(/Version\/([\d]+).*Safari/))&&x.length>=1&&Number(x[1])>=17))}async function iO(x){if(typeof importScripts!="function"){const e=document.createElement("script");return e.src=x.toString(),e.crossOrigin="anonymous",new Promise((t,n)=>{e.addEventListener("load",()=>{t()},!1),e.addEventListener("error",i=>{n(i)},!1),document.body.appendChild(e)})}importScripts(x.toString())}function RB(x){return x.videoWidth!==void 0?[x.videoWidth,x.videoHeight]:x.naturalWidth!==void 0?[x.naturalWidth,x.naturalHeight]:x.displayWidth!==void 0?[x.displayWidth,x.displayHeight]:[x.width,x.height]}function jt(x,e,t){x.m||console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"),t(e=x.i.stringToNewUTF8(e)),x.i._free(e)}function rO(x,e,t){if(!x.i.canvas)throw Error("No OpenGL canvas configured.");if(t?x.i._bindTextureToStream(t):x.i._bindTextureToCanvas(),!(t=x.i.canvas.getContext("webgl2")||x.i.canvas.getContext("webgl")))throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");x.i.gpuOriginForWebTexturesIsBottomLeft&&t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!0),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e),x.i.gpuOriginForWebTexturesIsBottomLeft&&t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!1);const[n,i]=RB(e);return!x.l||n===x.i.canvas.width&&i===x.i.canvas.height||(x.i.canvas.width=n,x.i.canvas.height=i),[n,i]}function aO(x,e,t){x.m||console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");const n=new Uint32Array(e.length);for(let i=0;i<e.length;i++)n[i]=x.i.stringToNewUTF8(e[i]);e=x.i._malloc(4*n.length),x.i.HEAPU32.set(n,e>>2),t(e);for(const i of n)x.i._free(i);x.i._free(e)}function ys(x,e,t){x.i.simpleListeners=x.i.simpleListeners||{},x.i.simpleListeners[e]=t}function S2(x,e,t){let n=[];x.i.simpleListeners=x.i.simpleListeners||{},x.i.simpleListeners[e]=(i,r,a)=>{r?(t(n,a),n=[]):n.push(i)}}async function jee(x,e,t,n){return x=await(async(i,r,a,s,l)=>{if(r&&await iO(r),!self.ModuleFactory||a&&(await iO(a),!self.ModuleFactory))throw Error("ModuleFactory not set.");return self.Module&&l&&((r=self.Module).locateFile=l.locateFile,l.mainScriptUrlOrBlob&&(r.mainScriptUrlOrBlob=l.mainScriptUrlOrBlob)),l=await self.ModuleFactory(self.Module||l),self.ModuleFactory=self.Module=void 0,new i(l,s)})(x,t.wasmLoaderPath,t.assetLoaderPath,e,{locateFile:i=>i.endsWith(".wasm")?t.wasmBinaryPath.toString():t.assetBinaryPath&&i.endsWith(".data")?t.assetBinaryPath.toString():i}),await x.o(n),x}function B_(x,e){const t=G0(x.baseOptions,$1,1)||new $1;typeof e=="string"?(wx(t,2,ad(e)),wx(t,1)):e instanceof Uint8Array&&(wx(t,1,wE(e,!1)),wx(t,2)),n0(x.baseOptions,0,1,t)}function sO(x){try{const e=x.G.length;if(e===1)throw Error(x.G[0].message);if(e>1)throw Error("Encountered multiple errors: "+x.G.map(t=>t.message).join(", "))}finally{x.G=[]}}function kt(x,e){x.B=Math.max(x.B,e)}function ov(x,e){x.A=new Mi,Vr(x.A,"PassThroughCalculator"),Ax(x.A,"free_memory"),k0(x.A,"free_memory_unused_out"),Mx(e,"free_memory"),Hr(e,x.A)}function Uh(x,e){Ax(x.A,e),k0(x.A,e+"_unused_out")}function lv(x){x.g.addBoolToStream(!0,"free_memory",x.B)}var a1=class{constructor(x){this.g=x,this.G=[],this.B=0,this.g.setAutoRenderToScreen(!1)}l(x,e=!0){var t,n,i,r,a,s;if(e){const l=x.baseOptions||{};if((t=x.baseOptions)!=null&&t.modelAssetBuffer&&(n=x.baseOptions)!=null&&n.modelAssetPath)throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");if(!((i=G0(this.baseOptions,$1,1))!=null&&i.g()||(r=G0(this.baseOptions,$1,1))!=null&&r.h()||(a=x.baseOptions)!=null&&a.modelAssetBuffer||(s=x.baseOptions)!=null&&s.modelAssetPath))throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");if(function(c,h){let d=G0(c.baseOptions,qI,3);if(!d){var p=d=new qI,m=new KI;Pf(p,4,r1,m)}"delegate"in h&&(h.delegate==="GPU"?(h=d,p=new Eee,Pf(h,2,r1,p)):(h=d,p=new KI,Pf(h,4,r1,p))),n0(c.baseOptions,0,3,d)}(this,l),l.modelAssetPath)return fetch(l.modelAssetPath.toString()).then(c=>{if(c.ok)return c.arrayBuffer();throw Error("Failed to fetch model: "+l.modelAssetPath+" ("+c.status+")")}).then(c=>{try{this.g.i.FS_unlink("/model.dat")}catch{}this.g.i.FS_createDataFile("/","model.dat",new Uint8Array(c),!0,!1,!1),B_(this,"/model.dat"),this.m(),this.I()});if(l.modelAssetBuffer instanceof Uint8Array)B_(this,l.modelAssetBuffer);else if(l.modelAssetBuffer)return async function(c){const h=[];for(var d=0;;){const{done:p,value:m}=await c.read();if(p)break;h.push(m),d+=m.length}if(h.length===0)return new Uint8Array(0);if(h.length===1)return h[0];c=new Uint8Array(d),d=0;for(const p of h)c.set(p,d),d+=p.length;return c}(l.modelAssetBuffer).then(c=>{B_(this,c),this.m(),this.I()})}return this.m(),this.I(),Promise.resolve()}I(){}da(){let x;if(this.g.da(e=>{x=Mee(e)}),!x)throw Error("Failed to retrieve CalculatorGraphConfig");return x}setGraph(x,e){this.g.attachErrorListener((t,n)=>{this.G.push(Error(n))}),this.g.La(),this.g.setGraph(x,e),this.A=void 0,sO(this)}finishProcessing(){this.g.finishProcessing(),sO(this)}close(){this.A=void 0,this.g.closeGraph()}};function Uo(x,e){if(!x)throw Error("Unable to obtain required WebGL resource: "+e);return x}a1.prototype.close=a1.prototype.close,function(x,e){x=x.split(".");var t,n=Mc;for((x[0]in n)||n.execScript===void 0||n.execScript("var "+x[0]);x.length&&(t=x.shift());)x.length||e===void 0?n=n[t]&&n[t]!==Object.prototype[t]?n[t]:n[t]={}:n[t]=e}("TaskRunner",a1);class qee{constructor(e,t,n,i){this.g=e,this.h=t,this.m=n,this.l=i}bind(){this.g.bindVertexArray(this.h)}close(){this.g.deleteVertexArray(this.h),this.g.deleteBuffer(this.m),this.g.deleteBuffer(this.l)}}function oO(x,e,t){const n=x.g;if(t=Uo(n.createShader(t),"Failed to create WebGL shader"),n.shaderSource(t,e),n.compileShader(t),!n.getShaderParameter(t,n.COMPILE_STATUS))throw Error("Could not compile WebGL shader: "+n.getShaderInfoLog(t));return n.attachShader(x.h,t),t}function lO(x,e){const t=x.g,n=Uo(t.createVertexArray(),"Failed to create vertex array");t.bindVertexArray(n);const i=Uo(t.createBuffer(),"Failed to create buffer");t.bindBuffer(t.ARRAY_BUFFER,i),t.enableVertexAttribArray(x.O),t.vertexAttribPointer(x.O,2,t.FLOAT,!1,0,0),t.bufferData(t.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),t.STATIC_DRAW);const r=Uo(t.createBuffer(),"Failed to create buffer");return t.bindBuffer(t.ARRAY_BUFFER,r),t.enableVertexAttribArray(x.I),t.vertexAttribPointer(x.I,2,t.FLOAT,!1,0,0),t.bufferData(t.ARRAY_BUFFER,new Float32Array(e?[0,1,0,0,1,0,1,1]:[0,0,0,1,1,1,1,0]),t.STATIC_DRAW),t.bindBuffer(t.ARRAY_BUFFER,null),t.bindVertexArray(null),new qee(t,n,i,r)}function hM(x,e){if(x.g){if(e!==x.g)throw Error("Cannot change GL context once initialized")}else x.g=e}function dM(x,e,t,n){return hM(x,e),x.h||(x.m(),x.C()),t?(x.s||(x.s=lO(x,!0)),t=x.s):(x.v||(x.v=lO(x,!1)),t=x.v),e.useProgram(x.h),t.bind(),x.l(),x=n(),t.g.bindVertexArray(null),x}function cv(x,e,t){return hM(x,e),x=Uo(e.createTexture(),"Failed to create texture"),e.bindTexture(e.TEXTURE_2D,x),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,t??e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,t??e.LINEAR),e.bindTexture(e.TEXTURE_2D,null),x}function uv(x,e,t){hM(x,e),x.A||(x.A=Uo(e.createFramebuffer(),"Failed to create framebuffe.")),e.bindFramebuffer(e.FRAMEBUFFER,x.A),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)}function fM(x){var e;(e=x.g)==null||e.bindFramebuffer(x.g.FRAMEBUFFER,null)}var pM=class{G(){return`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D inputTexture;
  void main() {
    gl_FragColor = texture2D(inputTexture, vTex);
  }
 `}m(){const x=this.g;if(this.h=Uo(x.createProgram(),"Failed to create WebGL program"),this.aa=oO(this,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,x.VERTEX_SHADER),this.Z=oO(this,this.G(),x.FRAGMENT_SHADER),x.linkProgram(this.h),!x.getProgramParameter(this.h,x.LINK_STATUS))throw Error("Error during program linking: "+x.getProgramInfoLog(this.h));this.O=x.getAttribLocation(this.h,"aVertex"),this.I=x.getAttribLocation(this.h,"aTex")}C(){}l(){}close(){if(this.h){const x=this.g;x.deleteProgram(this.h),x.deleteShader(this.aa),x.deleteShader(this.Z)}this.A&&this.g.deleteFramebuffer(this.A),this.v&&this.v.close(),this.s&&this.s.close()}};function Eo(x,e){switch(e){case 0:return x.g.find(t=>t instanceof Uint8Array);case 1:return x.g.find(t=>t instanceof Float32Array);case 2:return x.g.find(t=>typeof WebGLTexture<"u"&&t instanceof WebGLTexture);default:throw Error("Type is not supported: "+e)}}function KT(x){var e=Eo(x,1);if(!e){if(e=Eo(x,0))e=new Float32Array(e).map(n=>n/255);else{e=new Float32Array(x.width*x.height);const n=Fh(x);var t=mM(x);if(uv(t,n,CB(x)),"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"document"in self&&"ontouchend"in self.document){t=new Float32Array(x.width*x.height*4),n.readPixels(0,0,x.width,x.height,n.RGBA,n.FLOAT,t);for(let i=0,r=0;i<e.length;++i,r+=4)e[i]=t[r]}else n.readPixels(0,0,x.width,x.height,n.RED,n.FLOAT,e)}x.g.push(e)}return e}function CB(x){let e=Eo(x,2);if(!e){const t=Fh(x);e=IB(x);const n=KT(x),i=NB(x);t.texImage2D(t.TEXTURE_2D,0,i,x.width,x.height,0,t.RED,t.FLOAT,n),$T(x)}return e}function Fh(x){if(!x.canvas)throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");return x.h||(x.h=Uo(x.canvas.getContext("webgl2"),"You cannot use a canvas that is already bound to a different type of rendering context.")),x.h}function NB(x){if(x=Fh(x),!Km)if(x.getExtension("EXT_color_buffer_float")&&x.getExtension("OES_texture_float_linear")&&x.getExtension("EXT_float_blend"))Km=x.R32F;else{if(!x.getExtension("EXT_color_buffer_half_float"))throw Error("GPU does not fully support 4-channel float32 or float16 formats");Km=x.R16F}return Km}function mM(x){return x.l||(x.l=new pM),x.l}function IB(x){const e=Fh(x);e.viewport(0,0,x.width,x.height),e.activeTexture(e.TEXTURE0);let t=Eo(x,2);return t||(t=cv(mM(x),e,x.m?e.LINEAR:e.NEAREST),x.g.push(t),x.j=!0),e.bindTexture(e.TEXTURE_2D,t),t}function $T(x){x.h.bindTexture(x.h.TEXTURE_2D,null)}var Km,Bn=class{constructor(x,e,t,n,i,r,a){this.g=x,this.m=e,this.j=t,this.canvas=n,this.l=i,this.width=r,this.height=a,this.j&&--cO===0&&console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources.")}Fa(){return!!Eo(this,0)}ja(){return!!Eo(this,1)}P(){return!!Eo(this,2)}ia(){return(e=Eo(x=this,0))||(e=KT(x),e=new Uint8Array(e.map(t=>255*t)),x.g.push(e)),e;var x,e}ha(){return KT(this)}M(){return CB(this)}clone(){const x=[];for(const e of this.g){let t;if(e instanceof Uint8Array)t=new Uint8Array(e);else if(e instanceof Float32Array)t=new Float32Array(e);else{if(!(e instanceof WebGLTexture))throw Error("Type is not supported: "+e);{const n=Fh(this),i=mM(this);n.activeTexture(n.TEXTURE1),t=cv(i,n,this.m?n.LINEAR:n.NEAREST),n.bindTexture(n.TEXTURE_2D,t);const r=NB(this);n.texImage2D(n.TEXTURE_2D,0,r,this.width,this.height,0,n.RED,n.FLOAT,null),n.bindTexture(n.TEXTURE_2D,null),uv(i,n,t),dM(i,n,!1,()=>{IB(this),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.drawArrays(n.TRIANGLE_FAN,0,4),$T(this)}),fM(i),$T(this)}}x.push(t)}return new Bn(x,this.m,this.P(),this.canvas,this.l,this.width,this.height)}close(){this.j&&Fh(this).deleteTexture(Eo(this,2)),cO=-1}};Bn.prototype.close=Bn.prototype.close,Bn.prototype.clone=Bn.prototype.clone,Bn.prototype.getAsWebGLTexture=Bn.prototype.M,Bn.prototype.getAsFloat32Array=Bn.prototype.ha,Bn.prototype.getAsUint8Array=Bn.prototype.ia,Bn.prototype.hasWebGLTexture=Bn.prototype.P,Bn.prototype.hasFloat32Array=Bn.prototype.ja,Bn.prototype.hasUint8Array=Bn.prototype.Fa;var cO=250;function _s(x,e){switch(e){case 0:return x.g.find(t=>t instanceof ImageData);case 1:return x.g.find(t=>typeof ImageBitmap<"u"&&t instanceof ImageBitmap);case 2:return x.g.find(t=>typeof WebGLTexture<"u"&&t instanceof WebGLTexture);default:throw Error("Type is not supported: "+e)}}function OB(x){var e=_s(x,0);if(!e){e=Bh(x);const t=hv(x),n=new Uint8Array(x.width*x.height*4);uv(t,e,s1(x)),e.readPixels(0,0,x.width,x.height,e.RGBA,e.UNSIGNED_BYTE,n),fM(t),e=new ImageData(new Uint8ClampedArray(n.buffer),x.width,x.height),x.g.push(e)}return e}function s1(x){let e=_s(x,2);if(!e){const t=Bh(x);e=o1(x);const n=_s(x,1)||OB(x);t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n),If(x)}return e}function Bh(x){if(!x.canvas)throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");return x.h||(x.h=Uo(x.canvas.getContext("webgl2"),"You cannot use a canvas that is already bound to a different type of rendering context.")),x.h}function hv(x){return x.l||(x.l=new pM),x.l}function o1(x){const e=Bh(x);e.viewport(0,0,x.width,x.height),e.activeTexture(e.TEXTURE0);let t=_s(x,2);return t||(t=cv(hv(x),e),x.g.push(t),x.m=!0),e.bindTexture(e.TEXTURE_2D,t),t}function If(x){x.h.bindTexture(x.h.TEXTURE_2D,null)}function uO(x){const e=Bh(x);return dM(hv(x),e,!0,()=>function(t,n){const i=t.canvas;if(i.width===t.width&&i.height===t.height)return n();const r=i.width,a=i.height;return i.width=t.width,i.height=t.height,t=n(),i.width=r,i.height=a,t}(x,()=>{if(e.bindFramebuffer(e.FRAMEBUFFER,null),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.drawArrays(e.TRIANGLE_FAN,0,4),!(x.canvas instanceof OffscreenCanvas))throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");return x.canvas.transferToImageBitmap()}))}var Ln=class{constructor(x,e,t,n,i,r,a){this.g=x,this.j=e,this.m=t,this.canvas=n,this.l=i,this.width=r,this.height=a,(this.j||this.m)&&--hO===0&&console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources.")}Ea(){return!!_s(this,0)}ka(){return!!_s(this,1)}P(){return!!_s(this,2)}Ca(){return OB(this)}Ba(){var x=_s(this,1);return x||(s1(this),o1(this),x=uO(this),If(this),this.g.push(x),this.j=!0),x}M(){return s1(this)}clone(){const x=[];for(const e of this.g){let t;if(e instanceof ImageData)t=new ImageData(e.data,this.width,this.height);else if(e instanceof WebGLTexture){const n=Bh(this),i=hv(this);n.activeTexture(n.TEXTURE1),t=cv(i,n),n.bindTexture(n.TEXTURE_2D,t),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,this.width,this.height,0,n.RGBA,n.UNSIGNED_BYTE,null),n.bindTexture(n.TEXTURE_2D,null),uv(i,n,t),dM(i,n,!1,()=>{o1(this),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),n.drawArrays(n.TRIANGLE_FAN,0,4),If(this)}),fM(i),If(this)}else{if(!(e instanceof ImageBitmap))throw Error("Type is not supported: "+e);s1(this),o1(this),t=uO(this),If(this)}x.push(t)}return new Ln(x,this.ka(),this.P(),this.canvas,this.l,this.width,this.height)}close(){this.j&&_s(this,1).close(),this.m&&Bh(this).deleteTexture(_s(this,2)),hO=-1}};Ln.prototype.close=Ln.prototype.close,Ln.prototype.clone=Ln.prototype.clone,Ln.prototype.getAsWebGLTexture=Ln.prototype.M,Ln.prototype.getAsImageBitmap=Ln.prototype.Ba,Ln.prototype.getAsImageData=Ln.prototype.Ca,Ln.prototype.hasWebGLTexture=Ln.prototype.P,Ln.prototype.hasImageBitmap=Ln.prototype.ka,Ln.prototype.hasImageData=Ln.prototype.Ea;var hO=250;function xs(...x){return x.map(([e,t])=>({start:e,end:t}))}const ete=function(x){return class extends x{La(){this.i._registerModelResourcesGraphService()}}}((dO=class{constructor(x,e){this.l=!0,this.i=x,this.g=null,this.h=0,this.m=typeof this.i._addIntToInputStream=="function",e!==void 0?this.i.canvas=e:MB()?this.i.canvas=new OffscreenCanvas(1,1):(console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."),this.i.canvas=document.createElement("canvas"))}async initializeGraph(x){const e=await(await fetch(x)).arrayBuffer();x=!(x.endsWith(".pbtxt")||x.endsWith(".textproto")),this.setGraph(new Uint8Array(e),x)}setGraphFromString(x){this.setGraph(new TextEncoder().encode(x),!1)}setGraph(x,e){const t=x.length,n=this.i._malloc(t);this.i.HEAPU8.set(x,n),e?this.i._changeBinaryGraph(t,n):this.i._changeTextGraph(t,n),this.i._free(n)}configureAudio(x,e,t,n,i){this.i._configureAudio||console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'),jt(this,n||"input_audio",r=>{jt(this,i=i||"audio_header",a=>{this.i._configureAudio(r,a,x,e??0,t)})})}setAutoResizeCanvas(x){this.l=x}setAutoRenderToScreen(x){this.i._setAutoRenderToScreen(x)}setGpuBufferVerticalFlip(x){this.i.gpuOriginForWebTexturesIsBottomLeft=x}da(x){ys(this,"__graph_config__",e=>{x(e)}),jt(this,"__graph_config__",e=>{this.i._getGraphConfig(e,void 0)}),delete this.i.simpleListeners.__graph_config__}attachErrorListener(x){this.i.errorListener=x}attachEmptyPacketListener(x,e){this.i.emptyPacketListeners=this.i.emptyPacketListeners||{},this.i.emptyPacketListeners[x]=e}addAudioToStream(x,e,t){this.addAudioToStreamWithShape(x,0,0,e,t)}addAudioToStreamWithShape(x,e,t,n,i){const r=4*x.length;this.h!==r&&(this.g&&this.i._free(this.g),this.g=this.i._malloc(r),this.h=r),this.i.HEAPF32.set(x,this.g/4),jt(this,n,a=>{this.i._addAudioToInputStream(this.g,e,t,a,i)})}addGpuBufferToStream(x,e,t){jt(this,e,n=>{const[i,r]=rO(this,x,n);this.i._addBoundTextureToStream(n,i,r,t)})}addBoolToStream(x,e,t){jt(this,e,n=>{this.i._addBoolToInputStream(x,n,t)})}addDoubleToStream(x,e,t){jt(this,e,n=>{this.i._addDoubleToInputStream(x,n,t)})}addFloatToStream(x,e,t){jt(this,e,n=>{this.i._addFloatToInputStream(x,n,t)})}addIntToStream(x,e,t){jt(this,e,n=>{this.i._addIntToInputStream(x,n,t)})}addUintToStream(x,e,t){jt(this,e,n=>{this.i._addUintToInputStream(x,n,t)})}addStringToStream(x,e,t){jt(this,e,n=>{jt(this,x,i=>{this.i._addStringToInputStream(i,n,t)})})}addStringRecordToStream(x,e,t){jt(this,e,n=>{aO(this,Object.keys(x),i=>{aO(this,Object.values(x),r=>{this.i._addFlatHashMapToInputStream(i,r,Object.keys(x).length,n,t)})})})}addProtoToStream(x,e,t,n){jt(this,t,i=>{jt(this,e,r=>{const a=this.i._malloc(x.length);this.i.HEAPU8.set(x,a),this.i._addProtoToInputStream(a,x.length,r,i,n),this.i._free(a)})})}addEmptyPacketToStream(x,e){jt(this,x,t=>{this.i._addEmptyPacketToInputStream(t,e)})}addBoolVectorToStream(x,e,t){jt(this,e,n=>{const i=this.i._allocateBoolVector(x.length);if(!i)throw Error("Unable to allocate new bool vector on heap.");for(const r of x)this.i._addBoolVectorEntry(i,r);this.i._addBoolVectorToInputStream(i,n,t)})}addDoubleVectorToStream(x,e,t){jt(this,e,n=>{const i=this.i._allocateDoubleVector(x.length);if(!i)throw Error("Unable to allocate new double vector on heap.");for(const r of x)this.i._addDoubleVectorEntry(i,r);this.i._addDoubleVectorToInputStream(i,n,t)})}addFloatVectorToStream(x,e,t){jt(this,e,n=>{const i=this.i._allocateFloatVector(x.length);if(!i)throw Error("Unable to allocate new float vector on heap.");for(const r of x)this.i._addFloatVectorEntry(i,r);this.i._addFloatVectorToInputStream(i,n,t)})}addIntVectorToStream(x,e,t){jt(this,e,n=>{const i=this.i._allocateIntVector(x.length);if(!i)throw Error("Unable to allocate new int vector on heap.");for(const r of x)this.i._addIntVectorEntry(i,r);this.i._addIntVectorToInputStream(i,n,t)})}addUintVectorToStream(x,e,t){jt(this,e,n=>{const i=this.i._allocateUintVector(x.length);if(!i)throw Error("Unable to allocate new unsigned int vector on heap.");for(const r of x)this.i._addUintVectorEntry(i,r);this.i._addUintVectorToInputStream(i,n,t)})}addStringVectorToStream(x,e,t){jt(this,e,n=>{const i=this.i._allocateStringVector(x.length);if(!i)throw Error("Unable to allocate new string vector on heap.");for(const r of x)jt(this,r,a=>{this.i._addStringVectorEntry(i,a)});this.i._addStringVectorToInputStream(i,n,t)})}addBoolToInputSidePacket(x,e){jt(this,e,t=>{this.i._addBoolToInputSidePacket(x,t)})}addDoubleToInputSidePacket(x,e){jt(this,e,t=>{this.i._addDoubleToInputSidePacket(x,t)})}addFloatToInputSidePacket(x,e){jt(this,e,t=>{this.i._addFloatToInputSidePacket(x,t)})}addIntToInputSidePacket(x,e){jt(this,e,t=>{this.i._addIntToInputSidePacket(x,t)})}addUintToInputSidePacket(x,e){jt(this,e,t=>{this.i._addUintToInputSidePacket(x,t)})}addStringToInputSidePacket(x,e){jt(this,e,t=>{jt(this,x,n=>{this.i._addStringToInputSidePacket(n,t)})})}addProtoToInputSidePacket(x,e,t){jt(this,t,n=>{jt(this,e,i=>{const r=this.i._malloc(x.length);this.i.HEAPU8.set(x,r),this.i._addProtoToInputSidePacket(r,x.length,i,n),this.i._free(r)})})}addBoolVectorToInputSidePacket(x,e){jt(this,e,t=>{const n=this.i._allocateBoolVector(x.length);if(!n)throw Error("Unable to allocate new bool vector on heap.");for(const i of x)this.i._addBoolVectorEntry(n,i);this.i._addBoolVectorToInputSidePacket(n,t)})}addDoubleVectorToInputSidePacket(x,e){jt(this,e,t=>{const n=this.i._allocateDoubleVector(x.length);if(!n)throw Error("Unable to allocate new double vector on heap.");for(const i of x)this.i._addDoubleVectorEntry(n,i);this.i._addDoubleVectorToInputSidePacket(n,t)})}addFloatVectorToInputSidePacket(x,e){jt(this,e,t=>{const n=this.i._allocateFloatVector(x.length);if(!n)throw Error("Unable to allocate new float vector on heap.");for(const i of x)this.i._addFloatVectorEntry(n,i);this.i._addFloatVectorToInputSidePacket(n,t)})}addIntVectorToInputSidePacket(x,e){jt(this,e,t=>{const n=this.i._allocateIntVector(x.length);if(!n)throw Error("Unable to allocate new int vector on heap.");for(const i of x)this.i._addIntVectorEntry(n,i);this.i._addIntVectorToInputSidePacket(n,t)})}addUintVectorToInputSidePacket(x,e){jt(this,e,t=>{const n=this.i._allocateUintVector(x.length);if(!n)throw Error("Unable to allocate new unsigned int vector on heap.");for(const i of x)this.i._addUintVectorEntry(n,i);this.i._addUintVectorToInputSidePacket(n,t)})}addStringVectorToInputSidePacket(x,e){jt(this,e,t=>{const n=this.i._allocateStringVector(x.length);if(!n)throw Error("Unable to allocate new string vector on heap.");for(const i of x)jt(this,i,r=>{this.i._addStringVectorEntry(n,r)});this.i._addStringVectorToInputSidePacket(n,t)})}attachBoolListener(x,e){ys(this,x,e),jt(this,x,t=>{this.i._attachBoolListener(t)})}attachBoolVectorListener(x,e){S2(this,x,e),jt(this,x,t=>{this.i._attachBoolVectorListener(t)})}attachIntListener(x,e){ys(this,x,e),jt(this,x,t=>{this.i._attachIntListener(t)})}attachIntVectorListener(x,e){S2(this,x,e),jt(this,x,t=>{this.i._attachIntVectorListener(t)})}attachUintListener(x,e){ys(this,x,e),jt(this,x,t=>{this.i._attachUintListener(t)})}attachUintVectorListener(x,e){S2(this,x,e),jt(this,x,t=>{this.i._attachUintVectorListener(t)})}attachDoubleListener(x,e){ys(this,x,e),jt(this,x,t=>{this.i._attachDoubleListener(t)})}attachDoubleVectorListener(x,e){S2(this,x,e),jt(this,x,t=>{this.i._attachDoubleVectorListener(t)})}attachFloatListener(x,e){ys(this,x,e),jt(this,x,t=>{this.i._attachFloatListener(t)})}attachFloatVectorListener(x,e){S2(this,x,e),jt(this,x,t=>{this.i._attachFloatVectorListener(t)})}attachStringListener(x,e){ys(this,x,e),jt(this,x,t=>{this.i._attachStringListener(t)})}attachStringVectorListener(x,e){S2(this,x,e),jt(this,x,t=>{this.i._attachStringVectorListener(t)})}attachProtoListener(x,e,t){ys(this,x,e),jt(this,x,n=>{this.i._attachProtoListener(n,t||!1)})}attachProtoVectorListener(x,e,t){S2(this,x,e),jt(this,x,n=>{this.i._attachProtoVectorListener(n,t||!1)})}attachAudioListener(x,e,t){this.i._attachAudioListener||console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'),ys(this,x,(n,i)=>{n=new Float32Array(n.buffer,n.byteOffset,n.length/4),e(n,i)}),jt(this,x,n=>{this.i._attachAudioListener(n,t||!1)})}finishProcessing(){this.i._waitUntilIdle()}closeGraph(){this.i._closeGraph(),this.i.simpleListeners=void 0,this.i.emptyPacketListeners=void 0}},class extends dO{get ea(){return this.i}qa(x,e,t){jt(this,e,n=>{const[i,r]=rO(this,x,n);this.ea._addBoundTextureAsImageToStream(n,i,r,t)})}U(x,e){ys(this,x,e),jt(this,x,t=>{this.ea._attachImageListener(t)})}ca(x,e){S2(this,x,e),jt(this,x,t=>{this.ea._attachImageVectorListener(t)})}}));var dO,Aa=class extends ete{};async function O0(x,e,t){var n;return async function(i,r,a,s){return jee(i,r,a,s)}(x,(n=t.canvas)!=null?n:MB()?void 0:document.createElement("canvas"),e,t)}function DB(x,e,t,n){if(x.T){const r=new nB;if(t!=null&&t.regionOfInterest){if(!x.pa)throw Error("This task doesn't support region-of-interest.");var i=t.regionOfInterest;if(i.left>=i.right||i.top>=i.bottom)throw Error("Expected RectF with left < right and top < bottom.");if(i.left<0||i.top<0||i.right>1||i.bottom>1)throw Error("Expected RectF values to be in [0,1].");$t(r,1,(i.left+i.right)/2),$t(r,2,(i.top+i.bottom)/2),$t(r,4,i.right-i.left),$t(r,3,i.bottom-i.top)}else $t(r,1,.5),$t(r,2,.5),$t(r,4,1),$t(r,3,1);if(t!=null&&t.rotationDegrees){if((t==null?void 0:t.rotationDegrees)%90!=0)throw Error("Expected rotation to be a multiple of 90.");if($t(r,5,-Math.PI*t.rotationDegrees/180),(t==null?void 0:t.rotationDegrees)%180!=0){const[a,s]=RB(e);t=qx(r,3)*s/a,i=qx(r,4)*a/s,$t(r,4,t),$t(r,3,i)}}x.g.addProtoToStream(r.g(),"mediapipe.NormalizedRect",x.T,n)}x.g.qa(e,x.aa,n??performance.now()),x.finishProcessing()}function Ea(x,e,t){var n;if((n=x.baseOptions)!=null&&n.g())throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");DB(x,e,t,x.B+1)}function Ds(x,e,t,n){var i;if(!((i=x.baseOptions)!=null&&i.g()))throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");DB(x,e,t,n)}function Lh(x,e,t,n){var i=e.data;const r=e.width,a=r*(e=e.height);if((i instanceof Uint8Array||i instanceof Float32Array)&&i.length!==a)throw Error("Unsupported channel count: "+i.length/a);return x=new Bn([i],t,!1,x.g.i.canvas,x.O,r,e),n?x.clone():x}var tr=class extends a1{constructor(x,e,t,n){super(x),this.g=x,this.aa=e,this.T=t,this.pa=n,this.O=new pM}l(x,e=!0){if("runningMode"in x&&jf(this.baseOptions,2,!!x.runningMode&&x.runningMode!=="IMAGE"),x.canvas!==void 0&&this.g.i.canvas!==x.canvas)throw Error("You must create a new task to reset the canvas.");return super.l(x,e)}close(){this.O.close(),super.close()}};tr.prototype.close=tr.prototype.close;var na=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect_in",!1),this.j={detections:[]},n0(x=this.h=new av,0,1,e=new Ux),$t(this.h,2,.5),$t(this.h,3,.3)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){var e,t;return"minDetectionConfidence"in x&&$t(this.h,2,(e=x.minDetectionConfidence)!=null?e:.5),"minSuppressionThreshold"in x&&$t(this.h,3,(t=x.minSuppressionThreshold)!=null?t:.3),this.l(x)}D(x,e){return this.j={detections:[]},Ea(this,x,e),this.j}F(x,e,t){return this.j={detections:[]},Ds(this,x,t,e),this.j}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect_in"),X0(x,"detections");const e=new Pr;qa(e,Lee,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.face_detector.FaceDetectorGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect_in"),k0(t,"DETECTIONS:detections"),t.o(e),Hr(x,t),this.g.attachProtoVectorListener("detections",(n,i)=>{for(const r of n)n=eB(r),this.j.detections.push(EB(n));kt(this,i)}),this.g.attachEmptyPacketListener("detections",n=>{kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};na.prototype.detectForVideo=na.prototype.F,na.prototype.detect=na.prototype.D,na.prototype.setOptions=na.prototype.o,na.createFromModelPath=async function(x,e){return O0(na,x,{baseOptions:{modelAssetPath:e}})},na.createFromModelBuffer=function(x,e){return O0(na,x,{baseOptions:{modelAssetBuffer:e}})},na.createFromOptions=function(x,e){return O0(na,x,e)};var yM=xs([61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]),gM=xs([263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]),vM=xs([276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]),PB=xs([474,475],[475,476],[476,477],[477,474]),bM=xs([33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]),_M=xs([46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]),kB=xs([469,470],[470,471],[471,472],[472,469]),SM=xs([10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]),UB=[...yM,...gM,...vM,...bM,..._M,...SM],FB=xs([127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]);function fO(x){x.j={faceLandmarks:[],faceBlendshapes:[],facialTransformationMatrixes:[]}}var Kx=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect",!1),this.j={faceLandmarks:[],faceBlendshapes:[],facialTransformationMatrixes:[]},this.outputFacialTransformationMatrixes=this.outputFaceBlendshapes=!1,n0(x=this.h=new oB,0,1,e=new Ux),this.v=new sB,n0(this.h,0,3,this.v),this.s=new av,n0(this.h,0,2,this.s),Cs(this.s,4,1),$t(this.s,2,.5),$t(this.v,2,.5),$t(this.h,4,.5)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){var e,t,n,i;return"numFaces"in x&&Cs(this.s,4,(e=x.numFaces)!=null?e:1),"minFaceDetectionConfidence"in x&&$t(this.s,2,(t=x.minFaceDetectionConfidence)!=null?t:.5),"minTrackingConfidence"in x&&$t(this.h,4,(n=x.minTrackingConfidence)!=null?n:.5),"minFacePresenceConfidence"in x&&$t(this.v,2,(i=x.minFacePresenceConfidence)!=null?i:.5),"outputFaceBlendshapes"in x&&(this.outputFaceBlendshapes=!!x.outputFaceBlendshapes),"outputFacialTransformationMatrixes"in x&&(this.outputFacialTransformationMatrixes=!!x.outputFacialTransformationMatrixes),this.l(x)}D(x,e){return fO(this),Ea(this,x,e),this.j}F(x,e,t){return fO(this),Ds(this,x,t,e),this.j}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect"),X0(x,"face_landmarks");const e=new Pr;qa(e,Vee,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"NORM_LANDMARKS:face_landmarks"),t.o(e),Hr(x,t),this.g.attachProtoVectorListener("face_landmarks",(n,i)=>{for(const r of n)n=Rp(r),this.j.faceLandmarks.push(sv(n));kt(this,i)}),this.g.attachEmptyPacketListener("face_landmarks",n=>{kt(this,n)}),this.outputFaceBlendshapes&&(X0(x,"blendshapes"),k0(t,"BLENDSHAPES:blendshapes"),this.g.attachProtoVectorListener("blendshapes",(n,i)=>{var r;if(this.outputFaceBlendshapes)for(const a of n)n=rv(a),this.j.faceBlendshapes.push(uM((r=n.g())!=null?r:[]));kt(this,i)}),this.g.attachEmptyPacketListener("blendshapes",n=>{kt(this,n)})),this.outputFacialTransformationMatrixes&&(X0(x,"face_geometry"),k0(t,"FACE_GEOMETRY:face_geometry"),this.g.attachProtoVectorListener("face_geometry",(n,i)=>{var r,a,s,l,c;if(this.outputFacialTransformationMatrixes)for(const h of n)(n=G0(zee(h),Iee,2))&&this.j.facialTransformationMatrixes.push({rows:(a=(r=ya(n,1))!=null?r:0)!=null?a:0,columns:(l=(s=ya(n,2))!=null?s:0)!=null?l:0,data:(c=oc(n,3,dl,sc()).slice())!=null?c:[]});kt(this,i)}),this.g.attachEmptyPacketListener("face_geometry",n=>{kt(this,n)})),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};Kx.prototype.detectForVideo=Kx.prototype.F,Kx.prototype.detect=Kx.prototype.D,Kx.prototype.setOptions=Kx.prototype.o,Kx.createFromModelPath=function(x,e){return O0(Kx,x,{baseOptions:{modelAssetPath:e}})},Kx.createFromModelBuffer=function(x,e){return O0(Kx,x,{baseOptions:{modelAssetBuffer:e}})},Kx.createFromOptions=function(x,e){return O0(Kx,x,e)},Kx.FACE_LANDMARKS_LIPS=yM,Kx.FACE_LANDMARKS_LEFT_EYE=gM,Kx.FACE_LANDMARKS_LEFT_EYEBROW=vM,Kx.FACE_LANDMARKS_LEFT_IRIS=PB,Kx.FACE_LANDMARKS_RIGHT_EYE=bM,Kx.FACE_LANDMARKS_RIGHT_EYEBROW=_M,Kx.FACE_LANDMARKS_RIGHT_IRIS=kB,Kx.FACE_LANDMARKS_FACE_OVAL=SM,Kx.FACE_LANDMARKS_CONTOURS=UB,Kx.FACE_LANDMARKS_TESSELATION=FB;var gs=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect",!0),n0(x=this.j=new cB,0,1,e=new Ux)}get baseOptions(){return G0(this.j,Ux,1)}set baseOptions(x){n0(this.j,0,1,x)}o(x){return super.l(x)}Oa(x,e,t){const n=typeof e!="function"?e:{};if(this.h=typeof e=="function"?e:t,Ea(this,x,n??{}),!this.h)return this.s}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect"),X0(x,"stylized_image");const e=new Pr;qa(e,Hee,this.j);const t=new Mi;Vr(t,"mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"STYLIZED_IMAGE:stylized_image"),t.o(e),Hr(x,t),this.g.U("stylized_image",(n,i)=>{var r=!this.h,a=n.data,s=n.width;const l=s*(n=n.height);if(a instanceof Uint8Array)if(a.length===3*l){const c=new Uint8ClampedArray(4*l);for(let h=0;h<l;++h)c[4*h]=a[3*h],c[4*h+1]=a[3*h+1],c[4*h+2]=a[3*h+2],c[4*h+3]=255;a=new ImageData(c,s,n)}else{if(a.length!==4*l)throw Error("Unsupported channel count: "+a.length/l);a=new ImageData(new Uint8ClampedArray(a.buffer,a.byteOffset,a.length),s,n)}else if(!(a instanceof WebGLTexture))throw Error("Unsupported format: "+a.constructor.name);s=new Ln([a],!1,!1,this.g.i.canvas,this.O,s,n),this.s=r=r?s.clone():s,this.h&&this.h(r),kt(this,i)}),this.g.attachEmptyPacketListener("stylized_image",n=>{this.s=null,this.h&&this.h(null),kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};gs.prototype.stylize=gs.prototype.Oa,gs.prototype.setOptions=gs.prototype.o,gs.createFromModelPath=function(x,e){return O0(gs,x,{baseOptions:{modelAssetPath:e}})},gs.createFromModelBuffer=function(x,e){return O0(gs,x,{baseOptions:{modelAssetBuffer:e}})},gs.createFromOptions=function(x,e){return O0(gs,x,e)};var TM=xs([0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]);function pO(x){x.gestures=[],x.landmarks=[],x.worldLandmarks=[],x.handedness=[]}function mO(x){return x.gestures.length===0?{gestures:[],landmarks:[],worldLandmarks:[],handedness:[],handednesses:[]}:{gestures:x.gestures,landmarks:x.landmarks,worldLandmarks:x.worldLandmarks,handedness:x.handedness,handednesses:x.handedness}}function yO(x,e=!0){var t,n,i,r,a,s;const l=[];for(const h of x){var c=rv(h);x=[];for(const d of c.g())c=e&&ya(d,1)!=null?(t=ya(d,1))!=null?t:0:-1,x.push({score:(n=qx(d,2))!=null?n:0,index:c,categoryName:(r=(i=Ta(d,3))!=null?i:"")!=null?r:"",displayName:(s=(a=Ta(d,4))!=null?a:"")!=null?s:""});l.push(x)}return l}var pr=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect",!1),this.gestures=[],this.landmarks=[],this.worldLandmarks=[],this.handedness=[],n0(x=this.j=new dB,0,1,e=new Ux),this.s=new sM,n0(this.j,0,2,this.s),this.C=new aM,n0(this.s,0,3,this.C),this.v=new hB,n0(this.s,0,2,this.v),this.h=new Gee,n0(this.j,0,3,this.h),$t(this.v,2,.5),$t(this.s,4,.5),$t(this.C,2,.5)}get baseOptions(){return G0(this.j,Ux,1)}set baseOptions(x){n0(this.j,0,1,x)}o(x){var e,t,n,i,r,a,s,l;if(Cs(this.v,3,(e=x.numHands)!=null?e:1),"minHandDetectionConfidence"in x&&$t(this.v,2,(t=x.minHandDetectionConfidence)!=null?t:.5),"minTrackingConfidence"in x&&$t(this.s,4,(n=x.minTrackingConfidence)!=null?n:.5),"minHandPresenceConfidence"in x&&$t(this.C,2,(i=x.minHandPresenceConfidence)!=null?i:.5),x.cannedGesturesClassifierOptions){var c=new mu,h=c,d=YT(x.cannedGesturesClassifierOptions,(r=G0(this.h,mu,3))==null?void 0:r.h());n0(h,0,2,d),n0(this.h,0,3,c)}else x.cannedGesturesClassifierOptions===void 0&&((a=G0(this.h,mu,3))==null||a.g());return x.customGesturesClassifierOptions?(n0(h=c=new mu,0,2,d=YT(x.customGesturesClassifierOptions,(s=G0(this.h,mu,4))==null?void 0:s.h())),n0(this.h,0,4,c)):x.customGesturesClassifierOptions===void 0&&((l=G0(this.h,mu,4))==null||l.g()),this.l(x)}Ja(x,e){return pO(this),Ea(this,x,e),mO(this)}Ka(x,e,t){return pO(this),Ds(this,x,t,e),mO(this)}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect"),X0(x,"hand_gestures"),X0(x,"hand_landmarks"),X0(x,"world_hand_landmarks"),X0(x,"handedness");const e=new Pr;qa(e,Wee,this.j);const t=new Mi;Vr(t,"mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"HAND_GESTURES:hand_gestures"),k0(t,"LANDMARKS:hand_landmarks"),k0(t,"WORLD_LANDMARKS:world_hand_landmarks"),k0(t,"HANDEDNESS:handedness"),t.o(e),Hr(x,t),this.g.attachProtoVectorListener("hand_landmarks",(n,i)=>{var r,a,s,l;for(const c of n){n=Rp(c);const h=[];for(const d of Bo(n,xB,1))h.push({x:(r=qx(d,1))!=null?r:0,y:(a=qx(d,2))!=null?a:0,z:(s=qx(d,3))!=null?s:0,visibility:(l=qx(d,4))!=null?l:0});this.landmarks.push(h)}kt(this,i)}),this.g.attachEmptyPacketListener("hand_landmarks",n=>{kt(this,n)}),this.g.attachProtoVectorListener("world_hand_landmarks",(n,i)=>{var r,a,s,l;for(const c of n){n=hh(c);const h=[];for(const d of Bo(n,tB,1))h.push({x:(r=qx(d,1))!=null?r:0,y:(a=qx(d,2))!=null?a:0,z:(s=qx(d,3))!=null?s:0,visibility:(l=qx(d,4))!=null?l:0});this.worldLandmarks.push(h)}kt(this,i)}),this.g.attachEmptyPacketListener("world_hand_landmarks",n=>{kt(this,n)}),this.g.attachProtoVectorListener("hand_gestures",(n,i)=>{this.gestures.push(...yO(n,!1)),kt(this,i)}),this.g.attachEmptyPacketListener("hand_gestures",n=>{kt(this,n)}),this.g.attachProtoVectorListener("handedness",(n,i)=>{this.handedness.push(...yO(n)),kt(this,i)}),this.g.attachEmptyPacketListener("handedness",n=>{kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};function gO(x){return{landmarks:x.landmarks,worldLandmarks:x.worldLandmarks,handednesses:x.handedness,handedness:x.handedness}}pr.prototype.recognizeForVideo=pr.prototype.Ka,pr.prototype.recognize=pr.prototype.Ja,pr.prototype.setOptions=pr.prototype.o,pr.createFromModelPath=function(x,e){return O0(pr,x,{baseOptions:{modelAssetPath:e}})},pr.createFromModelBuffer=function(x,e){return O0(pr,x,{baseOptions:{modelAssetBuffer:e}})},pr.createFromOptions=function(x,e){return O0(pr,x,e)},pr.HAND_CONNECTIONS=TM;var mr=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect",!1),this.landmarks=[],this.worldLandmarks=[],this.handedness=[],n0(x=this.h=new sM,0,1,e=new Ux),this.s=new aM,n0(this.h,0,3,this.s),this.j=new hB,n0(this.h,0,2,this.j),Cs(this.j,3,1),$t(this.j,2,.5),$t(this.s,2,.5),$t(this.h,4,.5)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){var e,t,n,i;return"numHands"in x&&Cs(this.j,3,(e=x.numHands)!=null?e:1),"minHandDetectionConfidence"in x&&$t(this.j,2,(t=x.minHandDetectionConfidence)!=null?t:.5),"minTrackingConfidence"in x&&$t(this.h,4,(n=x.minTrackingConfidence)!=null?n:.5),"minHandPresenceConfidence"in x&&$t(this.s,2,(i=x.minHandPresenceConfidence)!=null?i:.5),this.l(x)}D(x,e){return this.landmarks=[],this.worldLandmarks=[],this.handedness=[],Ea(this,x,e),gO(this)}F(x,e,t){return this.landmarks=[],this.worldLandmarks=[],this.handedness=[],Ds(this,x,t,e),gO(this)}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect"),X0(x,"hand_landmarks"),X0(x,"world_hand_landmarks"),X0(x,"handedness");const e=new Pr;qa(e,Xee,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"LANDMARKS:hand_landmarks"),k0(t,"WORLD_LANDMARKS:world_hand_landmarks"),k0(t,"HANDEDNESS:handedness"),t.o(e),Hr(x,t),this.g.attachProtoVectorListener("hand_landmarks",(n,i)=>{for(const r of n)n=Rp(r),this.landmarks.push(sv(n));kt(this,i)}),this.g.attachEmptyPacketListener("hand_landmarks",n=>{kt(this,n)}),this.g.attachProtoVectorListener("world_hand_landmarks",(n,i)=>{for(const r of n)n=hh(r),this.worldLandmarks.push(Uf(n));kt(this,i)}),this.g.attachEmptyPacketListener("world_hand_landmarks",n=>{kt(this,n)}),this.g.attachProtoVectorListener("handedness",(n,i)=>{var r,a,s,l,c,h,d,p=this.handedness,m=p.push;const g=[];for(const _ of n){n=rv(_);const v=[];for(const b of n.g())v.push({score:(r=qx(b,2))!=null?r:0,index:(s=(a=ya(b,1))!=null?a:0)!=null?s:-1,categoryName:(c=(l=Ta(b,3))!=null?l:"")!=null?c:"",displayName:(d=(h=Ta(b,4))!=null?h:"")!=null?d:""});g.push(v)}m.call(p,...g),kt(this,i)}),this.g.attachEmptyPacketListener("handedness",n=>{kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};mr.prototype.detectForVideo=mr.prototype.F,mr.prototype.detect=mr.prototype.D,mr.prototype.setOptions=mr.prototype.o,mr.createFromModelPath=function(x,e){return O0(mr,x,{baseOptions:{modelAssetPath:e}})},mr.createFromModelBuffer=function(x,e){return O0(mr,x,{baseOptions:{modelAssetBuffer:e}})},mr.createFromOptions=function(x,e){return O0(mr,x,e)},mr.HAND_CONNECTIONS=TM;var BB=xs([0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]);function vO(x){x.h={faceLandmarks:[],faceBlendshapes:[],poseLandmarks:[],poseWorldLandmarks:[],poseSegmentationMasks:[],leftHandLandmarks:[],leftHandWorldLandmarks:[],rightHandLandmarks:[],rightHandWorldLandmarks:[]}}function bO(x){try{if(!x.C)return x.h;x.C(x.h)}finally{lv(x)}}function $m(x,e){x=Rp(x),e.push(sv(x))}var Ox=class extends tr{constructor(x,e){super(new Aa(x,e),"input_frames_image",null,!1),this.h={faceLandmarks:[],faceBlendshapes:[],poseLandmarks:[],poseWorldLandmarks:[],poseSegmentationMasks:[],leftHandLandmarks:[],leftHandWorldLandmarks:[],rightHandLandmarks:[],rightHandWorldLandmarks:[]},this.outputPoseSegmentationMasks=this.outputFaceBlendshapes=!1,n0(x=this.j=new gB,0,1,e=new Ux),this.J=new aM,n0(this.j,0,2,this.J),this.Z=new Yee,n0(this.j,0,3,this.Z),this.s=new av,n0(this.j,0,4,this.s),this.H=new sB,n0(this.j,0,5,this.H),this.v=new mB,n0(this.j,0,6,this.v),this.K=new yB,n0(this.j,0,7,this.K),$t(this.s,2,.5),$t(this.s,3,.3),$t(this.H,2,.5),$t(this.v,2,.5),$t(this.v,3,.3),$t(this.K,2,.5),$t(this.J,2,.5)}get baseOptions(){return G0(this.j,Ux,1)}set baseOptions(x){n0(this.j,0,1,x)}o(x){var e,t,n,i,r,a,s;return"minFaceDetectionConfidence"in x&&$t(this.s,2,(e=x.minFaceDetectionConfidence)!=null?e:.5),"minFaceSuppressionThreshold"in x&&$t(this.s,3,(t=x.minFaceSuppressionThreshold)!=null?t:.3),"minFacePresenceConfidence"in x&&$t(this.H,2,(n=x.minFacePresenceConfidence)!=null?n:.5),"outputFaceBlendshapes"in x&&(this.outputFaceBlendshapes=!!x.outputFaceBlendshapes),"minPoseDetectionConfidence"in x&&$t(this.v,2,(i=x.minPoseDetectionConfidence)!=null?i:.5),"minPoseSuppressionThreshold"in x&&$t(this.v,3,(r=x.minPoseSuppressionThreshold)!=null?r:.3),"minPosePresenceConfidence"in x&&$t(this.K,2,(a=x.minPosePresenceConfidence)!=null?a:.5),"outputPoseSegmentationMasks"in x&&(this.outputPoseSegmentationMasks=!!x.outputPoseSegmentationMasks),"minHandLandmarksConfidence"in x&&$t(this.J,2,(s=x.minHandLandmarksConfidence)!=null?s:.5),this.l(x)}D(x,e,t){const n=typeof e!="function"?e:{};return this.C=typeof e=="function"?e:t,vO(this),Ea(this,x,n),bO(this)}F(x,e,t,n){const i=typeof t!="function"?t:{};return this.C=typeof t=="function"?t:n,vO(this),Ds(this,x,i,e),bO(this)}m(){var x=new xr;Mx(x,"input_frames_image"),X0(x,"pose_landmarks"),X0(x,"pose_world_landmarks"),X0(x,"face_landmarks"),X0(x,"left_hand_landmarks"),X0(x,"left_hand_world_landmarks"),X0(x,"right_hand_landmarks"),X0(x,"right_hand_world_landmarks");const e=new Pr,t=new XI;BT(t,1,ad("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"),""),function(i,r){if(r!=null)if(Array.isArray(r))wx(i,2,f4(r));else{if(!(typeof r=="string"||r instanceof Po||wp(r)))throw Error("invalid value in Any.value field: "+r+" expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");BT(i,2,wE(r,!1),Rc())}}(t,this.j.g());const n=new Mi;Vr(n,"mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"),X1(n,8,XI,t),Ax(n,"IMAGE:input_frames_image"),k0(n,"POSE_LANDMARKS:pose_landmarks"),k0(n,"POSE_WORLD_LANDMARKS:pose_world_landmarks"),k0(n,"FACE_LANDMARKS:face_landmarks"),k0(n,"LEFT_HAND_LANDMARKS:left_hand_landmarks"),k0(n,"LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"),k0(n,"RIGHT_HAND_LANDMARKS:right_hand_landmarks"),k0(n,"RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"),n.o(e),Hr(x,n),ov(this,x),this.g.attachProtoListener("pose_landmarks",(i,r)=>{$m(i,this.h.poseLandmarks),kt(this,r)}),this.g.attachEmptyPacketListener("pose_landmarks",i=>{kt(this,i)}),this.g.attachProtoListener("pose_world_landmarks",(i,r)=>{var a=this.h.poseWorldLandmarks;i=hh(i),a.push(Uf(i)),kt(this,r)}),this.g.attachEmptyPacketListener("pose_world_landmarks",i=>{kt(this,i)}),this.outputPoseSegmentationMasks&&(k0(n,"POSE_SEGMENTATION_MASK:pose_segmentation_mask"),Uh(this,"pose_segmentation_mask"),this.g.U("pose_segmentation_mask",(i,r)=>{this.h.poseSegmentationMasks=[Lh(this,i,!0,!this.C)],kt(this,r)}),this.g.attachEmptyPacketListener("pose_segmentation_mask",i=>{this.h.poseSegmentationMasks=[],kt(this,i)})),this.g.attachProtoListener("face_landmarks",(i,r)=>{$m(i,this.h.faceLandmarks),kt(this,r)}),this.g.attachEmptyPacketListener("face_landmarks",i=>{kt(this,i)}),this.outputFaceBlendshapes&&(X0(x,"extra_blendshapes"),k0(n,"FACE_BLENDSHAPES:extra_blendshapes"),this.g.attachProtoListener("extra_blendshapes",(i,r)=>{var a,s=this.h.faceBlendshapes;this.outputFaceBlendshapes&&(i=rv(i),s.push(uM((a=i.g())!=null?a:[]))),kt(this,r)}),this.g.attachEmptyPacketListener("extra_blendshapes",i=>{kt(this,i)})),this.g.attachProtoListener("left_hand_landmarks",(i,r)=>{$m(i,this.h.leftHandLandmarks),kt(this,r)}),this.g.attachEmptyPacketListener("left_hand_landmarks",i=>{kt(this,i)}),this.g.attachProtoListener("left_hand_world_landmarks",(i,r)=>{var a=this.h.leftHandWorldLandmarks;i=hh(i),a.push(Uf(i)),kt(this,r)}),this.g.attachEmptyPacketListener("left_hand_world_landmarks",i=>{kt(this,i)}),this.g.attachProtoListener("right_hand_landmarks",(i,r)=>{$m(i,this.h.rightHandLandmarks),kt(this,r)}),this.g.attachEmptyPacketListener("right_hand_landmarks",i=>{kt(this,i)}),this.g.attachProtoListener("right_hand_world_landmarks",(i,r)=>{var a=this.h.rightHandWorldLandmarks;i=hh(i),a.push(Uf(i)),kt(this,r)}),this.g.attachEmptyPacketListener("right_hand_world_landmarks",i=>{kt(this,i)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};Ox.prototype.detectForVideo=Ox.prototype.F,Ox.prototype.detect=Ox.prototype.D,Ox.prototype.setOptions=Ox.prototype.o,Ox.createFromModelPath=function(x,e){return O0(Ox,x,{baseOptions:{modelAssetPath:e}})},Ox.createFromModelBuffer=function(x,e){return O0(Ox,x,{baseOptions:{modelAssetBuffer:e}})},Ox.createFromOptions=function(x,e){return O0(Ox,x,e)},Ox.HAND_CONNECTIONS=TM,Ox.POSE_CONNECTIONS=BB,Ox.FACE_LANDMARKS_LIPS=yM,Ox.FACE_LANDMARKS_LEFT_EYE=gM,Ox.FACE_LANDMARKS_LEFT_EYEBROW=vM,Ox.FACE_LANDMARKS_LEFT_IRIS=PB,Ox.FACE_LANDMARKS_RIGHT_EYE=bM,Ox.FACE_LANDMARKS_RIGHT_EYEBROW=_M,Ox.FACE_LANDMARKS_RIGHT_IRIS=kB,Ox.FACE_LANDMARKS_FACE_OVAL=SM,Ox.FACE_LANDMARKS_CONTOURS=UB,Ox.FACE_LANDMARKS_TESSELATION=FB;var ia=class extends tr{constructor(x,e){super(new Aa(x,e),"input_image","norm_rect",!0),this.j={classifications:[]},n0(x=this.h=new vB,0,1,e=new Ux)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){return n0(this.h,0,2,YT(x,G0(this.h,nM,2))),this.l(x)}sa(x,e){return this.j={classifications:[]},Ea(this,x,e),this.j}ta(x,e,t){return this.j={classifications:[]},Ds(this,x,t,e),this.j}m(){var x=new xr;Mx(x,"input_image"),Mx(x,"norm_rect"),X0(x,"classifications");const e=new Pr;qa(e,Kee,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"),Ax(t,"IMAGE:input_image"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"CLASSIFICATIONS:classifications"),t.o(e),Hr(x,t),this.g.attachProtoListener("classifications",(n,i)=>{this.j=function(r){var a;const s={classifications:Bo(r,Dee,1).map(l=>{var c,h,d,p;return uM((h=(c=G0(l,j4,4))==null?void 0:c.g())!=null?h:[],(d=ya(l,2))!=null?d:0,(p=Ta(l,3))!=null?p:"")})};return W1(Ph(r,2))!=null&&(s.timestampMs=(a=W1(Ph(r,2)))!=null?a:0),s}(Pee(n)),kt(this,i)}),this.g.attachEmptyPacketListener("classifications",n=>{kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};ia.prototype.classifyForVideo=ia.prototype.ta,ia.prototype.classify=ia.prototype.sa,ia.prototype.setOptions=ia.prototype.o,ia.createFromModelPath=function(x,e){return O0(ia,x,{baseOptions:{modelAssetPath:e}})},ia.createFromModelBuffer=function(x,e){return O0(ia,x,{baseOptions:{modelAssetBuffer:e}})},ia.createFromOptions=function(x,e){return O0(ia,x,e)};var yr=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect",!0),this.h=new bB,this.embeddings={embeddings:[]},n0(x=this.h,0,1,e=new Ux)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){var e=this.h,t=G0(this.h,jI,2);return t=t?t.clone():new jI,x.l2Normalize!==void 0?jf(t,1,x.l2Normalize):"l2Normalize"in x&&wx(t,1),x.quantize!==void 0?jf(t,2,x.quantize):"quantize"in x&&wx(t,2),n0(e,0,2,t),this.l(x)}za(x,e){return Ea(this,x,e),this.embeddings}Aa(x,e,t){return Ds(this,x,t,e),this.embeddings}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect"),X0(x,"embeddings_out");const e=new Pr;qa(e,$ee,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"EMBEDDINGS:embeddings_out"),t.o(e),Hr(x,t),this.g.attachProtoListener("embeddings_out",(n,i)=>{n=Fee(n),this.embeddings=function(r){var a;return{embeddings:Bo(r,Uee,1).map(s=>{var l,c,h,d,p,m,g;const _={headIndex:(c=(l=ya(s,3))!=null?l:0)!=null?c:-1,headName:(d=(h=Ta(s,4))!=null?h:"")!=null?d:""};if(v4(s,JI,P_(s,1))!==void 0)s=oc(s=G0(s,JI,P_(s,1)),1,dl,sc()),_.floatEmbedding=s.slice();else{const v=new Uint8Array(0);_.quantizedEmbedding=(g=(m=(p=G0(s,kee,P_(s,2)))==null?void 0:p.oa())==null?void 0:m.h())!=null?g:v}return _}),timestampMs:(a=W1(Ph(r,2)))!=null?a:0}}(n),kt(this,i)}),this.g.attachEmptyPacketListener("embeddings_out",n=>{kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};yr.cosineSimilarity=function(x,e){if(x.floatEmbedding&&e.floatEmbedding)x=nO(x.floatEmbedding,e.floatEmbedding);else{if(!x.quantizedEmbedding||!e.quantizedEmbedding)throw Error("Cannot compute cosine similarity between quantized and float embeddings.");x=nO(xO(x.quantizedEmbedding),xO(e.quantizedEmbedding))}return x},yr.prototype.embedForVideo=yr.prototype.Aa,yr.prototype.embed=yr.prototype.za,yr.prototype.setOptions=yr.prototype.o,yr.createFromModelPath=function(x,e){return O0(yr,x,{baseOptions:{modelAssetPath:e}})},yr.createFromModelBuffer=function(x,e){return O0(yr,x,{baseOptions:{modelAssetBuffer:e}})},yr.createFromOptions=function(x,e){return O0(yr,x,e)};var QT=class{constructor(x,e,t){this.confidenceMasks=x,this.categoryMask=e,this.qualityScores=t}close(){var x,e;(x=this.confidenceMasks)==null||x.forEach(t=>{t.close()}),(e=this.categoryMask)==null||e.close()}};function _O(x){x.categoryMask=void 0,x.confidenceMasks=void 0,x.qualityScores=void 0}function SO(x){try{const e=new QT(x.confidenceMasks,x.categoryMask,x.qualityScores);if(!x.j)return e;x.j(e)}finally{lv(x)}}QT.prototype.close=QT.prototype.close;var Gi=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect",!1),this.s=[],this.outputCategoryMask=!1,this.outputConfidenceMasks=!0,this.h=new cM,this.v=new _B,n0(this.h,0,3,this.v),n0(x=this.h,0,1,e=new Ux)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){var e,t;return x.displayNamesLocale!==void 0?wx(this.h,2,ad(x.displayNamesLocale)):"displayNamesLocale"in x&&wx(this.h,2),"outputCategoryMask"in x&&(this.outputCategoryMask=(e=x.outputCategoryMask)!=null?e:!1),"outputConfidenceMasks"in x&&(this.outputConfidenceMasks=(t=x.outputConfidenceMasks)!=null?t:!0),super.l(x)}I(){(function(x){var e,t,n;const i=Bo(x.da(),Mi,1).filter(r=>{var a;return((a=Ta(r,1))!=null?a:"").includes("mediapipe.tasks.TensorsToSegmentationCalculator")});if(x.s=[],i.length>1)throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");i.length===1&&((n=(t=(e=G0(i[0],Pr,7))==null?void 0:e.l())==null?void 0:t.g())!=null?n:new Map).forEach((r,a)=>{var s;x.s[Number(a)]=(s=Ta(r,1))!=null?s:""})})(this)}segment(x,e,t){const n=typeof e!="function"?e:{};return this.j=typeof e=="function"?e:t,_O(this),Ea(this,x,n),SO(this)}Ma(x,e,t,n){const i=typeof t!="function"?t:{};return this.j=typeof t=="function"?t:n,_O(this),Ds(this,x,i,e),SO(this)}Da(){return this.s}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect");const e=new Pr;qa(e,TB,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect"),t.o(e),Hr(x,t),ov(this,x),this.outputConfidenceMasks&&(X0(x,"confidence_masks"),k0(t,"CONFIDENCE_MASKS:confidence_masks"),Uh(this,"confidence_masks"),this.g.ca("confidence_masks",(n,i)=>{this.confidenceMasks=n.map(r=>Lh(this,r,!0,!this.j)),kt(this,i)}),this.g.attachEmptyPacketListener("confidence_masks",n=>{this.confidenceMasks=[],kt(this,n)})),this.outputCategoryMask&&(X0(x,"category_mask"),k0(t,"CATEGORY_MASK:category_mask"),Uh(this,"category_mask"),this.g.U("category_mask",(n,i)=>{this.categoryMask=Lh(this,n,!1,!this.j),kt(this,i)}),this.g.attachEmptyPacketListener("category_mask",n=>{this.categoryMask=void 0,kt(this,n)})),X0(x,"quality_scores"),k0(t,"QUALITY_SCORES:quality_scores"),this.g.attachFloatVectorListener("quality_scores",(n,i)=>{this.qualityScores=n,kt(this,i)}),this.g.attachEmptyPacketListener("quality_scores",n=>{this.categoryMask=void 0,kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};Gi.prototype.getLabels=Gi.prototype.Da,Gi.prototype.segmentForVideo=Gi.prototype.Ma,Gi.prototype.segment=Gi.prototype.segment,Gi.prototype.setOptions=Gi.prototype.o,Gi.createFromModelPath=function(x,e){return O0(Gi,x,{baseOptions:{modelAssetPath:e}})},Gi.createFromModelBuffer=function(x,e){return O0(Gi,x,{baseOptions:{modelAssetBuffer:e}})},Gi.createFromOptions=function(x,e){return O0(Gi,x,e)};var ZT=class{constructor(x,e,t){this.confidenceMasks=x,this.categoryMask=e,this.qualityScores=t}close(){var x,e;(x=this.confidenceMasks)==null||x.forEach(t=>{t.close()}),(e=this.categoryMask)==null||e.close()}};ZT.prototype.close=ZT.prototype.close;var tte=class extends Yt{constructor(x){super(x)}},yu=[0,Qx,-2],Q1=[0,So,-3,Px,So,-1],TO=[0,Q1],wO=[0,Q1,Qx,-1],L_=class extends Yt{constructor(x){super(x)}},AO=[0,So,-1,Px],xte=class extends Yt{constructor(x){super(x)}},EO=class extends Yt{constructor(x){super(x)}},JT=[1,2,3,4,5,6,7,8,9,10,14,15],LB=class extends Yt{constructor(x){super(x)}};LB.prototype.g=iv([0,Mn,[0,JT,rx,Q1,rx,[0,Q1,yu],rx,TO,rx,[0,TO,yu],rx,AO,rx,[0,So,-3,Px,wa],rx,[0,So,-3,Px],rx,[0,j0,So,-2,Px,Qx,Px,-1,2,So,yu],rx,wO,rx,[0,wO,yu],So,yu,j0,rx,[0,So,-3,Px,yu,-1],rx,[0,Mn,AO]],j0,[0,j0,Qx,-1,Px]]);var vs=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect_in",!1),this.outputCategoryMask=!1,this.outputConfidenceMasks=!0,this.h=new cM,this.s=new _B,n0(this.h,0,3,this.s),n0(x=this.h,0,1,e=new Ux)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){var e,t;return"outputCategoryMask"in x&&(this.outputCategoryMask=(e=x.outputCategoryMask)!=null?e:!1),"outputConfidenceMasks"in x&&(this.outputConfidenceMasks=(t=x.outputConfidenceMasks)!=null?t:!0),super.l(x)}segment(x,e,t,n){const i=typeof t!="function"?t:{};this.j=typeof t=="function"?t:n,this.qualityScores=this.categoryMask=this.confidenceMasks=void 0,t=this.B+1,n=new LB;const r=new EO;var a=new tte;if(Cs(a,1,255),n0(r,0,12,a),e.keypoint&&e.scribble)throw Error("Cannot provide both keypoint and scribble.");if(e.keypoint){var s=new L_;jf(s,3,!0),$t(s,1,e.keypoint.x),$t(s,2,e.keypoint.y),Pf(r,5,JT,s)}else{if(!e.scribble)throw Error("Must provide either a keypoint or a scribble.");for(s of(a=new xte,e.scribble))jf(e=new L_,3,!0),$t(e,1,s.x),$t(e,2,s.y),X1(a,1,L_,e);Pf(r,15,JT,a)}X1(n,1,EO,r),this.g.addProtoToStream(n.g(),"drishti.RenderData","roi_in",t),Ea(this,x,i);e:{try{const c=new ZT(this.confidenceMasks,this.categoryMask,this.qualityScores);if(!this.j){var l=c;break e}this.j(c)}finally{lv(this)}l=void 0}return l}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"roi_in"),Mx(x,"norm_rect_in");const e=new Pr;qa(e,TB,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"ROI:roi_in"),Ax(t,"NORM_RECT:norm_rect_in"),t.o(e),Hr(x,t),ov(this,x),this.outputConfidenceMasks&&(X0(x,"confidence_masks"),k0(t,"CONFIDENCE_MASKS:confidence_masks"),Uh(this,"confidence_masks"),this.g.ca("confidence_masks",(n,i)=>{this.confidenceMasks=n.map(r=>Lh(this,r,!0,!this.j)),kt(this,i)}),this.g.attachEmptyPacketListener("confidence_masks",n=>{this.confidenceMasks=[],kt(this,n)})),this.outputCategoryMask&&(X0(x,"category_mask"),k0(t,"CATEGORY_MASK:category_mask"),Uh(this,"category_mask"),this.g.U("category_mask",(n,i)=>{this.categoryMask=Lh(this,n,!1,!this.j),kt(this,i)}),this.g.attachEmptyPacketListener("category_mask",n=>{this.categoryMask=void 0,kt(this,n)})),X0(x,"quality_scores"),k0(t,"QUALITY_SCORES:quality_scores"),this.g.attachFloatVectorListener("quality_scores",(n,i)=>{this.qualityScores=n,kt(this,i)}),this.g.attachEmptyPacketListener("quality_scores",n=>{this.categoryMask=void 0,kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};vs.prototype.segment=vs.prototype.segment,vs.prototype.setOptions=vs.prototype.o,vs.createFromModelPath=function(x,e){return O0(vs,x,{baseOptions:{modelAssetPath:e}})},vs.createFromModelBuffer=function(x,e){return O0(vs,x,{baseOptions:{modelAssetBuffer:e}})},vs.createFromOptions=function(x,e){return O0(vs,x,e)};var ra=class extends tr{constructor(x,e){super(new Aa(x,e),"input_frame_gpu","norm_rect",!1),this.j={detections:[]},n0(x=this.h=new wB,0,1,e=new Ux)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){return x.displayNamesLocale!==void 0?wx(this.h,2,ad(x.displayNamesLocale)):"displayNamesLocale"in x&&wx(this.h,2),x.maxResults!==void 0?Cs(this.h,3,x.maxResults):"maxResults"in x&&wx(this.h,3),x.scoreThreshold!==void 0?$t(this.h,4,x.scoreThreshold):"scoreThreshold"in x&&wx(this.h,4),x.categoryAllowlist!==void 0?Y1(this.h,5,x.categoryAllowlist):"categoryAllowlist"in x&&wx(this.h,5),x.categoryDenylist!==void 0?Y1(this.h,6,x.categoryDenylist):"categoryDenylist"in x&&wx(this.h,6),this.l(x)}D(x,e){return this.j={detections:[]},Ea(this,x,e),this.j}F(x,e,t){return this.j={detections:[]},Ds(this,x,t,e),this.j}m(){var x=new xr;Mx(x,"input_frame_gpu"),Mx(x,"norm_rect"),X0(x,"detections");const e=new Pr;qa(e,Zee,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.ObjectDetectorGraph"),Ax(t,"IMAGE:input_frame_gpu"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"DETECTIONS:detections"),t.o(e),Hr(x,t),this.g.attachProtoVectorListener("detections",(n,i)=>{for(const r of n)n=eB(r),this.j.detections.push(EB(n));kt(this,i)}),this.g.attachEmptyPacketListener("detections",n=>{kt(this,n)}),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};ra.prototype.detectForVideo=ra.prototype.F,ra.prototype.detect=ra.prototype.D,ra.prototype.setOptions=ra.prototype.o,ra.createFromModelPath=async function(x,e){return O0(ra,x,{baseOptions:{modelAssetPath:e}})},ra.createFromModelBuffer=function(x,e){return O0(ra,x,{baseOptions:{modelAssetBuffer:e}})},ra.createFromOptions=function(x,e){return O0(ra,x,e)};var jT=class{constructor(x,e,t){this.landmarks=x,this.worldLandmarks=e,this.segmentationMasks=t}close(){var x;(x=this.segmentationMasks)==null||x.forEach(e=>{e.close()})}};function MO(x){x.landmarks=[],x.worldLandmarks=[],x.segmentationMasks=void 0}function RO(x){try{const e=new jT(x.landmarks,x.worldLandmarks,x.segmentationMasks);if(!x.s)return e;x.s(e)}finally{lv(x)}}jT.prototype.close=jT.prototype.close;var gr=class extends tr{constructor(x,e){super(new Aa(x,e),"image_in","norm_rect",!1),this.landmarks=[],this.worldLandmarks=[],this.outputSegmentationMasks=!1,n0(x=this.h=new AB,0,1,e=new Ux),this.v=new yB,n0(this.h,0,3,this.v),this.j=new mB,n0(this.h,0,2,this.j),Cs(this.j,4,1),$t(this.j,2,.5),$t(this.v,2,.5),$t(this.h,4,.5)}get baseOptions(){return G0(this.h,Ux,1)}set baseOptions(x){n0(this.h,0,1,x)}o(x){var e,t,n,i,r;return"numPoses"in x&&Cs(this.j,4,(e=x.numPoses)!=null?e:1),"minPoseDetectionConfidence"in x&&$t(this.j,2,(t=x.minPoseDetectionConfidence)!=null?t:.5),"minTrackingConfidence"in x&&$t(this.h,4,(n=x.minTrackingConfidence)!=null?n:.5),"minPosePresenceConfidence"in x&&$t(this.v,2,(i=x.minPosePresenceConfidence)!=null?i:.5),"outputSegmentationMasks"in x&&(this.outputSegmentationMasks=(r=x.outputSegmentationMasks)!=null?r:!1),this.l(x)}D(x,e,t){const n=typeof e!="function"?e:{};return this.s=typeof e=="function"?e:t,MO(this),Ea(this,x,n),RO(this)}F(x,e,t,n){const i=typeof t!="function"?t:{};return this.s=typeof t=="function"?t:n,MO(this),Ds(this,x,i,e),RO(this)}m(){var x=new xr;Mx(x,"image_in"),Mx(x,"norm_rect"),X0(x,"normalized_landmarks"),X0(x,"world_landmarks"),X0(x,"segmentation_masks");const e=new Pr;qa(e,Jee,this.h);const t=new Mi;Vr(t,"mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"),Ax(t,"IMAGE:image_in"),Ax(t,"NORM_RECT:norm_rect"),k0(t,"NORM_LANDMARKS:normalized_landmarks"),k0(t,"WORLD_LANDMARKS:world_landmarks"),t.o(e),Hr(x,t),ov(this,x),this.g.attachProtoVectorListener("normalized_landmarks",(n,i)=>{this.landmarks=[];for(const r of n)n=Rp(r),this.landmarks.push(sv(n));kt(this,i)}),this.g.attachEmptyPacketListener("normalized_landmarks",n=>{this.landmarks=[],kt(this,n)}),this.g.attachProtoVectorListener("world_landmarks",(n,i)=>{this.worldLandmarks=[];for(const r of n)n=hh(r),this.worldLandmarks.push(Uf(n));kt(this,i)}),this.g.attachEmptyPacketListener("world_landmarks",n=>{this.worldLandmarks=[],kt(this,n)}),this.outputSegmentationMasks&&(k0(t,"SEGMENTATION_MASK:segmentation_masks"),Uh(this,"segmentation_masks"),this.g.ca("segmentation_masks",(n,i)=>{this.segmentationMasks=n.map(r=>Lh(this,r,!0,!this.s)),kt(this,i)}),this.g.attachEmptyPacketListener("segmentation_masks",n=>{this.segmentationMasks=[],kt(this,n)})),x=x.g(),this.setGraph(new Uint8Array(x),!0)}};gr.prototype.detectForVideo=gr.prototype.F,gr.prototype.detect=gr.prototype.D,gr.prototype.setOptions=gr.prototype.o,gr.createFromModelPath=function(x,e){return O0(gr,x,{baseOptions:{modelAssetPath:e}})},gr.createFromModelBuffer=function(x,e){return O0(gr,x,{baseOptions:{modelAssetBuffer:e}})},gr.createFromOptions=function(x,e){return O0(gr,x,e)},gr.POSE_CONNECTIONS=BB;var Qm={exports:{}},CO;function nte(){if(CO)return Qm.exports;CO=1;var x=typeof Reflect=="object"?Reflect:null,e=x&&typeof x.apply=="function"?x.apply:function(M,R,C){return Function.prototype.apply.call(M,R,C)},t;x&&typeof x.ownKeys=="function"?t=x.ownKeys:Object.getOwnPropertySymbols?t=function(M){return Object.getOwnPropertyNames(M).concat(Object.getOwnPropertySymbols(M))}:t=function(M){return Object.getOwnPropertyNames(M)};function n(A){console&&console.warn&&console.warn(A)}var i=Number.isNaN||function(M){return M!==M};function r(){r.init.call(this)}Qm.exports=r,Qm.exports.once=b,r.EventEmitter=r,r.prototype._events=void 0,r.prototype._eventsCount=0,r.prototype._maxListeners=void 0;var a=10;function s(A){if(typeof A!="function")throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof A)}Object.defineProperty(r,"defaultMaxListeners",{enumerable:!0,get:function(){return a},set:function(A){if(typeof A!="number"||A<0||i(A))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+A+".");a=A}}),r.init=function(){(this._events===void 0||this._events===Object.getPrototypeOf(this)._events)&&(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},r.prototype.setMaxListeners=function(M){if(typeof M!="number"||M<0||i(M))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+M+".");return this._maxListeners=M,this};function l(A){return A._maxListeners===void 0?r.defaultMaxListeners:A._maxListeners}r.prototype.getMaxListeners=function(){return l(this)},r.prototype.emit=function(M){for(var R=[],C=1;C<arguments.length;C++)R.push(arguments[C]);var k=M==="error",P=this._events;if(P!==void 0)k=k&&P.error===void 0;else if(!k)return!1;if(k){var N;if(R.length>0&&(N=R[0]),N instanceof Error)throw N;var G=new Error("Unhandled error."+(N?" ("+N.message+")":""));throw G.context=N,G}var te=P[M];if(te===void 0)return!1;if(typeof te=="function")e(te,this,R);else for(var j=te.length,xe=g(te,j),C=0;C<j;++C)e(xe[C],this,R);return!0};function c(A,M,R,C){var k,P,N;if(s(R),P=A._events,P===void 0?(P=A._events=Object.create(null),A._eventsCount=0):(P.newListener!==void 0&&(A.emit("newListener",M,R.listener?R.listener:R),P=A._events),N=P[M]),N===void 0)N=P[M]=R,++A._eventsCount;else if(typeof N=="function"?N=P[M]=C?[R,N]:[N,R]:C?N.unshift(R):N.push(R),k=l(A),k>0&&N.length>k&&!N.warned){N.warned=!0;var G=new Error("Possible EventEmitter memory leak detected. "+N.length+" "+String(M)+" listeners added. Use emitter.setMaxListeners() to increase limit");G.name="MaxListenersExceededWarning",G.emitter=A,G.type=M,G.count=N.length,n(G)}return A}r.prototype.addListener=function(M,R){return c(this,M,R,!1)},r.prototype.on=r.prototype.addListener,r.prototype.prependListener=function(M,R){return c(this,M,R,!0)};function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length===0?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function d(A,M,R){var C={fired:!1,wrapFn:void 0,target:A,type:M,listener:R},k=h.bind(C);return k.listener=R,C.wrapFn=k,k}r.prototype.once=function(M,R){return s(R),this.on(M,d(this,M,R)),this},r.prototype.prependOnceListener=function(M,R){return s(R),this.prependListener(M,d(this,M,R)),this},r.prototype.removeListener=function(M,R){var C,k,P,N,G;if(s(R),k=this._events,k===void 0)return this;if(C=k[M],C===void 0)return this;if(C===R||C.listener===R)--this._eventsCount===0?this._events=Object.create(null):(delete k[M],k.removeListener&&this.emit("removeListener",M,C.listener||R));else if(typeof C!="function"){for(P=-1,N=C.length-1;N>=0;N--)if(C[N]===R||C[N].listener===R){G=C[N].listener,P=N;break}if(P<0)return this;P===0?C.shift():_(C,P),C.length===1&&(k[M]=C[0]),k.removeListener!==void 0&&this.emit("removeListener",M,G||R)}return this},r.prototype.off=r.prototype.removeListener,r.prototype.removeAllListeners=function(M){var R,C,k;if(C=this._events,C===void 0)return this;if(C.removeListener===void 0)return arguments.length===0?(this._events=Object.create(null),this._eventsCount=0):C[M]!==void 0&&(--this._eventsCount===0?this._events=Object.create(null):delete C[M]),this;if(arguments.length===0){var P=Object.keys(C),N;for(k=0;k<P.length;++k)N=P[k],N!=="removeListener"&&this.removeAllListeners(N);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if(R=C[M],typeof R=="function")this.removeListener(M,R);else if(R!==void 0)for(k=R.length-1;k>=0;k--)this.removeListener(M,R[k]);return this};function p(A,M,R){var C=A._events;if(C===void 0)return[];var k=C[M];return k===void 0?[]:typeof k=="function"?R?[k.listener||k]:[k]:R?v(k):g(k,k.length)}r.prototype.listeners=function(M){return p(this,M,!0)},r.prototype.rawListeners=function(M){return p(this,M,!1)},r.listenerCount=function(A,M){return typeof A.listenerCount=="function"?A.listenerCount(M):m.call(A,M)},r.prototype.listenerCount=m;function m(A){var M=this._events;if(M!==void 0){var R=M[A];if(typeof R=="function")return 1;if(R!==void 0)return R.length}return 0}r.prototype.eventNames=function(){return this._eventsCount>0?t(this._events):[]};function g(A,M){for(var R=new Array(M),C=0;C<M;++C)R[C]=A[C];return R}function _(A,M){for(;M+1<A.length;M++)A[M]=A[M+1];A.pop()}function v(A){for(var M=new Array(A.length),R=0;R<M.length;++R)M[R]=A[R].listener||A[R];return M}function b(A,M){return new Promise(function(R,C){function k(N){A.removeListener(M,P),C(N)}function P(){typeof A.removeListener=="function"&&A.removeListener("error",k),R([].slice.call(arguments))}E(A,M,P,{once:!0}),M!=="error"&&T(A,k,{once:!0})})}function T(A,M,R){typeof A.on=="function"&&E(A,"error",M,R)}function E(A,M,R,C){if(typeof A.on=="function")C.once?A.once(M,R):A.on(M,R);else if(typeof A.addEventListener=="function")A.addEventListener(M,function k(P){C.once&&A.removeEventListener(M,k),R(P)});else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof A)}return Qm.exports}var ite=nte();class Cp extends ite.EventEmitter{}var rte=Object.defineProperty,NO=Object.getOwnPropertySymbols,ate=Object.prototype.hasOwnProperty,ste=Object.prototype.propertyIsEnumerable,IO=(x,e,t)=>e in x?rte(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,ote=(x,e)=>{for(var t in e||(e={}))ate.call(e,t)&&IO(x,t,e[t]);if(NO)for(var t of NO(e))ste.call(e,t)&&IO(x,t,e[t]);return x};let zB=class{constructor(e="canvas"){this.size={width:0,height:0},this.transpose=!1,this.context=null,this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.capture."+e,this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}capture(e){const{context:t,clipPix:n,transpose:i}=this;if(!t)return!1;let{width:r,height:a}=this.size;return i&&([r,a]=[a,r]),i&&t.setTransform(0,1,1,0,0,0),n?t.drawImage(e,n.left,n.top,n.width,n.height,0,0,r,a):t.drawImage(e,0,0,r,a),i&&t.resetTransform(),!0}fill(){const{context:e}=this;if(!e)return;let{width:t,height:n}=this.size;e.fillStyle="rgba(255, 255, 255, 1)",e.fillRect(0,0,t,n)}data(){const{context:e}=this;if(!e)return;const{width:t,height:n}=this.size;return e.getImageData(0,0,t,n)}setSize(e){let{width:t,height:n}=e;this.transpose&&([t,n]=[n,t]),this.size={width:t,height:n},this.canvas.width=t,this.canvas.height=n,this.setClip(this.clip)}setClip(e){let{width:t,height:n}=this.size;this.transpose&&([t,n]=[n,t]),this.clip=e,this.clipPix=e&&{left:e.left*t,top:e.top*n,width:e.width*t,height:e.height*n}}setTranspose(e){if(e==this.transpose)return;let{width:t,height:n}=this.size;this.transpose&&([t,n]=[n,t]),this.transpose=e,this.setSize({width:t,height:n})}dispose(){this.context=null,this.canvas.remove()}};class lte extends Cp{constructor(){super(),this.buffer=new zB("capture"),this.captureTime=0}async setup(e){delete this.sizeMax,delete this.aspectRatio,delete this.clipRect,delete this.transpose;const t=(i=>i!==void 0&&typeof i!="string"&&"size"in i)(e)?e:void 0,n=(t==null?void 0:t.size)||{width:1920,height:1080};return t&&(this.aspectRatio=t.ratio,this.clipRect=t.clip,this.transpose=t.transpose),this.updateSize(n),this.buffer.fill(),!0}dispose(){this.reset(),this.buffer.dispose()}async start(){this.captureTime=0,this.timer=Date.now()}pause(){}reset(){this.pause(),delete this.timer}capture(){return this.timer===void 0?!1:(this.captureTime=(Date.now()-this.timer)*1e3,!0)}size(){return ote({},this.buffer.size)}ratio(){const e=this.buffer.size;return e.width/e.height}updateSize(e){let{width:t,height:n}=e,{sizeMax:i,aspectRatio:r,clipRect:a,transpose:s}=this;if(i&&(t>i||n>i)){const c=t/n;c>1?(t=i,n=i/c):(n=i,t=c*i),e={width:t,height:n}}const l=t/n;r&&l>r?(a={left:.5*(l/r-1),top:0,width:1,height:1},t=n*r,e={width:t,height:n}):r&&l<r&&(a={top:.5*(r/l-1),left:0,width:1,height:1},n=t/r,e={width:t,height:n}),this.buffer.setSize(e),this.buffer.setClip(a),this.buffer.setTranspose(!!s),this.emit("resize",this.buffer.size)}}var cte=Object.defineProperty,Z1=Object.getOwnPropertySymbols,VB=Object.prototype.hasOwnProperty,HB=Object.prototype.propertyIsEnumerable,OO=(x,e,t)=>e in x?cte(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,DO=(x,e)=>{for(var t in e||(e={}))VB.call(e,t)&&OO(x,t,e[t]);if(Z1)for(var t of Z1(e))HB.call(e,t)&&OO(x,t,e[t]);return x},ute=(x,e)=>{var t={};for(var n in x)VB.call(x,n)&&e.indexOf(n)<0&&(t[n]=x[n]);if(x!=null&&Z1)for(var n of Z1(x))e.indexOf(n)<0&&HB.call(x,n)&&(t[n]=x[n]);return t};class GB extends lte{constructor(){super(),this.timeShift=0,this.videoRef=document.createElement("video"),this.videoRef.id="engeenee.capture.source",this.videoRef.muted=!0,this.videoRef.loop=!0,this.videoRef.playsInline=!0}async setup(e){const t=l=>typeof l=="string"||"url"in l&&typeof l.url=="string",n=l=>t(l)||"getVideoTracks"in l,i=l=>t(l)&&typeof l!="string"?(this.sizeMax=l.sizeMax,l.url):l,r=l=>{var c,h;if(!l)return{video:!0,audio:!1};this.aspectRatio=l.ratio,this.clipRect=l.clip,this.transpose=l.transpose;const d=l.opts||{},{video:p}=d,m=ute(d,["video"]);return DO({video:DO({facingMode:l.rear===void 0?void 0:l.rear?"environment":"user",width:(c=l.size)==null?void 0:c.width,height:(h=l.size)==null?void 0:h.height,frameRate:l.fps},p instanceof Object?p:{}),audio:!1},m)};delete this.sizeMax,delete this.aspectRatio,delete this.clipRect,delete this.transpose;const a=e!==void 0&&n(e)?i(e):await navigator.mediaDevices.getUserMedia(r(e)).catch(()=>{});if(!a)return!1;const{videoRef:s}=this;return new Promise(l=>{s.onloadedmetadata=()=>{this.updateSize({width:s.videoWidth,height:s.videoHeight}),s.onresize=()=>{this.updateSize({width:s.videoWidth,height:s.videoHeight})},s.onseeked=()=>{this.timeShift=this.captureTime,this.captureTime=0},l(!0)},typeof a=="string"?s.src=a:s.srcObject=a})}dispose(){super.dispose(),this.videoRef.remove()}async start(){this.captureTime=0,this.timeShift=0,(this.videoRef.srcObject||this.videoRef.src)&&await this.videoRef.play()}pause(){this.videoRef.pause()}reset(){this.pause(),this.videoRef.srcObject&&(this.videoRef.srcObject.getTracks().forEach(e=>e.stop()),this.videoRef.srcObject=null)}capture(){const{videoRef:e,buffer:t}=this,n=e.currentTime+this.timeShift;return n<=this.captureTime?!1:(this.captureTime=n,t.capture(e))}}class hte extends Cp{constructor(e,t,n=GB){super(),this.engineParams=t,this.renderers=[],this.videoRatio=1920/1080,this.streamSize={width:1920,height:1080},this.processSize={width:1920,height:1080},this.resizeEnabled=!1,this.loopState=!1,this.init=async i=>{const r=await this.setupProcessor(i);return this.emit("init",r),r},this.setup=async i=>{this.pause();const r=await this.setupVideo(i);return this.emit("setup",r),r},this.start=async()=>{await this.video.start(),this.loopState=!0,this.emit("start"),this.enqueue()},this.pause=()=>{this.loopState=!1,this.loopId&&(window.cancelAnimationFrame(this.loopId),delete this.loopId),this.video.pause(),this.emit("pause")},this.reset=()=>{this.pause(),this.video.reset(),delete this.streamCanvas,delete this.processCanvas,this.processor.reset()},this.iterate=async()=>{var i;const{video:r,streamCanvas:a,processCanvas:s}=this;if(!r.capture()||!a||!s)return this.enqueue();this.resizeEnabled&&((i=this.resizeBuffer)==null||i.capture(r.buffer.canvas));const l=await this.processor.process(s,r.captureTime);l&&await Promise.all(this.renderers.map(c=>c.update(l,a))),this.enqueue()},this.processor=typeof e=="function"?new e:e,this.video=typeof n=="function"?new n:n,this.video.on("resize",this.resizeVideo.bind(this))}async addRenderer(e){this.renderers.push(e),await e.load(),e.setupVideo(this.video.size(),this.video.ratio()),e.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle)}removeRenderer(e){const{renderers:t}=this,n=t.indexOf(e);n<0||(t[n].dispose(),t.splice(n,1))}enqueue(){this.loopId=this.loopState?window.requestAnimationFrame(this.iterate):void 0}async setupProcessor(e){var t;const n=this.resizeEnabled&&((t=this.resizeBuffer)==null?void 0:t.size)||this.video.size();return this.processor.init(e,n,this.video.ratio())}async setupVideo(e){return this.video.reset(),await this.video.setup(e)?(this.setupSize(this.video.size()),!0):!1}async setupSize(e){var t,n;const{width:i,height:r}=e;this.videoRatio=i/r;const a=Math.max(i,r),s=((t=this.engineParams)==null?void 0:t.max)||this.processor.optimalSize;if(this.resizeEnabled=!1,s<a){this.resizeEnabled=!0;const l=a/s;this.resizeBuffer||(this.resizeBuffer=new zB("resize")),this.resizeBuffer.setSize({width:i/l,height:r/l})}this.resizeEnabled&&this.resizeBuffer?(this.processCanvas=this.resizeBuffer.canvas,this.processSize=this.resizeBuffer.size):(this.processCanvas=this.video.buffer.canvas,this.processSize=this.video.size()),((n=this.engineParams)==null?void 0:n.orig)!==!1?(this.streamCanvas=this.video.buffer.canvas,this.streamSize=this.video.size()):(this.streamCanvas=this.processCanvas,this.streamSize=this.streamSize)}resizeVideo(e){this.setupSize(e),this.processor.setupVideo(this.processSize,this.videoRatio),this.renderers.forEach(t=>t.setupVideo(this.streamSize,this.videoRatio)),this.renderers.forEach(t=>t.setupCamera(this.processor.cameraRatio,this.processor.cameraAngle))}}var dte=Object.defineProperty,PO=Object.getOwnPropertySymbols,fte=Object.prototype.hasOwnProperty,pte=Object.prototype.propertyIsEnumerable,kO=(x,e,t)=>e in x?dte(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,mte=(x,e)=>{for(var t in e||(e={}))fte.call(e,t)&&kO(x,t,e[t]);if(PO)for(var t of PO(e))pte.call(e,t)&&kO(x,t,e[t]);return x};class yte extends Cp{constructor(){super(),this.params={},this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.optimalSize=1024,this.cameraRatio=this.videoRatio,this.cameraAngle=60/180*Math.PI}async process(e,t){return{}}async init(e,t,n){return this.params=e,!n&&t&&(n=t.width/t.height),this.setupVideo(t||this.videoSize,n||this.videoRatio),this.emit("init",!0),!0}reset(){this.emit("reset")}dispose(){}setupVideo(e,t){t=t||e.width/e.height,this.videoSize=mte({},e),this.videoRatio=t,this.cameraRatio=t}}class gte extends Cp{constructor(e,t="crop",n=1,i=!1,r=1){super(),this.container=e,this.mode=t,this.layerCount=n,this.mirror=i,this.aspectRatio=r,this.layers=[],this.padsSize=[1,1],this.setAspectRatio=a=>{this.aspectRatio=a,this.updateSizes(this.container.clientWidth/this.container.clientHeight)},this.setMirror=a=>{this.mirror=a,this.layers.forEach(s=>{s.style.transform=a?"scaleX(-1)":""})},this.getMirror=()=>this.mirror,this.setMode=a=>{if(this.mode=a,this.mode==="pad"&&!this.pads){this.pads=[document.createElement("canvas"),document.createElement("canvas")];const s=-10*(this.layerCount+1)+"";for(let l=0;l<2;l++)this.pads[l].id="engeenee.canvas.pad"+l,this.pads[l].style.position="absolute",this.pads[l].style.zIndex=s,this.container.appendChild(this.pads[l])}this.mode!=="pad"&&this.pads&&(this.pads.forEach(s=>s.remove()),delete this.pads),this.setAspectRatio(this.aspectRatio)},this.getMode=()=>this.mode,this.dispose=()=>{var a,s;(a=this.observer)==null||a.disconnect(),delete this.observer,(s=this.pads)==null||s.forEach(l=>l.remove()),delete this.pads,this.layers.forEach(l=>l.remove()),this.layers=[]},this.updateSizes=a=>{let s=1,l=1;a>this.aspectRatio?this.mode==="crop"?l=a/this.aspectRatio:s=this.aspectRatio/a:this.mode==="crop"?s=this.aspectRatio/a:l=a/this.aspectRatio;const c=(1-s)/2,h=(1-l)/2,d=s*100+"%",p=l*100+"%",m=c*100+"%",g=h*100+"%";for(const _ of this.layers)_.style.width=d,_.style.height=p,_.style.left=m,_.style.top=g;if(this.pads){this.padsSize=c>0?[c,1]:[1,h];const _=10,{clientWidth:v,clientHeight:b}=this.container,T=[2*_/v,2*_/b],E=(this.padsSize[0]+2*T[0])*100+"%",A=(this.padsSize[1]+2*T[1])*100+"%";this.pads[0].style.width=E,this.pads[0].style.height=A,this.pads[1].style.width=E,this.pads[1].style.height=A;const M=-T[0]*100+"%",R=-T[1]*100+"%";this.pads[0].style.top=R,this.pads[1].style.bottom=R,this.pads[0].style.left="unset",this.pads[0].style.right="unset",this.pads[1].style.left="unset",this.pads[1].style.right="unset",this.pads[this.mirror?1:0].style.left=M,this.pads[this.mirror?0:1].style.right=M;const C=c>0?this.mirror?"":"scaleX(-1)":"scaleY(-1) "+(this.mirror?"scaleX(-1)":"");this.pads[0].style.transform=C,this.pads[1].style.transform=C;const k="blur("+_+"px)";this.pads[0].style.filter=k,this.pads[1].style.filter=k}this.emit("resize")},this.handleResize=a=>{if(a.length<1)return;const s=a[0].contentRect;this.updateSizes(s.width/s.height)};for(let a=0;a<n;a++){const s=document.createElement("canvas");s.id="engeenee.canvas.layer"+a,s.style.position="absolute",s.style.zIndex=-10*(n-a)+"",this.mirror&&(s.style.transform="scaleX(-1)"),this.container.appendChild(s),this.layers.push(s)}this.setMode(t),this.observer=new ResizeObserver(this.handleResize),this.observer.observe(this.container),this.container.style.overflow="hidden"}}var vte=Object.defineProperty,UO=Object.getOwnPropertySymbols,bte=Object.prototype.hasOwnProperty,_te=Object.prototype.propertyIsEnumerable,FO=(x,e,t)=>e in x?vte(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,Ste=(x,e)=>{for(var t in e||(e={}))bte.call(e,t)&&FO(x,t,e[t]);if(UO)for(var t of UO(e))_te.call(e,t)&&FO(x,t,e[t]);return x};class Tte extends Cp{constructor(){super(),this.loaded=!1,this.videoSize={width:1920,height:1080},this.videoRatio=this.videoSize.width/this.videoSize.height,this.cameraRatio=this.videoRatio,this.cameraAngle=10/180*Math.PI}async load(){this.loaded||(this.loaded=!0,this.emit("load"))}unload(){this.loaded&&(this.loaded=!1)}async update(e,t){this.loaded&&(this.updateVideo(t),this.updateScene(),this.emit("render"))}updateVideo(e){}updateScene(){}dispose(){this.unload()}setupVideo(e,t){this.videoSize=Ste({},e),this.videoRatio=t||e.width/e.height,this.emit("resize",this.videoSize,this.videoRatio)}setupCamera(e,t){this.cameraRatio=e,this.cameraAngle=t}}class wte extends Tte{constructor(){super(...arguments),this.plugins=[]}async load(){if(!this.loaded)return await Promise.all(this.plugins.map(e=>e.load(this))),super.load()}unload(){this.plugins.forEach(e=>e.unload()),super.unload()}async update(e,t){if(this.loaded)return await this.updatePlugins(e,t),super.update(e,t)}async updatePlugins(e,t){for(let n of this.plugins)n.loaded&&await n.update(e,t)}dispose(){this.plugins.forEach(e=>e.dispose()),this.plugins=[],super.dispose()}async addPlugin(e){const{plugins:t}=this;this.loaded&&!e.loaded&&await e.load(this),t.push(e),t.sort((n,i)=>n.ordinal-i.ordinal)}removePlugin(e){const{plugins:t}=this,n=t.indexOf(e);n<0||t.splice(n,1)[0].unload()}removeAllPlugins(){this.plugins.forEach(e=>e.dispose()),this.plugins=[]}setupVideo(e,t){super.setupVideo(e,t),this.plugins.forEach(n=>n.setupVideo(e))}setupCamera(e,t){super.setupCamera(e,t),this.plugins.forEach(n=>n.setupCamera(e,t))}}class Ate extends wte{constructor(e){super(),this.padCtx=[null,null],this.setupPadding=()=>{if(!this.canvas.pads)return;const{width:t,height:n}=this.videoSize,{padsSize:i}=this.canvas,r=t*i[0]/(i[0]<.5?1-2*i[0]:1),a=n*i[1]/(i[1]<.5?1-2*i[1]:1);this.canvas.pads[0].width=r,this.canvas.pads[0].height=a,this.canvas.pads[1].width=r,this.canvas.pads[1].height=a},this.canvas=new gte(e.container,e.mode,e.layerCount,e.mirror,e.aspectRatio),this.canvas.pads&&(this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]),this.canvas.addListener("resize",this.setupPadding)}updateVideo(e){super.updateVideo(e),this.updatePads(e)}dispose(){this.padCtx=[null,null],this.canvas.dispose(),super.dispose()}setupVideo(e,t){super.setupVideo(e,t),this.canvas.setAspectRatio(this.videoRatio)}setMirror(e){this.canvas.setMirror(e)}setMode(e){this.canvas.setMode(e),this.canvas.pads?this.padCtx=[this.canvas.pads[0].getContext("2d"),this.canvas.pads[1].getContext("2d")]:this.padCtx=[null,null]}updatePads(e){if(!this.padCtx[0]||!this.padCtx[1]||!this.canvas.pads)return;const{videoSize:{width:t,height:n}}=this,{width:i,height:r}=this.canvas.pads[0];this.padCtx[0].clearRect(0,0,i,r),this.padCtx[0].drawImage(e,0,0,i,r,0,0,i,r),this.padCtx[1].clearRect(0,0,i,r),this.padCtx[1].drawImage(e,t-i,n-r,i,r,0,0,i,r)}}var Ete=Object.defineProperty,BO=Object.getOwnPropertySymbols,Mte=Object.prototype.hasOwnProperty,Rte=Object.prototype.propertyIsEnumerable,LO=(x,e,t)=>e in x?Ete(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,Cte=(x,e)=>{for(var t in e||(e={}))Mte.call(e,t)&&LO(x,t,e[t]);if(BO)for(var t of BO(e))Rte.call(e,t)&&LO(x,t,e[t]);return x};class WB{constructor(e,t={width:1920,height:1080},n=!1,i=!1,r=!1){this.gl=e,this.size=t,this.grayscale=n,this.linear=i,this.mipmap=r,this.buffer=null,this.levels=0,this.resize(t)}update(e){const{gl:t,size:{width:n,height:i}}=this,r=t.getParameter(t.TEXTURE_BINDING_2D),a=t.getParameter(t.UNPACK_FLIP_Y_WEBGL);return t.bindTexture(t.TEXTURE_2D,this.buffer),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,!1),e instanceof Float32Array?t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,i,this.grayscale?t.RED:t.RGBA,t.FLOAT,e):e instanceof Uint8Array?t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,i,this.grayscale?t.RED:t.RGBA,t.UNSIGNED_BYTE,e):t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,i,this.grayscale?t.RED:t.RGBA,t.UNSIGNED_BYTE,e),this.genLevels(),t.bindTexture(t.TEXTURE_2D,r),t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,a),this.buffer}resize(e){const{width:t,height:n}=e;if(t===this.size.width&&n===this.size.height&&this.buffer)return!0;const{gl:i}=this;if(i.deleteTexture(this.buffer),this.buffer=null,(t>0||n>0)&&(this.buffer=i.createTexture()),!this.buffer)return!1;const r=this.linear?i.LINEAR:i.NEAREST,a=this.mipmap?this.linear?i.LINEAR_MIPMAP_LINEAR:i.NEAREST_MIPMAP_NEAREST:r,s=i.getParameter(i.TEXTURE_BINDING_2D),l=i.getParameter(i.UNPACK_FLIP_Y_WEBGL);return i.bindTexture(i.TEXTURE_2D,this.buffer),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,!1),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_R,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,a),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,r),this.size={width:t,height:n},this.levels=1+(this.mipmap?Math.floor(Math.log2(Math.max(t,n))):0),i.texStorage2D(i.TEXTURE_2D,this.levels,this.grayscale?i.R8:i.RGBA8,t,n),i.bindTexture(i.TEXTURE_2D,s),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,l),!0}dispose(){this.gl.deleteTexture(this.buffer),this.buffer=null}texture(){return this.buffer}textureSize(){return this.size}valid(){return!!this.buffer}isGrayscale(){return this.grayscale}genLevels(){if(!this.buffer||!this.mipmap)return!1;const{gl:e}=this,t=e.getParameter(e.TEXTURE_BINDING_2D);return e.bindTexture(e.TEXTURE_2D,this.buffer),e.generateMipmap(e.TEXTURE_2D),e.bindTexture(e.TEXTURE_2D,t),!0}levelCount(){return this.levels}levelSize(e){const t=Cte({},this.size);for(let n=0;n<e&&n<this.levels;n++)t.width=Math.max(Math.floor(t.width/2),1),t.height=Math.max(Math.floor(t.height/2),1);return t}}var Nte=Object.defineProperty,zO=Object.getOwnPropertySymbols,Ite=Object.prototype.hasOwnProperty,Ote=Object.prototype.propertyIsEnumerable,VO=(x,e,t)=>e in x?Nte(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,z_=(x,e)=>{for(var t in e||(e={}))Ite.call(e,t)&&VO(x,t,e[t]);if(zO)for(var t of zO(e))Ote.call(e,t)&&VO(x,t,e[t]);return x};class Dte{constructor(e,t={width:1920,height:1080},n=["image"],i={},r=kte,a=Pte,s=!1,l=!1,c=!1){this.gl=e,this.size=t,this.inputs=n,this.uniforms=i,this.vertShader=null,this.fragShader=null,this.shaderProgram=null,this.vertBuffer=null,this.vertAttrs=null,this.uniformsLoc={},this.frameBuffer=null,r.includes("uniform vec2 wh;")&&!i.wh&&(i.wh="2f"),a.includes("uniform float flip;")&&!i.flip&&(i.flip="1f"),this.outputTexture=new WB(e,t,s,l,c),this.compile(r,a),this.resize(t)}process(e,t={}){const{gl:n,outputTexture:i}=this;if(!n||!i||e.length!==this.inputs.length)return null;const r=i.texture();if(!r)return null;const a=this.save(n);return n.bindFramebuffer(n.FRAMEBUFFER,this.frameBuffer),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0),t=z_({flip:[-1]},t),this.prepare(n,e,t),n.drawArrays(n.TRIANGLES,0,6),i.genLevels(),this.restore(n,a),r}render(e,t={}){const{gl:n,outputTexture:i}=this;if(!n||!i||e.length!==this.inputs.length)return;const r=this.save(n);n.bindFramebuffer(n.FRAMEBUFFER,null),t=z_({flip:[1]},t),this.prepare(n,e,t),n.drawArrays(n.TRIANGLES,0,6),this.restore(n,r)}output(){var e;return((e=this.outputTexture)==null?void 0:e.texture())||null}read(){const{gl:e,outputTexture:t,frameBuffer:n}=this;if(!e||!t||!n)return null;const i=t.texture();if(!i)return null;const r=e.getParameter(e.TEXTURE_BINDING_2D),a=e.getParameter(e.FRAMEBUFFER_BINDING);e.bindFramebuffer(e.FRAMEBUFFER,this.frameBuffer),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,i,0);const{width:s,height:l}=t.textureSize(),c=t.isGrayscale(),h=new Uint8Array(s*l*(c?1:4)),d=c?e.RED:e.RGBA;return e.readPixels(0,0,s,l,d,e.UNSIGNED_BYTE,h),e.bindTexture(e.TEXTURE_2D,r),e.bindFramebuffer(e.FRAMEBUFFER,a),h}program(){return this.shaderProgram}resize(e){var t;const{gl:n}=this;this.size=z_({},e),(t=this.outputTexture)==null||t.resize(e);const i=n.getParameter(n.CURRENT_PROGRAM);n.useProgram(this.shaderProgram),this.uniformsLoc.wh&&n.uniform2f(this.uniformsLoc.wh,e.width,e.height),n.useProgram(i)}setUniform(e,t){const{gl:n}=this,i=n.getParameter(n.CURRENT_PROGRAM);n.useProgram(this.shaderProgram),this.setUniformUnsafe(e,t),n.useProgram(i)}dispose(){var e;const{gl:t}=this;t.deleteBuffer(this.vertBuffer),this.vertBuffer=null,t.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,t.deleteShader(this.vertShader),this.vertShader=null,t.deleteShader(this.fragShader),this.fragShader=null,t.deleteProgram(this.shaderProgram),this.shaderProgram=null,(e=this.outputTexture)==null||e.dispose(),delete this.outputTexture}compile(e,t){const{gl:n}=this,i=this.save(n);if(this.vertBuffer=n.createBuffer(),this.vertAttrs=n.createVertexArray(),this.frameBuffer=n.createFramebuffer(),!this.vertBuffer||!this.frameBuffer||!this.vertAttrs){n.deleteBuffer(this.vertBuffer),this.vertBuffer=null,n.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,n.deleteVertexArray(this.vertAttrs),this.vertAttrs=null;return}if(this.vertShader=n.createShader(n.VERTEX_SHADER),this.fragShader=n.createShader(n.FRAGMENT_SHADER),this.shaderProgram=n.createProgram(),!this.vertShader||!this.fragShader||!this.shaderProgram){n.deleteBuffer(this.vertBuffer),this.vertBuffer=null,n.deleteFramebuffer(this.frameBuffer),this.frameBuffer=null,n.deleteShader(this.vertShader),this.vertShader=null,n.deleteShader(this.fragShader),this.fragShader=null,n.deleteProgram(this.shaderProgram),this.shaderProgram=null;return}n.shaderSource(this.vertShader,t),n.shaderSource(this.fragShader,e),n.compileShader(this.vertShader),n.compileShader(this.fragShader),n.attachShader(this.shaderProgram,this.vertShader),n.attachShader(this.shaderProgram,this.fragShader),n.linkProgram(this.shaderProgram),n.useProgram(this.shaderProgram),n.bindBuffer(n.ARRAY_BUFFER,this.vertBuffer),n.bufferData(n.ARRAY_BUFFER,new Float32Array([-1,-1,1,1,-1,1,-1,-1,1,-1,1,1]),n.STATIC_DRAW),n.bindVertexArray(this.vertAttrs);const r=n.getAttribLocation(this.shaderProgram,"pos");n.vertexAttribPointer(r,2,n.FLOAT,!1,0,0),n.enableVertexAttribArray(r),this.uniformsLoc={};for(let a in this.uniforms)this.uniformsLoc[a]=n.getUniformLocation(this.shaderProgram,a);for(let a=0;a<this.inputs.length;a++)n.uniform1i(n.getUniformLocation(this.shaderProgram,this.inputs[a]),a);this.restore(n,i)}prepare(e,t,n={}){const{size:{width:i,height:r}}=this;for(let a=0;a<t.length;a++)e.activeTexture(e.TEXTURE0+a),e.bindTexture(e.TEXTURE_2D,t[a]);e.useProgram(this.shaderProgram),e.bindVertexArray(this.vertAttrs);for(let a in n)this.setUniformUnsafe(a,n[a]);e.disable(e.CULL_FACE),e.disable(e.BLEND),e.colorMask(!0,!0,!0,!0),e.viewport(0,0,i,r),e.scissor(0,0,i,r),e.clear(e.COLOR_BUFFER_BIT)}save(e){return{program:e.getParameter(e.CURRENT_PROGRAM),arrayBuffer:e.getParameter(e.ARRAY_BUFFER_BINDING),framebuffer:e.getParameter(e.FRAMEBUFFER_BINDING),vertexArray:e.getParameter(e.VERTEX_ARRAY_BINDING),viewport:e.getParameter(e.VIEWPORT),scissor:e.getParameter(e.SCISSOR_BOX),colorMask:e.getParameter(e.COLOR_WRITEMASK),cullFace:e.getParameter(e.CULL_FACE),blend:e.getParameter(e.BLEND),activeTexture:e.getParameter(e.ACTIVE_TEXTURE),textures:this.inputs.map((t,n)=>(e.activeTexture(e.TEXTURE0+n),e.getParameter(e.TEXTURE_BINDING_2D)))}}restore(e,t){e.useProgram(t.program),e.bindBuffer(e.ARRAY_BUFFER,t.arrayBuffer),e.bindFramebuffer(e.FRAMEBUFFER,t.framebuffer),e.bindVertexArray(t.vertexArray),e.viewport(t.viewport[0],t.viewport[1],t.viewport[2],t.viewport[3]),e.scissor(t.scissor[0],t.scissor[1],t.scissor[2],t.scissor[3]),e.colorMask(t.colorMask[0],t.colorMask[1],t.colorMask[2],t.colorMask[3]);for(let n=0;n<t.textures.length;n++)e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,t.textures[n]);e.activeTexture(t.activeTexture),t.cullFace?e.enable(e.CULL_FACE):e.disable(e.CULL_FACE),t.blend?e.enable(e.BLEND):e.disable(e.BLEND)}setUniformUnsafe(e,t){const n=this.uniformsLoc[e];if(!n)return;const{gl:i}=this;switch(this.uniforms[e]){case"1f":t.length===1&&i.uniform1f(n,t[0]);break;case"2f":t.length===2&&i.uniform2f(n,t[0],t[1]);break;case"3f":t.length===3&&i.uniform3f(n,t[0],t[1],t[2]);break;case"4f":t.length===4&&i.uniform4f(n,t[0],t[1],t[2],t[3]);break;case"1fv":i.uniform1fv(n,t);break;case"2fv":i.uniform2fv(n,t);break;case"3fv":i.uniform3fv(n,t);break;case"4fv":i.uniform4fv(n,t);break;case"1i":t.length===1&&i.uniform1i(n,t[0]);break;case"2i":t.length===2&&i.uniform2i(n,t[0],t[1]);break;case"3i":t.length===3&&i.uniform3i(n,t[0],t[1],t[2]);break;case"4i":t.length===4&&i.uniform4i(n,t[0],t[1],t[2],t[3]);break;case"1iv":i.uniform1iv(n,t);break;case"2iv":i.uniform2iv(n,t);break;case"3iv":i.uniform3iv(n,t);break;case"4iv":i.uniform4iv(n,t);break}}}const Pte=`
attribute vec2 pos;
uniform float flip;
varying vec2 xy;
void main() {
    xy = (vec2(pos.x, -pos.y) + 1.0) * 0.5;
    gl_Position = vec4(pos.x, pos.y * flip, 0, 1.0);
}`,kte=`
precision mediump float;
varying vec2 xy;
uniform vec2 wh;
uniform sampler2D image;
void main() {
    gl_FragColor = texture2D(image, xy);
}`;class Ute extends Ate{constructor(e){super(e),this.shaderCtx=null,this.current=null;const t=this.canvas.layers[0];this.shaderCtx=t.getContext("webgl2",{alpha:!0,preserveDrawingBuffer:!0})}async load(){if(this.loaded)return;const{shaderCtx:e,videoSize:t}=this;if(e)return this.shader=new Dte(e,t),this.input=new WB(e,t),super.load()}unload(){var e,t;(e=this.input)==null||e.dispose(),delete this.input,(t=this.shader)==null||t.dispose(),delete this.shader,super.unload()}async update(e,t){if(!this.loaded)return;const{input:n}=this,i=n==null?void 0:n.texture();if(!(!n||!i))return n.update(t),this.current=i,super.update(e,t)}updateVideo(e){this.shader&&(this.shader.render([this.current]),super.updateVideo(e))}setupVideo(e,t){var n,i;super.setupVideo(e,t);const{width:r,height:a}=this.videoSize;this.canvas.layers[0].width=r,this.canvas.layers[0].height=a,(n=this.input)==null||n.resize({width:r,height:a}),(i=this.shader)==null||i.resize({width:r,height:a})}}class XB extends Ute{dispose(){delete this.scene,super.dispose()}}class Fte{constructor(){this.loaded=!1,this.ordinal=800}async load(e){this.loaded||(this.renderer=e,this.loaded=!0)}unload(){this.loaded&&(this.loaded=!1)}async update(e,t){this.loaded}dispose(){this.unload()}setupVideo(e){}setupCamera(e,t){}}var YB=(x=>(x[x.PreProcess=100]="PreProcess",x[x.Process=200]="Process",x[x.PostProcess=300]="PostProcess",x[x.PreRender=700]="PreRender",x[x.Render=800]="Render",x[x.PostRender=900]="PostRender",x))(YB||{});class Bte extends Fte{constructor(){super(),this.ordinal=YB.Render}async load(e){if(!(this.loaded||!(e instanceof XB)||!e.scene))return this.scene=e.scene,super.load(e)}unload(){this.loaded&&(delete this.scene,super.unload())}}class Lte{constructor(e,t="video/webm",n=!1,i="video",r,a){this.renderer=e,this.type=t,this.mirror=n,this.sizeMode=i,this.sizeMax=r,this.bitRate=a,this.context=null,this.records=[],this.frame=()=>{var s;const{renderer:l,context:c,stream:h}=this,{width:d,height:p}=this.canvas;!h||!c||(l.canvas.layers.map(m=>c.drawImage(m,0,0,d,p)),(s=h.getVideoTracks()[0])==null||s.requestFrame())},this.canvas=document.createElement("canvas"),this.canvas.id="engeenee.record",this.canvas.hidden=!0,this.context=this.canvas.getContext("2d",{alpha:!1})}start(){const{canvas:e,context:t,renderer:n}=this;if(!e||!t)return!1;const{layers:i}=n.canvas;let{width:r,height:a}=i[0];this.sizeMode==="max"?(r=Math.max(...i.map(l=>l.width)),a=Math.max(...i.map(l=>l.height))):this.sizeMode==="min"&&(r=Math.min(...i.map(l=>l.width)),a=Math.min(...i.map(l=>l.height)));const s=Math.max(r,a);if(this.sizeMax&&s>this.sizeMax){const l=this.sizeMax/s;r*=l,a*=l}return e.width=r,e.height=a,t.resetTransform(),this.mirror&&(t.translate(r,0),t.scale(-1,1)),n.on("render",this.frame),this.records=[],this.stream=e.captureStream(0),this.recorder=new MediaRecorder(this.stream,{mimeType:this.type,videoBitsPerSecond:this.bitRate}),this.recorder.ondataavailable=l=>this.records.push(l.data),this.recorder.start(),!0}async stop(){const{recorder:e}=this;if(!(!e||e.state!="recording"))return new Promise(t=>{e.onstop=()=>{var n;t(new Blob(this.records,{type:this.type})),this.records=[],(n=this.stream)==null||n.getVideoTracks().forEach(i=>i.stop()),this.renderer.removeListener("render",this.frame),delete this.stream,delete this.recorder},e.stop()})}dispose(){this.canvas.remove()}}class zte extends yte{constructor(){super(),this.poseTracker=new zq,this.cameraAngleBase=15/180*Math.PI;const e=/iPhone|iPad|iPod/i.test(navigator.userAgent);this.optimalSize=e?512:1024}async init(e,t,n){return await this.poseTracker.init(e.token,e.root,e.cache,e.mask),await this.poseTracker.prepare(),super.init(e,t,n)}reset(){return this.poseTracker.reset(),super.reset()}dispose(){this.poseTracker.dispose()}async process(e,t){return{poses:(await this.poseTracker.process(e,t)).map(n=>({points:$B(i=>n.keypoints[Gte[i]]),score:n.score,mask:n.mask,timestamp:t,debug:n.debug}))}}setupVideo(e,t){super.setupVideo(e,t),this.cameraAngle=this.cameraRatio>=1?this.cameraAngleBase:2*Math.atan(Math.tan(.5*this.cameraAngleBase)/this.cameraRatio),this.poseTracker.setCamera(this.cameraAngle,this.cameraRatio,1),this.poseTracker.reset()}}class Vte extends hte{constructor(e,t=GB){super(zte,e,t)}}const KB=["nose","eyeInnerL","eyeL","eyeOutterL","eyeInnerR","eyeR","eyeOutterR","earL","earR","mouthL","mouthR","shoulderL","shoulderR","elbowL","elbowR","wristL","wristR","pinkyL","pinkyR","indexL","indexR","thumbL","thumbR","hipL","hipR","kneeL","kneeR","ankleL","ankleR","heelL","heelR","footIndexL","footIndexR"];function Hte(x,e){return Object.fromEntries(e.map(t=>[t,x(t)]))}const $B=x=>Hte(x,KB),Gte=$B(x=>KB.indexOf(x)),Wte="168",Xte=0,HO=1,Yte=2,QB=1,Kte=2,go=3,il=0,er=1,Mo=2,Q2=0,dh=1,GO=2,WO=3,XO=4,$te=5,nc=100,Qte=101,Zte=102,Jte=103,jte=104,qte=200,e0e=201,t0e=202,x0e=203,qT=204,ew=205,n0e=206,i0e=207,r0e=208,a0e=209,s0e=210,o0e=211,l0e=212,c0e=213,u0e=214,h0e=0,d0e=1,f0e=2,J1=3,p0e=4,m0e=5,y0e=6,g0e=7,ZB=0,v0e=1,b0e=2,Z2=0,_0e=1,S0e=2,T0e=3,w0e=4,A0e=5,E0e=6,M0e=7,JB=300,zh=301,Vh=302,tw=303,xw=304,dv=306,nw=1e3,lc=1001,iw=1002,ga=1003,R0e=1004,Zm=1005,Ga=1006,V_=1007,cc=1008,zo=1009,jB=1010,qB=1011,ep=1012,wM=1013,Cc=1014,Oo=1015,Np=1016,AM=1017,EM=1018,Hh=1020,eL=35902,tL=1021,xL=1022,Ka=1023,nL=1024,iL=1025,fh=1026,Gh=1027,rL=1028,MM=1029,aL=1030,RM=1031,CM=1033,l1=33776,c1=33777,u1=33778,h1=33779,rw=35840,aw=35841,sw=35842,ow=35843,lw=36196,cw=37492,uw=37496,hw=37808,dw=37809,fw=37810,pw=37811,mw=37812,yw=37813,gw=37814,vw=37815,bw=37816,_w=37817,Sw=37818,Tw=37819,ww=37820,Aw=37821,d1=36492,Ew=36494,Mw=36495,sL=36283,Rw=36284,Cw=36285,Nw=36286,C0e=3200,N0e=3201,I0e=0,O0e=1,z2="",La="srgb",pl="srgb-linear",NM="display-p3",fv="display-p3-linear",j1="linear",Ex="srgb",q1="rec709",eg="p3",gu=7680,YO=519,D0e=512,P0e=513,k0e=514,oL=515,U0e=516,F0e=517,B0e=518,L0e=519,KO=35044,$O="300 es",Do=2e3,tg=2001,ii=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"],H_=Math.PI/180,Iw=180/Math.PI;function Ip(){const x=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ii[x&255]+ii[x>>8&255]+ii[x>>16&255]+ii[x>>24&255]+"-"+ii[e&255]+ii[e>>8&255]+"-"+ii[e>>16&15|64]+ii[e>>24&255]+"-"+ii[t&63|128]+ii[t>>8&255]+"-"+ii[t>>16&255]+ii[t>>24&255]+ii[n&255]+ii[n>>8&255]+ii[n>>16&255]+ii[n>>24&255]).toLowerCase()}function Zi(x,e,t){return Math.max(e,Math.min(t,x))}function z0e(x,e){return(x%e+e)%e}function G_(x,e,t){return(1-t)*x+t*e}function lf(x,e){switch(e.constructor){case Float32Array:return x;case Uint32Array:return x/4294967295;case Uint16Array:return x/65535;case Uint8Array:return x/255;case Int32Array:return Math.max(x/2147483647,-1);case Int16Array:return Math.max(x/32767,-1);case Int8Array:return Math.max(x/127,-1);default:throw new Error("Invalid component type.")}}function Wi(x,e){switch(e.constructor){case Float32Array:return x;case Uint32Array:return Math.round(x*4294967295);case Uint16Array:return Math.round(x*65535);case Uint8Array:return Math.round(x*255);case Int32Array:return Math.round(x*2147483647);case Int16Array:return Math.round(x*32767);case Int8Array:return Math.round(x*127);default:throw new Error("Invalid component type.")}}let E0=class lL{constructor(e,t,n,i,r,a,s,l,c){lL.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,i,r,a,s,l,c)}set(e,t,n,i,r,a,s,l,c){const h=this.elements;return h[0]=e,h[1]=i,h[2]=s,h[3]=t,h[4]=r,h[5]=l,h[6]=n,h[7]=a,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],s=n[3],l=n[6],c=n[1],h=n[4],d=n[7],p=n[2],m=n[5],g=n[8],_=i[0],v=i[3],b=i[6],T=i[1],E=i[4],A=i[7],M=i[2],R=i[5],C=i[8];return r[0]=a*_+s*T+l*M,r[3]=a*v+s*E+l*R,r[6]=a*b+s*A+l*C,r[1]=c*_+h*T+d*M,r[4]=c*v+h*E+d*R,r[7]=c*b+h*A+d*C,r[2]=p*_+m*T+g*M,r[5]=p*v+m*E+g*R,r[8]=p*b+m*A+g*C,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],s=e[5],l=e[6],c=e[7],h=e[8];return t*a*h-t*s*c-n*r*h+n*s*l+i*r*c-i*a*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],s=e[5],l=e[6],c=e[7],h=e[8],d=h*a-s*c,p=s*l-h*r,m=c*r-a*l,g=t*d+n*p+i*m;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const _=1/g;return e[0]=d*_,e[1]=(i*c-h*n)*_,e[2]=(s*n-i*a)*_,e[3]=p*_,e[4]=(h*t-i*l)*_,e[5]=(i*r-s*t)*_,e[6]=m*_,e[7]=(n*l-c*t)*_,e[8]=(a*t-n*r)*_,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,r,a,s){const l=Math.cos(r),c=Math.sin(r);return this.set(n*l,n*c,-n*(l*a+c*s)+a+e,-i*c,i*l,-i*(-c*a+l*s)+s+t,0,0,1),this}scale(e,t){return this.premultiply(W_.makeScale(e,t)),this}rotate(e){return this.premultiply(W_.makeRotation(-e)),this}translate(e,t){return this.premultiply(W_.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}};const W_=new E0,QO=new E0().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),ZO=new E0().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),cf={[pl]:{transfer:j1,primaries:q1,luminanceCoefficients:[.2126,.7152,.0722],toReference:x=>x,fromReference:x=>x},[La]:{transfer:Ex,primaries:q1,luminanceCoefficients:[.2126,.7152,.0722],toReference:x=>x.convertSRGBToLinear(),fromReference:x=>x.convertLinearToSRGB()},[fv]:{transfer:j1,primaries:eg,luminanceCoefficients:[.2289,.6917,.0793],toReference:x=>x.applyMatrix3(ZO),fromReference:x=>x.applyMatrix3(QO)},[NM]:{transfer:Ex,primaries:eg,luminanceCoefficients:[.2289,.6917,.0793],toReference:x=>x.convertSRGBToLinear().applyMatrix3(ZO),fromReference:x=>x.applyMatrix3(QO).convertLinearToSRGB()}},V0e=new Set([pl,fv]),J0={enabled:!0,_workingColorSpace:pl,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(x){if(!V0e.has(x))throw new Error(`Unsupported working color space, "${x}".`);this._workingColorSpace=x},convert:function(x,e,t){if(this.enabled===!1||e===t||!e||!t)return x;const n=cf[e].toReference,i=cf[t].fromReference;return i(n(x))},fromWorkingColorSpace:function(x,e){return this.convert(x,this._workingColorSpace,e)},toWorkingColorSpace:function(x,e){return this.convert(x,e,this._workingColorSpace)},getPrimaries:function(x){return cf[x].primaries},getTransfer:function(x){return x===z2?j1:cf[x].transfer},getLuminanceCoefficients:function(x,e=this._workingColorSpace){return x.fromArray(cf[e].luminanceCoefficients)}};function ph(x){return x<.04045?x*.0773993808:Math.pow(x*.9478672986+.0521327014,2.4)}function X_(x){return x<.0031308?x*12.92:1.055*Math.pow(x,.41666)-.055}const cL={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},T2={h:0,s:0,l:0},Jm={h:0,s:0,l:0};function Y_(x,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?x+(e-x)*6*t:t<1/2?e:t<2/3?x+(e-x)*6*(2/3-t):x}let dx=class{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=La){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,J0.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=J0.workingColorSpace){return this.r=e,this.g=t,this.b=n,J0.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=J0.workingColorSpace){if(e=z0e(e,1),t=Zi(t,0,1),n=Zi(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,a=2*n-r;this.r=Y_(a,r,e+1/3),this.g=Y_(a,r,e),this.b=Y_(a,r,e-1/3)}return J0.toWorkingColorSpace(this,i),this}setStyle(e,t=La){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const a=i[1],s=i[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],a=r.length;if(a===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(a===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=La){const n=cL[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=ph(e.r),this.g=ph(e.g),this.b=ph(e.b),this}copyLinearToSRGB(e){return this.r=X_(e.r),this.g=X_(e.g),this.b=X_(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=La){return J0.fromWorkingColorSpace(ri.copy(this),e),Math.round(Zi(ri.r*255,0,255))*65536+Math.round(Zi(ri.g*255,0,255))*256+Math.round(Zi(ri.b*255,0,255))}getHexString(e=La){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=J0.workingColorSpace){J0.fromWorkingColorSpace(ri.copy(this),t);const n=ri.r,i=ri.g,r=ri.b,a=Math.max(n,i,r),s=Math.min(n,i,r);let l,c;const h=(s+a)/2;if(s===a)l=0,c=0;else{const d=a-s;switch(c=h<=.5?d/(a+s):d/(2-a-s),a){case n:l=(i-r)/d+(i<r?6:0);break;case i:l=(r-n)/d+2;break;case r:l=(n-i)/d+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=J0.workingColorSpace){return J0.fromWorkingColorSpace(ri.copy(this),t),e.r=ri.r,e.g=ri.g,e.b=ri.b,e}getStyle(e=La){J0.fromWorkingColorSpace(ri.copy(this),e);const t=ri.r,n=ri.g,i=ri.b;return e!==La?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(e,t,n){return this.getHSL(T2),this.setHSL(T2.h+e,T2.s+t,T2.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(T2),e.getHSL(Jm);const n=G_(T2.h,Jm.h,t),i=G_(T2.s,Jm.s,t),r=G_(T2.l,Jm.l,t);return this.setHSL(n,i,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,i=this.b,r=e.elements;return this.r=r[0]*t+r[3]*n+r[6]*i,this.g=r[1]*t+r[4]*n+r[7]*i,this.b=r[2]*t+r[5]*n+r[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}};const ri=new dx;dx.NAMES=cL;let Ts=class{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,r,a,s){let l=n[i+0],c=n[i+1],h=n[i+2],d=n[i+3];const p=r[a+0],m=r[a+1],g=r[a+2],_=r[a+3];if(s===0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d;return}if(s===1){e[t+0]=p,e[t+1]=m,e[t+2]=g,e[t+3]=_;return}if(d!==_||l!==p||c!==m||h!==g){let v=1-s;const b=l*p+c*m+h*g+d*_,T=b>=0?1:-1,E=1-b*b;if(E>Number.EPSILON){const M=Math.sqrt(E),R=Math.atan2(M,b*T);v=Math.sin(v*R)/M,s=Math.sin(s*R)/M}const A=s*T;if(l=l*v+p*A,c=c*v+m*A,h=h*v+g*A,d=d*v+_*A,v===1-s){const M=1/Math.sqrt(l*l+c*c+h*h+d*d);l*=M,c*=M,h*=M,d*=M}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d}static multiplyQuaternionsFlat(e,t,n,i,r,a){const s=n[i],l=n[i+1],c=n[i+2],h=n[i+3],d=r[a],p=r[a+1],m=r[a+2],g=r[a+3];return e[t]=s*g+h*d+l*m-c*p,e[t+1]=l*g+h*p+c*d-s*m,e[t+2]=c*g+h*m+s*p-l*d,e[t+3]=h*g-s*d-l*p-c*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const n=e._x,i=e._y,r=e._z,a=e._order,s=Math.cos,l=Math.sin,c=s(n/2),h=s(i/2),d=s(r/2),p=l(n/2),m=l(i/2),g=l(r/2);switch(a){case"XYZ":this._x=p*h*d+c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d-p*m*g;break;case"YXZ":this._x=p*h*d+c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d+p*m*g;break;case"ZXY":this._x=p*h*d-c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d-p*m*g;break;case"ZYX":this._x=p*h*d-c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d+p*m*g;break;case"YZX":this._x=p*h*d+c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d-p*m*g;break;case"XZY":this._x=p*h*d-c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d+p*m*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],r=t[8],a=t[1],s=t[5],l=t[9],c=t[2],h=t[6],d=t[10],p=n+s+d;if(p>0){const m=.5/Math.sqrt(p+1);this._w=.25/m,this._x=(h-l)*m,this._y=(r-c)*m,this._z=(a-i)*m}else if(n>s&&n>d){const m=2*Math.sqrt(1+n-s-d);this._w=(h-l)/m,this._x=.25*m,this._y=(i+a)/m,this._z=(r+c)/m}else if(s>d){const m=2*Math.sqrt(1+s-n-d);this._w=(r-c)/m,this._x=(i+a)/m,this._y=.25*m,this._z=(l+h)/m}else{const m=2*Math.sqrt(1+d-n-s);this._w=(a-i)/m,this._x=(r+c)/m,this._y=(l+h)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Zi(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,r=e._z,a=e._w,s=t._x,l=t._y,c=t._z,h=t._w;return this._x=n*h+a*s+i*c-r*l,this._y=i*h+a*l+r*s-n*c,this._z=r*h+a*c+n*l-i*s,this._w=a*h-n*s-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,r=this._z,a=this._w;let s=a*e._w+n*e._x+i*e._y+r*e._z;if(s<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,s=-s):this.copy(e),s>=1)return this._w=a,this._x=n,this._y=i,this._z=r,this;const l=1-s*s;if(l<=Number.EPSILON){const m=1-t;return this._w=m*a+t*this._w,this._x=m*n+t*this._x,this._y=m*i+t*this._y,this._z=m*r+t*this._z,this.normalize(),this}const c=Math.sqrt(l),h=Math.atan2(c,s),d=Math.sin((1-t)*h)/c,p=Math.sin(t*h)/c;return this._w=a*d+this._w*p,this._x=n*d+this._x*p,this._y=i*d+this._y*p,this._z=r*d+this._z*p,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),r=Math.sqrt(n);return this.set(i*Math.sin(e),i*Math.cos(e),r*Math.sin(t),r*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}},Be=class uL{constructor(e=0,t=0,n=0){uL.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(JO.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(JO.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*i,this.y=r[1]*t+r[4]*n+r[7]*i,this.z=r[2]*t+r[5]*n+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=e.elements,a=1/(r[3]*t+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*i+r[12])*a,this.y=(r[1]*t+r[5]*n+r[9]*i+r[13])*a,this.z=(r[2]*t+r[6]*n+r[10]*i+r[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,r=e.x,a=e.y,s=e.z,l=e.w,c=2*(a*i-s*n),h=2*(s*t-r*i),d=2*(r*n-a*t);return this.x=t+l*c+a*d-s*h,this.y=n+l*h+s*c-r*d,this.z=i+l*d+r*h-a*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i,this.y=r[1]*t+r[5]*n+r[9]*i,this.z=r[2]*t+r[6]*n+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,r=e.z,a=t.x,s=t.y,l=t.z;return this.x=i*l-r*s,this.y=r*a-n*l,this.z=n*s-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return K_.copy(this).projectOnVector(e),this.sub(K_)}reflect(e){return this.sub(K_.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Zi(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,n=Math.sqrt(1-t*t);return this.x=n*Math.cos(e),this.y=t,this.z=n*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}};const K_=new Be,JO=new Ts;let Op=class{constructor(e=new Be(1/0,1/0,1/0),t=new Be(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t+=3)this.expandByPoint(Ia.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,n=e.count;t<n;t++)this.expandByPoint(Ia.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Ia.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0){const r=n.getAttribute("position");if(t===!0&&r!==void 0&&e.isInstancedMesh!==!0)for(let a=0,s=r.count;a<s;a++)e.isMesh===!0?e.getVertexPosition(a,Ia):Ia.fromBufferAttribute(r,a),Ia.applyMatrix4(e.matrixWorld),this.expandByPoint(Ia);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),jm.copy(e.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),jm.copy(n.boundingBox)),jm.applyMatrix4(e.matrixWorld),this.union(jm)}const i=e.children;for(let r=0,a=i.length;r<a;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Ia),Ia.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(uf),qm.subVectors(this.max,uf),vu.subVectors(e.a,uf),bu.subVectors(e.b,uf),_u.subVectors(e.c,uf),w2.subVectors(bu,vu),A2.subVectors(_u,bu),Ll.subVectors(vu,_u);let t=[0,-w2.z,w2.y,0,-A2.z,A2.y,0,-Ll.z,Ll.y,w2.z,0,-w2.x,A2.z,0,-A2.x,Ll.z,0,-Ll.x,-w2.y,w2.x,0,-A2.y,A2.x,0,-Ll.y,Ll.x,0];return!$_(t,vu,bu,_u,qm)||(t=[1,0,0,0,1,0,0,0,1],!$_(t,vu,bu,_u,qm))?!1:(ey.crossVectors(w2,A2),t=[ey.x,ey.y,ey.z],$_(t,vu,bu,_u,qm))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Ia).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Ia).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(ro[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),ro[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),ro[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),ro[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),ro[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),ro[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),ro[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),ro[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(ro),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}};const ro=[new Be,new Be,new Be,new Be,new Be,new Be,new Be,new Be],Ia=new Be,jm=new Op,vu=new Be,bu=new Be,_u=new Be,w2=new Be,A2=new Be,Ll=new Be,uf=new Be,qm=new Be,ey=new Be,zl=new Be;function $_(x,e,t,n,i){for(let r=0,a=x.length-3;r<=a;r+=3){zl.fromArray(x,r);const s=i.x*Math.abs(zl.x)+i.y*Math.abs(zl.y)+i.z*Math.abs(zl.z),l=e.dot(zl),c=t.dot(zl),h=n.dot(zl);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>s)return!1}return!0}const H0e=new Op,hf=new Be,Q_=new Be;let IM=class{constructor(e=new Be,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):H0e.setFromPoints(e).getCenter(n);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;hf.subVectors(e,this.center);const t=hf.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.addScaledVector(hf,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(Q_.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(hf.copy(e.center).add(Q_)),this.expandByPoint(hf.copy(e.center).sub(Q_))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}};const Z_=new Be,G0e=new Be,W0e=new E0;let jl=class{constructor(e=new Be(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=Z_.subVectors(n,t).cross(G0e.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(Z_),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(e.start).addScaledVector(n,r)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||W0e.getNormalMatrix(e),i=this.coplanarPoint(Z_).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}};const Vl=new IM,ty=new Be;let hL=class{constructor(e=new jl,t=new jl,n=new jl,i=new jl,r=new jl,a=new jl){this.planes=[e,t,n,i,r,a]}set(e,t,n,i,r,a){const s=this.planes;return s[0].copy(e),s[1].copy(t),s[2].copy(n),s[3].copy(i),s[4].copy(r),s[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e,t=Do){const n=this.planes,i=e.elements,r=i[0],a=i[1],s=i[2],l=i[3],c=i[4],h=i[5],d=i[6],p=i[7],m=i[8],g=i[9],_=i[10],v=i[11],b=i[12],T=i[13],E=i[14],A=i[15];if(n[0].setComponents(l-r,p-c,v-m,A-b).normalize(),n[1].setComponents(l+r,p+c,v+m,A+b).normalize(),n[2].setComponents(l+a,p+h,v+g,A+T).normalize(),n[3].setComponents(l-a,p-h,v-g,A-T).normalize(),n[4].setComponents(l-s,p-d,v-_,A-E).normalize(),t===Do)n[5].setComponents(l+s,p+d,v+_,A+E).normalize();else if(t===tg)n[5].setComponents(s,d,_,E).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),Vl.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),Vl.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(Vl)}intersectsSprite(e){return Vl.center.set(0,0,0),Vl.radius=.7071067811865476,Vl.applyMatrix4(e.matrixWorld),this.intersectsSphere(Vl)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(ty.x=i.normal.x>0?e.max.x:e.min.x,ty.y=i.normal.y>0?e.max.y:e.min.y,ty.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(ty)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}},Hn=class Ow{constructor(e,t,n,i,r,a,s,l,c,h,d,p,m,g,_,v){Ow.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,n,i,r,a,s,l,c,h,d,p,m,g,_,v)}set(e,t,n,i,r,a,s,l,c,h,d,p,m,g,_,v){const b=this.elements;return b[0]=e,b[4]=t,b[8]=n,b[12]=i,b[1]=r,b[5]=a,b[9]=s,b[13]=l,b[2]=c,b[6]=h,b[10]=d,b[14]=p,b[3]=m,b[7]=g,b[11]=_,b[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new Ow().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/Su.setFromMatrixColumn(e,0).length(),r=1/Su.setFromMatrixColumn(e,1).length(),a=1/Su.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,r=e.z,a=Math.cos(n),s=Math.sin(n),l=Math.cos(i),c=Math.sin(i),h=Math.cos(r),d=Math.sin(r);if(e.order==="XYZ"){const p=a*h,m=a*d,g=s*h,_=s*d;t[0]=l*h,t[4]=-l*d,t[8]=c,t[1]=m+g*c,t[5]=p-_*c,t[9]=-s*l,t[2]=_-p*c,t[6]=g+m*c,t[10]=a*l}else if(e.order==="YXZ"){const p=l*h,m=l*d,g=c*h,_=c*d;t[0]=p+_*s,t[4]=g*s-m,t[8]=a*c,t[1]=a*d,t[5]=a*h,t[9]=-s,t[2]=m*s-g,t[6]=_+p*s,t[10]=a*l}else if(e.order==="ZXY"){const p=l*h,m=l*d,g=c*h,_=c*d;t[0]=p-_*s,t[4]=-a*d,t[8]=g+m*s,t[1]=m+g*s,t[5]=a*h,t[9]=_-p*s,t[2]=-a*c,t[6]=s,t[10]=a*l}else if(e.order==="ZYX"){const p=a*h,m=a*d,g=s*h,_=s*d;t[0]=l*h,t[4]=g*c-m,t[8]=p*c+_,t[1]=l*d,t[5]=_*c+p,t[9]=m*c-g,t[2]=-c,t[6]=s*l,t[10]=a*l}else if(e.order==="YZX"){const p=a*l,m=a*c,g=s*l,_=s*c;t[0]=l*h,t[4]=_-p*d,t[8]=g*d+m,t[1]=d,t[5]=a*h,t[9]=-s*h,t[2]=-c*h,t[6]=m*d+g,t[10]=p-_*d}else if(e.order==="XZY"){const p=a*l,m=a*c,g=s*l,_=s*c;t[0]=l*h,t[4]=-d,t[8]=c*h,t[1]=p*d+_,t[5]=a*h,t[9]=m*d-g,t[2]=g*d-m,t[6]=s*h,t[10]=_*d+p}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(X0e,e,Y0e)}lookAt(e,t,n){const i=this.elements;return vr.subVectors(e,t),vr.lengthSq()===0&&(vr.z=1),vr.normalize(),E2.crossVectors(n,vr),E2.lengthSq()===0&&(Math.abs(n.z)===1?vr.x+=1e-4:vr.z+=1e-4,vr.normalize(),E2.crossVectors(n,vr)),E2.normalize(),xy.crossVectors(vr,E2),i[0]=E2.x,i[4]=xy.x,i[8]=vr.x,i[1]=E2.y,i[5]=xy.y,i[9]=vr.y,i[2]=E2.z,i[6]=xy.z,i[10]=vr.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],s=n[4],l=n[8],c=n[12],h=n[1],d=n[5],p=n[9],m=n[13],g=n[2],_=n[6],v=n[10],b=n[14],T=n[3],E=n[7],A=n[11],M=n[15],R=i[0],C=i[4],k=i[8],P=i[12],N=i[1],G=i[5],te=i[9],j=i[13],xe=i[2],ae=i[6],H=i[10],re=i[14],q=i[3],be=i[7],K=i[11],se=i[15];return r[0]=a*R+s*N+l*xe+c*q,r[4]=a*C+s*G+l*ae+c*be,r[8]=a*k+s*te+l*H+c*K,r[12]=a*P+s*j+l*re+c*se,r[1]=h*R+d*N+p*xe+m*q,r[5]=h*C+d*G+p*ae+m*be,r[9]=h*k+d*te+p*H+m*K,r[13]=h*P+d*j+p*re+m*se,r[2]=g*R+_*N+v*xe+b*q,r[6]=g*C+_*G+v*ae+b*be,r[10]=g*k+_*te+v*H+b*K,r[14]=g*P+_*j+v*re+b*se,r[3]=T*R+E*N+A*xe+M*q,r[7]=T*C+E*G+A*ae+M*be,r[11]=T*k+E*te+A*H+M*K,r[15]=T*P+E*j+A*re+M*se,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],r=e[12],a=e[1],s=e[5],l=e[9],c=e[13],h=e[2],d=e[6],p=e[10],m=e[14],g=e[3],_=e[7],v=e[11],b=e[15];return g*(+r*l*d-i*c*d-r*s*p+n*c*p+i*s*m-n*l*m)+_*(+t*l*m-t*c*p+r*a*p-i*a*m+i*c*h-r*l*h)+v*(+t*c*d-t*s*m-r*a*d+n*a*m+r*s*h-n*c*h)+b*(-i*s*h-t*l*d+t*s*p+i*a*d-n*a*p+n*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],s=e[5],l=e[6],c=e[7],h=e[8],d=e[9],p=e[10],m=e[11],g=e[12],_=e[13],v=e[14],b=e[15],T=d*v*c-_*p*c+_*l*m-s*v*m-d*l*b+s*p*b,E=g*p*c-h*v*c-g*l*m+a*v*m+h*l*b-a*p*b,A=h*_*c-g*d*c+g*s*m-a*_*m-h*s*b+a*d*b,M=g*d*l-h*_*l-g*s*p+a*_*p+h*s*v-a*d*v,R=t*T+n*E+i*A+r*M;if(R===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/R;return e[0]=T*C,e[1]=(_*p*r-d*v*r-_*i*m+n*v*m+d*i*b-n*p*b)*C,e[2]=(s*v*r-_*l*r+_*i*c-n*v*c-s*i*b+n*l*b)*C,e[3]=(d*l*r-s*p*r-d*i*c+n*p*c+s*i*m-n*l*m)*C,e[4]=E*C,e[5]=(h*v*r-g*p*r+g*i*m-t*v*m-h*i*b+t*p*b)*C,e[6]=(g*l*r-a*v*r-g*i*c+t*v*c+a*i*b-t*l*b)*C,e[7]=(a*p*r-h*l*r+h*i*c-t*p*c-a*i*m+t*l*m)*C,e[8]=A*C,e[9]=(g*d*r-h*_*r-g*n*m+t*_*m+h*n*b-t*d*b)*C,e[10]=(a*_*r-g*s*r+g*n*c-t*_*c-a*n*b+t*s*b)*C,e[11]=(h*s*r-a*d*r-h*n*c+t*d*c+a*n*m-t*s*m)*C,e[12]=M*C,e[13]=(h*_*i-g*d*i+g*n*p-t*_*p-h*n*v+t*d*v)*C,e[14]=(g*s*i-a*_*i-g*n*l+t*_*l+a*n*v-t*s*v)*C,e[15]=(a*d*i-h*s*i+h*n*l-t*d*l-a*n*p+t*s*p)*C,this}scale(e){const t=this.elements,n=e.x,i=e.y,r=e.z;return t[0]*=n,t[4]*=i,t[8]*=r,t[1]*=n,t[5]*=i,t[9]*=r,t[2]*=n,t[6]*=i,t[10]*=r,t[3]*=n,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),r=1-n,a=e.x,s=e.y,l=e.z,c=r*a,h=r*s;return this.set(c*a+n,c*s-i*l,c*l+i*s,0,c*s+i*l,h*s+n,h*l-i*a,0,c*l-i*s,h*l+i*a,r*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,r,a){return this.set(1,n,r,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,r=t._x,a=t._y,s=t._z,l=t._w,c=r+r,h=a+a,d=s+s,p=r*c,m=r*h,g=r*d,_=a*h,v=a*d,b=s*d,T=l*c,E=l*h,A=l*d,M=n.x,R=n.y,C=n.z;return i[0]=(1-(_+b))*M,i[1]=(m+A)*M,i[2]=(g-E)*M,i[3]=0,i[4]=(m-A)*R,i[5]=(1-(p+b))*R,i[6]=(v+T)*R,i[7]=0,i[8]=(g+E)*C,i[9]=(v-T)*C,i[10]=(1-(p+_))*C,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let r=Su.set(i[0],i[1],i[2]).length();const a=Su.set(i[4],i[5],i[6]).length(),s=Su.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Oa.copy(this);const c=1/r,h=1/a,d=1/s;return Oa.elements[0]*=c,Oa.elements[1]*=c,Oa.elements[2]*=c,Oa.elements[4]*=h,Oa.elements[5]*=h,Oa.elements[6]*=h,Oa.elements[8]*=d,Oa.elements[9]*=d,Oa.elements[10]*=d,t.setFromRotationMatrix(Oa),n.x=r,n.y=a,n.z=s,this}makePerspective(e,t,n,i,r,a,s=Do){const l=this.elements,c=2*r/(t-e),h=2*r/(n-i),d=(t+e)/(t-e),p=(n+i)/(n-i);let m,g;if(s===Do)m=-(a+r)/(a-r),g=-2*a*r/(a-r);else if(s===tg)m=-a/(a-r),g=-a*r/(a-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+s);return l[0]=c,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=h,l[9]=p,l[13]=0,l[2]=0,l[6]=0,l[10]=m,l[14]=g,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,n,i,r,a,s=Do){const l=this.elements,c=1/(t-e),h=1/(n-i),d=1/(a-r),p=(t+e)*c,m=(n+i)*h;let g,_;if(s===Do)g=(a+r)*d,_=-2*d;else if(s===tg)g=r*d,_=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+s);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-p,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-m,l[2]=0,l[6]=0,l[10]=_,l[14]=-g,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}};const Su=new Be,Oa=new Hn,X0e=new Be(0,0,0),Y0e=new Be(1,1,1),E2=new Be,xy=new Be,vr=new Be;let ui=class dL{constructor(e=0,t=0,n=0,i=1){dL.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*r,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*r,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*r,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,r;const l=e.elements,c=l[0],h=l[4],d=l[8],p=l[1],m=l[5],g=l[9],_=l[2],v=l[6],b=l[10];if(Math.abs(h-p)<.01&&Math.abs(d-_)<.01&&Math.abs(g-v)<.01){if(Math.abs(h+p)<.1&&Math.abs(d+_)<.1&&Math.abs(g+v)<.1&&Math.abs(c+m+b-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const E=(c+1)/2,A=(m+1)/2,M=(b+1)/2,R=(h+p)/4,C=(d+_)/4,k=(g+v)/4;return E>A&&E>M?E<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(E),i=R/n,r=C/n):A>M?A<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(A),n=R/i,r=k/i):M<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(M),n=C/r,i=k/r),this.set(n,i,r,t),this}let T=Math.sqrt((v-g)*(v-g)+(d-_)*(d-_)+(p-h)*(p-h));return Math.abs(T)<.001&&(T=1),this.x=(v-g)/T,this.y=(d-_)/T,this.z=(p-h)/T,this.w=Math.acos((c+m+b-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}};function fL(){let x=null,e=!1,t=null,n=null;function i(r,a){t(r,a),n=x.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(n=x.requestAnimationFrame(i),e=!0)},stop:function(){x.cancelAnimationFrame(n),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){x=r}}}function K0e(x){const e=new WeakMap;function t(s,l){const c=s.array,h=s.usage,d=c.byteLength,p=x.createBuffer();x.bindBuffer(l,p),x.bufferData(l,c,h),s.onUploadCallback();let m;if(c instanceof Float32Array)m=x.FLOAT;else if(c instanceof Uint16Array)s.isFloat16BufferAttribute?m=x.HALF_FLOAT:m=x.UNSIGNED_SHORT;else if(c instanceof Int16Array)m=x.SHORT;else if(c instanceof Uint32Array)m=x.UNSIGNED_INT;else if(c instanceof Int32Array)m=x.INT;else if(c instanceof Int8Array)m=x.BYTE;else if(c instanceof Uint8Array)m=x.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)m=x.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:p,type:m,bytesPerElement:c.BYTES_PER_ELEMENT,version:s.version,size:d}}function n(s,l,c){const h=l.array,d=l._updateRange,p=l.updateRanges;if(x.bindBuffer(c,s),d.count===-1&&p.length===0&&x.bufferSubData(c,0,h),p.length!==0){for(let m=0,g=p.length;m<g;m++){const _=p[m];x.bufferSubData(c,_.start*h.BYTES_PER_ELEMENT,h,_.start,_.count)}l.clearUpdateRanges()}d.count!==-1&&(x.bufferSubData(c,d.offset*h.BYTES_PER_ELEMENT,h,d.offset,d.count),d.count=-1),l.onUploadCallback()}function i(s){return s.isInterleavedBufferAttribute&&(s=s.data),e.get(s)}function r(s){s.isInterleavedBufferAttribute&&(s=s.data);const l=e.get(s);l&&(x.deleteBuffer(l.buffer),e.delete(s))}function a(s,l){if(s.isInterleavedBufferAttribute&&(s=s.data),s.isGLBufferAttribute){const h=e.get(s);(!h||h.version<s.version)&&e.set(s,{buffer:s.buffer,type:s.type,bytesPerElement:s.elementSize,version:s.version});return}const c=e.get(s);if(c===void 0)e.set(s,t(s,l));else if(c.version<s.version){if(c.size!==s.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");n(c.buffer,s,l),c.version=s.version}}return{get:i,remove:r,update:a}}let fx=class pL{constructor(e=0,t=0){pL.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(Zi(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*n-a*i+e.x,this.y=r*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}},hd=class{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,e);e.target=null}}};function mL(x){for(let e=x.length-1;e>=0;--e)if(x[e]>=65535)return!0;return!1}function xg(x){return document.createElementNS("http://www.w3.org/1999/xhtml",x)}function $0e(){const x=xg("canvas");return x.style.display="block",x}const jO={};function Ff(x){x in jO||(jO[x]=!0,console.warn(x))}function Q0e(x,e,t){return new Promise(function(n,i){function r(){switch(x.clientWaitSync(e,x.SYNC_FLUSH_COMMANDS_BIT,0)){case x.WAIT_FAILED:i();break;case x.TIMEOUT_EXPIRED:setTimeout(r,t);break;default:n()}}setTimeout(r,t)})}const cn=new Be,ny=new fx;let Es=class{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=KO,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=Oo,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return Ff("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)ny.fromBufferAttribute(this,t),ny.applyMatrix3(e),this.setXY(t,ny.x,ny.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)cn.fromBufferAttribute(this,t),cn.applyMatrix3(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)cn.fromBufferAttribute(this,t),cn.applyMatrix4(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)cn.fromBufferAttribute(this,t),cn.applyNormalMatrix(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)cn.fromBufferAttribute(this,t),cn.transformDirection(e),this.setXYZ(t,cn.x,cn.y,cn.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let n=this.array[e*this.itemSize+t];return this.normalized&&(n=lf(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=Wi(n,this.array)),this.array[e*this.itemSize+t]=n,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=lf(t,this.array)),t}setX(e,t){return this.normalized&&(t=Wi(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=lf(t,this.array)),t}setY(e,t){return this.normalized&&(t=Wi(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=lf(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Wi(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=lf(t,this.array)),t}setW(e,t){return this.normalized&&(t=Wi(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=Wi(t,this.array),n=Wi(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=Wi(t,this.array),n=Wi(n,this.array),i=Wi(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.normalized&&(t=Wi(t,this.array),n=Wi(n,this.array),i=Wi(i,this.array),r=Wi(r,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==KO&&(e.usage=this.usage),e}},yL=class extends Es{constructor(e,t,n){super(new Uint16Array(e),t,n)}},gL=class extends Es{constructor(e,t,n){super(new Uint32Array(e),t,n)}},fc=class extends Es{constructor(e,t,n){super(new Float32Array(e),t,n)}};const qO=new Hn,eD=new Ts;let Nc=class vL{constructor(e=0,t=0,n=0,i=vL.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,r=i[0],a=i[4],s=i[8],l=i[1],c=i[5],h=i[9],d=i[2],p=i[6],m=i[10];switch(t){case"XYZ":this._y=Math.asin(Zi(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-h,m),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(p,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Zi(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(s,m),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-d,r),this._z=0);break;case"ZXY":this._x=Math.asin(Zi(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-d,m),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-Zi(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(p,m),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(Zi(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-d,r)):(this._x=0,this._y=Math.atan2(s,m));break;case"XZY":this._z=Math.asin(-Zi(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(p,c),this._y=Math.atan2(s,r)):(this._x=Math.atan2(-h,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return qO.makeRotationFromQuaternion(e),this.setFromRotationMatrix(qO,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return eD.setFromEuler(this),this.setFromQuaternion(eD,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}};Nc.DEFAULT_ORDER="XYZ";let bL=class{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}},Z0e=0;const tD=new Be,Tu=new Ts,ao=new Hn,iy=new Be,df=new Be,J0e=new Be,j0e=new Ts,xD=new Be(1,0,0),nD=new Be(0,1,0),iD=new Be(0,0,1),rD={type:"added"},q0e={type:"removed"},wu={type:"childadded",child:null},J_={type:"childremoved",child:null};let Xo=class f1 extends hd{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Z0e++}),this.uuid=Ip(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=f1.DEFAULT_UP.clone();const e=new Be,t=new Nc,n=new Ts,i=new Be(1,1,1);function r(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(r),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new Hn},normalMatrix:{value:new E0}}),this.matrix=new Hn,this.matrixWorld=new Hn,this.matrixAutoUpdate=f1.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=f1.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new bL,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Tu.setFromAxisAngle(e,t),this.quaternion.multiply(Tu),this}rotateOnWorldAxis(e,t){return Tu.setFromAxisAngle(e,t),this.quaternion.premultiply(Tu),this}rotateX(e){return this.rotateOnAxis(xD,e)}rotateY(e){return this.rotateOnAxis(nD,e)}rotateZ(e){return this.rotateOnAxis(iD,e)}translateOnAxis(e,t){return tD.copy(e).applyQuaternion(this.quaternion),this.position.add(tD.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(xD,e)}translateY(e){return this.translateOnAxis(nD,e)}translateZ(e){return this.translateOnAxis(iD,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(ao.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?iy.copy(e):iy.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),df.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ao.lookAt(df,iy,this.up):ao.lookAt(iy,df,this.up),this.quaternion.setFromRotationMatrix(ao),i&&(ao.extractRotation(i.matrixWorld),Tu.setFromRotationMatrix(ao),this.quaternion.premultiply(Tu.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(rD),wu.child=e,this.dispatchEvent(wu),wu.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(q0e),J_.child=e,this.dispatchEvent(J_),J_.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),ao.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ao.multiply(e.parent.matrixWorld)),e.applyMatrix4(ao),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(rD),wu.child=e,this.dispatchEvent(wu),wu.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getObjectsByProperty(e,t,n=[]){this[e]===t&&n.push(this);const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].getObjectsByProperty(e,t,n);return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(df,e,J0e),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(df,j0e,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(s=>({boxInitialized:s.boxInitialized,boxMin:s.box.min.toArray(),boxMax:s.box.max.toArray(),sphereInitialized:s.sphereInitialized,sphereRadius:s.sphere.radius,sphereCenter:s.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function r(s,l){return s[l.uuid]===void 0&&(s[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const s=this.geometry.parameters;if(s!==void 0&&s.shapes!==void 0){const l=s.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const d=l[c];r(e.shapes,d)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const s=[];for(let l=0,c=this.material.length;l<c;l++)s.push(r(e.materials,this.material[l]));i.material=s}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let s=0;s<this.children.length;s++)i.children.push(this.children[s].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let s=0;s<this.animations.length;s++){const l=this.animations[s];i.animations.push(r(e.animations,l))}}if(t){const s=a(e.geometries),l=a(e.materials),c=a(e.textures),h=a(e.images),d=a(e.shapes),p=a(e.skeletons),m=a(e.animations),g=a(e.nodes);s.length>0&&(n.geometries=s),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),d.length>0&&(n.shapes=d),p.length>0&&(n.skeletons=p),m.length>0&&(n.animations=m),g.length>0&&(n.nodes=g)}return n.object=i,n;function a(s){const l=[];for(const c in s){const h=s[c];delete h.metadata,l.push(h)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}};Xo.DEFAULT_UP=new Be(0,1,0);Xo.DEFAULT_MATRIX_AUTO_UPDATE=!0;Xo.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;let exe=0;const aa=new Hn,j_=new Xo,Au=new Be,br=new Op,ff=new Op,Un=new Be;let dd=class _L extends hd{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:exe++}),this.uuid=Ip(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(mL(e)?gL:yL)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new E0().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return aa.makeRotationFromQuaternion(e),this.applyMatrix4(aa),this}rotateX(e){return aa.makeRotationX(e),this.applyMatrix4(aa),this}rotateY(e){return aa.makeRotationY(e),this.applyMatrix4(aa),this}rotateZ(e){return aa.makeRotationZ(e),this.applyMatrix4(aa),this}translate(e,t,n){return aa.makeTranslation(e,t,n),this.applyMatrix4(aa),this}scale(e,t,n){return aa.makeScale(e,t,n),this.applyMatrix4(aa),this}lookAt(e){return j_.lookAt(e),j_.updateMatrix(),this.applyMatrix4(j_.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Au).negate(),this.translate(Au.x,Au.y,Au.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new fc(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Op);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new Be(-1/0,-1/0,-1/0),new Be(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const r=t[n];br.setFromBufferAttribute(r),this.morphTargetsRelative?(Un.addVectors(this.boundingBox.min,br.min),this.boundingBox.expandByPoint(Un),Un.addVectors(this.boundingBox.max,br.max),this.boundingBox.expandByPoint(Un)):(this.boundingBox.expandByPoint(br.min),this.boundingBox.expandByPoint(br.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new IM);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new Be,1/0);return}if(e){const n=this.boundingSphere.center;if(br.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){const s=t[r];ff.setFromBufferAttribute(s),this.morphTargetsRelative?(Un.addVectors(br.min,ff.min),br.expandByPoint(Un),Un.addVectors(br.max,ff.max),br.expandByPoint(Un)):(br.expandByPoint(ff.min),br.expandByPoint(ff.max))}br.getCenter(n);let i=0;for(let r=0,a=e.count;r<a;r++)Un.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Un));if(t)for(let r=0,a=t.length;r<a;r++){const s=t[r],l=this.morphTargetsRelative;for(let c=0,h=s.count;c<h;c++)Un.fromBufferAttribute(s,c),l&&(Au.fromBufferAttribute(e,c),Un.add(Au)),i=Math.max(i,n.distanceToSquared(Un))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.position,i=t.normal,r=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Es(new Float32Array(4*n.count),4));const a=this.getAttribute("tangent"),s=[],l=[];for(let k=0;k<n.count;k++)s[k]=new Be,l[k]=new Be;const c=new Be,h=new Be,d=new Be,p=new fx,m=new fx,g=new fx,_=new Be,v=new Be;function b(k,P,N){c.fromBufferAttribute(n,k),h.fromBufferAttribute(n,P),d.fromBufferAttribute(n,N),p.fromBufferAttribute(r,k),m.fromBufferAttribute(r,P),g.fromBufferAttribute(r,N),h.sub(c),d.sub(c),m.sub(p),g.sub(p);const G=1/(m.x*g.y-g.x*m.y);isFinite(G)&&(_.copy(h).multiplyScalar(g.y).addScaledVector(d,-m.y).multiplyScalar(G),v.copy(d).multiplyScalar(m.x).addScaledVector(h,-g.x).multiplyScalar(G),s[k].add(_),s[P].add(_),s[N].add(_),l[k].add(v),l[P].add(v),l[N].add(v))}let T=this.groups;T.length===0&&(T=[{start:0,count:e.count}]);for(let k=0,P=T.length;k<P;++k){const N=T[k],G=N.start,te=N.count;for(let j=G,xe=G+te;j<xe;j+=3)b(e.getX(j+0),e.getX(j+1),e.getX(j+2))}const E=new Be,A=new Be,M=new Be,R=new Be;function C(k){M.fromBufferAttribute(i,k),R.copy(M);const P=s[k];E.copy(P),E.sub(M.multiplyScalar(M.dot(P))).normalize(),A.crossVectors(R,P);const G=A.dot(l[k])<0?-1:1;a.setXYZW(k,E.x,E.y,E.z,G)}for(let k=0,P=T.length;k<P;++k){const N=T[k],G=N.start,te=N.count;for(let j=G,xe=G+te;j<xe;j+=3)C(e.getX(j+0)),C(e.getX(j+1)),C(e.getX(j+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Es(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let p=0,m=n.count;p<m;p++)n.setXYZ(p,0,0,0);const i=new Be,r=new Be,a=new Be,s=new Be,l=new Be,c=new Be,h=new Be,d=new Be;if(e)for(let p=0,m=e.count;p<m;p+=3){const g=e.getX(p+0),_=e.getX(p+1),v=e.getX(p+2);i.fromBufferAttribute(t,g),r.fromBufferAttribute(t,_),a.fromBufferAttribute(t,v),h.subVectors(a,r),d.subVectors(i,r),h.cross(d),s.fromBufferAttribute(n,g),l.fromBufferAttribute(n,_),c.fromBufferAttribute(n,v),s.add(h),l.add(h),c.add(h),n.setXYZ(g,s.x,s.y,s.z),n.setXYZ(_,l.x,l.y,l.z),n.setXYZ(v,c.x,c.y,c.z)}else for(let p=0,m=t.count;p<m;p+=3)i.fromBufferAttribute(t,p+0),r.fromBufferAttribute(t,p+1),a.fromBufferAttribute(t,p+2),h.subVectors(a,r),d.subVectors(i,r),h.cross(d),n.setXYZ(p+0,h.x,h.y,h.z),n.setXYZ(p+1,h.x,h.y,h.z),n.setXYZ(p+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Un.fromBufferAttribute(e,t),Un.normalize(),e.setXYZ(t,Un.x,Un.y,Un.z)}toNonIndexed(){function e(s,l){const c=s.array,h=s.itemSize,d=s.normalized,p=new c.constructor(l.length*h);let m=0,g=0;for(let _=0,v=l.length;_<v;_++){s.isInterleavedBufferAttribute?m=l[_]*s.data.stride+s.offset:m=l[_]*h;for(let b=0;b<h;b++)p[g++]=c[m++]}return new Es(p,h,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new _L,n=this.index.array,i=this.attributes;for(const s in i){const l=i[s],c=e(l,n);t.setAttribute(s,c)}const r=this.morphAttributes;for(const s in r){const l=[],c=r[s];for(let h=0,d=c.length;h<d;h++){const p=c[h],m=e(p,n);l.push(m)}t.morphAttributes[s]=l}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let s=0,l=a.length;s<l;s++){const c=a[s];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const c=n[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let d=0,p=c.length;d<p;d++){const m=c[d];h.push(m.toJSON(e.data))}h.length>0&&(i[l]=h,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const s=this.boundingSphere;return s!==null&&(e.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i){const h=i[c];this.setAttribute(c,h.clone(t))}const r=e.morphAttributes;for(const c in r){const h=[],d=r[c];for(let p=0,m=d.length;p<m;p++)h.push(d[p].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let c=0,h=a.length;c<h;c++){const d=a[c];this.addGroup(d.start,d.count,d.materialIndex)}const s=e.boundingBox;s!==null&&(this.boundingBox=s.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}};class Dp extends dd{constructor(e=1,t=1,n=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:n,widthSegments:i,heightSegments:r,depthSegments:a};const s=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);const l=[],c=[],h=[],d=[];let p=0,m=0;g("z","y","x",-1,-1,n,t,e,a,r,0),g("z","y","x",1,-1,n,t,-e,a,r,1),g("x","z","y",1,1,e,n,t,i,a,2),g("x","z","y",1,-1,e,n,-t,i,a,3),g("x","y","z",1,-1,e,t,n,i,r,4),g("x","y","z",-1,-1,e,t,-n,i,r,5),this.setIndex(l),this.setAttribute("position",new fc(c,3)),this.setAttribute("normal",new fc(h,3)),this.setAttribute("uv",new fc(d,2));function g(_,v,b,T,E,A,M,R,C,k,P){const N=A/C,G=M/k,te=A/2,j=M/2,xe=R/2,ae=C+1,H=k+1;let re=0,q=0;const be=new Be;for(let K=0;K<H;K++){const se=K*G-j;for(let ge=0;ge<ae;ge++){const Me=ge*N-te;be[_]=Me*T,be[v]=se*E,be[b]=xe,c.push(be.x,be.y,be.z),be[_]=0,be[v]=0,be[b]=R>0?1:-1,h.push(be.x,be.y,be.z),d.push(ge/C),d.push(1-K/k),re+=1}}for(let K=0;K<k;K++)for(let se=0;se<C;se++){const ge=p+se+ae*K,Me=p+se+ae*(K+1),le=p+(se+1)+ae*(K+1),Se=p+(se+1)+ae*K;l.push(ge,Me,Se),l.push(Me,le,Se),q+=6}s.addGroup(m,q,P),m+=q,p+=re}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Dp(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}class pv extends dd{constructor(e=1,t=1,n=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:n,heightSegments:i};const r=e/2,a=t/2,s=Math.floor(n),l=Math.floor(i),c=s+1,h=l+1,d=e/s,p=t/l,m=[],g=[],_=[],v=[];for(let b=0;b<h;b++){const T=b*p-a;for(let E=0;E<c;E++){const A=E*d-r;g.push(A,-T,0),_.push(0,0,1),v.push(E/s),v.push(1-b/l)}}for(let b=0;b<l;b++)for(let T=0;T<s;T++){const E=T+c*b,A=T+c*(b+1),M=T+1+c*(b+1),R=T+1+c*b;m.push(E,A,R),m.push(A,M,R)}this.setIndex(m),this.setAttribute("position",new fc(g,3)),this.setAttribute("normal",new fc(_,3)),this.setAttribute("uv",new fc(v,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new pv(e.width,e.height,e.widthSegments,e.heightSegments)}}let txe=0,Wh=class extends hd{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:txe++}),this.uuid=Ip(),this.name="",this.type="Material",this.blending=dh,this.side=il,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=qT,this.blendDst=ew,this.blendEquation=nc,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new dx(0,0,0),this.blendAlpha=0,this.depthFunc=J1,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=YO,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=gu,this.stencilZFail=gu,this.stencilZPass=gu,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(n.dispersion=this.dispersion),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapRotation!==void 0&&(n.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==dh&&(n.blending=this.blending),this.side!==il&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==qT&&(n.blendSrc=this.blendSrc),this.blendDst!==ew&&(n.blendDst=this.blendDst),this.blendEquation!==nc&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==J1&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==YO&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==gu&&(n.stencilFail=this.stencilFail),this.stencilZFail!==gu&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==gu&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(r){const a=[];for(const s in r){const l=r[s];delete l.metadata,a.push(l)}return a}if(t){const r=i(e.textures),a=i(e.images);r.length>0&&(n.textures=r),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}};function Xh(x){const e={};for(const t in x){e[t]={};for(const n in x[t]){const i=x[t][n];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][n]=null):e[t][n]=i.clone():Array.isArray(i)?e[t][n]=i.slice():e[t][n]=i}}return e}function Ai(x){const e={};for(let t=0;t<x.length;t++){const n=Xh(x[t]);for(const i in n)e[i]=n[i]}return e}function xxe(x){const e=[];for(let t=0;t<x.length;t++)e.push(x[t].clone());return e}function SL(x){const e=x.getRenderTarget();return e===null?x.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:J0.workingColorSpace}const nxe={clone:Xh,merge:Ai},ixe=`
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`,rxe=`
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`;class rl extends Wh{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=ixe,this.fragmentShader=rxe,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Xh(e.uniforms),this.uniformsGroups=xxe(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const n={};for(const i in this.extensions)this.extensions[i]===!0&&(n[i]=!0);return Object.keys(n).length>0&&(t.extensions=n),t}}const so=new Be,q_=new Be,ry=new Be,M2=new Be,eS=new Be,ay=new Be,tS=new Be;let axe=class{constructor(e=new Be,t=new Be(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,so)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=so.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(so.copy(this.origin).addScaledVector(this.direction,t),so.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){q_.copy(e).add(t).multiplyScalar(.5),ry.copy(t).sub(e).normalize(),M2.copy(this.origin).sub(q_);const r=e.distanceTo(t)*.5,a=-this.direction.dot(ry),s=M2.dot(this.direction),l=-M2.dot(ry),c=M2.lengthSq(),h=Math.abs(1-a*a);let d,p,m,g;if(h>0)if(d=a*l-s,p=a*s-l,g=r*h,d>=0)if(p>=-g)if(p<=g){const _=1/h;d*=_,p*=_,m=d*(d+a*p+2*s)+p*(a*d+p+2*l)+c}else p=r,d=Math.max(0,-(a*p+s)),m=-d*d+p*(p+2*l)+c;else p=-r,d=Math.max(0,-(a*p+s)),m=-d*d+p*(p+2*l)+c;else p<=-g?(d=Math.max(0,-(-a*r+s)),p=d>0?-r:Math.min(Math.max(-r,-l),r),m=-d*d+p*(p+2*l)+c):p<=g?(d=0,p=Math.min(Math.max(-r,-l),r),m=p*(p+2*l)+c):(d=Math.max(0,-(a*r+s)),p=d>0?r:Math.min(Math.max(-r,-l),r),m=-d*d+p*(p+2*l)+c);else p=a>0?-r:r,d=Math.max(0,-(a*p+s)),m=-d*d+p*(p+2*l)+c;return n&&n.copy(this.origin).addScaledVector(this.direction,d),i&&i.copy(q_).addScaledVector(ry,p),m}intersectSphere(e,t){so.subVectors(e.center,this.origin);const n=so.dot(this.direction),i=so.dot(so)-n*n,r=e.radius*e.radius;if(i>r)return null;const a=Math.sqrt(r-i),s=n-a,l=n+a;return l<0?null:s<0?this.at(l,t):this.at(s,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,r,a,s,l;const c=1/this.direction.x,h=1/this.direction.y,d=1/this.direction.z,p=this.origin;return c>=0?(n=(e.min.x-p.x)*c,i=(e.max.x-p.x)*c):(n=(e.max.x-p.x)*c,i=(e.min.x-p.x)*c),h>=0?(r=(e.min.y-p.y)*h,a=(e.max.y-p.y)*h):(r=(e.max.y-p.y)*h,a=(e.min.y-p.y)*h),n>a||r>i||((r>n||isNaN(n))&&(n=r),(a<i||isNaN(i))&&(i=a),d>=0?(s=(e.min.z-p.z)*d,l=(e.max.z-p.z)*d):(s=(e.max.z-p.z)*d,l=(e.min.z-p.z)*d),n>l||s>i)||((s>n||n!==n)&&(n=s),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,so)!==null}intersectTriangle(e,t,n,i,r){eS.subVectors(t,e),ay.subVectors(n,e),tS.crossVectors(eS,ay);let a=this.direction.dot(tS),s;if(a>0){if(i)return null;s=1}else if(a<0)s=-1,a=-a;else return null;M2.subVectors(this.origin,e);const l=s*this.direction.dot(ay.crossVectors(M2,ay));if(l<0)return null;const c=s*this.direction.dot(eS.cross(M2));if(c<0||l+c>a)return null;const h=-s*M2.dot(tS);return h<0?null:this.at(h/a,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}};const Da=new Be,oo=new Be,xS=new Be,lo=new Be,Eu=new Be,Mu=new Be,aD=new Be,nS=new Be,iS=new Be,rS=new Be;let sy=class eh{constructor(e=new Be,t=new Be,n=new Be){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),Da.subVectors(e,t),i.cross(Da);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,n,i,r){Da.subVectors(i,t),oo.subVectors(n,t),xS.subVectors(e,t);const a=Da.dot(Da),s=Da.dot(oo),l=Da.dot(xS),c=oo.dot(oo),h=oo.dot(xS),d=a*c-s*s;if(d===0)return r.set(0,0,0),null;const p=1/d,m=(c*l-s*h)*p,g=(a*h-s*l)*p;return r.set(1-m-g,g,m)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,lo)===null?!1:lo.x>=0&&lo.y>=0&&lo.x+lo.y<=1}static getInterpolation(e,t,n,i,r,a,s,l){return this.getBarycoord(e,t,n,i,lo)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(r,lo.x),l.addScaledVector(a,lo.y),l.addScaledVector(s,lo.z),l)}static isFrontFacing(e,t,n,i){return Da.subVectors(n,t),oo.subVectors(e,t),Da.cross(oo).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Da.subVectors(this.c,this.b),oo.subVectors(this.a,this.b),Da.cross(oo).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return eh.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return eh.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,n,i,r){return eh.getInterpolation(e,this.a,this.b,this.c,t,n,i,r)}containsPoint(e){return eh.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return eh.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,r=this.c;let a,s;Eu.subVectors(i,n),Mu.subVectors(r,n),nS.subVectors(e,n);const l=Eu.dot(nS),c=Mu.dot(nS);if(l<=0&&c<=0)return t.copy(n);iS.subVectors(e,i);const h=Eu.dot(iS),d=Mu.dot(iS);if(h>=0&&d<=h)return t.copy(i);const p=l*d-h*c;if(p<=0&&l>=0&&h<=0)return a=l/(l-h),t.copy(n).addScaledVector(Eu,a);rS.subVectors(e,r);const m=Eu.dot(rS),g=Mu.dot(rS);if(g>=0&&m<=g)return t.copy(r);const _=m*c-l*g;if(_<=0&&c>=0&&g<=0)return s=c/(c-g),t.copy(n).addScaledVector(Mu,s);const v=h*g-m*d;if(v<=0&&d-h>=0&&m-g>=0)return aD.subVectors(r,i),s=(d-h)/(d-h+(m-g)),t.copy(i).addScaledVector(aD,s);const b=1/(v+_+p);return a=_*b,s=p*b,t.copy(n).addScaledVector(Eu,a).addScaledVector(Mu,s)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}},TL=class extends Wh{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new dx(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Nc,this.combine=ZB,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}};const sD=new Hn,Hl=new axe,oy=new IM,oD=new Be,Ru=new Be,Cu=new Be,Nu=new Be,aS=new Be,ly=new Be,cy=new fx,uy=new fx,hy=new fx,lD=new Be,cD=new Be,uD=new Be,dy=new Be,fy=new Be;let ws=class extends Xo{constructor(e=new dd,t=new TL){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const s=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=r}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,r=n.morphAttributes.position,a=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const s=this.morphTargetInfluences;if(r&&s){ly.set(0,0,0);for(let l=0,c=r.length;l<c;l++){const h=s[l],d=r[l];h!==0&&(aS.fromBufferAttribute(d,e),a?ly.addScaledVector(aS,h):ly.addScaledVector(aS.sub(t),h))}t.add(ly)}return t}raycast(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),oy.copy(n.boundingSphere),oy.applyMatrix4(r),Hl.copy(e.ray).recast(e.near),!(oy.containsPoint(Hl.origin)===!1&&(Hl.intersectSphere(oy,oD)===null||Hl.origin.distanceToSquared(oD)>(e.far-e.near)**2))&&(sD.copy(r).invert(),Hl.copy(e.ray).applyMatrix4(sD),!(n.boundingBox!==null&&Hl.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(e,t,Hl)))}_computeIntersections(e,t,n){let i;const r=this.geometry,a=this.material,s=r.index,l=r.attributes.position,c=r.attributes.uv,h=r.attributes.uv1,d=r.attributes.normal,p=r.groups,m=r.drawRange;if(s!==null)if(Array.isArray(a))for(let g=0,_=p.length;g<_;g++){const v=p[g],b=a[v.materialIndex],T=Math.max(v.start,m.start),E=Math.min(s.count,Math.min(v.start+v.count,m.start+m.count));for(let A=T,M=E;A<M;A+=3){const R=s.getX(A),C=s.getX(A+1),k=s.getX(A+2);i=py(this,b,e,n,c,h,d,R,C,k),i&&(i.faceIndex=Math.floor(A/3),i.face.materialIndex=v.materialIndex,t.push(i))}}else{const g=Math.max(0,m.start),_=Math.min(s.count,m.start+m.count);for(let v=g,b=_;v<b;v+=3){const T=s.getX(v),E=s.getX(v+1),A=s.getX(v+2);i=py(this,a,e,n,c,h,d,T,E,A),i&&(i.faceIndex=Math.floor(v/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(a))for(let g=0,_=p.length;g<_;g++){const v=p[g],b=a[v.materialIndex],T=Math.max(v.start,m.start),E=Math.min(l.count,Math.min(v.start+v.count,m.start+m.count));for(let A=T,M=E;A<M;A+=3){const R=A,C=A+1,k=A+2;i=py(this,b,e,n,c,h,d,R,C,k),i&&(i.faceIndex=Math.floor(A/3),i.face.materialIndex=v.materialIndex,t.push(i))}}else{const g=Math.max(0,m.start),_=Math.min(l.count,m.start+m.count);for(let v=g,b=_;v<b;v+=3){const T=v,E=v+1,A=v+2;i=py(this,a,e,n,c,h,d,T,E,A),i&&(i.faceIndex=Math.floor(v/3),t.push(i))}}}};function sxe(x,e,t,n,i,r,a,s){let l;if(e.side===er?l=n.intersectTriangle(a,r,i,!0,s):l=n.intersectTriangle(i,r,a,e.side===il,s),l===null)return null;fy.copy(s),fy.applyMatrix4(x.matrixWorld);const c=t.ray.origin.distanceTo(fy);return c<t.near||c>t.far?null:{distance:c,point:fy.clone(),object:x}}function py(x,e,t,n,i,r,a,s,l,c){x.getVertexPosition(s,Ru),x.getVertexPosition(l,Cu),x.getVertexPosition(c,Nu);const h=sxe(x,e,t,n,Ru,Cu,Nu,dy);if(h){i&&(cy.fromBufferAttribute(i,s),uy.fromBufferAttribute(i,l),hy.fromBufferAttribute(i,c),h.uv=sy.getInterpolation(dy,Ru,Cu,Nu,cy,uy,hy,new fx)),r&&(cy.fromBufferAttribute(r,s),uy.fromBufferAttribute(r,l),hy.fromBufferAttribute(r,c),h.uv1=sy.getInterpolation(dy,Ru,Cu,Nu,cy,uy,hy,new fx)),a&&(lD.fromBufferAttribute(a,s),cD.fromBufferAttribute(a,l),uD.fromBufferAttribute(a,c),h.normal=sy.getInterpolation(dy,Ru,Cu,Nu,lD,cD,uD,new Be),h.normal.dot(n.direction)>0&&h.normal.multiplyScalar(-1));const d={a:s,b:l,c,normal:new Be,materialIndex:0};sy.getNormal(Ru,Cu,Nu,d.normal),h.face=d}return h}const oxe=`
#ifdef USE_ALPHAHASH

	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;

#endif
`,lxe=`
#ifdef USE_ALPHAHASH

	/**
	 * See: https://casual-effects.com/research/Wyman2017Hashed/index.html
	 */

	const float ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

	float hash2D( vec2 value ) {

		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );

	}

	float hash3D( vec3 value ) {

		return hash2D( vec2( hash2D( value.xy ), value.z ) );

	}

	float getAlphaHashThreshold( vec3 position ) {

		// Find the discretized derivatives of our coordinates
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );

		// Find two nearest log-discretized noise scales
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);

		// Compute alpha thresholds at our two noise scales
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);

		// Factor to interpolate lerp with
		float lerpFactor = fract( log2( pixScale ) );

		// Interpolate alpha threshold from noise at two scales
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;

		// Pass into CDF to compute uniformly distrib threshold
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);

		// Find our final, uniformly distributed alpha threshold ()
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;

		// Avoids  == 0. Could also do  =1-
		return clamp( threshold , 1.0e-6, 1.0 );

	}

#endif
`,cxe=`
#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;

#endif
`,uxe=`
#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`,hxe=`
#ifdef USE_ALPHATEST

	#ifdef ALPHA_TO_COVERAGE

	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;

	#else

	if ( diffuseColor.a < alphaTest ) discard;

	#endif

#endif
`,dxe=`
#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif
`,fxe=`
#ifdef USE_AOMAP

	// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;

	reflectedLight.indirectDiffuse *= ambientOcclusion;

	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD )

		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );

		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );

	#endif

#endif
`,pxe=`
#ifdef USE_AOMAP

	uniform sampler2D aoMap;
	uniform float aoMapIntensity;

#endif
`,mxe=`
#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif

	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {

		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );

	}

	float getIndirectIndex( const in int i ) {

		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );

	}

#endif

#ifdef USE_BATCHING_COLOR

	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {

		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;

	}

#endif
`,yxe=`
#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif
`,gxe=`
vec3 transformed = vec3( position );

#ifdef USE_ALPHAHASH

	vPosition = vec3( position );

#endif
`,vxe=`
vec3 objectNormal = vec3( normal );

#ifdef USE_TANGENT

	vec3 objectTangent = vec3( tangent.xyz );

#endif
`,bxe=`

float G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {

	// geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)
	return 0.25;

}

float D_BlinnPhong( const in float shininess, const in float dotNH ) {

	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );

}

vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( specularColor, 1.0, dotVH );

	float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );

	float D = D_BlinnPhong( shininess, dotNH );

	return F * ( G * D );

} // validated

`,_xe=`

#ifdef USE_IRIDESCENCE

	// XYZ to linear-sRGB color space
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);

	// Assume air interface for top
	// Note: We don't handle the case fresnel0 == 1
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {

		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );

	}

	// Conversion FO/IOR
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {

		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );

	}

	// ior is a value between 1.0 and 3.0. 1.0 is air interface
	float IorToFresnel0( float transmittedIor, float incidentIor ) {

		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));

	}

	// Fresnel equations for dielectric/dielectric interfaces.
	// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
	// Evaluation XYZ sensitivity curves in Fourier space
	vec3 evalSensitivity( float OPD, vec3 shift ) {

		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );

		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;

		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;

	}

	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {

		vec3 I;

		// Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		// Evaluate the cosTheta on the base layer (Snell law)
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );

		// Handle TIR:
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {

			return vec3( 1.0 );

		}

		float cosTheta2 = sqrt( cosTheta2Sq );

		// First interface
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;

		// Second interface
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0
		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;

		// Phase shift
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;

		// Compound terms
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );

		// Reflectance term for m = 0 (DC term amplitude)
		vec3 C0 = R12 + Rs;
		I = C0;

		// Reflectance term for m > 0 (pairs of diracs)
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {

			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;

		}

		// Since out of gamut colors might be produced, negative color values are clamped to 0.
		return max( I, vec3( 0.0 ) );

	}

#endif

`,Sxe=`
#ifdef USE_BUMPMAP

	uniform sampler2D bumpMap;
	uniform float bumpScale;

	// Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
	// https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

	// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

	vec2 dHdxy_fwd() {

		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );

		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;

		return vec2( dBx, dBy );

	}

	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {

		// normalize is done to ensure that the bump map looks the same regardless of the texture's scale
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm; // normalized

		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );

		float fDet = dot( vSigmaX, R1 ) * faceDirection;

		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );

	}

#endif
`,Txe=`
#if NUM_CLIPPING_PLANES > 0

	vec4 plane;

	#ifdef ALPHA_TO_COVERAGE

		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;

		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );

			if ( clipOpacity == 0.0 ) discard;

		}
		#pragma unroll_loop_end

		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

			float unionClipOpacity = 1.0;

			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );

			}
			#pragma unroll_loop_end

			clipOpacity *= 1.0 - unionClipOpacity;

		#endif

		diffuseColor.a *= clipOpacity;

		if ( diffuseColor.a == 0.0 ) discard;

	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {

			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;

		}
		#pragma unroll_loop_end

		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES

			bool clipped = true;

			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {

				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;

			}
			#pragma unroll_loop_end

			if ( clipped ) discard;

		#endif

	#endif

#endif
`,wxe=`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];

#endif
`,Axe=`
#if NUM_CLIPPING_PLANES > 0

	varying vec3 vClipPosition;

#endif
`,Exe=`
#if NUM_CLIPPING_PLANES > 0

	vClipPosition = - mvPosition.xyz;

#endif
`,Mxe=`
#if defined( USE_COLOR_ALPHA )

	diffuseColor *= vColor;

#elif defined( USE_COLOR )

	diffuseColor.rgb *= vColor;

#endif
`,Rxe=`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR )

	varying vec3 vColor;

#endif
`,Cxe=`
#if defined( USE_COLOR_ALPHA )

	varying vec4 vColor;

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )

	varying vec3 vColor;

#endif
`,Nxe=`
#if defined( USE_COLOR_ALPHA )

	vColor = vec4( 1.0 );

#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )

	vColor = vec3( 1.0 );

#endif

#ifdef USE_COLOR

	vColor *= color;

#endif

#ifdef USE_INSTANCING_COLOR

	vColor.xyz *= instanceColor.xyz;

#endif

#ifdef USE_BATCHING_COLOR

	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );

	vColor.xyz *= batchingColor.xyz;

#endif
`,Ixe=`
#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6

#ifndef saturate
// <tonemapping_pars_fragment> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )

float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }

// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.
// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/
highp float rand( const in vec2 uv ) {

	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );

	return fract( sin( sn ) * c );

}

#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif

struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};

struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};

#ifdef USE_ALPHAHASH

	varying vec3 vPosition;

#endif

vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

}

vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {

	// dir can be either a direction vector or a normal vector
	// upper-left 3x3 of matrix is assumed to be orthogonal

	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );

}

mat3 transposeMat3( const in mat3 m ) {

	mat3 tmp;

	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );

	return tmp;

}

bool isPerspectiveMatrix( mat4 m ) {

	return m[ 2 ][ 3 ] == - 1.0;

}

vec2 equirectUv( in vec3 dir ) {

	// dir is assumed to be unit length

	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;

	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;

	return vec2( u, v );

}

vec3 BRDF_Lambert( const in vec3 diffuseColor ) {

	return RECIPROCAL_PI * diffuseColor;

} // validated

vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated

float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {

	// Original approximation by Christophe Schlick '94
	// float fresnel = pow( 1.0 - dotVH, 5.0 );

	// Optimized variant (presented by Epic at SIGGRAPH '13)
	// https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );

	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );

} // validated
`,Oxe=`
#ifdef ENVMAP_TYPE_CUBE_UV

	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0

	// These shader functions convert between the UV coordinates of a single face of
	// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
	// sampling a textureCube (not generally normalized ).

	float getFace( vec3 direction ) {

		vec3 absDirection = abs( direction );

		float face = - 1.0;

		if ( absDirection.x > absDirection.z ) {

			if ( absDirection.x > absDirection.y )

				face = direction.x > 0.0 ? 0.0 : 3.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		} else {

			if ( absDirection.z > absDirection.y )

				face = direction.z > 0.0 ? 2.0 : 5.0;

			else

				face = direction.y > 0.0 ? 1.0 : 4.0;

		}

		return face;

	}

	// RH coordinate system; PMREM face-indexing convention
	vec2 getUV( vec3 direction, float face ) {

		vec2 uv;

		if ( face == 0.0 ) {

			uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x

		} else if ( face == 1.0 ) {

			uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y

		} else if ( face == 2.0 ) {

			uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z

		} else if ( face == 3.0 ) {

			uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x

		} else if ( face == 4.0 ) {

			uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y

		} else {

			uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z

		}

		return 0.5 * ( uv + 1.0 );

	}

	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {

		float face = getFace( direction );

		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );

		mipInt = max( mipInt, cubeUV_minMipLevel );

		float faceSize = exp2( mipInt );

		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0; // #25071

		if ( face > 2.0 ) {

			uv.y += faceSize;

			face -= 3.0;

		}

		uv.x += face * faceSize;

		uv.x += filterInt * 3.0 * cubeUV_minTileSize;

		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );

		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;

		#ifdef texture2DGradEXT

			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering

		#else

			return texture2D( envMap, uv ).rgb;

		#endif

	}

	// These defines must match with PMREMGenerator

	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0

	float roughnessToMip( float roughness ) {

		float mip = 0.0;

		if ( roughness >= cubeUV_r1 ) {

			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;

		} else if ( roughness >= cubeUV_r4 ) {

			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;

		} else if ( roughness >= cubeUV_r5 ) {

			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;

		} else if ( roughness >= cubeUV_r6 ) {

			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;

		} else {

			mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
		}

		return mip;

	}

	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {

		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );

		float mipF = fract( mip );

		float mipInt = floor( mip );

		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );

		if ( mipF == 0.0 ) {

			return vec4( color0, 1.0 );

		} else {

			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );

			return vec4( mix( color0, color1, mipF ), 1.0 );

		}

	}

#endif
`,Dxe=`

vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT

	vec3 transformedTangent = objectTangent;

#endif

#ifdef USE_BATCHING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = bm * transformedTangent;

	#endif

#endif

#ifdef USE_INSTANCING

	// this is in lieu of a per-instance normal-matrix
	// shear transforms in the instance matrix are not supported

	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;

	#ifdef USE_TANGENT

		transformedTangent = im * transformedTangent;

	#endif

#endif

transformedNormal = normalMatrix * transformedNormal;

#ifdef FLIP_SIDED

	transformedNormal = - transformedNormal;

#endif

#ifdef USE_TANGENT

	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;

	#ifdef FLIP_SIDED

		transformedTangent = - transformedTangent;

	#endif

#endif
`,Pxe=`
#ifdef USE_DISPLACEMENTMAP

	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;

#endif
`,kxe=`
#ifdef USE_DISPLACEMENTMAP

	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );

#endif
`,Uxe=`
#ifdef USE_EMISSIVEMAP

	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );

	totalEmissiveRadiance *= emissiveColor.rgb;

#endif
`,Fxe=`
#ifdef USE_EMISSIVEMAP

	uniform sampler2D emissiveMap;

#endif
`,Bxe=`
gl_FragColor = linearToOutputTexel( gl_FragColor );
`,Lxe=`

// http://www.russellcottrell.com/photo/matrixCalculator.htm

// Linear sRGB => XYZ => Linear Display P3
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);

// Linear Display P3 => XYZ => Linear sRGB
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);

vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}

vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}

vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}

vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}

`,zxe=`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vec3 cameraToFrag;

		if ( isOrthographic ) {

			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToFrag = normalize( vWorldPosition - cameraPosition );

		}

		// Transforming Normal Vectors with the Inverse Transformation
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vec3 reflectVec = reflect( cameraToFrag, worldNormal );

		#else

			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );

		#endif

	#else

		vec3 reflectVec = vReflect;

	#endif

	#ifdef ENVMAP_TYPE_CUBE

		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );

	#else

		vec4 envColor = vec4( 0.0 );

	#endif

	#ifdef ENVMAP_BLENDING_MULTIPLY

		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_MIX )

		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );

	#elif defined( ENVMAP_BLENDING_ADD )

		outgoingLight += envColor.xyz * specularStrength * reflectivity;

	#endif

#endif
`,Vxe=`
#ifdef USE_ENVMAP

	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;

	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif
`,Hxe=`
#ifdef USE_ENVMAP

	uniform float reflectivity;

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS

		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif

#endif
`,Gxe=`
#ifdef USE_ENVMAP

	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )

		#define ENV_WORLDPOS

	#endif

	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;

	#else

		varying vec3 vReflect;
		uniform float refractionRatio;

	#endif

#endif
`,Wxe=`
#ifdef USE_ENVMAP

	#ifdef ENV_WORLDPOS

		vWorldPosition = worldPosition.xyz;

	#else

		vec3 cameraToVertex;

		if ( isOrthographic ) {

			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );

		} else {

			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );

		}

		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );

		#ifdef ENVMAP_MODE_REFLECTION

			vReflect = reflect( cameraToVertex, worldNormal );

		#else

			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );

		#endif

	#endif

#endif
`,Xxe=`
#ifdef USE_FOG

	vFogDepth = - mvPosition.z;

#endif
`,Yxe=`
#ifdef USE_FOG

	varying float vFogDepth;

#endif
`,Kxe=`
#ifdef USE_FOG

	#ifdef FOG_EXP2

		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );

	#else

		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );

	#endif

	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );

#endif
`,$xe=`
#ifdef USE_FOG

	uniform vec3 fogColor;
	varying float vFogDepth;

	#ifdef FOG_EXP2

		uniform float fogDensity;

	#else

		uniform float fogNear;
		uniform float fogFar;

	#endif

#endif
`,Qxe=`

#ifdef USE_GRADIENTMAP

	uniform sampler2D gradientMap;

#endif

vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {

	// dotNL will be from -1.0 to 1.0
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );

	#ifdef USE_GRADIENTMAP

		return vec3( texture2D( gradientMap, coord ).r );

	#else

		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );

	#endif

}
`,Zxe=`
#ifdef USE_LIGHTMAP

	uniform sampler2D lightMap;
	uniform float lightMapIntensity;

#endif
`,Jxe=`
LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;
`,jxe=`
varying vec3 vViewPosition;

struct LambertMaterial {

	vec3 diffuseColor;
	float specularStrength;

};

void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert
`,qxe=`
uniform bool receiveShadow;
uniform vec3 ambientLightColor;

#if defined( USE_LIGHT_PROBES )

	uniform vec3 lightProbe[ 9 ];

#endif

// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere
// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {

	// normal is assumed to have unit length

	float x = normal.x, y = normal.y, z = normal.z;

	// band 0
	vec3 result = shCoefficients[ 0 ] * 0.886227;

	// band 1
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;

	// band 2
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );

	return result;

}

vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {

	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );

	return irradiance;

}

vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {

	vec3 irradiance = ambientLightColor;

	return irradiance;

}

float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {

	// based upon Frostbite 3 Moving to Physically-based Rendering
	// page 32, equation 26: E[window1]
	// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );

	if ( cutoffDistance > 0.0 ) {

		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );

	}

	return distanceFalloff;

}

float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {

	return smoothstep( coneCosine, penumbraCosine, angleCosine );

}

#if NUM_DIR_LIGHTS > 0

	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};

	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];

	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {

		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;

	}

#endif


#if NUM_POINT_LIGHTS > 0

	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};

	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {

		vec3 lVector = pointLight.position - geometryPosition;

		light.direction = normalize( lVector );

		float lightDistance = length( lVector );

		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );

	}

#endif


#if NUM_SPOT_LIGHTS > 0

	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};

	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];

	// light is an out parameter as having it as a return value caused compiler errors on some devices
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {

		vec3 lVector = spotLight.position - geometryPosition;

		light.direction = normalize( lVector );

		float angleCos = dot( light.direction, spotLight.direction );

		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );

		if ( spotAttenuation > 0.0 ) {

			float lightDistance = length( lVector );

			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );

		} else {

			light.color = vec3( 0.0 );
			light.visible = false;

		}

	}

#endif


#if NUM_RECT_AREA_LIGHTS > 0

	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};

	// Pre-computed values of LinearTransformedCosine approximation of BRDF
	// BRDF approximation Texture is 64x64
	uniform sampler2D ltc_1; // RGBA Float
	uniform sampler2D ltc_2; // RGBA Float

	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];

#endif


#if NUM_HEMI_LIGHTS > 0

	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};

	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];

	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {

		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;

		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );

		return irradiance;

	}

#endif
`,ene=`
#ifdef USE_ENVMAP

	vec3 getIBLIrradiance( const in vec3 normal ) {

		#ifdef ENVMAP_TYPE_CUBE_UV

			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );

			return PI * envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {

		#ifdef ENVMAP_TYPE_CUBE_UV

			vec3 reflectVec = reflect( - viewDir, normal );

			// Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );

			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );

			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );

			return envMapColor.rgb * envMapIntensity;

		#else

			return vec3( 0.0 );

		#endif

	}

	#ifdef USE_ANISOTROPY

		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {

			#ifdef ENVMAP_TYPE_CUBE_UV

			  // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );

				return getIBLRadiance( viewDir, bentNormal, roughness );

			#else

				return vec3( 0.0 );

			#endif

		}

	#endif

#endif
`,tne=`
ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;
`,xne=`
varying vec3 vViewPosition;

struct ToonMaterial {

	vec3 diffuseColor;

};

void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
`,nne=`
BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;
`,ine=`
varying vec3 vViewPosition;

struct BlinnPhongMaterial {

	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;

};

void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;

}

void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
`,rne=`
PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );

vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );

material.roughness = max( roughnessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.
material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );

#ifdef IOR

	material.ior = ior;

	#ifdef USE_SPECULAR

		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;

		#ifdef USE_SPECULAR_COLORMAP

			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;

		#endif

		#ifdef USE_SPECULAR_INTENSITYMAP

			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;

		#endif

		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );

	#else

		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;

	#endif

	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );

#else

	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;

#endif

#ifdef USE_CLEARCOAT

	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;

	#ifdef USE_CLEARCOATMAP

		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;

	#endif

	#ifdef USE_CLEARCOAT_ROUGHNESSMAP

		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;

	#endif

	material.clearcoat = saturate( material.clearcoat ); // Burley clearcoat model
	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );

#endif

#ifdef USE_DISPERSION

	material.dispersion = dispersion;

#endif

#ifdef USE_IRIDESCENCE

	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;

	#ifdef USE_IRIDESCENCEMAP

		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;

	#endif

	#ifdef USE_IRIDESCENCE_THICKNESSMAP

		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;

	#else

		material.iridescenceThickness = iridescenceThicknessMaximum;

	#endif

#endif

#ifdef USE_SHEEN

	material.sheenColor = sheenColor;

	#ifdef USE_SHEEN_COLORMAP

		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;

	#endif

	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );

	#ifdef USE_SHEEN_ROUGHNESSMAP

		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;

	#endif

#endif

#ifdef USE_ANISOTROPY

	#ifdef USE_ANISOTROPYMAP

		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;

	#else

		vec2 anisotropyV = anisotropyVector;

	#endif

	material.anisotropy = length( anisotropyV );

	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}

	// Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );

	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;

#endif
`,ane=`

struct PhysicalMaterial {

	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;

	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif

	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif

	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif

	#ifdef IOR
		float ior;
	#endif

	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif

	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif

};

// temporary
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );

vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );

    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}

// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {

	float a2 = pow2( alpha );

	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );

	return 0.5 / max( gv + gl, EPSILON );

}

// Microfacet Models for Refraction through Rough Surfaces - equation (33)
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
// alpha is "roughness squared" in Disneys reparameterization
float D_GGX( const in float alpha, const in float dotNH ) {

	float a2 = pow2( alpha );

	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1

	return RECIPROCAL_PI * a2 / pow2( denom );

}

// https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf
#ifdef USE_ANISOTROPY

	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {

		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );

		return saturate(v);

	}

	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {

		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;

		return RECIPROCAL_PI * a2 * pow2 ( w2 );

	}

#endif

#ifdef USE_CLEARCOAT

	// GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {

		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;

		float alpha = pow2( roughness ); // UE4's roughness

		vec3 halfDir = normalize( lightDir + viewDir );

		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );

		vec3 F = F_Schlick( f0, f90, dotVH );

		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

		float D = D_GGX( alpha, dotNH );

		return F * ( V * D );

	}

#endif

vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {

	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;

	float alpha = pow2( roughness ); // UE4's roughness

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );

	vec3 F = F_Schlick( f0, f90, dotVH );

	#ifdef USE_IRIDESCENCE

		F = mix( F, material.iridescenceFresnel, material.iridescence );

	#endif

	#ifdef USE_ANISOTROPY

		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );

		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );

		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );

	#else

		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );

		float D = D_GGX( alpha, dotNH );

	#endif

	return F * ( V * D );

}

// Rect Area Light

// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
// code: https://github.com/selfshadow/ltc_code/

vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	float dotNV = saturate( dot( N, V ) );

	// texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );

	uv = uv * LUT_SCALE + LUT_BIAS;

	return uv;

}

float LTC_ClippedSphereFormFactor( const in vec3 f ) {

	// Real-Time Area Lighting: a Journey from Research to Production (p.102)
	// An approximation of the form factor of a horizon-clipped rectangle.

	float l = length( f );

	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );

}

vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {

	float x = dot( v1, v2 );

	float y = abs( x );

	// rational polynomial approximation to theta / sin( theta ) / 2PI
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;

	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;

	return cross( v1, v2 ) * theta_sintheta;

}

vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {

	// bail if point is on back side of plane of light
	// assumes ccw winding order of light vertices
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );

	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );

	// construct orthonormal basis around N
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system

	// compute transform
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );

	// transform rect
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );

	// project rect onto sphere
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );

	// calculate vector form factor
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );

	// adjust for horizon clipping
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );

/*
	// alternate method of adjusting for horizon clipping (see referece)
	// refactoring required
	float len = length( vectorFormFactor );
	float z = vectorFormFactor.z / len;

	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;

	// tabulated horizon-clipped sphere, apparently...
	vec2 uv = vec2( z * 0.5 + 0.5, len );
	uv = uv * LUT_SCALE + LUT_BIAS;

	float scale = texture2D( ltc_2, uv ).w;

	float result = len * scale;
*/

	return vec3( result );

}

// End Rect Area Light

#if defined( USE_SHEEN )

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float D_Charlie( float roughness, float dotNH ) {

	float alpha = pow2( roughness );

	// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 ); // 2^(-14/2), so sin2h^2 > 0 in fp16

	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );

}

// https://github.com/google/filament/blob/master/shaders/src/brdf.fs
float V_Neubelt( float dotNV, float dotNL ) {

	// Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );

}

vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {

	vec3 halfDir = normalize( lightDir + viewDir );

	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );

	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );

	return sheenColor * ( D * V );

}

#endif

// This is a curve-fit approxmation to the "Charlie sheen" BRDF integrated over the hemisphere from 
// Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
// in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	float r2 = roughness * roughness;

	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;

	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;

	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );

	return saturate( DG * RECIPROCAL_PI );

}

// Analytical approximation of the DFG LUT, one half of the
// split-sum approximation used in indirect specular lighting.
// via 'environmentBRDF' from "Physically Based Shading on Mobile"
// https://www.unrealengine.com/blog/physically-based-shading-on-mobile
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {

	float dotNV = saturate( dot( normal, viewDir ) );

	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );

	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );

	vec4 r = roughness * c0 + c1;

	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;

	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;

	return fab;

}

vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	return specularColor * fab.x + specularF90 * fab.y;

}

// Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
// Approximates multiscattering in order to preserve energy.
// http://www.jcgt.org/published/0008/01/03/
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif

	vec2 fab = DFGApprox( normal, viewDir, roughness );

	#ifdef USE_IRIDESCENCE

		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );

	#else

		vec3 Fr = specularColor;

	#endif

	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;

	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;

	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619; // 1/21
	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );

	singleScatter += FssEss;
	multiScatter += Fms * Ems;

}

#if NUM_RECT_AREA_LIGHTS > 0

	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;

		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight; // counterclockwise; light shines in local neg z direction
		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;

		vec2 uv = LTC_Uv( normal, viewDir, roughness );

		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );

		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);

		// LTC Fresnel Approximation by Stephen Hill
		// http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );

		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );

		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );

	}

#endif

void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );

	vec3 irradiance = dotNL * directLight.color;

	#ifdef USE_CLEARCOAT

		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );

		vec3 ccIrradiance = dotNLcc * directLight.color;

		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );

	#endif

	#ifdef USE_SHEEN

		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );

	#endif

	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );

	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}

void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {

	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );

}

void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {

	#ifdef USE_CLEARCOAT

		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );

	#endif

	#ifdef USE_SHEEN

		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );

	#endif

	// Both indirect specular and indirect diffuse light accumulate here

	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;

	#ifdef USE_IRIDESCENCE

		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );

	#else

		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );

	#endif

	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );

	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;

	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;

}

#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical

// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {

	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );

}
`,sne=`
/**
 * This is a template that can be used to light a material, it uses pluggable
 * RenderEquations (RE)for specific lighting scenarios.
 *
 * Instructions for use:
 * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined
 * - Create a material parameter that is to be passed as the third parameter to your lighting functions.
 *
 * TODO:
 * - Add area light support.
 * - Add sphere light support.
 * - Add diffuse light probe (irradiance cubemap) support.
 */

vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal = vec3( 0.0 );

#ifdef USE_CLEARCOAT

	geometryClearcoatNormal = clearcoatNormal;

#endif

#ifdef USE_IRIDESCENCE

	float dotNVi = saturate( dot( normal, geometryViewDir ) );

	if ( material.iridescenceThickness == 0.0 ) {

		material.iridescence = 0.0;

	} else {

		material.iridescence = saturate( material.iridescence );

	}

	if ( material.iridescence > 0.0 ) {

		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );

		// Iridescence F0 approximation
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );

	}

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;

	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

		// spot lights are ordered [shadows with maps, shadows without maps, maps without shadows, none]
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif

		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif

		#undef SPOT_LIGHT_MAP_INDEX

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`,one=`
#if defined( RE_IndirectDiffuse )

	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;

		irradiance += lightMapIrradiance;

	#endif

	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )

		iblIrradiance += getIBLIrradiance( geometryNormal );

	#endif

#endif

#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )

	#ifdef USE_ANISOTROPY

		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );

	#else

		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );

	#endif

	#ifdef USE_CLEARCOAT

		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );

	#endif

#endif
`,lne=`
#if defined( RE_IndirectDiffuse )

	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

#endif

#if defined( RE_IndirectSpecular )

	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

#endif
`,cne=`
#if defined( USE_LOGDEPTHBUF )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`,une=`
#if defined( USE_LOGDEPTHBUF )

	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`,hne=`
#ifdef USE_LOGDEPTHBUF

	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`,dne=`
#ifdef USE_LOGDEPTHBUF

	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );

#endif
`,fne=`
#ifdef USE_MAP

	vec4 sampledDiffuseColor = texture2D( map, vMapUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// use inline sRGB decode until browsers properly support SRGB8_ALPHA8 with video textures (#26516)

		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif

	diffuseColor *= sampledDiffuseColor;

#endif
`,pne=`
#ifdef USE_MAP

	uniform sampler2D map;

#endif
`,mne=`
#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

	#if defined( USE_POINTS_UV )

		vec2 uv = vUv;

	#else

		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;

	#endif

#endif

#ifdef USE_MAP

	diffuseColor *= texture2D( map, uv );

#endif

#ifdef USE_ALPHAMAP

	diffuseColor.a *= texture2D( alphaMap, uv ).g;

#endif
`,yne=`
#if defined( USE_POINTS_UV )

	varying vec2 vUv;

#else

	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )

		uniform mat3 uvTransform;

	#endif

#endif

#ifdef USE_MAP

	uniform sampler2D map;

#endif

#ifdef USE_ALPHAMAP

	uniform sampler2D alphaMap;

#endif
`,gne=`
float metalnessFactor = metalness;

#ifdef USE_METALNESSMAP

	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );

	// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	metalnessFactor *= texelMetalness.b;

#endif
`,vne=`
#ifdef USE_METALNESSMAP

	uniform sampler2D metalnessMap;

#endif
`,bne=`
#ifdef USE_INSTANCING_MORPH

	float morphTargetInfluences[ MORPHTARGETS_COUNT ];

	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;

	}
#endif
`,_ne=`
#if defined( USE_MORPHCOLORS )

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	vColor *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		#if defined( USE_COLOR_ALPHA )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];

		#elif defined( USE_COLOR )

			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];

		#endif

	}

#endif
`,Sne=`
#ifdef USE_MORPHNORMALS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	objectNormal *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];

	}

#endif
`,Tne=`
#ifdef USE_MORPHTARGETS

	#ifndef USE_INSTANCING_MORPH

		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];

	#endif

	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;

	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {

		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;

		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );

	}

#endif
`,wne=`
#ifdef USE_MORPHTARGETS

	// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:
	// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in position = sum((target - base) * influence)
	// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting
	transformed *= morphTargetBaseInfluence;

	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {

		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];

	}

#endif
`,Ane=`
float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;

#ifdef FLAT_SHADED

	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );

#else

	vec3 normal = normalize( vNormal );

	#ifdef DOUBLE_SIDED

		normal *= faceDirection;

	#endif

#endif

#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )

	#ifdef USE_TANGENT

		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

	#else

		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);

	#endif

	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;

	#endif

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	#ifdef USE_TANGENT

		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );

	#else

		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );

	#endif

	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )

		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;

	#endif

#endif

// non perturbed normal for clearcoat among others

vec3 nonPerturbedNormal = normal;

`,Ene=`

#ifdef USE_NORMALMAP_OBJECTSPACE

	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals

	#ifdef FLIP_SIDED

		normal = - normal;

	#endif

	#ifdef DOUBLE_SIDED

		normal = normal * faceDirection;

	#endif

	normal = normalize( normalMatrix * normal );

#elif defined( USE_NORMALMAP_TANGENTSPACE )

	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;

	normal = normalize( tbn * mapN );

#elif defined( USE_BUMPMAP )

	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );

#endif
`,Mne=`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`,Rne=`
#ifndef FLAT_SHADED

	varying vec3 vNormal;

	#ifdef USE_TANGENT

		varying vec3 vTangent;
		varying vec3 vBitangent;

	#endif

#endif
`,Cne=`
#ifndef FLAT_SHADED // normal is computed with derivatives when FLAT_SHADED

	vNormal = normalize( transformedNormal );

	#ifdef USE_TANGENT

		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );

	#endif

#endif
`,Nne=`
#ifdef USE_NORMALMAP

	uniform sampler2D normalMap;
	uniform vec2 normalScale;

#endif

#ifdef USE_NORMALMAP_OBJECTSPACE

	uniform mat3 normalMatrix;

#endif

#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )

	// Normal Mapping Without Precomputed Tangents
	// http://www.thetenthplanet.de/archives/1180

	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {

		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );

		vec3 N = surf_norm; // normalized

		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );

		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;

		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );

		return mat3( T * scale, B * scale, N );

	}

#endif
`,Ine=`
#ifdef USE_CLEARCOAT

	vec3 clearcoatNormal = nonPerturbedNormal;

#endif
`,One=`
#ifdef USE_CLEARCOAT_NORMALMAP

	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;

	clearcoatNormal = normalize( tbn2 * clearcoatMapN );

#endif
`,Dne=`

#ifdef USE_CLEARCOATMAP

	uniform sampler2D clearcoatMap;

#endif

#ifdef USE_CLEARCOAT_NORMALMAP

	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;

#endif

#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform sampler2D clearcoatRoughnessMap;

#endif
`,Pne=`

#ifdef USE_IRIDESCENCEMAP

	uniform sampler2D iridescenceMap;

#endif

#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform sampler2D iridescenceThicknessMap;

#endif
`,kne=`
#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif

#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif

gl_FragColor = vec4( outgoingLight, diffuseColor.a );
`,Une=`
vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}

vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}

const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)
const float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)
const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;

const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );

const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );

vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}

vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	// the 0.9999 tweak is unimportant, very tiny empirical improvement
	// return vec3( vuf * Inv255, gf * PackUpscale, bf * 0.9999 );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}

vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}

float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}

float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}

float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}

vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}

vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}

// NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	// -near maps to 0; -far maps to 1
	return ( viewZ + near ) / ( near - far );
}

float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	// maps orthographic depth in [ 0, 1 ] to viewZ
	return depth * ( near - far ) - near;
}

// NOTE: https://twitter.com/gonnavis/status/1377183786949959682

float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	// -near maps to 0; -far maps to 1
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}

float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	// maps perspective depth in [ 0, 1 ] to viewZ
	return ( near * far ) / ( ( far - near ) * depth - far );
}
`,Fne=`
#ifdef PREMULTIPLIED_ALPHA

	// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.
	gl_FragColor.rgb *= gl_FragColor.a;

#endif
`,Bne=`
vec4 mvPosition = vec4( transformed, 1.0 );

#ifdef USE_BATCHING

	mvPosition = batchingMatrix * mvPosition;

#endif

#ifdef USE_INSTANCING

	mvPosition = instanceMatrix * mvPosition;

#endif

mvPosition = modelViewMatrix * mvPosition;

gl_Position = projectionMatrix * mvPosition;
`,Lne=`
#ifdef DITHERING

	gl_FragColor.rgb = dithering( gl_FragColor.rgb );

#endif
`,zne=`
#ifdef DITHERING

	// based on https://www.shadertoy.com/view/MslGR8
	vec3 dithering( vec3 color ) {
		//Calculate grid position
		float grid_position = rand( gl_FragCoord.xy );

		//Shift the individual colors differently, thus making it even harder to see the dithering pattern
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );

		//modify shift according to grid position.
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );

		//shift the color by dither_shift
		return color + dither_shift_RGB;
	}

#endif
`,Vne=`
float roughnessFactor = roughness;

#ifdef USE_ROUGHNESSMAP

	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );

	// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture
	roughnessFactor *= texelRoughness.g;

#endif
`,Hne=`
#ifdef USE_ROUGHNESSMAP

	uniform sampler2D roughnessMap;

#endif
`,Gne=`
#if NUM_SPOT_LIGHT_COORDS > 0

	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#if NUM_SPOT_LIGHT_MAPS > 0

	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];

#endif

#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return mix( 1.0, shadow, shadowIntensity );

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		float shadow = 1.0;

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );

		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {

			// dp = normalized distance from light to fragment position
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
			dp += shadowBias;

			// bd3D = base direction 3D
			vec3 bd3D = normalize( lightToPosition );

			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );

			#else // no percentage-closer filtering

				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

			#endif

		}

		return mix( 1.0, shadow, shadowIntensity );

	}

#endif
`,Wne=`

#if NUM_SPOT_LIGHT_COORDS > 0

	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): uniforms for area light shadows

	#endif
	*/

#endif
`,Xne=`

#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )

	// Offsetting the position used for querying occlusion along the world normal can be used to reduce shadow acne.
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;

#endif

#if defined( USE_SHADOWMAP )

	#if NUM_DIR_LIGHT_SHADOWS > 0

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;

		}
		#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;

		}
		#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update vAreaShadowCoord with area light info

	#endif
	*/

#endif

// spot lights can be evaluated without active shadow mapping (when SpotLight.map is used)

#if NUM_SPOT_LIGHT_COORDS > 0

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {

		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;

	}
	#pragma unroll_loop_end

#endif


`,Yne=`
float getShadowMask() {

	float shadow = 1.0;

	#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

	DirectionalLightShadow directionalLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {

		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

	SpotLightShadow spotLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {

		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

	PointLightShadow pointLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {

		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;

	}
	#pragma unroll_loop_end

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): update shadow for Area light

	#endif
	*/

	#endif

	return shadow;

}
`,Kne=`
#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

#endif
`,$ne=`
#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	uniform highp sampler2D boneTexture;

	mat4 getBoneMatrix( const in float i ) {

		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );

		return mat4( v1, v2, v3, v4 );

	}

#endif
`,Qne=`
#ifdef USE_SKINNING

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;

#endif
`,Zne=`
#ifdef USE_SKINNING

	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;

	#ifdef USE_TANGENT

		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;

	#endif

#endif
`,Jne=`
float specularStrength;

#ifdef USE_SPECULARMAP

	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;

#else

	specularStrength = 1.0;

#endif
`,jne=`
#ifdef USE_SPECULARMAP

	uniform sampler2D specularMap;

#endif
`,qne=`
#if defined( TONE_MAPPING )

	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );

#endif
`,eie=`
#ifndef saturate
// <common> may have defined saturate() already
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif

uniform float toneMappingExposure;

// exposure only
vec3 LinearToneMapping( vec3 color ) {

	return saturate( toneMappingExposure * color );

}

// source: https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf
vec3 ReinhardToneMapping( vec3 color ) {

	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );

}

// source: http://filmicworlds.com/blog/filmic-tonemapping-operators/
vec3 CineonToneMapping( vec3 color ) {

	// filmic operator by Jim Hejl and Richard Burgess-Dawson
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );

}

// source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
vec3 RRTAndODTFit( vec3 v ) {

	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;

}

// this implementation of ACES is modified to accommodate a brighter viewing environment.
// the scale factor of 1/0.6 is subjective. see discussion in #19621.

vec3 ACESFilmicToneMapping( vec3 color ) {

	// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ), // transposed from source
		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);

	// ODT_SAT => XYZ => D60_2_D65 => sRGB
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ), // transposed from source
		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);

	color *= toneMappingExposure / 0.6;

	color = ACESInputMat * color;

	// Apply RRT and ODT
	color = RRTAndODTFit( color );

	color = ACESOutputMat * color;

	// Clamp to [0, 1]
	return saturate( color );

}

// Matrices for rec 2020 <> rec 709 color space conversion
// matrix provided in row-major order so it has been transposed
// https://www.itu.int/pub/R-REP-BT.2407-2017
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);

const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);

// https://iolite-engine.com/blog_posts/minimal_agx_implementation
// Mean error^2: 3.6705141e-06
vec3 agxDefaultContrastApprox( vec3 x ) {

	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;

	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;

}

// AgX Tone Mapping implementation based on Filament, which in turn is based
// on Blender's implementation using rec 2020 primaries
// https://github.com/google/filament/pull/7236
// Inputs and outputs are encoded as Linear-sRGB.

vec3 AgXToneMapping( vec3 color ) {

	// AgX constants
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);

	// explicit AgXOutsetMatrix generated from Filaments AgXOutsetMatrixInv
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);

	// LOG2_MIN      = -10.0
	// LOG2_MAX      =  +6.5
	// MIDDLE_GRAY   =  0.18
	const float AgxMinEv = - 12.47393;  // log2( pow( 2, LOG2_MIN ) * MIDDLE_GRAY )
	const float AgxMaxEv = 4.026069;    // log2( pow( 2, LOG2_MAX ) * MIDDLE_GRAY )

	color *= toneMappingExposure;

	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;

	color = AgXInsetMatrix * color;

	// Log2 encoding
	color = max( color, 1e-10 ); // avoid 0 or negative numbers for log2
	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );

	color = clamp( color, 0.0, 1.0 );

	// Apply sigmoid
	color = agxDefaultContrastApprox( color );

	// Apply AgX look
	// v = agxLook(v, look);

	color = AgXOutsetMatrix * color;

	// Linearize
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );

	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;

	// Gamut mapping. Simple clamp for now.
	color = clamp( color, 0.0, 1.0 );

	return color;

}

// https://modelviewer.dev/examples/tone-mapping

vec3 NeutralToneMapping( vec3 color ) {

	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;

	color *= toneMappingExposure;

	float x = min( color.r, min( color.g, color.b ) );

	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;

	color -= offset;

	float peak = max( color.r, max( color.g, color.b ) );

	if ( peak < StartCompression ) return color;

	float d = 1. - StartCompression;

	float newPeak = 1. - d * d / ( peak + d - StartCompression );

	color *= newPeak / peak;

	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );

	return mix( color, vec3( newPeak ), g );

}

vec3 CustomToneMapping( vec3 color ) { return color; }
`,tie=`
#ifdef USE_TRANSMISSION

	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;

	#endif

	#ifdef USE_THICKNESSMAP

		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;

	#endif

	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );

	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );

	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );

	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );

#endif
`,xie=`
#ifdef USE_TRANSMISSION

	// Transmission code is based on glTF-Sampler-Viewer
	// https://github.com/KhronosGroup/glTF-Sample-Viewer

	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;

	#ifdef USE_TRANSMISSIONMAP

		uniform sampler2D transmissionMap;

	#endif

	#ifdef USE_THICKNESSMAP

		uniform sampler2D thicknessMap;

	#endif

	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;

	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;

	varying vec3 vWorldPosition;

	// Mipped Bicubic Texture Filtering by N8
	// https://www.shadertoy.com/view/Dl2SDW

	float w0( float a ) {

		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );

	}

	float w1( float a ) {

		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );

	}

	float w2( float a ){

		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );

	}

	float w3( float a ) {

		return ( 1.0 / 6.0 ) * ( a * a * a );

	}

	// g0 and g1 are the two amplitude functions
	float g0( float a ) {

		return w0( a ) + w1( a );

	}

	float g1( float a ) {

		return w2( a ) + w3( a );

	}

	// h0 and h1 are the two offset functions
	float h0( float a ) {

		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );

	}

	float h1( float a ) {

		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );

	}

	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {

		uv = uv * texelSize.zw + 0.5;

		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );

		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );

		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;

		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );

	}

	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {

		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );

	}

	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {

		// Direction of refracted light.
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

		// Compute rotation-independant scaling of the model matrix.
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		// The thickness is specified in local space.
		return normalize( refractionVector ) * thickness * modelScale;

	}

	float applyIorToRoughness( const in float roughness, const in float ior ) {

		// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
		// an IOR of 1.5 results in the default amount of microfacet refraction.
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );

	}

	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {

		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );

	}

	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {

		if ( isinf( attenuationDistance ) ) {

			// Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
			return vec3( 1.0 );

		} else {

			// Compute light attenuation using Beer's law.
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
			return transmittance;

		}

	}

	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {

		vec4 transmittedLight;
		vec3 transmittance;

		#ifdef USE_DISPERSION

			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );

			for ( int i = 0; i < 3; i ++ ) {

				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				// Sample framebuffer to get pixel the refracted ray hits.
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;

				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];

			}

			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;

			// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;

			// Sample framebuffer to get pixel the refracted ray hits.
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif

		vec3 attenuatedColor = transmittance * transmittedLight.rgb;

		// Get the specular component.
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );

		// As less light is transmitted, the opacity should be increased. This simple approximation does a decent job 
		// of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;

		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );

	}
#endif
`,nie=`
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	varying vec2 vNormalMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_SPECULARMAP

	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`,iie=`
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	varying vec2 vUv;

#endif
#ifdef USE_MAP

	uniform mat3 mapTransform;
	varying vec2 vMapUv;

#endif
#ifdef USE_ALPHAMAP

	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;

#endif
#ifdef USE_LIGHTMAP

	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;

#endif
#ifdef USE_AOMAP

	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;

#endif
#ifdef USE_BUMPMAP

	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;

#endif
#ifdef USE_NORMALMAP

	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;

#endif
#ifdef USE_DISPLACEMENTMAP

	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;

#endif
#ifdef USE_EMISSIVEMAP

	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;

#endif
#ifdef USE_METALNESSMAP

	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;

#endif
#ifdef USE_ROUGHNESSMAP

	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;

#endif
#ifdef USE_ANISOTROPYMAP

	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;

#endif
#ifdef USE_CLEARCOATMAP

	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;

#endif
#ifdef USE_SHEEN_COLORMAP

	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;

#endif
#ifdef USE_IRIDESCENCEMAP

	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;

#endif
#ifdef USE_SPECULARMAP

	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;

#endif
#ifdef USE_SPECULAR_COLORMAP

	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;

#endif
#ifdef USE_TRANSMISSIONMAP

	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;

#endif
#ifdef USE_THICKNESSMAP

	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;

#endif
`,rie=`
#if defined( USE_UV ) || defined( USE_ANISOTROPY )

	vUv = vec3( uv, 1 ).xy;

#endif
#ifdef USE_MAP

	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ALPHAMAP

	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_LIGHTMAP

	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_AOMAP

	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_BUMPMAP

	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_NORMALMAP

	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_DISPLACEMENTMAP

	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_EMISSIVEMAP

	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_METALNESSMAP

	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ROUGHNESSMAP

	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_ANISOTROPYMAP

	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOATMAP

	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_NORMALMAP

	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP

	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCEMAP

	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP

	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_COLORMAP

	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SHEEN_ROUGHNESSMAP

	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULARMAP

	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_COLORMAP

	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_SPECULAR_INTENSITYMAP

	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_TRANSMISSIONMAP

	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;

#endif
#ifdef USE_THICKNESSMAP

	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;

#endif
`,aie=`
#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0

	vec4 worldPosition = vec4( transformed, 1.0 );

	#ifdef USE_BATCHING

		worldPosition = batchingMatrix * worldPosition;

	#endif

	#ifdef USE_INSTANCING

		worldPosition = instanceMatrix * worldPosition;

	#endif

	worldPosition = modelMatrix * worldPosition;

#endif
`,sie=`
varying vec2 vUv;
uniform mat3 uvTransform;

void main() {

	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	gl_Position = vec4( position.xy, 1.0, 1.0 );

}
`,oie=`
uniform sampler2D t2D;
uniform float backgroundIntensity;

varying vec2 vUv;

void main() {

	vec4 texColor = texture2D( t2D, vUv );

	#ifdef DECODE_VIDEO_TEXTURE

		// use inline sRGB decode until browsers properly support SRGB8_APLHA8 with video textures

		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

	#endif

	texColor.rgb *= backgroundIntensity;

	gl_FragColor = texColor;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`,lie=`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`,cie=`

#ifdef ENVMAP_TYPE_CUBE

	uniform samplerCube envMap;

#elif defined( ENVMAP_TYPE_CUBE_UV )

	uniform sampler2D envMap;

#endif

uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;

varying vec3 vWorldDirection;

#include <cube_uv_reflection_fragment>

void main() {

	#ifdef ENVMAP_TYPE_CUBE

		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );

	#elif defined( ENVMAP_TYPE_CUBE_UV )

		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );

	#else

		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );

	#endif

	texColor.rgb *= backgroundIntensity;

	gl_FragColor = texColor;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`,uie=`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

	gl_Position.z = gl_Position.w; // set z to camera.far

}
`,hie=`
uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;

varying vec3 vWorldDirection;

void main() {

	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );

	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`,die=`
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

// This is used for computing an equivalent of gl_FragCoord.z that is as high precision as possible.
// Some platforms compute gl_FragCoord at a lower precision which makes the manually computed value better for
// depth-based postprocessing effects. Reproduced on iPad with A10 processor / iPadOS 13.3.1.
varying vec2 vHighPrecisionZW;

void main() {

	#include <uv_vertex>

	#include <batching_vertex>
	#include <skinbase_vertex>

	#include <morphinstance_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vHighPrecisionZW = gl_Position.zw;

}
`,fie=`
#if DEPTH_PACKING == 3200

	uniform float opacity;

#endif

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

varying vec2 vHighPrecisionZW;

void main() {

	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>

	#if DEPTH_PACKING == 3200

		diffuseColor.a = opacity;

	#endif

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	#include <logdepthbuf_fragment>

	// Higher precision equivalent of gl_FragCoord.z. This assumes depthRange has been left to its default values.
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;

	#if DEPTH_PACKING == 3200

		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );

	#elif DEPTH_PACKING == 3201

		gl_FragColor = packDepthToRGBA( fragCoordZ );

	#elif DEPTH_PACKING == 3202

		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );

	#elif DEPTH_PACKING == 3203

		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );

	#endif

}
`,pie=`
#define DISTANCE

varying vec3 vWorldPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	#include <batching_vertex>
	#include <skinbase_vertex>

	#include <morphinstance_vertex>

	#ifdef USE_DISPLACEMENTMAP

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>

	vWorldPosition = worldPosition.xyz;

}
`,mie=`
#define DISTANCE

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;

#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>

void main () {

	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>

	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); // clamp to [ 0, 1 ]

	gl_FragColor = packDepthToRGBA( dist );

}
`,yie=`
varying vec3 vWorldDirection;

#include <common>

void main() {

	vWorldDirection = transformDirection( position, modelMatrix );

	#include <begin_vertex>
	#include <project_vertex>

}
`,gie=`
uniform sampler2D tEquirect;

varying vec3 vWorldDirection;

#include <common>

void main() {

	vec3 direction = normalize( vWorldDirection );

	vec2 sampleUV = equirectUv( direction );

	gl_FragColor = texture2D( tEquirect, sampleUV );

	#include <tonemapping_fragment>
	#include <colorspace_fragment>

}
`,vie=`
uniform float scale;
attribute float lineDistance;

varying float vLineDistance;

#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	vLineDistance = scale * lineDistance;

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`,bie=`
uniform vec3 diffuse;
uniform float opacity;

uniform float dashSize;
uniform float totalSize;

varying float vLineDistance;

#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	if ( mod( vLineDistance, totalSize ) > dashSize ) {

		discard;

	}

	vec3 outgoingLight = vec3( 0.0 );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	outgoingLight = diffuseColor.rgb; // simple shader

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`,_ie=`
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )

		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>

	#endif

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>

}
`,Sie=`
uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED

	varying vec3 vNormal;

#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP

		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;

	#else

		reflectedLight.indirectDiffuse += vec3( 1.0 );

	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;

	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Tie=`
#define LAMBERT

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,wie=`
#define LAMBERT

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Aie=`
#define MATCAP

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>

#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

	vViewPosition = - mvPosition.xyz;

}
`,Eie=`
#define MATCAP

uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;

varying vec3 vViewPosition;

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks

	#ifdef USE_MATCAP

		vec4 matcapColor = texture2D( matcap, uv );

	#else

		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 ); // default if matcap is missing

	#endif

	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Mie=`
#define NORMAL

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	varying vec3 vViewPosition;

#endif

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	vViewPosition = - mvPosition.xyz;

#endif

}
`,Rie=`
#define NORMAL

uniform float opacity;

#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )

	varying vec3 vViewPosition;

#endif

#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );

	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>

	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );

	#ifdef OPAQUE

		gl_FragColor.a = 1.0;

	#endif

}
`,Cie=`
#define PHONG

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,Nie=`
#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;

	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Iie=`
#define STANDARD

varying vec3 vViewPosition;

#ifdef USE_TRANSMISSION

	varying vec3 vWorldPosition;

#endif

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

#ifdef USE_TRANSMISSION

	vWorldPosition = worldPosition.xyz;

#endif
}
`,Oie=`
#define STANDARD

#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;

#ifdef IOR
	uniform float ior;
#endif

#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;

	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif

	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif

#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif

#ifdef USE_DISPERSION
	uniform float dispersion;
#endif

#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif

#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;

	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif

	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif

#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;

	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif

varying vec3 vViewPosition;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;

	#include <transmission_fragment>

	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;

	#ifdef USE_SHEEN

		// Sheen energy compensation approximation calculation can be found at the end of
		// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );

		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;

	#endif

	#ifdef USE_CLEARCOAT

		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );

		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );

		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;

	#endif

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,Die=`
#define TOON

varying vec3 vViewPosition;

#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	vViewPosition = - mvPosition.xyz;

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,Pie=`
#define TOON

uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>

	// accumulation
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>

}
`,kie=`
uniform float size;
uniform float scale;

#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

#ifdef USE_POINTS_UV

	varying vec2 vUv;
	uniform mat3 uvTransform;

#endif

void main() {

	#ifdef USE_POINTS_UV

		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;

	#endif

	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>

	gl_PointSize = size;

	#ifdef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );

	#endif

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>

}
`,Uie=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );

	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>

}
`,Fie=`
#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>

void main() {

	#include <batching_vertex>

	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>

	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>

}
`,Bie=`
uniform vec3 color;
uniform float opacity;

#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>

void main() {

	#include <logdepthbuf_fragment>

	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );

	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>

}
`,Lie=`
uniform float rotation;
uniform vec2 center;

#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {

	#include <uv_vertex>

	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	#ifndef USE_SIZEATTENUATION

		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;

	#endif

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>

}
`,zie=`
uniform vec3 diffuse;
uniform float opacity;

#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {

	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>

	vec3 outgoingLight = vec3( 0.0 );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>

	outgoingLight = diffuseColor.rgb;

	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>

}
`,g0={alphahash_fragment:oxe,alphahash_pars_fragment:lxe,alphamap_fragment:cxe,alphamap_pars_fragment:uxe,alphatest_fragment:hxe,alphatest_pars_fragment:dxe,aomap_fragment:fxe,aomap_pars_fragment:pxe,batching_pars_vertex:mxe,batching_vertex:yxe,begin_vertex:gxe,beginnormal_vertex:vxe,bsdfs:bxe,iridescence_fragment:_xe,bumpmap_pars_fragment:Sxe,clipping_planes_fragment:Txe,clipping_planes_pars_fragment:wxe,clipping_planes_pars_vertex:Axe,clipping_planes_vertex:Exe,color_fragment:Mxe,color_pars_fragment:Rxe,color_pars_vertex:Cxe,color_vertex:Nxe,common:Ixe,cube_uv_reflection_fragment:Oxe,defaultnormal_vertex:Dxe,displacementmap_pars_vertex:Pxe,displacementmap_vertex:kxe,emissivemap_fragment:Uxe,emissivemap_pars_fragment:Fxe,colorspace_fragment:Bxe,colorspace_pars_fragment:Lxe,envmap_fragment:zxe,envmap_common_pars_fragment:Vxe,envmap_pars_fragment:Hxe,envmap_pars_vertex:Gxe,envmap_physical_pars_fragment:ene,envmap_vertex:Wxe,fog_vertex:Xxe,fog_pars_vertex:Yxe,fog_fragment:Kxe,fog_pars_fragment:$xe,gradientmap_pars_fragment:Qxe,lightmap_pars_fragment:Zxe,lights_lambert_fragment:Jxe,lights_lambert_pars_fragment:jxe,lights_pars_begin:qxe,lights_toon_fragment:tne,lights_toon_pars_fragment:xne,lights_phong_fragment:nne,lights_phong_pars_fragment:ine,lights_physical_fragment:rne,lights_physical_pars_fragment:ane,lights_fragment_begin:sne,lights_fragment_maps:one,lights_fragment_end:lne,logdepthbuf_fragment:cne,logdepthbuf_pars_fragment:une,logdepthbuf_pars_vertex:hne,logdepthbuf_vertex:dne,map_fragment:fne,map_pars_fragment:pne,map_particle_fragment:mne,map_particle_pars_fragment:yne,metalnessmap_fragment:gne,metalnessmap_pars_fragment:vne,morphinstance_vertex:bne,morphcolor_vertex:_ne,morphnormal_vertex:Sne,morphtarget_pars_vertex:Tne,morphtarget_vertex:wne,normal_fragment_begin:Ane,normal_fragment_maps:Ene,normal_pars_fragment:Mne,normal_pars_vertex:Rne,normal_vertex:Cne,normalmap_pars_fragment:Nne,clearcoat_normal_fragment_begin:Ine,clearcoat_normal_fragment_maps:One,clearcoat_pars_fragment:Dne,iridescence_pars_fragment:Pne,opaque_fragment:kne,packing:Une,premultiplied_alpha_fragment:Fne,project_vertex:Bne,dithering_fragment:Lne,dithering_pars_fragment:zne,roughnessmap_fragment:Vne,roughnessmap_pars_fragment:Hne,shadowmap_pars_fragment:Gne,shadowmap_pars_vertex:Wne,shadowmap_vertex:Xne,shadowmask_pars_fragment:Yne,skinbase_vertex:Kne,skinning_pars_vertex:$ne,skinning_vertex:Qne,skinnormal_vertex:Zne,specularmap_fragment:Jne,specularmap_pars_fragment:jne,tonemapping_fragment:qne,tonemapping_pars_fragment:eie,transmission_fragment:tie,transmission_pars_fragment:xie,uv_pars_fragment:nie,uv_pars_vertex:iie,uv_vertex:rie,worldpos_vertex:aie,background_vert:sie,background_frag:oie,backgroundCube_vert:lie,backgroundCube_frag:cie,cube_vert:uie,cube_frag:hie,depth_vert:die,depth_frag:fie,distanceRGBA_vert:pie,distanceRGBA_frag:mie,equirect_vert:yie,equirect_frag:gie,linedashed_vert:vie,linedashed_frag:bie,meshbasic_vert:_ie,meshbasic_frag:Sie,meshlambert_vert:Tie,meshlambert_frag:wie,meshmatcap_vert:Aie,meshmatcap_frag:Eie,meshnormal_vert:Mie,meshnormal_frag:Rie,meshphong_vert:Cie,meshphong_frag:Nie,meshphysical_vert:Iie,meshphysical_frag:Oie,meshtoon_vert:Die,meshtoon_frag:Pie,points_vert:kie,points_frag:Uie,shadow_vert:Fie,shadow_frag:Bie,sprite_vert:Lie,sprite_frag:zie},Rt={common:{diffuse:{value:new dx(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new E0},alphaMap:{value:null},alphaMapTransform:{value:new E0},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new E0}},envmap:{envMap:{value:null},envMapRotation:{value:new E0},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new E0}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new E0}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new E0},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new E0},normalScale:{value:new fx(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new E0},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new E0}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new E0}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new E0}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new dx(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new dx(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new E0},alphaTest:{value:0},uvTransform:{value:new E0}},sprite:{diffuse:{value:new dx(16777215)},opacity:{value:1},center:{value:new fx(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new E0},alphaMap:{value:null},alphaMapTransform:{value:new E0},alphaTest:{value:0}}},Ss={basic:{uniforms:Ai([Rt.common,Rt.specularmap,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.fog]),vertexShader:g0.meshbasic_vert,fragmentShader:g0.meshbasic_frag},lambert:{uniforms:Ai([Rt.common,Rt.specularmap,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.fog,Rt.lights,{emissive:{value:new dx(0)}}]),vertexShader:g0.meshlambert_vert,fragmentShader:g0.meshlambert_frag},phong:{uniforms:Ai([Rt.common,Rt.specularmap,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.fog,Rt.lights,{emissive:{value:new dx(0)},specular:{value:new dx(1118481)},shininess:{value:30}}]),vertexShader:g0.meshphong_vert,fragmentShader:g0.meshphong_frag},standard:{uniforms:Ai([Rt.common,Rt.envmap,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.roughnessmap,Rt.metalnessmap,Rt.fog,Rt.lights,{emissive:{value:new dx(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:g0.meshphysical_vert,fragmentShader:g0.meshphysical_frag},toon:{uniforms:Ai([Rt.common,Rt.aomap,Rt.lightmap,Rt.emissivemap,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.gradientmap,Rt.fog,Rt.lights,{emissive:{value:new dx(0)}}]),vertexShader:g0.meshtoon_vert,fragmentShader:g0.meshtoon_frag},matcap:{uniforms:Ai([Rt.common,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,Rt.fog,{matcap:{value:null}}]),vertexShader:g0.meshmatcap_vert,fragmentShader:g0.meshmatcap_frag},points:{uniforms:Ai([Rt.points,Rt.fog]),vertexShader:g0.points_vert,fragmentShader:g0.points_frag},dashed:{uniforms:Ai([Rt.common,Rt.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:g0.linedashed_vert,fragmentShader:g0.linedashed_frag},depth:{uniforms:Ai([Rt.common,Rt.displacementmap]),vertexShader:g0.depth_vert,fragmentShader:g0.depth_frag},normal:{uniforms:Ai([Rt.common,Rt.bumpmap,Rt.normalmap,Rt.displacementmap,{opacity:{value:1}}]),vertexShader:g0.meshnormal_vert,fragmentShader:g0.meshnormal_frag},sprite:{uniforms:Ai([Rt.sprite,Rt.fog]),vertexShader:g0.sprite_vert,fragmentShader:g0.sprite_frag},background:{uniforms:{uvTransform:{value:new E0},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:g0.background_vert,fragmentShader:g0.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new E0}},vertexShader:g0.backgroundCube_vert,fragmentShader:g0.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:g0.cube_vert,fragmentShader:g0.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:g0.equirect_vert,fragmentShader:g0.equirect_frag},distanceRGBA:{uniforms:Ai([Rt.common,Rt.displacementmap,{referencePosition:{value:new Be},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:g0.distanceRGBA_vert,fragmentShader:g0.distanceRGBA_frag},shadow:{uniforms:Ai([Rt.lights,Rt.fog,{color:{value:new dx(0)},opacity:{value:1}}]),vertexShader:g0.shadow_vert,fragmentShader:g0.shadow_frag}};Ss.physical={uniforms:Ai([Ss.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new E0},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new E0},clearcoatNormalScale:{value:new fx(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new E0},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new E0},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new E0},sheen:{value:0},sheenColor:{value:new dx(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new E0},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new E0},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new E0},transmissionSamplerSize:{value:new fx},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new E0},attenuationDistance:{value:0},attenuationColor:{value:new dx(0)},specularColor:{value:new dx(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new E0},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new E0},anisotropyVector:{value:new fx},anisotropyMap:{value:null},anisotropyMapTransform:{value:new E0}}]),vertexShader:g0.meshphysical_vert,fragmentShader:g0.meshphysical_frag};const my={r:0,b:0,g:0},Gl=new Nc,Vie=new Hn;function Hie(x,e,t,n,i,r,a){const s=new dx(0);let l=r===!0?0:1,c,h,d=null,p=0,m=null;function g(T){let E=T.isScene===!0?T.background:null;return E&&E.isTexture&&(E=(T.backgroundBlurriness>0?t:e).get(E)),E}function _(T){let E=!1;const A=g(T);A===null?b(s,l):A&&A.isColor&&(b(A,1),E=!0);const M=x.xr.getEnvironmentBlendMode();M==="additive"?n.buffers.color.setClear(0,0,0,1,a):M==="alpha-blend"&&n.buffers.color.setClear(0,0,0,0,a),(x.autoClear||E)&&(n.buffers.depth.setTest(!0),n.buffers.depth.setMask(!0),n.buffers.color.setMask(!0),x.clear(x.autoClearColor,x.autoClearDepth,x.autoClearStencil))}function v(T,E){const A=g(E);A&&(A.isCubeTexture||A.mapping===dv)?(h===void 0&&(h=new ws(new Dp(1,1,1),new rl({name:"BackgroundCubeMaterial",uniforms:Xh(Ss.backgroundCube.uniforms),vertexShader:Ss.backgroundCube.vertexShader,fragmentShader:Ss.backgroundCube.fragmentShader,side:er,depthTest:!1,depthWrite:!1,fog:!1})),h.geometry.deleteAttribute("normal"),h.geometry.deleteAttribute("uv"),h.onBeforeRender=function(M,R,C){this.matrixWorld.copyPosition(C.matrixWorld)},Object.defineProperty(h.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(h)),Gl.copy(E.backgroundRotation),Gl.x*=-1,Gl.y*=-1,Gl.z*=-1,A.isCubeTexture&&A.isRenderTargetTexture===!1&&(Gl.y*=-1,Gl.z*=-1),h.material.uniforms.envMap.value=A,h.material.uniforms.flipEnvMap.value=A.isCubeTexture&&A.isRenderTargetTexture===!1?-1:1,h.material.uniforms.backgroundBlurriness.value=E.backgroundBlurriness,h.material.uniforms.backgroundIntensity.value=E.backgroundIntensity,h.material.uniforms.backgroundRotation.value.setFromMatrix4(Vie.makeRotationFromEuler(Gl)),h.material.toneMapped=J0.getTransfer(A.colorSpace)!==Ex,(d!==A||p!==A.version||m!==x.toneMapping)&&(h.material.needsUpdate=!0,d=A,p=A.version,m=x.toneMapping),h.layers.enableAll(),T.unshift(h,h.geometry,h.material,0,0,null)):A&&A.isTexture&&(c===void 0&&(c=new ws(new pv(2,2),new rl({name:"BackgroundMaterial",uniforms:Xh(Ss.background.uniforms),vertexShader:Ss.background.vertexShader,fragmentShader:Ss.background.fragmentShader,side:il,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=A,c.material.uniforms.backgroundIntensity.value=E.backgroundIntensity,c.material.toneMapped=J0.getTransfer(A.colorSpace)!==Ex,A.matrixAutoUpdate===!0&&A.updateMatrix(),c.material.uniforms.uvTransform.value.copy(A.matrix),(d!==A||p!==A.version||m!==x.toneMapping)&&(c.material.needsUpdate=!0,d=A,p=A.version,m=x.toneMapping),c.layers.enableAll(),T.unshift(c,c.geometry,c.material,0,0,null))}function b(T,E){T.getRGB(my,SL(x)),n.buffers.color.setClear(my.r,my.g,my.b,E,a)}return{getClearColor:function(){return s},setClearColor:function(T,E=1){s.set(T),l=E,b(s,l)},getClearAlpha:function(){return l},setClearAlpha:function(T){l=T,b(s,l)},render:_,addToRenderList:v}}function Gie(x,e){const t=x.getParameter(x.MAX_VERTEX_ATTRIBS),n={},i=p(null);let r=i,a=!1;function s(N,G,te,j,xe){let ae=!1;const H=d(j,te,G);r!==H&&(r=H,c(r.object)),ae=m(N,j,te,xe),ae&&g(N,j,te,xe),xe!==null&&e.update(xe,x.ELEMENT_ARRAY_BUFFER),(ae||a)&&(a=!1,A(N,G,te,j),xe!==null&&x.bindBuffer(x.ELEMENT_ARRAY_BUFFER,e.get(xe).buffer))}function l(){return x.createVertexArray()}function c(N){return x.bindVertexArray(N)}function h(N){return x.deleteVertexArray(N)}function d(N,G,te){const j=te.wireframe===!0;let xe=n[N.id];xe===void 0&&(xe={},n[N.id]=xe);let ae=xe[G.id];ae===void 0&&(ae={},xe[G.id]=ae);let H=ae[j];return H===void 0&&(H=p(l()),ae[j]=H),H}function p(N){const G=[],te=[],j=[];for(let xe=0;xe<t;xe++)G[xe]=0,te[xe]=0,j[xe]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:G,enabledAttributes:te,attributeDivisors:j,object:N,attributes:{},index:null}}function m(N,G,te,j){const xe=r.attributes,ae=G.attributes;let H=0;const re=te.getAttributes();for(const q in re)if(re[q].location>=0){const K=xe[q];let se=ae[q];if(se===void 0&&(q==="instanceMatrix"&&N.instanceMatrix&&(se=N.instanceMatrix),q==="instanceColor"&&N.instanceColor&&(se=N.instanceColor)),K===void 0||K.attribute!==se||se&&K.data!==se.data)return!0;H++}return r.attributesNum!==H||r.index!==j}function g(N,G,te,j){const xe={},ae=G.attributes;let H=0;const re=te.getAttributes();for(const q in re)if(re[q].location>=0){let K=ae[q];K===void 0&&(q==="instanceMatrix"&&N.instanceMatrix&&(K=N.instanceMatrix),q==="instanceColor"&&N.instanceColor&&(K=N.instanceColor));const se={};se.attribute=K,K&&K.data&&(se.data=K.data),xe[q]=se,H++}r.attributes=xe,r.attributesNum=H,r.index=j}function _(){const N=r.newAttributes;for(let G=0,te=N.length;G<te;G++)N[G]=0}function v(N){b(N,0)}function b(N,G){const te=r.newAttributes,j=r.enabledAttributes,xe=r.attributeDivisors;te[N]=1,j[N]===0&&(x.enableVertexAttribArray(N),j[N]=1),xe[N]!==G&&(x.vertexAttribDivisor(N,G),xe[N]=G)}function T(){const N=r.newAttributes,G=r.enabledAttributes;for(let te=0,j=G.length;te<j;te++)G[te]!==N[te]&&(x.disableVertexAttribArray(te),G[te]=0)}function E(N,G,te,j,xe,ae,H){H===!0?x.vertexAttribIPointer(N,G,te,xe,ae):x.vertexAttribPointer(N,G,te,j,xe,ae)}function A(N,G,te,j){_();const xe=j.attributes,ae=te.getAttributes(),H=G.defaultAttributeValues;for(const re in ae){const q=ae[re];if(q.location>=0){let be=xe[re];if(be===void 0&&(re==="instanceMatrix"&&N.instanceMatrix&&(be=N.instanceMatrix),re==="instanceColor"&&N.instanceColor&&(be=N.instanceColor)),be!==void 0){const K=be.normalized,se=be.itemSize,ge=e.get(be);if(ge===void 0)continue;const Me=ge.buffer,le=ge.type,Se=ge.bytesPerElement,Fe=le===x.INT||le===x.UNSIGNED_INT||be.gpuType===wM;if(be.isInterleavedBufferAttribute){const Qe=be.data,qe=Qe.stride,Et=be.offset;if(Qe.isInstancedInterleavedBuffer){for(let Tt=0;Tt<q.locationSize;Tt++)b(q.location+Tt,Qe.meshPerAttribute);N.isInstancedMesh!==!0&&j._maxInstanceCount===void 0&&(j._maxInstanceCount=Qe.meshPerAttribute*Qe.count)}else for(let Tt=0;Tt<q.locationSize;Tt++)v(q.location+Tt);x.bindBuffer(x.ARRAY_BUFFER,Me);for(let Tt=0;Tt<q.locationSize;Tt++)E(q.location+Tt,se/q.locationSize,le,K,qe*Se,(Et+se/q.locationSize*Tt)*Se,Fe)}else{if(be.isInstancedBufferAttribute){for(let Qe=0;Qe<q.locationSize;Qe++)b(q.location+Qe,be.meshPerAttribute);N.isInstancedMesh!==!0&&j._maxInstanceCount===void 0&&(j._maxInstanceCount=be.meshPerAttribute*be.count)}else for(let Qe=0;Qe<q.locationSize;Qe++)v(q.location+Qe);x.bindBuffer(x.ARRAY_BUFFER,Me);for(let Qe=0;Qe<q.locationSize;Qe++)E(q.location+Qe,se/q.locationSize,le,K,se*Se,se/q.locationSize*Qe*Se,Fe)}}else if(H!==void 0){const K=H[re];if(K!==void 0)switch(K.length){case 2:x.vertexAttrib2fv(q.location,K);break;case 3:x.vertexAttrib3fv(q.location,K);break;case 4:x.vertexAttrib4fv(q.location,K);break;default:x.vertexAttrib1fv(q.location,K)}}}}T()}function M(){k();for(const N in n){const G=n[N];for(const te in G){const j=G[te];for(const xe in j)h(j[xe].object),delete j[xe];delete G[te]}delete n[N]}}function R(N){if(n[N.id]===void 0)return;const G=n[N.id];for(const te in G){const j=G[te];for(const xe in j)h(j[xe].object),delete j[xe];delete G[te]}delete n[N.id]}function C(N){for(const G in n){const te=n[G];if(te[N.id]===void 0)continue;const j=te[N.id];for(const xe in j)h(j[xe].object),delete j[xe];delete te[N.id]}}function k(){P(),a=!0,r!==i&&(r=i,c(r.object))}function P(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:s,reset:k,resetDefaultState:P,dispose:M,releaseStatesOfGeometry:R,releaseStatesOfProgram:C,initAttributes:_,enableAttribute:v,disableUnusedAttributes:T}}function Wie(x,e,t){let n;function i(c){n=c}function r(c,h){x.drawArrays(n,c,h),t.update(h,n,1)}function a(c,h,d){d!==0&&(x.drawArraysInstanced(n,c,h,d),t.update(h,n,d))}function s(c,h,d){if(d===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n,c,0,h,0,d);let m=0;for(let g=0;g<d;g++)m+=h[g];t.update(m,n,1)}function l(c,h,d,p){if(d===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let g=0;g<c.length;g++)a(c[g],h[g],p[g]);else{m.multiDrawArraysInstancedWEBGL(n,c,0,h,0,p,0,d);let g=0;for(let _=0;_<d;_++)g+=h[_];for(let _=0;_<p.length;_++)t.update(g,n,p[_])}}this.setMode=i,this.render=r,this.renderInstances=a,this.renderMultiDraw=s,this.renderMultiDrawInstances=l}function Xie(x,e,t,n){let i;function r(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const R=e.get("EXT_texture_filter_anisotropic");i=x.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(R){return!(R!==Ka&&n.convert(R)!==x.getParameter(x.IMPLEMENTATION_COLOR_READ_FORMAT))}function s(R){const C=R===Np&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(R!==zo&&n.convert(R)!==x.getParameter(x.IMPLEMENTATION_COLOR_READ_TYPE)&&R!==Oo&&!C)}function l(R){if(R==="highp"){if(x.getShaderPrecisionFormat(x.VERTEX_SHADER,x.HIGH_FLOAT).precision>0&&x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.HIGH_FLOAT).precision>0)return"highp";R="mediump"}return R==="mediump"&&x.getShaderPrecisionFormat(x.VERTEX_SHADER,x.MEDIUM_FLOAT).precision>0&&x.getShaderPrecisionFormat(x.FRAGMENT_SHADER,x.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let c=t.precision!==void 0?t.precision:"highp";const h=l(c);h!==c&&(console.warn("THREE.WebGLRenderer:",c,"not supported, using",h,"instead."),c=h);const d=t.logarithmicDepthBuffer===!0,p=x.getParameter(x.MAX_TEXTURE_IMAGE_UNITS),m=x.getParameter(x.MAX_VERTEX_TEXTURE_IMAGE_UNITS),g=x.getParameter(x.MAX_TEXTURE_SIZE),_=x.getParameter(x.MAX_CUBE_MAP_TEXTURE_SIZE),v=x.getParameter(x.MAX_VERTEX_ATTRIBS),b=x.getParameter(x.MAX_VERTEX_UNIFORM_VECTORS),T=x.getParameter(x.MAX_VARYING_VECTORS),E=x.getParameter(x.MAX_FRAGMENT_UNIFORM_VECTORS),A=m>0,M=x.getParameter(x.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:r,getMaxPrecision:l,textureFormatReadable:a,textureTypeReadable:s,precision:c,logarithmicDepthBuffer:d,maxTextures:p,maxVertexTextures:m,maxTextureSize:g,maxCubemapSize:_,maxAttributes:v,maxVertexUniforms:b,maxVaryings:T,maxFragmentUniforms:E,vertexTextures:A,maxSamples:M}}function Yie(x){const e=this;let t=null,n=0,i=!1,r=!1;const a=new jl,s=new E0,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(d,p){const m=d.length!==0||p||n!==0||i;return i=p,n=d.length,m},this.beginShadows=function(){r=!0,h(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(d,p){t=h(d,p,0)},this.setState=function(d,p,m){const g=d.clippingPlanes,_=d.clipIntersection,v=d.clipShadows,b=x.get(d);if(!i||g===null||g.length===0||r&&!v)r?h(null):c();else{const T=r?0:n,E=T*4;let A=b.clippingState||null;l.value=A,A=h(g,p,E,m);for(let M=0;M!==E;++M)A[M]=t[M];b.clippingState=A,this.numIntersection=_?this.numPlanes:0,this.numPlanes+=T}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=n>0),e.numPlanes=n,e.numIntersection=0}function h(d,p,m,g){const _=d!==null?d.length:0;let v=null;if(_!==0){if(v=l.value,g!==!0||v===null){const b=m+_*4,T=p.matrixWorldInverse;s.getNormalMatrix(T),(v===null||v.length<b)&&(v=new Float32Array(b));for(let E=0,A=m;E!==_;++E,A+=4)a.copy(d[E]).applyMatrix4(T,s),a.normal.toArray(v,A),v[A+3]=a.constant}l.value=v,l.needsUpdate=!0}return e.numPlanes=_,e.numIntersection=0,v}}let Iu,Kie=class{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Iu===void 0&&(Iu=xg("canvas")),Iu.width=e.width,Iu.height=e.height;const n=Iu.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Iu}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=xg("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),r=i.data;for(let a=0;a<r.length;a++)r[a]=ph(r[a]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(ph(t[n]/255)*255):t[n]=ph(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}},$ie=0,wL=class{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:$ie++}),this.uuid=Ip(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let a=0,s=i.length;a<s;a++)i[a].isDataTexture?r.push(sS(i[a].image)):r.push(sS(i[a]))}else r=sS(i);n.url=r}return t||(e.images[this.uuid]=n),n}};function sS(x){return typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&x instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&x instanceof ImageBitmap?Kie.getDataURL(x):x.data?{data:Array.from(x.data),width:x.width,height:x.height,type:x.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Qie=0,ns=class p1 extends hd{constructor(e=p1.DEFAULT_IMAGE,t=p1.DEFAULT_MAPPING,n=lc,i=lc,r=Ga,a=cc,s=Ka,l=zo,c=p1.DEFAULT_ANISOTROPY,h=z2){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Qie++}),this.uuid=Ip(),this.name="",this.source=new wL(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=c,this.format=s,this.internalFormat=null,this.type=l,this.offset=new fx(0,0),this.repeat=new fx(1,1),this.center=new fx(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new E0,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==JB)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case nw:e.x=e.x-Math.floor(e.x);break;case lc:e.x=e.x<0?0:1;break;case iw:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case nw:e.y=e.y-Math.floor(e.y);break;case lc:e.y=e.y<0?0:1;break;case iw:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}};ns.DEFAULT_IMAGE=null;ns.DEFAULT_MAPPING=JB;ns.DEFAULT_ANISOTROPY=1;class Zie extends hd{constructor(e=1,t=1,n={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new ui(0,0,e,t),this.scissorTest=!1,this.viewport=new ui(0,0,e,t);const i={width:e,height:t,depth:1};n=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Ga,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},n);const r=new ns(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);r.flipY=!1,r.generateMipmaps=n.generateMipmaps,r.internalFormat=n.internalFormat,this.textures=[];const a=n.count;for(let s=0;s<a;s++)this.textures[s]=r.clone(),this.textures[s].isRenderTargetTexture=!0;this.depthBuffer=n.depthBuffer,this.stencilBuffer=n.stencilBuffer,this.resolveDepthBuffer=n.resolveDepthBuffer,this.resolveStencilBuffer=n.resolveStencilBuffer,this.depthTexture=n.depthTexture,this.samples=n.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}setSize(e,t,n=1){if(this.width!==e||this.height!==t||this.depth!==n){this.width=e,this.height=t,this.depth=n;for(let i=0,r=this.textures.length;i<r;i++)this.textures[i].image.width=e,this.textures[i].image.height=t,this.textures[i].image.depth=n;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let n=0,i=e.textures.length;n<i;n++)this.textures[n]=e.textures[n].clone(),this.textures[n].isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new wL(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Ic extends Zie{constructor(e=1,t=1,n={}){super(e,t,n),this.isWebGLRenderTarget=!0}}let AL=class extends Xo{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Hn,this.projectionMatrix=new Hn,this.projectionMatrixInverse=new Hn,this.coordinateSystem=Do}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}};const R2=new Be,hD=new fx,dD=new fx;let Cr=class extends AL{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=Iw*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(H_*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Iw*2*Math.atan(Math.tan(H_*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,n){R2.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(R2.x,R2.y).multiplyScalar(-e/R2.z),R2.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(R2.x,R2.y).multiplyScalar(-e/R2.z)}getViewSize(e,t){return this.getViewBounds(e,hD,dD),t.subVectors(dD,hD)}setViewOffset(e,t,n,i,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(H_*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,c=a.fullHeight;r+=a.offsetX*i/l,t-=a.offsetY*n/c,i*=a.width/l,n*=a.height/c}const s=this.filmOffset;s!==0&&(r+=e*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}};const Ou=-90,Du=1;class Jie extends Xo{constructor(e,t,n){super(),this.type="CubeCamera",this.renderTarget=n,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Cr(Ou,Du,e,t);i.layers=this.layers,this.add(i);const r=new Cr(Ou,Du,e,t);r.layers=this.layers,this.add(r);const a=new Cr(Ou,Du,e,t);a.layers=this.layers,this.add(a);const s=new Cr(Ou,Du,e,t);s.layers=this.layers,this.add(s);const l=new Cr(Ou,Du,e,t);l.layers=this.layers,this.add(l);const c=new Cr(Ou,Du,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[n,i,r,a,s,l]=t;for(const c of t)this.remove(c);if(e===Do)n.up.set(0,1,0),n.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),s.up.set(0,1,0),s.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===tg)n.up.set(0,-1,0),n.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),s.up.set(0,-1,0),s.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:n,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[r,a,s,l,c,h]=this.children,d=e.getRenderTarget(),p=e.getActiveCubeFace(),m=e.getActiveMipmapLevel(),g=e.xr.enabled;e.xr.enabled=!1;const _=n.texture.generateMipmaps;n.texture.generateMipmaps=!1,e.setRenderTarget(n,0,i),e.render(t,r),e.setRenderTarget(n,1,i),e.render(t,a),e.setRenderTarget(n,2,i),e.render(t,s),e.setRenderTarget(n,3,i),e.render(t,l),e.setRenderTarget(n,4,i),e.render(t,c),n.texture.generateMipmaps=_,e.setRenderTarget(n,5,i),e.render(t,h),e.setRenderTarget(d,p,m),e.xr.enabled=g,n.texture.needsPMREMUpdate=!0}}class EL extends ns{constructor(e,t,n,i,r,a,s,l,c,h){e=e!==void 0?e:[],t=t!==void 0?t:zh,super(e,t,n,i,r,a,s,l,c,h),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class jie extends Ic{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const n={width:e,height:e,depth:1},i=[n,n,n,n,n,n];this.texture=new EL(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Ga}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const n={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Dp(5,5,5),r=new rl({name:"CubemapFromEquirect",uniforms:Xh(n.uniforms),vertexShader:n.vertexShader,fragmentShader:n.fragmentShader,side:er,blending:Q2});r.uniforms.tEquirect.value=t;const a=new ws(i,r),s=t.minFilter;return t.minFilter===cc&&(t.minFilter=Ga),new Jie(1,10,this).update(e,a),t.minFilter=s,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,n,i){const r=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,n,i);e.setRenderTarget(r)}}function qie(x){let e=new WeakMap;function t(a,s){return s===tw?a.mapping=zh:s===xw&&(a.mapping=Vh),a}function n(a){if(a&&a.isTexture){const s=a.mapping;if(s===tw||s===xw)if(e.has(a)){const l=e.get(a).texture;return t(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=new jie(l.height);return c.fromEquirectangularTexture(x,a),e.set(a,c),a.addEventListener("dispose",i),t(c.texture,a.mapping)}else return null}}return a}function i(a){const s=a.target;s.removeEventListener("dispose",i);const l=e.get(s);l!==void 0&&(e.delete(s),l.dispose())}function r(){e=new WeakMap}return{get:n,dispose:r}}let ML=class extends AL{constructor(e=-1,t=1,n=1,i=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,a=n+e,s=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,a=r+c*this.view.width,s-=h*this.view.offsetY,l=s-h*this.view.height}this.projectionMatrix.makeOrthographic(r,a,s,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}};const xh=4,fD=[.125,.215,.35,.446,.526,.582],ic=20,oS=new ML,pD=new dx;let lS=null,cS=0,uS=0,hS=!1;const ql=(1+Math.sqrt(5))/2,Pu=1/ql,mD=[new Be(-ql,Pu,0),new Be(ql,Pu,0),new Be(-Pu,0,ql),new Be(Pu,0,ql),new Be(0,ql,-Pu),new Be(0,ql,Pu),new Be(-1,1,-1),new Be(1,1,-1),new Be(-1,1,1),new Be(1,1,1)];class yD{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,n=.1,i=100){lS=this._renderer.getRenderTarget(),cS=this._renderer.getActiveCubeFace(),uS=this._renderer.getActiveMipmapLevel(),hS=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,n,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=bD(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=vD(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(lS,cS,uS),this._renderer.xr.enabled=hS,e.scissorTest=!1,yy(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===zh||e.mapping===Vh?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),lS=this._renderer.getRenderTarget(),cS=this._renderer.getActiveCubeFace(),uS=this._renderer.getActiveMipmapLevel(),hS=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const n=t||this._allocateTargets();return this._textureToCubeUV(e,n),this._applyPMREM(n),this._cleanup(n),n}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,n={magFilter:Ga,minFilter:Ga,generateMipmaps:!1,type:Np,format:Ka,colorSpace:pl,depthBuffer:!1},i=gD(e,t,n);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=gD(e,t,n);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=ere(r)),this._blurMaterial=tre(r,e,t)}return i}_compileMaterial(e){const t=new ws(this._lodPlanes[0],e);this._renderer.compile(t,oS)}_sceneToCubeUV(e,t,n,i){const s=new Cr(90,1,t,n),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],h=this._renderer,d=h.autoClear,p=h.toneMapping;h.getClearColor(pD),h.toneMapping=Z2,h.autoClear=!1;const m=new TL({name:"PMREM.Background",side:er,depthWrite:!1,depthTest:!1}),g=new ws(new Dp,m);let _=!1;const v=e.background;v?v.isColor&&(m.color.copy(v),e.background=null,_=!0):(m.color.copy(pD),_=!0);for(let b=0;b<6;b++){const T=b%3;T===0?(s.up.set(0,l[b],0),s.lookAt(c[b],0,0)):T===1?(s.up.set(0,0,l[b]),s.lookAt(0,c[b],0)):(s.up.set(0,l[b],0),s.lookAt(0,0,c[b]));const E=this._cubeSize;yy(i,T*E,b>2?E:0,E,E),h.setRenderTarget(i),_&&h.render(g,s),h.render(e,s)}g.geometry.dispose(),g.material.dispose(),h.toneMapping=p,h.autoClear=d,e.background=v}_textureToCubeUV(e,t){const n=this._renderer,i=e.mapping===zh||e.mapping===Vh;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=bD()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=vD());const r=i?this._cubemapMaterial:this._equirectMaterial,a=new ws(this._lodPlanes[0],r),s=r.uniforms;s.envMap.value=e;const l=this._cubeSize;yy(t,0,0,3*l,2*l),n.setRenderTarget(t),n.render(a,oS)}_applyPMREM(e){const t=this._renderer,n=t.autoClear;t.autoClear=!1;const i=this._lodPlanes.length;for(let r=1;r<i;r++){const a=Math.sqrt(this._sigmas[r]*this._sigmas[r]-this._sigmas[r-1]*this._sigmas[r-1]),s=mD[(i-r-1)%mD.length];this._blur(e,r-1,r,a,s)}t.autoClear=n}_blur(e,t,n,i,r){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,n,i,"latitudinal",r),this._halfBlur(a,e,n,n,i,"longitudinal",r)}_halfBlur(e,t,n,i,r,a,s){const l=this._renderer,c=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const h=3,d=new ws(this._lodPlanes[i],c),p=c.uniforms,m=this._sizeLods[n]-1,g=isFinite(r)?Math.PI/(2*m):2*Math.PI/(2*ic-1),_=r/g,v=isFinite(r)?1+Math.floor(h*_):ic;v>ic&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${ic}`);const b=[];let T=0;for(let C=0;C<ic;++C){const k=C/_,P=Math.exp(-k*k/2);b.push(P),C===0?T+=P:C<v&&(T+=2*P)}for(let C=0;C<b.length;C++)b[C]=b[C]/T;p.envMap.value=e.texture,p.samples.value=v,p.weights.value=b,p.latitudinal.value=a==="latitudinal",s&&(p.poleAxis.value=s);const{_lodMax:E}=this;p.dTheta.value=g,p.mipInt.value=E-n;const A=this._sizeLods[i],M=3*A*(i>E-xh?i-E+xh:0),R=4*(this._cubeSize-A);yy(t,M,R,3*A,2*A),l.setRenderTarget(t),l.render(d,oS)}}function ere(x){const e=[],t=[],n=[];let i=x;const r=x-xh+1+fD.length;for(let a=0;a<r;a++){const s=Math.pow(2,i);t.push(s);let l=1/s;a>x-xh?l=fD[a-x+xh-1]:a===0&&(l=0),n.push(l);const c=1/(s-2),h=-c,d=1+c,p=[h,h,d,h,d,d,h,h,d,d,h,d],m=6,g=6,_=3,v=2,b=1,T=new Float32Array(_*g*m),E=new Float32Array(v*g*m),A=new Float32Array(b*g*m);for(let R=0;R<m;R++){const C=R%3*2/3-1,k=R>2?0:-1,P=[C,k,0,C+2/3,k,0,C+2/3,k+1,0,C,k,0,C+2/3,k+1,0,C,k+1,0];T.set(P,_*g*R),E.set(p,v*g*R);const N=[R,R,R,R,R,R];A.set(N,b*g*R)}const M=new dd;M.setAttribute("position",new Es(T,_)),M.setAttribute("uv",new Es(E,v)),M.setAttribute("faceIndex",new Es(A,b)),e.push(M),i>xh&&i--}return{lodPlanes:e,sizeLods:t,sigmas:n}}function gD(x,e,t){const n=new Ic(x,e,t);return n.texture.mapping=dv,n.texture.name="PMREM.cubeUv",n.scissorTest=!0,n}function yy(x,e,t,n,i){x.viewport.set(e,t,n,i),x.scissor.set(e,t,n,i)}function tre(x,e,t){const n=new Float32Array(ic),i=new Be(0,1,0);return new rl({name:"SphericalGaussianBlur",defines:{n:ic,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${x}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:n},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:OM(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Q2,depthTest:!1,depthWrite:!1})}function vD(){return new rl({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:OM(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Q2,depthTest:!1,depthWrite:!1})}function bD(){return new rl({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:OM(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Q2,depthTest:!1,depthWrite:!1})}function OM(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function xre(x){let e=new WeakMap,t=null;function n(s){if(s&&s.isTexture){const l=s.mapping,c=l===tw||l===xw,h=l===zh||l===Vh;if(c||h){let d=e.get(s);const p=d!==void 0?d.texture.pmremVersion:0;if(s.isRenderTargetTexture&&s.pmremVersion!==p)return t===null&&(t=new yD(x)),d=c?t.fromEquirectangular(s,d):t.fromCubemap(s,d),d.texture.pmremVersion=s.pmremVersion,e.set(s,d),d.texture;if(d!==void 0)return d.texture;{const m=s.image;return c&&m&&m.height>0||h&&m&&i(m)?(t===null&&(t=new yD(x)),d=c?t.fromEquirectangular(s):t.fromCubemap(s),d.texture.pmremVersion=s.pmremVersion,e.set(s,d),s.addEventListener("dispose",r),d.texture):null}}}return s}function i(s){let l=0;const c=6;for(let h=0;h<c;h++)s[h]!==void 0&&l++;return l===c}function r(s){const l=s.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:n,dispose:a}}function nre(x){const e={};function t(n){if(e[n]!==void 0)return e[n];let i;switch(n){case"WEBGL_depth_texture":i=x.getExtension("WEBGL_depth_texture")||x.getExtension("MOZ_WEBGL_depth_texture")||x.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=x.getExtension("EXT_texture_filter_anisotropic")||x.getExtension("MOZ_EXT_texture_filter_anisotropic")||x.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=x.getExtension("WEBGL_compressed_texture_s3tc")||x.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||x.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=x.getExtension("WEBGL_compressed_texture_pvrtc")||x.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=x.getExtension(n)}return e[n]=i,i}return{has:function(n){return t(n)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(n){const i=t(n);return i===null&&Ff("THREE.WebGLRenderer: "+n+" extension not supported."),i}}}function ire(x,e,t,n){const i={},r=new WeakMap;function a(d){const p=d.target;p.index!==null&&e.remove(p.index);for(const g in p.attributes)e.remove(p.attributes[g]);for(const g in p.morphAttributes){const _=p.morphAttributes[g];for(let v=0,b=_.length;v<b;v++)e.remove(_[v])}p.removeEventListener("dispose",a),delete i[p.id];const m=r.get(p);m&&(e.remove(m),r.delete(p)),n.releaseStatesOfGeometry(p),p.isInstancedBufferGeometry===!0&&delete p._maxInstanceCount,t.memory.geometries--}function s(d,p){return i[p.id]===!0||(p.addEventListener("dispose",a),i[p.id]=!0,t.memory.geometries++),p}function l(d){const p=d.attributes;for(const g in p)e.update(p[g],x.ARRAY_BUFFER);const m=d.morphAttributes;for(const g in m){const _=m[g];for(let v=0,b=_.length;v<b;v++)e.update(_[v],x.ARRAY_BUFFER)}}function c(d){const p=[],m=d.index,g=d.attributes.position;let _=0;if(m!==null){const T=m.array;_=m.version;for(let E=0,A=T.length;E<A;E+=3){const M=T[E+0],R=T[E+1],C=T[E+2];p.push(M,R,R,C,C,M)}}else if(g!==void 0){const T=g.array;_=g.version;for(let E=0,A=T.length/3-1;E<A;E+=3){const M=E+0,R=E+1,C=E+2;p.push(M,R,R,C,C,M)}}else return;const v=new(mL(p)?gL:yL)(p,1);v.version=_;const b=r.get(d);b&&e.remove(b),r.set(d,v)}function h(d){const p=r.get(d);if(p){const m=d.index;m!==null&&p.version<m.version&&c(d)}else c(d);return r.get(d)}return{get:s,update:l,getWireframeAttribute:h}}function rre(x,e,t){let n;function i(p){n=p}let r,a;function s(p){r=p.type,a=p.bytesPerElement}function l(p,m){x.drawElements(n,m,r,p*a),t.update(m,n,1)}function c(p,m,g){g!==0&&(x.drawElementsInstanced(n,m,r,p*a,g),t.update(m,n,g))}function h(p,m,g){if(g===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n,m,0,r,p,0,g);let v=0;for(let b=0;b<g;b++)v+=m[b];t.update(v,n,1)}function d(p,m,g,_){if(g===0)return;const v=e.get("WEBGL_multi_draw");if(v===null)for(let b=0;b<p.length;b++)c(p[b]/a,m[b],_[b]);else{v.multiDrawElementsInstancedWEBGL(n,m,0,r,p,0,_,0,g);let b=0;for(let T=0;T<g;T++)b+=m[T];for(let T=0;T<_.length;T++)t.update(b,n,_[T])}}this.setMode=i,this.setIndex=s,this.render=l,this.renderInstances=c,this.renderMultiDraw=h,this.renderMultiDrawInstances=d}function are(x){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function n(r,a,s){switch(t.calls++,a){case x.TRIANGLES:t.triangles+=s*(r/3);break;case x.LINES:t.lines+=s*(r/2);break;case x.LINE_STRIP:t.lines+=s*(r-1);break;case x.LINE_LOOP:t.lines+=s*r;break;case x.POINTS:t.points+=s*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:n}}class RL extends ns{constructor(e=null,t=1,n=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=ga,this.minFilter=ga,this.wrapR=lc,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}function sre(x,e,t){const n=new WeakMap,i=new ui;function r(a,s,l){const c=a.morphTargetInfluences,h=s.morphAttributes.position||s.morphAttributes.normal||s.morphAttributes.color,d=h!==void 0?h.length:0;let p=n.get(s);if(p===void 0||p.count!==d){let P=function(){C.dispose(),n.delete(s),s.removeEventListener("dispose",P)};p!==void 0&&p.texture.dispose();const m=s.morphAttributes.position!==void 0,g=s.morphAttributes.normal!==void 0,_=s.morphAttributes.color!==void 0,v=s.morphAttributes.position||[],b=s.morphAttributes.normal||[],T=s.morphAttributes.color||[];let E=0;m===!0&&(E=1),g===!0&&(E=2),_===!0&&(E=3);let A=s.attributes.position.count*E,M=1;A>e.maxTextureSize&&(M=Math.ceil(A/e.maxTextureSize),A=e.maxTextureSize);const R=new Float32Array(A*M*4*d),C=new RL(R,A,M,d);C.type=Oo,C.needsUpdate=!0;const k=E*4;for(let N=0;N<d;N++){const G=v[N],te=b[N],j=T[N],xe=A*M*4*N;for(let ae=0;ae<G.count;ae++){const H=ae*k;m===!0&&(i.fromBufferAttribute(G,ae),R[xe+H+0]=i.x,R[xe+H+1]=i.y,R[xe+H+2]=i.z,R[xe+H+3]=0),g===!0&&(i.fromBufferAttribute(te,ae),R[xe+H+4]=i.x,R[xe+H+5]=i.y,R[xe+H+6]=i.z,R[xe+H+7]=0),_===!0&&(i.fromBufferAttribute(j,ae),R[xe+H+8]=i.x,R[xe+H+9]=i.y,R[xe+H+10]=i.z,R[xe+H+11]=j.itemSize===4?i.w:1)}}p={count:d,texture:C,size:new fx(A,M)},n.set(s,p),s.addEventListener("dispose",P)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)l.getUniforms().setValue(x,"morphTexture",a.morphTexture,t);else{let m=0;for(let _=0;_<c.length;_++)m+=c[_];const g=s.morphTargetsRelative?1:1-m;l.getUniforms().setValue(x,"morphTargetBaseInfluence",g),l.getUniforms().setValue(x,"morphTargetInfluences",c)}l.getUniforms().setValue(x,"morphTargetsTexture",p.texture,t),l.getUniforms().setValue(x,"morphTargetsTextureSize",p.size)}return{update:r}}function ore(x,e,t,n){let i=new WeakMap;function r(l){const c=n.render.frame,h=l.geometry,d=e.get(l,h);if(i.get(d)!==c&&(e.update(d),i.set(d,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",s)===!1&&l.addEventListener("dispose",s),i.get(l)!==c&&(t.update(l.instanceMatrix,x.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,x.ARRAY_BUFFER),i.set(l,c))),l.isSkinnedMesh){const p=l.skeleton;i.get(p)!==c&&(p.update(),i.set(p,c))}return d}function a(){i=new WeakMap}function s(l){const c=l.target;c.removeEventListener("dispose",s),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:r,dispose:a}}class lre extends ns{constructor(e=null,t=1,n=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:n,depth:i},this.magFilter=ga,this.minFilter=ga,this.wrapR=lc,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class CL extends ns{constructor(e,t,n,i,r,a,s,l,c,h=fh){if(h!==fh&&h!==Gh)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");n===void 0&&h===fh&&(n=Cc),n===void 0&&h===Gh&&(n=Hh),super(null,i,r,a,s,l,h,n,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=s!==void 0?s:ga,this.minFilter=l!==void 0?l:ga,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}const NL=new ns,_D=new CL(1,1),IL=new RL,OL=new lre,DL=new EL,SD=[],TD=[],wD=new Float32Array(16),AD=new Float32Array(9),ED=new Float32Array(4);function fd(x,e,t){const n=x[0];if(n<=0||n>0)return x;const i=e*t;let r=SD[i];if(r===void 0&&(r=new Float32Array(i),SD[i]=r),e!==0){n.toArray(r,0);for(let a=1,s=0;a!==e;++a)s+=t,x[a].toArray(r,s)}return r}function Cn(x,e){if(x.length!==e.length)return!1;for(let t=0,n=x.length;t<n;t++)if(x[t]!==e[t])return!1;return!0}function Nn(x,e){for(let t=0,n=e.length;t<n;t++)x[t]=e[t]}function mv(x,e){let t=TD[e];t===void 0&&(t=new Int32Array(e),TD[e]=t);for(let n=0;n!==e;++n)t[n]=x.allocateTextureUnit();return t}function cre(x,e){const t=this.cache;t[0]!==e&&(x.uniform1f(this.addr,e),t[0]=e)}function ure(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(x.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Cn(t,e))return;x.uniform2fv(this.addr,e),Nn(t,e)}}function hre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(x.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(x.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Cn(t,e))return;x.uniform3fv(this.addr,e),Nn(t,e)}}function dre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(x.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Cn(t,e))return;x.uniform4fv(this.addr,e),Nn(t,e)}}function fre(x,e){const t=this.cache,n=e.elements;if(n===void 0){if(Cn(t,e))return;x.uniformMatrix2fv(this.addr,!1,e),Nn(t,e)}else{if(Cn(t,n))return;ED.set(n),x.uniformMatrix2fv(this.addr,!1,ED),Nn(t,n)}}function pre(x,e){const t=this.cache,n=e.elements;if(n===void 0){if(Cn(t,e))return;x.uniformMatrix3fv(this.addr,!1,e),Nn(t,e)}else{if(Cn(t,n))return;AD.set(n),x.uniformMatrix3fv(this.addr,!1,AD),Nn(t,n)}}function mre(x,e){const t=this.cache,n=e.elements;if(n===void 0){if(Cn(t,e))return;x.uniformMatrix4fv(this.addr,!1,e),Nn(t,e)}else{if(Cn(t,n))return;wD.set(n),x.uniformMatrix4fv(this.addr,!1,wD),Nn(t,n)}}function yre(x,e){const t=this.cache;t[0]!==e&&(x.uniform1i(this.addr,e),t[0]=e)}function gre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(x.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Cn(t,e))return;x.uniform2iv(this.addr,e),Nn(t,e)}}function vre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(x.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Cn(t,e))return;x.uniform3iv(this.addr,e),Nn(t,e)}}function bre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(x.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Cn(t,e))return;x.uniform4iv(this.addr,e),Nn(t,e)}}function _re(x,e){const t=this.cache;t[0]!==e&&(x.uniform1ui(this.addr,e),t[0]=e)}function Sre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(x.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Cn(t,e))return;x.uniform2uiv(this.addr,e),Nn(t,e)}}function Tre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(x.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Cn(t,e))return;x.uniform3uiv(this.addr,e),Nn(t,e)}}function wre(x,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(x.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Cn(t,e))return;x.uniform4uiv(this.addr,e),Nn(t,e)}}function Are(x,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(x.uniform1i(this.addr,i),n[0]=i);let r;this.type===x.SAMPLER_2D_SHADOW?(_D.compareFunction=oL,r=_D):r=NL,t.setTexture2D(e||r,i)}function Ere(x,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(x.uniform1i(this.addr,i),n[0]=i),t.setTexture3D(e||OL,i)}function Mre(x,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(x.uniform1i(this.addr,i),n[0]=i),t.setTextureCube(e||DL,i)}function Rre(x,e,t){const n=this.cache,i=t.allocateTextureUnit();n[0]!==i&&(x.uniform1i(this.addr,i),n[0]=i),t.setTexture2DArray(e||IL,i)}function Cre(x){switch(x){case 5126:return cre;case 35664:return ure;case 35665:return hre;case 35666:return dre;case 35674:return fre;case 35675:return pre;case 35676:return mre;case 5124:case 35670:return yre;case 35667:case 35671:return gre;case 35668:case 35672:return vre;case 35669:case 35673:return bre;case 5125:return _re;case 36294:return Sre;case 36295:return Tre;case 36296:return wre;case 35678:case 36198:case 36298:case 36306:case 35682:return Are;case 35679:case 36299:case 36307:return Ere;case 35680:case 36300:case 36308:case 36293:return Mre;case 36289:case 36303:case 36311:case 36292:return Rre}}function Nre(x,e){x.uniform1fv(this.addr,e)}function Ire(x,e){const t=fd(e,this.size,2);x.uniform2fv(this.addr,t)}function Ore(x,e){const t=fd(e,this.size,3);x.uniform3fv(this.addr,t)}function Dre(x,e){const t=fd(e,this.size,4);x.uniform4fv(this.addr,t)}function Pre(x,e){const t=fd(e,this.size,4);x.uniformMatrix2fv(this.addr,!1,t)}function kre(x,e){const t=fd(e,this.size,9);x.uniformMatrix3fv(this.addr,!1,t)}function Ure(x,e){const t=fd(e,this.size,16);x.uniformMatrix4fv(this.addr,!1,t)}function Fre(x,e){x.uniform1iv(this.addr,e)}function Bre(x,e){x.uniform2iv(this.addr,e)}function Lre(x,e){x.uniform3iv(this.addr,e)}function zre(x,e){x.uniform4iv(this.addr,e)}function Vre(x,e){x.uniform1uiv(this.addr,e)}function Hre(x,e){x.uniform2uiv(this.addr,e)}function Gre(x,e){x.uniform3uiv(this.addr,e)}function Wre(x,e){x.uniform4uiv(this.addr,e)}function Xre(x,e,t){const n=this.cache,i=e.length,r=mv(t,i);Cn(n,r)||(x.uniform1iv(this.addr,r),Nn(n,r));for(let a=0;a!==i;++a)t.setTexture2D(e[a]||NL,r[a])}function Yre(x,e,t){const n=this.cache,i=e.length,r=mv(t,i);Cn(n,r)||(x.uniform1iv(this.addr,r),Nn(n,r));for(let a=0;a!==i;++a)t.setTexture3D(e[a]||OL,r[a])}function Kre(x,e,t){const n=this.cache,i=e.length,r=mv(t,i);Cn(n,r)||(x.uniform1iv(this.addr,r),Nn(n,r));for(let a=0;a!==i;++a)t.setTextureCube(e[a]||DL,r[a])}function $re(x,e,t){const n=this.cache,i=e.length,r=mv(t,i);Cn(n,r)||(x.uniform1iv(this.addr,r),Nn(n,r));for(let a=0;a!==i;++a)t.setTexture2DArray(e[a]||IL,r[a])}function Qre(x){switch(x){case 5126:return Nre;case 35664:return Ire;case 35665:return Ore;case 35666:return Dre;case 35674:return Pre;case 35675:return kre;case 35676:return Ure;case 5124:case 35670:return Fre;case 35667:case 35671:return Bre;case 35668:case 35672:return Lre;case 35669:case 35673:return zre;case 5125:return Vre;case 36294:return Hre;case 36295:return Gre;case 36296:return Wre;case 35678:case 36198:case 36298:case 36306:case 35682:return Xre;case 35679:case 36299:case 36307:return Yre;case 35680:case 36300:case 36308:case 36293:return Kre;case 36289:case 36303:case 36311:case 36292:return $re}}class Zre{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.setValue=Cre(t.type)}}class Jre{constructor(e,t,n){this.id=e,this.addr=n,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=Qre(t.type)}}class jre{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,n){const i=this.seq;for(let r=0,a=i.length;r!==a;++r){const s=i[r];s.setValue(e,t[s.id],n)}}}const dS=/(\w+)(\])?(\[|\.)?/g;function MD(x,e){x.seq.push(e),x.map[e.id]=e}function qre(x,e,t){const n=x.name,i=n.length;for(dS.lastIndex=0;;){const r=dS.exec(n),a=dS.lastIndex;let s=r[1];const l=r[2]==="]",c=r[3];if(l&&(s=s|0),c===void 0||c==="["&&a+2===i){MD(t,c===void 0?new Zre(s,x,e):new Jre(s,x,e));break}else{let d=t.map[s];d===void 0&&(d=new jre(s),MD(t,d)),t=d}}}class m1{constructor(e,t){this.seq=[],this.map={};const n=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){const r=e.getActiveUniform(t,i),a=e.getUniformLocation(t,r.name);qre(r,a,this)}}setValue(e,t,n,i){const r=this.map[t];r!==void 0&&r.setValue(e,n,i)}setOptional(e,t,n){const i=t[n];i!==void 0&&this.setValue(e,n,i)}static upload(e,t,n,i){for(let r=0,a=t.length;r!==a;++r){const s=t[r],l=n[s.id];l.needsUpdate!==!1&&s.setValue(e,l.value,i)}}static seqWithValue(e,t){const n=[];for(let i=0,r=e.length;i!==r;++i){const a=e[i];a.id in t&&n.push(a)}return n}}function RD(x,e,t){const n=x.createShader(e);return x.shaderSource(n,t),x.compileShader(n),n}const eae=37297;let tae=0;function xae(x,e){const t=x.split(`
`),n=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let a=i;a<r;a++){const s=a+1;n.push(`${s===e?">":" "} ${s}: ${t[a]}`)}return n.join(`
`)}function nae(x){const e=J0.getPrimaries(J0.workingColorSpace),t=J0.getPrimaries(x);let n;switch(e===t?n="":e===eg&&t===q1?n="LinearDisplayP3ToLinearSRGB":e===q1&&t===eg&&(n="LinearSRGBToLinearDisplayP3"),x){case pl:case fv:return[n,"LinearTransferOETF"];case La:case NM:return[n,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",x),[n,"LinearTransferOETF"]}}function CD(x,e,t){const n=x.getShaderParameter(e,x.COMPILE_STATUS),i=x.getShaderInfoLog(e).trim();if(n&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const a=parseInt(r[1]);return t.toUpperCase()+`

`+i+`

`+xae(x.getShaderSource(e),a)}else return i}function iae(x,e){const t=nae(e);return`vec4 ${x}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function rae(x,e){let t;switch(e){case _0e:t="Linear";break;case S0e:t="Reinhard";break;case T0e:t="Cineon";break;case w0e:t="ACESFilmic";break;case E0e:t="AgX";break;case M0e:t="Neutral";break;case A0e:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+x+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const gy=new Be;function aae(){J0.getLuminanceCoefficients(gy);const x=gy.x.toFixed(4),e=gy.y.toFixed(4),t=gy.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${x}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function sae(x){return[x.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",x.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(Of).join(`
`)}function oae(x){const e=[];for(const t in x){const n=x[t];n!==!1&&e.push("#define "+t+" "+n)}return e.join(`
`)}function lae(x,e){const t={},n=x.getProgramParameter(e,x.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const r=x.getActiveAttrib(e,i),a=r.name;let s=1;r.type===x.FLOAT_MAT2&&(s=2),r.type===x.FLOAT_MAT3&&(s=3),r.type===x.FLOAT_MAT4&&(s=4),t[a]={type:r.type,location:x.getAttribLocation(e,a),locationSize:s}}return t}function Of(x){return x!==""}function ND(x,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return x.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function ID(x,e){return x.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const cae=/^[ \t]*#include +<([\w\d./]+)>/gm;function Dw(x){return x.replace(cae,hae)}const uae=new Map;function hae(x,e){let t=g0[e];if(t===void 0){const n=uae.get(e);if(n!==void 0)t=g0[n],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,n);else throw new Error("Can not resolve #include <"+e+">")}return Dw(t)}const dae=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function OD(x){return x.replace(dae,fae)}function fae(x,e,t,n){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=n.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function DD(x){let e=`precision ${x.precision} float;
	precision ${x.precision} int;
	precision ${x.precision} sampler2D;
	precision ${x.precision} samplerCube;
	precision ${x.precision} sampler3D;
	precision ${x.precision} sampler2DArray;
	precision ${x.precision} sampler2DShadow;
	precision ${x.precision} samplerCubeShadow;
	precision ${x.precision} sampler2DArrayShadow;
	precision ${x.precision} isampler2D;
	precision ${x.precision} isampler3D;
	precision ${x.precision} isamplerCube;
	precision ${x.precision} isampler2DArray;
	precision ${x.precision} usampler2D;
	precision ${x.precision} usampler3D;
	precision ${x.precision} usamplerCube;
	precision ${x.precision} usampler2DArray;
	`;return x.precision==="highp"?e+=`
#define HIGH_PRECISION`:x.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:x.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function pae(x){let e="SHADOWMAP_TYPE_BASIC";return x.shadowMapType===QB?e="SHADOWMAP_TYPE_PCF":x.shadowMapType===Kte?e="SHADOWMAP_TYPE_PCF_SOFT":x.shadowMapType===go&&(e="SHADOWMAP_TYPE_VSM"),e}function mae(x){let e="ENVMAP_TYPE_CUBE";if(x.envMap)switch(x.envMapMode){case zh:case Vh:e="ENVMAP_TYPE_CUBE";break;case dv:e="ENVMAP_TYPE_CUBE_UV";break}return e}function yae(x){let e="ENVMAP_MODE_REFLECTION";if(x.envMap)switch(x.envMapMode){case Vh:e="ENVMAP_MODE_REFRACTION";break}return e}function gae(x){let e="ENVMAP_BLENDING_NONE";if(x.envMap)switch(x.combine){case ZB:e="ENVMAP_BLENDING_MULTIPLY";break;case v0e:e="ENVMAP_BLENDING_MIX";break;case b0e:e="ENVMAP_BLENDING_ADD";break}return e}function vae(x){const e=x.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,n=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:n,maxMip:t}}function bae(x,e,t,n){const i=x.getContext(),r=t.defines;let a=t.vertexShader,s=t.fragmentShader;const l=pae(t),c=mae(t),h=yae(t),d=gae(t),p=vae(t),m=sae(t),g=oae(r),_=i.createProgram();let v,b,T=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(v=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g].filter(Of).join(`
`),v.length>0&&(v+=`
`),b=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g].filter(Of).join(`
`),b.length>0&&(b+=`
`)):(v=[DD(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Of).join(`
`),b=[DD(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,g,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+h:"",t.envMap?"#define "+d:"",p?"#define CUBEUV_TEXEL_WIDTH "+p.texelWidth:"",p?"#define CUBEUV_TEXEL_HEIGHT "+p.texelHeight:"",p?"#define CUBEUV_MAX_MIP "+p.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Z2?"#define TONE_MAPPING":"",t.toneMapping!==Z2?g0.tonemapping_pars_fragment:"",t.toneMapping!==Z2?rae("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",g0.colorspace_pars_fragment,iae("linearToOutputTexel",t.outputColorSpace),aae(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Of).join(`
`)),a=Dw(a),a=ND(a,t),a=ID(a,t),s=Dw(s),s=ND(s,t),s=ID(s,t),a=OD(a),s=OD(s),t.isRawShaderMaterial!==!0&&(T=`#version 300 es
`,v=[m,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+v,b=["#define varying in",t.glslVersion===$O?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===$O?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+b);const E=T+v+a,A=T+b+s,M=RD(i,i.VERTEX_SHADER,E),R=RD(i,i.FRAGMENT_SHADER,A);i.attachShader(_,M),i.attachShader(_,R),t.index0AttributeName!==void 0?i.bindAttribLocation(_,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(_,0,"position"),i.linkProgram(_);function C(G){if(x.debug.checkShaderErrors){const te=i.getProgramInfoLog(_).trim(),j=i.getShaderInfoLog(M).trim(),xe=i.getShaderInfoLog(R).trim();let ae=!0,H=!0;if(i.getProgramParameter(_,i.LINK_STATUS)===!1)if(ae=!1,typeof x.debug.onShaderError=="function")x.debug.onShaderError(i,_,M,R);else{const re=CD(i,M,"vertex"),q=CD(i,R,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(_,i.VALIDATE_STATUS)+`

Material Name: `+G.name+`
Material Type: `+G.type+`

Program Info Log: `+te+`
`+re+`
`+q)}else te!==""?console.warn("THREE.WebGLProgram: Program Info Log:",te):(j===""||xe==="")&&(H=!1);H&&(G.diagnostics={runnable:ae,programLog:te,vertexShader:{log:j,prefix:v},fragmentShader:{log:xe,prefix:b}})}i.deleteShader(M),i.deleteShader(R),k=new m1(i,_),P=lae(i,_)}let k;this.getUniforms=function(){return k===void 0&&C(this),k};let P;this.getAttributes=function(){return P===void 0&&C(this),P};let N=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return N===!1&&(N=i.getProgramParameter(_,eae)),N},this.destroy=function(){n.releaseStatesOfProgram(this),i.deleteProgram(_),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=tae++,this.cacheKey=e,this.usedTimes=1,this.program=_,this.vertexShader=M,this.fragmentShader=R,this}let _ae=0;class Sae{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,n=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(n),a=this._getShaderCacheForMaterial(e);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(r)===!1&&(a.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const n of t)n.usedTimes--,n.usedTimes===0&&this.shaderCache.delete(n.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let n=t.get(e);return n===void 0&&(n=new Set,t.set(e,n)),n}_getShaderStage(e){const t=this.shaderCache;let n=t.get(e);return n===void 0&&(n=new Tae(e),t.set(e,n)),n}}class Tae{constructor(e){this.id=_ae++,this.code=e,this.usedTimes=0}}function wae(x,e,t,n,i,r,a){const s=new bL,l=new Sae,c=new Set,h=[],d=i.logarithmicDepthBuffer,p=i.vertexTextures;let m=i.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function _(P){return c.add(P),P===0?"uv":`uv${P}`}function v(P,N,G,te,j){const xe=te.fog,ae=j.geometry,H=P.isMeshStandardMaterial?te.environment:null,re=(P.isMeshStandardMaterial?t:e).get(P.envMap||H),q=re&&re.mapping===dv?re.image.height:null,be=g[P.type];P.precision!==null&&(m=i.getMaxPrecision(P.precision),m!==P.precision&&console.warn("THREE.WebGLProgram.getParameters:",P.precision,"not supported, using",m,"instead."));const K=ae.morphAttributes.position||ae.morphAttributes.normal||ae.morphAttributes.color,se=K!==void 0?K.length:0;let ge=0;ae.morphAttributes.position!==void 0&&(ge=1),ae.morphAttributes.normal!==void 0&&(ge=2),ae.morphAttributes.color!==void 0&&(ge=3);let Me,le,Se,Fe;if(be){const s0=Ss[be];Me=s0.vertexShader,le=s0.fragmentShader}else Me=P.vertexShader,le=P.fragmentShader,l.update(P),Se=l.getVertexShaderID(P),Fe=l.getFragmentShaderID(P);const Qe=x.getRenderTarget(),qe=j.isInstancedMesh===!0,Et=j.isBatchedMesh===!0,Tt=!!P.map,Bt=!!P.matcap,Q=!!re,rt=!!P.aoMap,He=!!P.lightMap,at=!!P.bumpMap,Ue=!!P.normalMap,bt=!!P.displacementMap,ht=!!P.emissiveMap,dt=!!P.metalnessMap,Z=!!P.roughnessMap,V=P.anisotropy>0,_e=P.clearcoat>0,Ge=P.dispersion>0,Re=P.iridescence>0,Ve=P.sheen>0,_t=P.transmission>0,Ce=V&&!!P.anisotropyMap,pt=_e&&!!P.clearcoatMap,et=_e&&!!P.clearcoatNormalMap,tt=_e&&!!P.clearcoatRoughnessMap,gt=Re&&!!P.iridescenceMap,i0=Re&&!!P.iridescenceThicknessMap,Ht=Ve&&!!P.sheenColorMap,St=Ve&&!!P.sheenRoughnessMap,Ut=!!P.specularMap,t0=!!P.specularColorMap,p0=!!P.specularIntensityMap,de=_t&&!!P.transmissionMap,ft=_t&&!!P.thicknessMap,Xe=!!P.gradientMap,Ze=!!P.alphaMap,lt=P.alphaTest>0,Wt=!!P.alphaHash,Qt=!!P.extensions;let D0=Z2;P.toneMapped&&(Qe===null||Qe.isXRRenderTarget===!0)&&(D0=x.toneMapping);const P0={shaderID:be,shaderType:P.type,shaderName:P.name,vertexShader:Me,fragmentShader:le,defines:P.defines,customVertexShaderID:Se,customFragmentShaderID:Fe,isRawShaderMaterial:P.isRawShaderMaterial===!0,glslVersion:P.glslVersion,precision:m,batching:Et,batchingColor:Et&&j._colorsTexture!==null,instancing:qe,instancingColor:qe&&j.instanceColor!==null,instancingMorph:qe&&j.morphTexture!==null,supportsVertexTextures:p,outputColorSpace:Qe===null?x.outputColorSpace:Qe.isXRRenderTarget===!0?Qe.texture.colorSpace:pl,alphaToCoverage:!!P.alphaToCoverage,map:Tt,matcap:Bt,envMap:Q,envMapMode:Q&&re.mapping,envMapCubeUVHeight:q,aoMap:rt,lightMap:He,bumpMap:at,normalMap:Ue,displacementMap:p&&bt,emissiveMap:ht,normalMapObjectSpace:Ue&&P.normalMapType===O0e,normalMapTangentSpace:Ue&&P.normalMapType===I0e,metalnessMap:dt,roughnessMap:Z,anisotropy:V,anisotropyMap:Ce,clearcoat:_e,clearcoatMap:pt,clearcoatNormalMap:et,clearcoatRoughnessMap:tt,dispersion:Ge,iridescence:Re,iridescenceMap:gt,iridescenceThicknessMap:i0,sheen:Ve,sheenColorMap:Ht,sheenRoughnessMap:St,specularMap:Ut,specularColorMap:t0,specularIntensityMap:p0,transmission:_t,transmissionMap:de,thicknessMap:ft,gradientMap:Xe,opaque:P.transparent===!1&&P.blending===dh&&P.alphaToCoverage===!1,alphaMap:Ze,alphaTest:lt,alphaHash:Wt,combine:P.combine,mapUv:Tt&&_(P.map.channel),aoMapUv:rt&&_(P.aoMap.channel),lightMapUv:He&&_(P.lightMap.channel),bumpMapUv:at&&_(P.bumpMap.channel),normalMapUv:Ue&&_(P.normalMap.channel),displacementMapUv:bt&&_(P.displacementMap.channel),emissiveMapUv:ht&&_(P.emissiveMap.channel),metalnessMapUv:dt&&_(P.metalnessMap.channel),roughnessMapUv:Z&&_(P.roughnessMap.channel),anisotropyMapUv:Ce&&_(P.anisotropyMap.channel),clearcoatMapUv:pt&&_(P.clearcoatMap.channel),clearcoatNormalMapUv:et&&_(P.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:tt&&_(P.clearcoatRoughnessMap.channel),iridescenceMapUv:gt&&_(P.iridescenceMap.channel),iridescenceThicknessMapUv:i0&&_(P.iridescenceThicknessMap.channel),sheenColorMapUv:Ht&&_(P.sheenColorMap.channel),sheenRoughnessMapUv:St&&_(P.sheenRoughnessMap.channel),specularMapUv:Ut&&_(P.specularMap.channel),specularColorMapUv:t0&&_(P.specularColorMap.channel),specularIntensityMapUv:p0&&_(P.specularIntensityMap.channel),transmissionMapUv:de&&_(P.transmissionMap.channel),thicknessMapUv:ft&&_(P.thicknessMap.channel),alphaMapUv:Ze&&_(P.alphaMap.channel),vertexTangents:!!ae.attributes.tangent&&(Ue||V),vertexColors:P.vertexColors,vertexAlphas:P.vertexColors===!0&&!!ae.attributes.color&&ae.attributes.color.itemSize===4,pointsUvs:j.isPoints===!0&&!!ae.attributes.uv&&(Tt||Ze),fog:!!xe,useFog:P.fog===!0,fogExp2:!!xe&&xe.isFogExp2,flatShading:P.flatShading===!0,sizeAttenuation:P.sizeAttenuation===!0,logarithmicDepthBuffer:d,skinning:j.isSkinnedMesh===!0,morphTargets:ae.morphAttributes.position!==void 0,morphNormals:ae.morphAttributes.normal!==void 0,morphColors:ae.morphAttributes.color!==void 0,morphTargetsCount:se,morphTextureStride:ge,numDirLights:N.directional.length,numPointLights:N.point.length,numSpotLights:N.spot.length,numSpotLightMaps:N.spotLightMap.length,numRectAreaLights:N.rectArea.length,numHemiLights:N.hemi.length,numDirLightShadows:N.directionalShadowMap.length,numPointLightShadows:N.pointShadowMap.length,numSpotLightShadows:N.spotShadowMap.length,numSpotLightShadowsWithMaps:N.numSpotLightShadowsWithMaps,numLightProbes:N.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:P.dithering,shadowMapEnabled:x.shadowMap.enabled&&G.length>0,shadowMapType:x.shadowMap.type,toneMapping:D0,decodeVideoTexture:Tt&&P.map.isVideoTexture===!0&&J0.getTransfer(P.map.colorSpace)===Ex,premultipliedAlpha:P.premultipliedAlpha,doubleSided:P.side===Mo,flipSided:P.side===er,useDepthPacking:P.depthPacking>=0,depthPacking:P.depthPacking||0,index0AttributeName:P.index0AttributeName,extensionClipCullDistance:Qt&&P.extensions.clipCullDistance===!0&&n.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(Qt&&P.extensions.multiDraw===!0||Et)&&n.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:n.has("KHR_parallel_shader_compile"),customProgramCacheKey:P.customProgramCacheKey()};return P0.vertexUv1s=c.has(1),P0.vertexUv2s=c.has(2),P0.vertexUv3s=c.has(3),c.clear(),P0}function b(P){const N=[];if(P.shaderID?N.push(P.shaderID):(N.push(P.customVertexShaderID),N.push(P.customFragmentShaderID)),P.defines!==void 0)for(const G in P.defines)N.push(G),N.push(P.defines[G]);return P.isRawShaderMaterial===!1&&(T(N,P),E(N,P),N.push(x.outputColorSpace)),N.push(P.customProgramCacheKey),N.join()}function T(P,N){P.push(N.precision),P.push(N.outputColorSpace),P.push(N.envMapMode),P.push(N.envMapCubeUVHeight),P.push(N.mapUv),P.push(N.alphaMapUv),P.push(N.lightMapUv),P.push(N.aoMapUv),P.push(N.bumpMapUv),P.push(N.normalMapUv),P.push(N.displacementMapUv),P.push(N.emissiveMapUv),P.push(N.metalnessMapUv),P.push(N.roughnessMapUv),P.push(N.anisotropyMapUv),P.push(N.clearcoatMapUv),P.push(N.clearcoatNormalMapUv),P.push(N.clearcoatRoughnessMapUv),P.push(N.iridescenceMapUv),P.push(N.iridescenceThicknessMapUv),P.push(N.sheenColorMapUv),P.push(N.sheenRoughnessMapUv),P.push(N.specularMapUv),P.push(N.specularColorMapUv),P.push(N.specularIntensityMapUv),P.push(N.transmissionMapUv),P.push(N.thicknessMapUv),P.push(N.combine),P.push(N.fogExp2),P.push(N.sizeAttenuation),P.push(N.morphTargetsCount),P.push(N.morphAttributeCount),P.push(N.numDirLights),P.push(N.numPointLights),P.push(N.numSpotLights),P.push(N.numSpotLightMaps),P.push(N.numHemiLights),P.push(N.numRectAreaLights),P.push(N.numDirLightShadows),P.push(N.numPointLightShadows),P.push(N.numSpotLightShadows),P.push(N.numSpotLightShadowsWithMaps),P.push(N.numLightProbes),P.push(N.shadowMapType),P.push(N.toneMapping),P.push(N.numClippingPlanes),P.push(N.numClipIntersection),P.push(N.depthPacking)}function E(P,N){s.disableAll(),N.supportsVertexTextures&&s.enable(0),N.instancing&&s.enable(1),N.instancingColor&&s.enable(2),N.instancingMorph&&s.enable(3),N.matcap&&s.enable(4),N.envMap&&s.enable(5),N.normalMapObjectSpace&&s.enable(6),N.normalMapTangentSpace&&s.enable(7),N.clearcoat&&s.enable(8),N.iridescence&&s.enable(9),N.alphaTest&&s.enable(10),N.vertexColors&&s.enable(11),N.vertexAlphas&&s.enable(12),N.vertexUv1s&&s.enable(13),N.vertexUv2s&&s.enable(14),N.vertexUv3s&&s.enable(15),N.vertexTangents&&s.enable(16),N.anisotropy&&s.enable(17),N.alphaHash&&s.enable(18),N.batching&&s.enable(19),N.dispersion&&s.enable(20),N.batchingColor&&s.enable(21),P.push(s.mask),s.disableAll(),N.fog&&s.enable(0),N.useFog&&s.enable(1),N.flatShading&&s.enable(2),N.logarithmicDepthBuffer&&s.enable(3),N.skinning&&s.enable(4),N.morphTargets&&s.enable(5),N.morphNormals&&s.enable(6),N.morphColors&&s.enable(7),N.premultipliedAlpha&&s.enable(8),N.shadowMapEnabled&&s.enable(9),N.doubleSided&&s.enable(10),N.flipSided&&s.enable(11),N.useDepthPacking&&s.enable(12),N.dithering&&s.enable(13),N.transmission&&s.enable(14),N.sheen&&s.enable(15),N.opaque&&s.enable(16),N.pointsUvs&&s.enable(17),N.decodeVideoTexture&&s.enable(18),N.alphaToCoverage&&s.enable(19),P.push(s.mask)}function A(P){const N=g[P.type];let G;if(N){const te=Ss[N];G=nxe.clone(te.uniforms)}else G=P.uniforms;return G}function M(P,N){let G;for(let te=0,j=h.length;te<j;te++){const xe=h[te];if(xe.cacheKey===N){G=xe,++G.usedTimes;break}}return G===void 0&&(G=new bae(x,N,P,r),h.push(G)),G}function R(P){if(--P.usedTimes===0){const N=h.indexOf(P);h[N]=h[h.length-1],h.pop(),P.destroy()}}function C(P){l.remove(P)}function k(){l.dispose()}return{getParameters:v,getProgramCacheKey:b,getUniforms:A,acquireProgram:M,releaseProgram:R,releaseShaderCache:C,programs:h,dispose:k}}function Aae(){let x=new WeakMap;function e(a){return x.has(a)}function t(a){let s=x.get(a);return s===void 0&&(s={},x.set(a,s)),s}function n(a){x.delete(a)}function i(a,s,l){x.get(a)[s]=l}function r(){x=new WeakMap}return{has:e,get:t,remove:n,update:i,dispose:r}}function Eae(x,e){return x.groupOrder!==e.groupOrder?x.groupOrder-e.groupOrder:x.renderOrder!==e.renderOrder?x.renderOrder-e.renderOrder:x.material.id!==e.material.id?x.material.id-e.material.id:x.z!==e.z?x.z-e.z:x.id-e.id}function PD(x,e){return x.groupOrder!==e.groupOrder?x.groupOrder-e.groupOrder:x.renderOrder!==e.renderOrder?x.renderOrder-e.renderOrder:x.z!==e.z?e.z-x.z:x.id-e.id}function kD(){const x=[];let e=0;const t=[],n=[],i=[];function r(){e=0,t.length=0,n.length=0,i.length=0}function a(d,p,m,g,_,v){let b=x[e];return b===void 0?(b={id:d.id,object:d,geometry:p,material:m,groupOrder:g,renderOrder:d.renderOrder,z:_,group:v},x[e]=b):(b.id=d.id,b.object=d,b.geometry=p,b.material=m,b.groupOrder=g,b.renderOrder=d.renderOrder,b.z=_,b.group=v),e++,b}function s(d,p,m,g,_,v){const b=a(d,p,m,g,_,v);m.transmission>0?n.push(b):m.transparent===!0?i.push(b):t.push(b)}function l(d,p,m,g,_,v){const b=a(d,p,m,g,_,v);m.transmission>0?n.unshift(b):m.transparent===!0?i.unshift(b):t.unshift(b)}function c(d,p){t.length>1&&t.sort(d||Eae),n.length>1&&n.sort(p||PD),i.length>1&&i.sort(p||PD)}function h(){for(let d=e,p=x.length;d<p;d++){const m=x[d];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.group=null}}return{opaque:t,transmissive:n,transparent:i,init:r,push:s,unshift:l,finish:h,sort:c}}function Mae(){let x=new WeakMap;function e(n,i){const r=x.get(n);let a;return r===void 0?(a=new kD,x.set(n,[a])):i>=r.length?(a=new kD,r.push(a)):a=r[i],a}function t(){x=new WeakMap}return{get:e,dispose:t}}function Rae(){const x={};return{get:function(e){if(x[e.id]!==void 0)return x[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new Be,color:new dx};break;case"SpotLight":t={position:new Be,direction:new Be,color:new dx,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new Be,color:new dx,distance:0,decay:0};break;case"HemisphereLight":t={direction:new Be,skyColor:new dx,groundColor:new dx};break;case"RectAreaLight":t={color:new dx,position:new Be,halfWidth:new Be,halfHeight:new Be};break}return x[e.id]=t,t}}}function Cae(){const x={};return{get:function(e){if(x[e.id]!==void 0)return x[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fx};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fx};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new fx,shadowCameraNear:1,shadowCameraFar:1e3};break}return x[e.id]=t,t}}}let Nae=0;function Iae(x,e){return(e.castShadow?2:0)-(x.castShadow?2:0)+(e.map?1:0)-(x.map?1:0)}function Oae(x){const e=new Rae,t=Cae(),n={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)n.probe.push(new Be);const i=new Be,r=new Hn,a=new Hn;function s(c){let h=0,d=0,p=0;for(let P=0;P<9;P++)n.probe[P].set(0,0,0);let m=0,g=0,_=0,v=0,b=0,T=0,E=0,A=0,M=0,R=0,C=0;c.sort(Iae);for(let P=0,N=c.length;P<N;P++){const G=c[P],te=G.color,j=G.intensity,xe=G.distance,ae=G.shadow&&G.shadow.map?G.shadow.map.texture:null;if(G.isAmbientLight)h+=te.r*j,d+=te.g*j,p+=te.b*j;else if(G.isLightProbe){for(let H=0;H<9;H++)n.probe[H].addScaledVector(G.sh.coefficients[H],j);C++}else if(G.isDirectionalLight){const H=e.get(G);if(H.color.copy(G.color).multiplyScalar(G.intensity),G.castShadow){const re=G.shadow,q=t.get(G);q.shadowIntensity=re.intensity,q.shadowBias=re.bias,q.shadowNormalBias=re.normalBias,q.shadowRadius=re.radius,q.shadowMapSize=re.mapSize,n.directionalShadow[m]=q,n.directionalShadowMap[m]=ae,n.directionalShadowMatrix[m]=G.shadow.matrix,T++}n.directional[m]=H,m++}else if(G.isSpotLight){const H=e.get(G);H.position.setFromMatrixPosition(G.matrixWorld),H.color.copy(te).multiplyScalar(j),H.distance=xe,H.coneCos=Math.cos(G.angle),H.penumbraCos=Math.cos(G.angle*(1-G.penumbra)),H.decay=G.decay,n.spot[_]=H;const re=G.shadow;if(G.map&&(n.spotLightMap[M]=G.map,M++,re.updateMatrices(G),G.castShadow&&R++),n.spotLightMatrix[_]=re.matrix,G.castShadow){const q=t.get(G);q.shadowIntensity=re.intensity,q.shadowBias=re.bias,q.shadowNormalBias=re.normalBias,q.shadowRadius=re.radius,q.shadowMapSize=re.mapSize,n.spotShadow[_]=q,n.spotShadowMap[_]=ae,A++}_++}else if(G.isRectAreaLight){const H=e.get(G);H.color.copy(te).multiplyScalar(j),H.halfWidth.set(G.width*.5,0,0),H.halfHeight.set(0,G.height*.5,0),n.rectArea[v]=H,v++}else if(G.isPointLight){const H=e.get(G);if(H.color.copy(G.color).multiplyScalar(G.intensity),H.distance=G.distance,H.decay=G.decay,G.castShadow){const re=G.shadow,q=t.get(G);q.shadowIntensity=re.intensity,q.shadowBias=re.bias,q.shadowNormalBias=re.normalBias,q.shadowRadius=re.radius,q.shadowMapSize=re.mapSize,q.shadowCameraNear=re.camera.near,q.shadowCameraFar=re.camera.far,n.pointShadow[g]=q,n.pointShadowMap[g]=ae,n.pointShadowMatrix[g]=G.shadow.matrix,E++}n.point[g]=H,g++}else if(G.isHemisphereLight){const H=e.get(G);H.skyColor.copy(G.color).multiplyScalar(j),H.groundColor.copy(G.groundColor).multiplyScalar(j),n.hemi[b]=H,b++}}v>0&&(x.has("OES_texture_float_linear")===!0?(n.rectAreaLTC1=Rt.LTC_FLOAT_1,n.rectAreaLTC2=Rt.LTC_FLOAT_2):(n.rectAreaLTC1=Rt.LTC_HALF_1,n.rectAreaLTC2=Rt.LTC_HALF_2)),n.ambient[0]=h,n.ambient[1]=d,n.ambient[2]=p;const k=n.hash;(k.directionalLength!==m||k.pointLength!==g||k.spotLength!==_||k.rectAreaLength!==v||k.hemiLength!==b||k.numDirectionalShadows!==T||k.numPointShadows!==E||k.numSpotShadows!==A||k.numSpotMaps!==M||k.numLightProbes!==C)&&(n.directional.length=m,n.spot.length=_,n.rectArea.length=v,n.point.length=g,n.hemi.length=b,n.directionalShadow.length=T,n.directionalShadowMap.length=T,n.pointShadow.length=E,n.pointShadowMap.length=E,n.spotShadow.length=A,n.spotShadowMap.length=A,n.directionalShadowMatrix.length=T,n.pointShadowMatrix.length=E,n.spotLightMatrix.length=A+M-R,n.spotLightMap.length=M,n.numSpotLightShadowsWithMaps=R,n.numLightProbes=C,k.directionalLength=m,k.pointLength=g,k.spotLength=_,k.rectAreaLength=v,k.hemiLength=b,k.numDirectionalShadows=T,k.numPointShadows=E,k.numSpotShadows=A,k.numSpotMaps=M,k.numLightProbes=C,n.version=Nae++)}function l(c,h){let d=0,p=0,m=0,g=0,_=0;const v=h.matrixWorldInverse;for(let b=0,T=c.length;b<T;b++){const E=c[b];if(E.isDirectionalLight){const A=n.directional[d];A.direction.setFromMatrixPosition(E.matrixWorld),i.setFromMatrixPosition(E.target.matrixWorld),A.direction.sub(i),A.direction.transformDirection(v),d++}else if(E.isSpotLight){const A=n.spot[m];A.position.setFromMatrixPosition(E.matrixWorld),A.position.applyMatrix4(v),A.direction.setFromMatrixPosition(E.matrixWorld),i.setFromMatrixPosition(E.target.matrixWorld),A.direction.sub(i),A.direction.transformDirection(v),m++}else if(E.isRectAreaLight){const A=n.rectArea[g];A.position.setFromMatrixPosition(E.matrixWorld),A.position.applyMatrix4(v),a.identity(),r.copy(E.matrixWorld),r.premultiply(v),a.extractRotation(r),A.halfWidth.set(E.width*.5,0,0),A.halfHeight.set(0,E.height*.5,0),A.halfWidth.applyMatrix4(a),A.halfHeight.applyMatrix4(a),g++}else if(E.isPointLight){const A=n.point[p];A.position.setFromMatrixPosition(E.matrixWorld),A.position.applyMatrix4(v),p++}else if(E.isHemisphereLight){const A=n.hemi[_];A.direction.setFromMatrixPosition(E.matrixWorld),A.direction.transformDirection(v),_++}}}return{setup:s,setupView:l,state:n}}function UD(x){const e=new Oae(x),t=[],n=[];function i(h){c.camera=h,t.length=0,n.length=0}function r(h){t.push(h)}function a(h){n.push(h)}function s(){e.setup(t)}function l(h){e.setupView(t,h)}const c={lightsArray:t,shadowsArray:n,camera:null,lights:e,transmissionRenderTarget:{}};return{init:i,state:c,setupLights:s,setupLightsView:l,pushLight:r,pushShadow:a}}function Dae(x){let e=new WeakMap;function t(i,r=0){const a=e.get(i);let s;return a===void 0?(s=new UD(x),e.set(i,[s])):r>=a.length?(s=new UD(x),a.push(s)):s=a[r],s}function n(){e=new WeakMap}return{get:t,dispose:n}}class Pae extends Wh{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=C0e,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class kae extends Wh{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const Uae=`
void main() {

	gl_Position = vec4( position, 1.0 );

}
`,Fae=`
uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;

#include <packing>

void main() {

	const float samples = float( VSM_SAMPLES );

	float mean = 0.0;
	float squared_mean = 0.0;

	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {

		float uvOffset = uvStart + i * uvStride;

		#ifdef HORIZONTAL_PASS

			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;

		#else

			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;

		#endif

	}

	mean = mean / samples;
	squared_mean = squared_mean / samples;

	float std_dev = sqrt( squared_mean - mean * mean );

	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );

}
`;function Bae(x,e,t){let n=new hL;const i=new fx,r=new fx,a=new ui,s=new Pae({depthPacking:N0e}),l=new kae,c={},h=t.maxTextureSize,d={[il]:er,[er]:il,[Mo]:Mo},p=new rl({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new fx},radius:{value:4}},vertexShader:Uae,fragmentShader:Fae}),m=p.clone();m.defines.HORIZONTAL_PASS=1;const g=new dd;g.setAttribute("position",new Es(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const _=new ws(g,p),v=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=QB;let b=this.type;this.render=function(R,C,k){if(v.enabled===!1||v.autoUpdate===!1&&v.needsUpdate===!1||R.length===0)return;const P=x.getRenderTarget(),N=x.getActiveCubeFace(),G=x.getActiveMipmapLevel(),te=x.state;te.setBlending(Q2),te.buffers.color.setClear(1,1,1,1),te.buffers.depth.setTest(!0),te.setScissorTest(!1);const j=b!==go&&this.type===go,xe=b===go&&this.type!==go;for(let ae=0,H=R.length;ae<H;ae++){const re=R[ae],q=re.shadow;if(q===void 0){console.warn("THREE.WebGLShadowMap:",re,"has no shadow.");continue}if(q.autoUpdate===!1&&q.needsUpdate===!1)continue;i.copy(q.mapSize);const be=q.getFrameExtents();if(i.multiply(be),r.copy(q.mapSize),(i.x>h||i.y>h)&&(i.x>h&&(r.x=Math.floor(h/be.x),i.x=r.x*be.x,q.mapSize.x=r.x),i.y>h&&(r.y=Math.floor(h/be.y),i.y=r.y*be.y,q.mapSize.y=r.y)),q.map===null||j===!0||xe===!0){const se=this.type!==go?{minFilter:ga,magFilter:ga}:{};q.map!==null&&q.map.dispose(),q.map=new Ic(i.x,i.y,se),q.map.texture.name=re.name+".shadowMap",q.camera.updateProjectionMatrix()}x.setRenderTarget(q.map),x.clear();const K=q.getViewportCount();for(let se=0;se<K;se++){const ge=q.getViewport(se);a.set(r.x*ge.x,r.y*ge.y,r.x*ge.z,r.y*ge.w),te.viewport(a),q.updateMatrices(re,se),n=q.getFrustum(),A(C,k,q.camera,re,this.type)}q.isPointLightShadow!==!0&&this.type===go&&T(q,k),q.needsUpdate=!1}b=this.type,v.needsUpdate=!1,x.setRenderTarget(P,N,G)};function T(R,C){const k=e.update(_);p.defines.VSM_SAMPLES!==R.blurSamples&&(p.defines.VSM_SAMPLES=R.blurSamples,m.defines.VSM_SAMPLES=R.blurSamples,p.needsUpdate=!0,m.needsUpdate=!0),R.mapPass===null&&(R.mapPass=new Ic(i.x,i.y)),p.uniforms.shadow_pass.value=R.map.texture,p.uniforms.resolution.value=R.mapSize,p.uniforms.radius.value=R.radius,x.setRenderTarget(R.mapPass),x.clear(),x.renderBufferDirect(C,null,k,p,_,null),m.uniforms.shadow_pass.value=R.mapPass.texture,m.uniforms.resolution.value=R.mapSize,m.uniforms.radius.value=R.radius,x.setRenderTarget(R.map),x.clear(),x.renderBufferDirect(C,null,k,m,_,null)}function E(R,C,k,P){let N=null;const G=k.isPointLight===!0?R.customDistanceMaterial:R.customDepthMaterial;if(G!==void 0)N=G;else if(N=k.isPointLight===!0?l:s,x.localClippingEnabled&&C.clipShadows===!0&&Array.isArray(C.clippingPlanes)&&C.clippingPlanes.length!==0||C.displacementMap&&C.displacementScale!==0||C.alphaMap&&C.alphaTest>0||C.map&&C.alphaTest>0){const te=N.uuid,j=C.uuid;let xe=c[te];xe===void 0&&(xe={},c[te]=xe);let ae=xe[j];ae===void 0&&(ae=N.clone(),xe[j]=ae,C.addEventListener("dispose",M)),N=ae}if(N.visible=C.visible,N.wireframe=C.wireframe,P===go?N.side=C.shadowSide!==null?C.shadowSide:C.side:N.side=C.shadowSide!==null?C.shadowSide:d[C.side],N.alphaMap=C.alphaMap,N.alphaTest=C.alphaTest,N.map=C.map,N.clipShadows=C.clipShadows,N.clippingPlanes=C.clippingPlanes,N.clipIntersection=C.clipIntersection,N.displacementMap=C.displacementMap,N.displacementScale=C.displacementScale,N.displacementBias=C.displacementBias,N.wireframeLinewidth=C.wireframeLinewidth,N.linewidth=C.linewidth,k.isPointLight===!0&&N.isMeshDistanceMaterial===!0){const te=x.properties.get(N);te.light=k}return N}function A(R,C,k,P,N){if(R.visible===!1)return;if(R.layers.test(C.layers)&&(R.isMesh||R.isLine||R.isPoints)&&(R.castShadow||R.receiveShadow&&N===go)&&(!R.frustumCulled||n.intersectsObject(R))){R.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse,R.matrixWorld);const j=e.update(R),xe=R.material;if(Array.isArray(xe)){const ae=j.groups;for(let H=0,re=ae.length;H<re;H++){const q=ae[H],be=xe[q.materialIndex];if(be&&be.visible){const K=E(R,be,P,N);R.onBeforeShadow(x,R,C,k,j,K,q),x.renderBufferDirect(k,null,j,K,R,q),R.onAfterShadow(x,R,C,k,j,K,q)}}}else if(xe.visible){const ae=E(R,xe,P,N);R.onBeforeShadow(x,R,C,k,j,ae,null),x.renderBufferDirect(k,null,j,ae,R,null),R.onAfterShadow(x,R,C,k,j,ae,null)}}const te=R.children;for(let j=0,xe=te.length;j<xe;j++)A(te[j],C,k,P,N)}function M(R){R.target.removeEventListener("dispose",M);for(const k in c){const P=c[k],N=R.target.uuid;N in P&&(P[N].dispose(),delete P[N])}}}function Lae(x){function e(){let de=!1;const ft=new ui;let Xe=null;const Ze=new ui(0,0,0,0);return{setMask:function(lt){Xe!==lt&&!de&&(x.colorMask(lt,lt,lt,lt),Xe=lt)},setLocked:function(lt){de=lt},setClear:function(lt,Wt,Qt,D0,P0){P0===!0&&(lt*=D0,Wt*=D0,Qt*=D0),ft.set(lt,Wt,Qt,D0),Ze.equals(ft)===!1&&(x.clearColor(lt,Wt,Qt,D0),Ze.copy(ft))},reset:function(){de=!1,Xe=null,Ze.set(-1,0,0,0)}}}function t(){let de=!1,ft=null,Xe=null,Ze=null;return{setTest:function(lt){lt?Fe(x.DEPTH_TEST):Qe(x.DEPTH_TEST)},setMask:function(lt){ft!==lt&&!de&&(x.depthMask(lt),ft=lt)},setFunc:function(lt){if(Xe!==lt){switch(lt){case h0e:x.depthFunc(x.NEVER);break;case d0e:x.depthFunc(x.ALWAYS);break;case f0e:x.depthFunc(x.LESS);break;case J1:x.depthFunc(x.LEQUAL);break;case p0e:x.depthFunc(x.EQUAL);break;case m0e:x.depthFunc(x.GEQUAL);break;case y0e:x.depthFunc(x.GREATER);break;case g0e:x.depthFunc(x.NOTEQUAL);break;default:x.depthFunc(x.LEQUAL)}Xe=lt}},setLocked:function(lt){de=lt},setClear:function(lt){Ze!==lt&&(x.clearDepth(lt),Ze=lt)},reset:function(){de=!1,ft=null,Xe=null,Ze=null}}}function n(){let de=!1,ft=null,Xe=null,Ze=null,lt=null,Wt=null,Qt=null,D0=null,P0=null;return{setTest:function(s0){de||(s0?Fe(x.STENCIL_TEST):Qe(x.STENCIL_TEST))},setMask:function(s0){ft!==s0&&!de&&(x.stencilMask(s0),ft=s0)},setFunc:function(s0,rn,Cx){(Xe!==s0||Ze!==rn||lt!==Cx)&&(x.stencilFunc(s0,rn,Cx),Xe=s0,Ze=rn,lt=Cx)},setOp:function(s0,rn,Cx){(Wt!==s0||Qt!==rn||D0!==Cx)&&(x.stencilOp(s0,rn,Cx),Wt=s0,Qt=rn,D0=Cx)},setLocked:function(s0){de=s0},setClear:function(s0){P0!==s0&&(x.clearStencil(s0),P0=s0)},reset:function(){de=!1,ft=null,Xe=null,Ze=null,lt=null,Wt=null,Qt=null,D0=null,P0=null}}}const i=new e,r=new t,a=new n,s=new WeakMap,l=new WeakMap;let c={},h={},d=new WeakMap,p=[],m=null,g=!1,_=null,v=null,b=null,T=null,E=null,A=null,M=null,R=new dx(0,0,0),C=0,k=!1,P=null,N=null,G=null,te=null,j=null;const xe=x.getParameter(x.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let ae=!1,H=0;const re=x.getParameter(x.VERSION);re.indexOf("WebGL")!==-1?(H=parseFloat(/^WebGL (\d)/.exec(re)[1]),ae=H>=1):re.indexOf("OpenGL ES")!==-1&&(H=parseFloat(/^OpenGL ES (\d)/.exec(re)[1]),ae=H>=2);let q=null,be={};const K=x.getParameter(x.SCISSOR_BOX),se=x.getParameter(x.VIEWPORT),ge=new ui().fromArray(K),Me=new ui().fromArray(se);function le(de,ft,Xe,Ze){const lt=new Uint8Array(4),Wt=x.createTexture();x.bindTexture(de,Wt),x.texParameteri(de,x.TEXTURE_MIN_FILTER,x.NEAREST),x.texParameteri(de,x.TEXTURE_MAG_FILTER,x.NEAREST);for(let Qt=0;Qt<Xe;Qt++)de===x.TEXTURE_3D||de===x.TEXTURE_2D_ARRAY?x.texImage3D(ft,0,x.RGBA,1,1,Ze,0,x.RGBA,x.UNSIGNED_BYTE,lt):x.texImage2D(ft+Qt,0,x.RGBA,1,1,0,x.RGBA,x.UNSIGNED_BYTE,lt);return Wt}const Se={};Se[x.TEXTURE_2D]=le(x.TEXTURE_2D,x.TEXTURE_2D,1),Se[x.TEXTURE_CUBE_MAP]=le(x.TEXTURE_CUBE_MAP,x.TEXTURE_CUBE_MAP_POSITIVE_X,6),Se[x.TEXTURE_2D_ARRAY]=le(x.TEXTURE_2D_ARRAY,x.TEXTURE_2D_ARRAY,1,1),Se[x.TEXTURE_3D]=le(x.TEXTURE_3D,x.TEXTURE_3D,1,1),i.setClear(0,0,0,1),r.setClear(1),a.setClear(0),Fe(x.DEPTH_TEST),r.setFunc(J1),at(!1),Ue(HO),Fe(x.CULL_FACE),rt(Q2);function Fe(de){c[de]!==!0&&(x.enable(de),c[de]=!0)}function Qe(de){c[de]!==!1&&(x.disable(de),c[de]=!1)}function qe(de,ft){return h[de]!==ft?(x.bindFramebuffer(de,ft),h[de]=ft,de===x.DRAW_FRAMEBUFFER&&(h[x.FRAMEBUFFER]=ft),de===x.FRAMEBUFFER&&(h[x.DRAW_FRAMEBUFFER]=ft),!0):!1}function Et(de,ft){let Xe=p,Ze=!1;if(de){Xe=d.get(ft),Xe===void 0&&(Xe=[],d.set(ft,Xe));const lt=de.textures;if(Xe.length!==lt.length||Xe[0]!==x.COLOR_ATTACHMENT0){for(let Wt=0,Qt=lt.length;Wt<Qt;Wt++)Xe[Wt]=x.COLOR_ATTACHMENT0+Wt;Xe.length=lt.length,Ze=!0}}else Xe[0]!==x.BACK&&(Xe[0]=x.BACK,Ze=!0);Ze&&x.drawBuffers(Xe)}function Tt(de){return m!==de?(x.useProgram(de),m=de,!0):!1}const Bt={[nc]:x.FUNC_ADD,[Qte]:x.FUNC_SUBTRACT,[Zte]:x.FUNC_REVERSE_SUBTRACT};Bt[Jte]=x.MIN,Bt[jte]=x.MAX;const Q={[qte]:x.ZERO,[e0e]:x.ONE,[t0e]:x.SRC_COLOR,[qT]:x.SRC_ALPHA,[s0e]:x.SRC_ALPHA_SATURATE,[r0e]:x.DST_COLOR,[n0e]:x.DST_ALPHA,[x0e]:x.ONE_MINUS_SRC_COLOR,[ew]:x.ONE_MINUS_SRC_ALPHA,[a0e]:x.ONE_MINUS_DST_COLOR,[i0e]:x.ONE_MINUS_DST_ALPHA,[o0e]:x.CONSTANT_COLOR,[l0e]:x.ONE_MINUS_CONSTANT_COLOR,[c0e]:x.CONSTANT_ALPHA,[u0e]:x.ONE_MINUS_CONSTANT_ALPHA};function rt(de,ft,Xe,Ze,lt,Wt,Qt,D0,P0,s0){if(de===Q2){g===!0&&(Qe(x.BLEND),g=!1);return}if(g===!1&&(Fe(x.BLEND),g=!0),de!==$te){if(de!==_||s0!==k){if((v!==nc||E!==nc)&&(x.blendEquation(x.FUNC_ADD),v=nc,E=nc),s0)switch(de){case dh:x.blendFuncSeparate(x.ONE,x.ONE_MINUS_SRC_ALPHA,x.ONE,x.ONE_MINUS_SRC_ALPHA);break;case GO:x.blendFunc(x.ONE,x.ONE);break;case WO:x.blendFuncSeparate(x.ZERO,x.ONE_MINUS_SRC_COLOR,x.ZERO,x.ONE);break;case XO:x.blendFuncSeparate(x.ZERO,x.SRC_COLOR,x.ZERO,x.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",de);break}else switch(de){case dh:x.blendFuncSeparate(x.SRC_ALPHA,x.ONE_MINUS_SRC_ALPHA,x.ONE,x.ONE_MINUS_SRC_ALPHA);break;case GO:x.blendFunc(x.SRC_ALPHA,x.ONE);break;case WO:x.blendFuncSeparate(x.ZERO,x.ONE_MINUS_SRC_COLOR,x.ZERO,x.ONE);break;case XO:x.blendFunc(x.ZERO,x.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",de);break}b=null,T=null,A=null,M=null,R.set(0,0,0),C=0,_=de,k=s0}return}lt=lt||ft,Wt=Wt||Xe,Qt=Qt||Ze,(ft!==v||lt!==E)&&(x.blendEquationSeparate(Bt[ft],Bt[lt]),v=ft,E=lt),(Xe!==b||Ze!==T||Wt!==A||Qt!==M)&&(x.blendFuncSeparate(Q[Xe],Q[Ze],Q[Wt],Q[Qt]),b=Xe,T=Ze,A=Wt,M=Qt),(D0.equals(R)===!1||P0!==C)&&(x.blendColor(D0.r,D0.g,D0.b,P0),R.copy(D0),C=P0),_=de,k=!1}function He(de,ft){de.side===Mo?Qe(x.CULL_FACE):Fe(x.CULL_FACE);let Xe=de.side===er;ft&&(Xe=!Xe),at(Xe),de.blending===dh&&de.transparent===!1?rt(Q2):rt(de.blending,de.blendEquation,de.blendSrc,de.blendDst,de.blendEquationAlpha,de.blendSrcAlpha,de.blendDstAlpha,de.blendColor,de.blendAlpha,de.premultipliedAlpha),r.setFunc(de.depthFunc),r.setTest(de.depthTest),r.setMask(de.depthWrite),i.setMask(de.colorWrite);const Ze=de.stencilWrite;a.setTest(Ze),Ze&&(a.setMask(de.stencilWriteMask),a.setFunc(de.stencilFunc,de.stencilRef,de.stencilFuncMask),a.setOp(de.stencilFail,de.stencilZFail,de.stencilZPass)),ht(de.polygonOffset,de.polygonOffsetFactor,de.polygonOffsetUnits),de.alphaToCoverage===!0?Fe(x.SAMPLE_ALPHA_TO_COVERAGE):Qe(x.SAMPLE_ALPHA_TO_COVERAGE)}function at(de){P!==de&&(de?x.frontFace(x.CW):x.frontFace(x.CCW),P=de)}function Ue(de){de!==Xte?(Fe(x.CULL_FACE),de!==N&&(de===HO?x.cullFace(x.BACK):de===Yte?x.cullFace(x.FRONT):x.cullFace(x.FRONT_AND_BACK))):Qe(x.CULL_FACE),N=de}function bt(de){de!==G&&(ae&&x.lineWidth(de),G=de)}function ht(de,ft,Xe){de?(Fe(x.POLYGON_OFFSET_FILL),(te!==ft||j!==Xe)&&(x.polygonOffset(ft,Xe),te=ft,j=Xe)):Qe(x.POLYGON_OFFSET_FILL)}function dt(de){de?Fe(x.SCISSOR_TEST):Qe(x.SCISSOR_TEST)}function Z(de){de===void 0&&(de=x.TEXTURE0+xe-1),q!==de&&(x.activeTexture(de),q=de)}function V(de,ft,Xe){Xe===void 0&&(q===null?Xe=x.TEXTURE0+xe-1:Xe=q);let Ze=be[Xe];Ze===void 0&&(Ze={type:void 0,texture:void 0},be[Xe]=Ze),(Ze.type!==de||Ze.texture!==ft)&&(q!==Xe&&(x.activeTexture(Xe),q=Xe),x.bindTexture(de,ft||Se[de]),Ze.type=de,Ze.texture=ft)}function _e(){const de=be[q];de!==void 0&&de.type!==void 0&&(x.bindTexture(de.type,null),de.type=void 0,de.texture=void 0)}function Ge(){try{x.compressedTexImage2D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Re(){try{x.compressedTexImage3D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Ve(){try{x.texSubImage2D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function _t(){try{x.texSubImage3D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Ce(){try{x.compressedTexSubImage2D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function pt(){try{x.compressedTexSubImage3D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function et(){try{x.texStorage2D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function tt(){try{x.texStorage3D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function gt(){try{x.texImage2D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function i0(){try{x.texImage3D.apply(x,arguments)}catch(de){console.error("THREE.WebGLState:",de)}}function Ht(de){ge.equals(de)===!1&&(x.scissor(de.x,de.y,de.z,de.w),ge.copy(de))}function St(de){Me.equals(de)===!1&&(x.viewport(de.x,de.y,de.z,de.w),Me.copy(de))}function Ut(de,ft){let Xe=l.get(ft);Xe===void 0&&(Xe=new WeakMap,l.set(ft,Xe));let Ze=Xe.get(de);Ze===void 0&&(Ze=x.getUniformBlockIndex(ft,de.name),Xe.set(de,Ze))}function t0(de,ft){const Ze=l.get(ft).get(de);s.get(ft)!==Ze&&(x.uniformBlockBinding(ft,Ze,de.__bindingPointIndex),s.set(ft,Ze))}function p0(){x.disable(x.BLEND),x.disable(x.CULL_FACE),x.disable(x.DEPTH_TEST),x.disable(x.POLYGON_OFFSET_FILL),x.disable(x.SCISSOR_TEST),x.disable(x.STENCIL_TEST),x.disable(x.SAMPLE_ALPHA_TO_COVERAGE),x.blendEquation(x.FUNC_ADD),x.blendFunc(x.ONE,x.ZERO),x.blendFuncSeparate(x.ONE,x.ZERO,x.ONE,x.ZERO),x.blendColor(0,0,0,0),x.colorMask(!0,!0,!0,!0),x.clearColor(0,0,0,0),x.depthMask(!0),x.depthFunc(x.LESS),x.clearDepth(1),x.stencilMask(4294967295),x.stencilFunc(x.ALWAYS,0,4294967295),x.stencilOp(x.KEEP,x.KEEP,x.KEEP),x.clearStencil(0),x.cullFace(x.BACK),x.frontFace(x.CCW),x.polygonOffset(0,0),x.activeTexture(x.TEXTURE0),x.bindFramebuffer(x.FRAMEBUFFER,null),x.bindFramebuffer(x.DRAW_FRAMEBUFFER,null),x.bindFramebuffer(x.READ_FRAMEBUFFER,null),x.useProgram(null),x.lineWidth(1),x.scissor(0,0,x.canvas.width,x.canvas.height),x.viewport(0,0,x.canvas.width,x.canvas.height),c={},q=null,be={},h={},d=new WeakMap,p=[],m=null,g=!1,_=null,v=null,b=null,T=null,E=null,A=null,M=null,R=new dx(0,0,0),C=0,k=!1,P=null,N=null,G=null,te=null,j=null,ge.set(0,0,x.canvas.width,x.canvas.height),Me.set(0,0,x.canvas.width,x.canvas.height),i.reset(),r.reset(),a.reset()}return{buffers:{color:i,depth:r,stencil:a},enable:Fe,disable:Qe,bindFramebuffer:qe,drawBuffers:Et,useProgram:Tt,setBlending:rt,setMaterial:He,setFlipSided:at,setCullFace:Ue,setLineWidth:bt,setPolygonOffset:ht,setScissorTest:dt,activeTexture:Z,bindTexture:V,unbindTexture:_e,compressedTexImage2D:Ge,compressedTexImage3D:Re,texImage2D:gt,texImage3D:i0,updateUBOMapping:Ut,uniformBlockBinding:t0,texStorage2D:et,texStorage3D:tt,texSubImage2D:Ve,texSubImage3D:_t,compressedTexSubImage2D:Ce,compressedTexSubImage3D:pt,scissor:Ht,viewport:St,reset:p0}}function FD(x,e,t,n){const i=zae(n);switch(t){case tL:return x*e;case nL:return x*e;case iL:return x*e*2;case rL:return x*e/i.components*i.byteLength;case MM:return x*e/i.components*i.byteLength;case aL:return x*e*2/i.components*i.byteLength;case RM:return x*e*2/i.components*i.byteLength;case xL:return x*e*3/i.components*i.byteLength;case Ka:return x*e*4/i.components*i.byteLength;case CM:return x*e*4/i.components*i.byteLength;case l1:case c1:return Math.floor((x+3)/4)*Math.floor((e+3)/4)*8;case u1:case h1:return Math.floor((x+3)/4)*Math.floor((e+3)/4)*16;case aw:case ow:return Math.max(x,16)*Math.max(e,8)/4;case rw:case sw:return Math.max(x,8)*Math.max(e,8)/2;case lw:case cw:return Math.floor((x+3)/4)*Math.floor((e+3)/4)*8;case uw:return Math.floor((x+3)/4)*Math.floor((e+3)/4)*16;case hw:return Math.floor((x+3)/4)*Math.floor((e+3)/4)*16;case dw:return Math.floor((x+4)/5)*Math.floor((e+3)/4)*16;case fw:return Math.floor((x+4)/5)*Math.floor((e+4)/5)*16;case pw:return Math.floor((x+5)/6)*Math.floor((e+4)/5)*16;case mw:return Math.floor((x+5)/6)*Math.floor((e+5)/6)*16;case yw:return Math.floor((x+7)/8)*Math.floor((e+4)/5)*16;case gw:return Math.floor((x+7)/8)*Math.floor((e+5)/6)*16;case vw:return Math.floor((x+7)/8)*Math.floor((e+7)/8)*16;case bw:return Math.floor((x+9)/10)*Math.floor((e+4)/5)*16;case _w:return Math.floor((x+9)/10)*Math.floor((e+5)/6)*16;case Sw:return Math.floor((x+9)/10)*Math.floor((e+7)/8)*16;case Tw:return Math.floor((x+9)/10)*Math.floor((e+9)/10)*16;case ww:return Math.floor((x+11)/12)*Math.floor((e+9)/10)*16;case Aw:return Math.floor((x+11)/12)*Math.floor((e+11)/12)*16;case d1:case Ew:case Mw:return Math.ceil(x/4)*Math.ceil(e/4)*16;case sL:case Rw:return Math.ceil(x/4)*Math.ceil(e/4)*8;case Cw:case Nw:return Math.ceil(x/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function zae(x){switch(x){case zo:case jB:return{byteLength:1,components:1};case ep:case qB:case Np:return{byteLength:2,components:1};case AM:case EM:return{byteLength:2,components:4};case Cc:case wM:case Oo:return{byteLength:4,components:1};case eL:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${x}.`)}function Vae(x,e,t,n,i,r,a){const s=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new fx,h=new WeakMap;let d;const p=new WeakMap;let m=!1;try{m=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(Z,V){return m?new OffscreenCanvas(Z,V):xg("canvas")}function _(Z,V,_e){let Ge=1;const Re=dt(Z);if((Re.width>_e||Re.height>_e)&&(Ge=_e/Math.max(Re.width,Re.height)),Ge<1)if(typeof HTMLImageElement<"u"&&Z instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&Z instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&Z instanceof ImageBitmap||typeof VideoFrame<"u"&&Z instanceof VideoFrame){const Ve=Math.floor(Ge*Re.width),_t=Math.floor(Ge*Re.height);d===void 0&&(d=g(Ve,_t));const Ce=V?g(Ve,_t):d;return Ce.width=Ve,Ce.height=_t,Ce.getContext("2d").drawImage(Z,0,0,Ve,_t),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+Re.width+"x"+Re.height+") to ("+Ve+"x"+_t+")."),Ce}else return"data"in Z&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+Re.width+"x"+Re.height+")."),Z;return Z}function v(Z){return Z.generateMipmaps&&Z.minFilter!==ga&&Z.minFilter!==Ga}function b(Z){x.generateMipmap(Z)}function T(Z,V,_e,Ge,Re=!1){if(Z!==null){if(x[Z]!==void 0)return x[Z];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+Z+"'")}let Ve=V;if(V===x.RED&&(_e===x.FLOAT&&(Ve=x.R32F),_e===x.HALF_FLOAT&&(Ve=x.R16F),_e===x.UNSIGNED_BYTE&&(Ve=x.R8)),V===x.RED_INTEGER&&(_e===x.UNSIGNED_BYTE&&(Ve=x.R8UI),_e===x.UNSIGNED_SHORT&&(Ve=x.R16UI),_e===x.UNSIGNED_INT&&(Ve=x.R32UI),_e===x.BYTE&&(Ve=x.R8I),_e===x.SHORT&&(Ve=x.R16I),_e===x.INT&&(Ve=x.R32I)),V===x.RG&&(_e===x.FLOAT&&(Ve=x.RG32F),_e===x.HALF_FLOAT&&(Ve=x.RG16F),_e===x.UNSIGNED_BYTE&&(Ve=x.RG8)),V===x.RG_INTEGER&&(_e===x.UNSIGNED_BYTE&&(Ve=x.RG8UI),_e===x.UNSIGNED_SHORT&&(Ve=x.RG16UI),_e===x.UNSIGNED_INT&&(Ve=x.RG32UI),_e===x.BYTE&&(Ve=x.RG8I),_e===x.SHORT&&(Ve=x.RG16I),_e===x.INT&&(Ve=x.RG32I)),V===x.RGB&&_e===x.UNSIGNED_INT_5_9_9_9_REV&&(Ve=x.RGB9_E5),V===x.RGBA){const _t=Re?j1:J0.getTransfer(Ge);_e===x.FLOAT&&(Ve=x.RGBA32F),_e===x.HALF_FLOAT&&(Ve=x.RGBA16F),_e===x.UNSIGNED_BYTE&&(Ve=_t===Ex?x.SRGB8_ALPHA8:x.RGBA8),_e===x.UNSIGNED_SHORT_4_4_4_4&&(Ve=x.RGBA4),_e===x.UNSIGNED_SHORT_5_5_5_1&&(Ve=x.RGB5_A1)}return(Ve===x.R16F||Ve===x.R32F||Ve===x.RG16F||Ve===x.RG32F||Ve===x.RGBA16F||Ve===x.RGBA32F)&&e.get("EXT_color_buffer_float"),Ve}function E(Z,V){let _e;return Z?V===null||V===Cc||V===Hh?_e=x.DEPTH24_STENCIL8:V===Oo?_e=x.DEPTH32F_STENCIL8:V===ep&&(_e=x.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):V===null||V===Cc||V===Hh?_e=x.DEPTH_COMPONENT24:V===Oo?_e=x.DEPTH_COMPONENT32F:V===ep&&(_e=x.DEPTH_COMPONENT16),_e}function A(Z,V){return v(Z)===!0||Z.isFramebufferTexture&&Z.minFilter!==ga&&Z.minFilter!==Ga?Math.log2(Math.max(V.width,V.height))+1:Z.mipmaps!==void 0&&Z.mipmaps.length>0?Z.mipmaps.length:Z.isCompressedTexture&&Array.isArray(Z.image)?V.mipmaps.length:1}function M(Z){const V=Z.target;V.removeEventListener("dispose",M),C(V),V.isVideoTexture&&h.delete(V)}function R(Z){const V=Z.target;V.removeEventListener("dispose",R),P(V)}function C(Z){const V=n.get(Z);if(V.__webglInit===void 0)return;const _e=Z.source,Ge=p.get(_e);if(Ge){const Re=Ge[V.__cacheKey];Re.usedTimes--,Re.usedTimes===0&&k(Z),Object.keys(Ge).length===0&&p.delete(_e)}n.remove(Z)}function k(Z){const V=n.get(Z);x.deleteTexture(V.__webglTexture);const _e=Z.source,Ge=p.get(_e);delete Ge[V.__cacheKey],a.memory.textures--}function P(Z){const V=n.get(Z);if(Z.depthTexture&&Z.depthTexture.dispose(),Z.isWebGLCubeRenderTarget)for(let Ge=0;Ge<6;Ge++){if(Array.isArray(V.__webglFramebuffer[Ge]))for(let Re=0;Re<V.__webglFramebuffer[Ge].length;Re++)x.deleteFramebuffer(V.__webglFramebuffer[Ge][Re]);else x.deleteFramebuffer(V.__webglFramebuffer[Ge]);V.__webglDepthbuffer&&x.deleteRenderbuffer(V.__webglDepthbuffer[Ge])}else{if(Array.isArray(V.__webglFramebuffer))for(let Ge=0;Ge<V.__webglFramebuffer.length;Ge++)x.deleteFramebuffer(V.__webglFramebuffer[Ge]);else x.deleteFramebuffer(V.__webglFramebuffer);if(V.__webglDepthbuffer&&x.deleteRenderbuffer(V.__webglDepthbuffer),V.__webglMultisampledFramebuffer&&x.deleteFramebuffer(V.__webglMultisampledFramebuffer),V.__webglColorRenderbuffer)for(let Ge=0;Ge<V.__webglColorRenderbuffer.length;Ge++)V.__webglColorRenderbuffer[Ge]&&x.deleteRenderbuffer(V.__webglColorRenderbuffer[Ge]);V.__webglDepthRenderbuffer&&x.deleteRenderbuffer(V.__webglDepthRenderbuffer)}const _e=Z.textures;for(let Ge=0,Re=_e.length;Ge<Re;Ge++){const Ve=n.get(_e[Ge]);Ve.__webglTexture&&(x.deleteTexture(Ve.__webglTexture),a.memory.textures--),n.remove(_e[Ge])}n.remove(Z)}let N=0;function G(){N=0}function te(){const Z=N;return Z>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+Z+" texture units while this GPU supports only "+i.maxTextures),N+=1,Z}function j(Z){const V=[];return V.push(Z.wrapS),V.push(Z.wrapT),V.push(Z.wrapR||0),V.push(Z.magFilter),V.push(Z.minFilter),V.push(Z.anisotropy),V.push(Z.internalFormat),V.push(Z.format),V.push(Z.type),V.push(Z.generateMipmaps),V.push(Z.premultiplyAlpha),V.push(Z.flipY),V.push(Z.unpackAlignment),V.push(Z.colorSpace),V.join()}function xe(Z,V){const _e=n.get(Z);if(Z.isVideoTexture&&bt(Z),Z.isRenderTargetTexture===!1&&Z.version>0&&_e.__version!==Z.version){const Ge=Z.image;if(Ge===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(Ge.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{Me(_e,Z,V);return}}t.bindTexture(x.TEXTURE_2D,_e.__webglTexture,x.TEXTURE0+V)}function ae(Z,V){const _e=n.get(Z);if(Z.version>0&&_e.__version!==Z.version){Me(_e,Z,V);return}t.bindTexture(x.TEXTURE_2D_ARRAY,_e.__webglTexture,x.TEXTURE0+V)}function H(Z,V){const _e=n.get(Z);if(Z.version>0&&_e.__version!==Z.version){Me(_e,Z,V);return}t.bindTexture(x.TEXTURE_3D,_e.__webglTexture,x.TEXTURE0+V)}function re(Z,V){const _e=n.get(Z);if(Z.version>0&&_e.__version!==Z.version){le(_e,Z,V);return}t.bindTexture(x.TEXTURE_CUBE_MAP,_e.__webglTexture,x.TEXTURE0+V)}const q={[nw]:x.REPEAT,[lc]:x.CLAMP_TO_EDGE,[iw]:x.MIRRORED_REPEAT},be={[ga]:x.NEAREST,[R0e]:x.NEAREST_MIPMAP_NEAREST,[Zm]:x.NEAREST_MIPMAP_LINEAR,[Ga]:x.LINEAR,[V_]:x.LINEAR_MIPMAP_NEAREST,[cc]:x.LINEAR_MIPMAP_LINEAR},K={[D0e]:x.NEVER,[L0e]:x.ALWAYS,[P0e]:x.LESS,[oL]:x.LEQUAL,[k0e]:x.EQUAL,[B0e]:x.GEQUAL,[U0e]:x.GREATER,[F0e]:x.NOTEQUAL};function se(Z,V){if(V.type===Oo&&e.has("OES_texture_float_linear")===!1&&(V.magFilter===Ga||V.magFilter===V_||V.magFilter===Zm||V.magFilter===cc||V.minFilter===Ga||V.minFilter===V_||V.minFilter===Zm||V.minFilter===cc)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),x.texParameteri(Z,x.TEXTURE_WRAP_S,q[V.wrapS]),x.texParameteri(Z,x.TEXTURE_WRAP_T,q[V.wrapT]),(Z===x.TEXTURE_3D||Z===x.TEXTURE_2D_ARRAY)&&x.texParameteri(Z,x.TEXTURE_WRAP_R,q[V.wrapR]),x.texParameteri(Z,x.TEXTURE_MAG_FILTER,be[V.magFilter]),x.texParameteri(Z,x.TEXTURE_MIN_FILTER,be[V.minFilter]),V.compareFunction&&(x.texParameteri(Z,x.TEXTURE_COMPARE_MODE,x.COMPARE_REF_TO_TEXTURE),x.texParameteri(Z,x.TEXTURE_COMPARE_FUNC,K[V.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(V.magFilter===ga||V.minFilter!==Zm&&V.minFilter!==cc||V.type===Oo&&e.has("OES_texture_float_linear")===!1)return;if(V.anisotropy>1||n.get(V).__currentAnisotropy){const _e=e.get("EXT_texture_filter_anisotropic");x.texParameterf(Z,_e.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(V.anisotropy,i.getMaxAnisotropy())),n.get(V).__currentAnisotropy=V.anisotropy}}}function ge(Z,V){let _e=!1;Z.__webglInit===void 0&&(Z.__webglInit=!0,V.addEventListener("dispose",M));const Ge=V.source;let Re=p.get(Ge);Re===void 0&&(Re={},p.set(Ge,Re));const Ve=j(V);if(Ve!==Z.__cacheKey){Re[Ve]===void 0&&(Re[Ve]={texture:x.createTexture(),usedTimes:0},a.memory.textures++,_e=!0),Re[Ve].usedTimes++;const _t=Re[Z.__cacheKey];_t!==void 0&&(Re[Z.__cacheKey].usedTimes--,_t.usedTimes===0&&k(V)),Z.__cacheKey=Ve,Z.__webglTexture=Re[Ve].texture}return _e}function Me(Z,V,_e){let Ge=x.TEXTURE_2D;(V.isDataArrayTexture||V.isCompressedArrayTexture)&&(Ge=x.TEXTURE_2D_ARRAY),V.isData3DTexture&&(Ge=x.TEXTURE_3D);const Re=ge(Z,V),Ve=V.source;t.bindTexture(Ge,Z.__webglTexture,x.TEXTURE0+_e);const _t=n.get(Ve);if(Ve.version!==_t.__version||Re===!0){t.activeTexture(x.TEXTURE0+_e);const Ce=J0.getPrimaries(J0.workingColorSpace),pt=V.colorSpace===z2?null:J0.getPrimaries(V.colorSpace),et=V.colorSpace===z2||Ce===pt?x.NONE:x.BROWSER_DEFAULT_WEBGL;x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL,V.flipY),x.pixelStorei(x.UNPACK_PREMULTIPLY_ALPHA_WEBGL,V.premultiplyAlpha),x.pixelStorei(x.UNPACK_ALIGNMENT,V.unpackAlignment),x.pixelStorei(x.UNPACK_COLORSPACE_CONVERSION_WEBGL,et);let tt=_(V.image,!1,i.maxTextureSize);tt=ht(V,tt);const gt=r.convert(V.format,V.colorSpace),i0=r.convert(V.type);let Ht=T(V.internalFormat,gt,i0,V.colorSpace,V.isVideoTexture);se(Ge,V);let St;const Ut=V.mipmaps,t0=V.isVideoTexture!==!0,p0=_t.__version===void 0||Re===!0,de=Ve.dataReady,ft=A(V,tt);if(V.isDepthTexture)Ht=E(V.format===Gh,V.type),p0&&(t0?t.texStorage2D(x.TEXTURE_2D,1,Ht,tt.width,tt.height):t.texImage2D(x.TEXTURE_2D,0,Ht,tt.width,tt.height,0,gt,i0,null));else if(V.isDataTexture)if(Ut.length>0){t0&&p0&&t.texStorage2D(x.TEXTURE_2D,ft,Ht,Ut[0].width,Ut[0].height);for(let Xe=0,Ze=Ut.length;Xe<Ze;Xe++)St=Ut[Xe],t0?de&&t.texSubImage2D(x.TEXTURE_2D,Xe,0,0,St.width,St.height,gt,i0,St.data):t.texImage2D(x.TEXTURE_2D,Xe,Ht,St.width,St.height,0,gt,i0,St.data);V.generateMipmaps=!1}else t0?(p0&&t.texStorage2D(x.TEXTURE_2D,ft,Ht,tt.width,tt.height),de&&t.texSubImage2D(x.TEXTURE_2D,0,0,0,tt.width,tt.height,gt,i0,tt.data)):t.texImage2D(x.TEXTURE_2D,0,Ht,tt.width,tt.height,0,gt,i0,tt.data);else if(V.isCompressedTexture)if(V.isCompressedArrayTexture){t0&&p0&&t.texStorage3D(x.TEXTURE_2D_ARRAY,ft,Ht,Ut[0].width,Ut[0].height,tt.depth);for(let Xe=0,Ze=Ut.length;Xe<Ze;Xe++)if(St=Ut[Xe],V.format!==Ka)if(gt!==null)if(t0){if(de)if(V.layerUpdates.size>0){const lt=FD(St.width,St.height,V.format,V.type);for(const Wt of V.layerUpdates){const Qt=St.data.subarray(Wt*lt/St.data.BYTES_PER_ELEMENT,(Wt+1)*lt/St.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(x.TEXTURE_2D_ARRAY,Xe,0,0,Wt,St.width,St.height,1,gt,Qt,0,0)}V.clearLayerUpdates()}else t.compressedTexSubImage3D(x.TEXTURE_2D_ARRAY,Xe,0,0,0,St.width,St.height,tt.depth,gt,St.data,0,0)}else t.compressedTexImage3D(x.TEXTURE_2D_ARRAY,Xe,Ht,St.width,St.height,tt.depth,0,St.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else t0?de&&t.texSubImage3D(x.TEXTURE_2D_ARRAY,Xe,0,0,0,St.width,St.height,tt.depth,gt,i0,St.data):t.texImage3D(x.TEXTURE_2D_ARRAY,Xe,Ht,St.width,St.height,tt.depth,0,gt,i0,St.data)}else{t0&&p0&&t.texStorage2D(x.TEXTURE_2D,ft,Ht,Ut[0].width,Ut[0].height);for(let Xe=0,Ze=Ut.length;Xe<Ze;Xe++)St=Ut[Xe],V.format!==Ka?gt!==null?t0?de&&t.compressedTexSubImage2D(x.TEXTURE_2D,Xe,0,0,St.width,St.height,gt,St.data):t.compressedTexImage2D(x.TEXTURE_2D,Xe,Ht,St.width,St.height,0,St.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t0?de&&t.texSubImage2D(x.TEXTURE_2D,Xe,0,0,St.width,St.height,gt,i0,St.data):t.texImage2D(x.TEXTURE_2D,Xe,Ht,St.width,St.height,0,gt,i0,St.data)}else if(V.isDataArrayTexture)if(t0){if(p0&&t.texStorage3D(x.TEXTURE_2D_ARRAY,ft,Ht,tt.width,tt.height,tt.depth),de)if(V.layerUpdates.size>0){const Xe=FD(tt.width,tt.height,V.format,V.type);for(const Ze of V.layerUpdates){const lt=tt.data.subarray(Ze*Xe/tt.data.BYTES_PER_ELEMENT,(Ze+1)*Xe/tt.data.BYTES_PER_ELEMENT);t.texSubImage3D(x.TEXTURE_2D_ARRAY,0,0,0,Ze,tt.width,tt.height,1,gt,i0,lt)}V.clearLayerUpdates()}else t.texSubImage3D(x.TEXTURE_2D_ARRAY,0,0,0,0,tt.width,tt.height,tt.depth,gt,i0,tt.data)}else t.texImage3D(x.TEXTURE_2D_ARRAY,0,Ht,tt.width,tt.height,tt.depth,0,gt,i0,tt.data);else if(V.isData3DTexture)t0?(p0&&t.texStorage3D(x.TEXTURE_3D,ft,Ht,tt.width,tt.height,tt.depth),de&&t.texSubImage3D(x.TEXTURE_3D,0,0,0,0,tt.width,tt.height,tt.depth,gt,i0,tt.data)):t.texImage3D(x.TEXTURE_3D,0,Ht,tt.width,tt.height,tt.depth,0,gt,i0,tt.data);else if(V.isFramebufferTexture){if(p0)if(t0)t.texStorage2D(x.TEXTURE_2D,ft,Ht,tt.width,tt.height);else{let Xe=tt.width,Ze=tt.height;for(let lt=0;lt<ft;lt++)t.texImage2D(x.TEXTURE_2D,lt,Ht,Xe,Ze,0,gt,i0,null),Xe>>=1,Ze>>=1}}else if(Ut.length>0){if(t0&&p0){const Xe=dt(Ut[0]);t.texStorage2D(x.TEXTURE_2D,ft,Ht,Xe.width,Xe.height)}for(let Xe=0,Ze=Ut.length;Xe<Ze;Xe++)St=Ut[Xe],t0?de&&t.texSubImage2D(x.TEXTURE_2D,Xe,0,0,gt,i0,St):t.texImage2D(x.TEXTURE_2D,Xe,Ht,gt,i0,St);V.generateMipmaps=!1}else if(t0){if(p0){const Xe=dt(tt);t.texStorage2D(x.TEXTURE_2D,ft,Ht,Xe.width,Xe.height)}de&&t.texSubImage2D(x.TEXTURE_2D,0,0,0,gt,i0,tt)}else t.texImage2D(x.TEXTURE_2D,0,Ht,gt,i0,tt);v(V)&&b(Ge),_t.__version=Ve.version,V.onUpdate&&V.onUpdate(V)}Z.__version=V.version}function le(Z,V,_e){if(V.image.length!==6)return;const Ge=ge(Z,V),Re=V.source;t.bindTexture(x.TEXTURE_CUBE_MAP,Z.__webglTexture,x.TEXTURE0+_e);const Ve=n.get(Re);if(Re.version!==Ve.__version||Ge===!0){t.activeTexture(x.TEXTURE0+_e);const _t=J0.getPrimaries(J0.workingColorSpace),Ce=V.colorSpace===z2?null:J0.getPrimaries(V.colorSpace),pt=V.colorSpace===z2||_t===Ce?x.NONE:x.BROWSER_DEFAULT_WEBGL;x.pixelStorei(x.UNPACK_FLIP_Y_WEBGL,V.flipY),x.pixelStorei(x.UNPACK_PREMULTIPLY_ALPHA_WEBGL,V.premultiplyAlpha),x.pixelStorei(x.UNPACK_ALIGNMENT,V.unpackAlignment),x.pixelStorei(x.UNPACK_COLORSPACE_CONVERSION_WEBGL,pt);const et=V.isCompressedTexture||V.image[0].isCompressedTexture,tt=V.image[0]&&V.image[0].isDataTexture,gt=[];for(let Ze=0;Ze<6;Ze++)!et&&!tt?gt[Ze]=_(V.image[Ze],!0,i.maxCubemapSize):gt[Ze]=tt?V.image[Ze].image:V.image[Ze],gt[Ze]=ht(V,gt[Ze]);const i0=gt[0],Ht=r.convert(V.format,V.colorSpace),St=r.convert(V.type),Ut=T(V.internalFormat,Ht,St,V.colorSpace),t0=V.isVideoTexture!==!0,p0=Ve.__version===void 0||Ge===!0,de=Re.dataReady;let ft=A(V,i0);se(x.TEXTURE_CUBE_MAP,V);let Xe;if(et){t0&&p0&&t.texStorage2D(x.TEXTURE_CUBE_MAP,ft,Ut,i0.width,i0.height);for(let Ze=0;Ze<6;Ze++){Xe=gt[Ze].mipmaps;for(let lt=0;lt<Xe.length;lt++){const Wt=Xe[lt];V.format!==Ka?Ht!==null?t0?de&&t.compressedTexSubImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt,0,0,Wt.width,Wt.height,Ht,Wt.data):t.compressedTexImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt,Ut,Wt.width,Wt.height,0,Wt.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t0?de&&t.texSubImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt,0,0,Wt.width,Wt.height,Ht,St,Wt.data):t.texImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt,Ut,Wt.width,Wt.height,0,Ht,St,Wt.data)}}}else{if(Xe=V.mipmaps,t0&&p0){Xe.length>0&&ft++;const Ze=dt(gt[0]);t.texStorage2D(x.TEXTURE_CUBE_MAP,ft,Ut,Ze.width,Ze.height)}for(let Ze=0;Ze<6;Ze++)if(tt){t0?de&&t.texSubImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,0,0,gt[Ze].width,gt[Ze].height,Ht,St,gt[Ze].data):t.texImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,Ut,gt[Ze].width,gt[Ze].height,0,Ht,St,gt[Ze].data);for(let lt=0;lt<Xe.length;lt++){const Qt=Xe[lt].image[Ze].image;t0?de&&t.texSubImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt+1,0,0,Qt.width,Qt.height,Ht,St,Qt.data):t.texImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt+1,Ut,Qt.width,Qt.height,0,Ht,St,Qt.data)}}else{t0?de&&t.texSubImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,0,0,Ht,St,gt[Ze]):t.texImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,0,Ut,Ht,St,gt[Ze]);for(let lt=0;lt<Xe.length;lt++){const Wt=Xe[lt];t0?de&&t.texSubImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt+1,0,0,Ht,St,Wt.image[Ze]):t.texImage2D(x.TEXTURE_CUBE_MAP_POSITIVE_X+Ze,lt+1,Ut,Ht,St,Wt.image[Ze])}}}v(V)&&b(x.TEXTURE_CUBE_MAP),Ve.__version=Re.version,V.onUpdate&&V.onUpdate(V)}Z.__version=V.version}function Se(Z,V,_e,Ge,Re,Ve){const _t=r.convert(_e.format,_e.colorSpace),Ce=r.convert(_e.type),pt=T(_e.internalFormat,_t,Ce,_e.colorSpace);if(!n.get(V).__hasExternalTextures){const tt=Math.max(1,V.width>>Ve),gt=Math.max(1,V.height>>Ve);Re===x.TEXTURE_3D||Re===x.TEXTURE_2D_ARRAY?t.texImage3D(Re,Ve,pt,tt,gt,V.depth,0,_t,Ce,null):t.texImage2D(Re,Ve,pt,tt,gt,0,_t,Ce,null)}t.bindFramebuffer(x.FRAMEBUFFER,Z),Ue(V)?s.framebufferTexture2DMultisampleEXT(x.FRAMEBUFFER,Ge,Re,n.get(_e).__webglTexture,0,at(V)):(Re===x.TEXTURE_2D||Re>=x.TEXTURE_CUBE_MAP_POSITIVE_X&&Re<=x.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&x.framebufferTexture2D(x.FRAMEBUFFER,Ge,Re,n.get(_e).__webglTexture,Ve),t.bindFramebuffer(x.FRAMEBUFFER,null)}function Fe(Z,V,_e){if(x.bindRenderbuffer(x.RENDERBUFFER,Z),V.depthBuffer){const Ge=V.depthTexture,Re=Ge&&Ge.isDepthTexture?Ge.type:null,Ve=E(V.stencilBuffer,Re),_t=V.stencilBuffer?x.DEPTH_STENCIL_ATTACHMENT:x.DEPTH_ATTACHMENT,Ce=at(V);Ue(V)?s.renderbufferStorageMultisampleEXT(x.RENDERBUFFER,Ce,Ve,V.width,V.height):_e?x.renderbufferStorageMultisample(x.RENDERBUFFER,Ce,Ve,V.width,V.height):x.renderbufferStorage(x.RENDERBUFFER,Ve,V.width,V.height),x.framebufferRenderbuffer(x.FRAMEBUFFER,_t,x.RENDERBUFFER,Z)}else{const Ge=V.textures;for(let Re=0;Re<Ge.length;Re++){const Ve=Ge[Re],_t=r.convert(Ve.format,Ve.colorSpace),Ce=r.convert(Ve.type),pt=T(Ve.internalFormat,_t,Ce,Ve.colorSpace),et=at(V);_e&&Ue(V)===!1?x.renderbufferStorageMultisample(x.RENDERBUFFER,et,pt,V.width,V.height):Ue(V)?s.renderbufferStorageMultisampleEXT(x.RENDERBUFFER,et,pt,V.width,V.height):x.renderbufferStorage(x.RENDERBUFFER,pt,V.width,V.height)}}x.bindRenderbuffer(x.RENDERBUFFER,null)}function Qe(Z,V){if(V&&V.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(x.FRAMEBUFFER,Z),!(V.depthTexture&&V.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!n.get(V.depthTexture).__webglTexture||V.depthTexture.image.width!==V.width||V.depthTexture.image.height!==V.height)&&(V.depthTexture.image.width=V.width,V.depthTexture.image.height=V.height,V.depthTexture.needsUpdate=!0),xe(V.depthTexture,0);const Ge=n.get(V.depthTexture).__webglTexture,Re=at(V);if(V.depthTexture.format===fh)Ue(V)?s.framebufferTexture2DMultisampleEXT(x.FRAMEBUFFER,x.DEPTH_ATTACHMENT,x.TEXTURE_2D,Ge,0,Re):x.framebufferTexture2D(x.FRAMEBUFFER,x.DEPTH_ATTACHMENT,x.TEXTURE_2D,Ge,0);else if(V.depthTexture.format===Gh)Ue(V)?s.framebufferTexture2DMultisampleEXT(x.FRAMEBUFFER,x.DEPTH_STENCIL_ATTACHMENT,x.TEXTURE_2D,Ge,0,Re):x.framebufferTexture2D(x.FRAMEBUFFER,x.DEPTH_STENCIL_ATTACHMENT,x.TEXTURE_2D,Ge,0);else throw new Error("Unknown depthTexture format")}function qe(Z){const V=n.get(Z),_e=Z.isWebGLCubeRenderTarget===!0;if(V.__boundDepthTexture!==Z.depthTexture){const Ge=Z.depthTexture;if(V.__depthDisposeCallback&&V.__depthDisposeCallback(),Ge){const Re=()=>{delete V.__boundDepthTexture,delete V.__depthDisposeCallback,Ge.removeEventListener("dispose",Re)};Ge.addEventListener("dispose",Re),V.__depthDisposeCallback=Re}V.__boundDepthTexture=Ge}if(Z.depthTexture&&!V.__autoAllocateDepthBuffer){if(_e)throw new Error("target.depthTexture not supported in Cube render targets");Qe(V.__webglFramebuffer,Z)}else if(_e){V.__webglDepthbuffer=[];for(let Ge=0;Ge<6;Ge++)if(t.bindFramebuffer(x.FRAMEBUFFER,V.__webglFramebuffer[Ge]),V.__webglDepthbuffer[Ge]===void 0)V.__webglDepthbuffer[Ge]=x.createRenderbuffer(),Fe(V.__webglDepthbuffer[Ge],Z,!1);else{const Re=Z.stencilBuffer?x.DEPTH_STENCIL_ATTACHMENT:x.DEPTH_ATTACHMENT,Ve=V.__webglDepthbuffer[Ge];x.bindRenderbuffer(x.RENDERBUFFER,Ve),x.framebufferRenderbuffer(x.FRAMEBUFFER,Re,x.RENDERBUFFER,Ve)}}else if(t.bindFramebuffer(x.FRAMEBUFFER,V.__webglFramebuffer),V.__webglDepthbuffer===void 0)V.__webglDepthbuffer=x.createRenderbuffer(),Fe(V.__webglDepthbuffer,Z,!1);else{const Ge=Z.stencilBuffer?x.DEPTH_STENCIL_ATTACHMENT:x.DEPTH_ATTACHMENT,Re=V.__webglDepthbuffer;x.bindRenderbuffer(x.RENDERBUFFER,Re),x.framebufferRenderbuffer(x.FRAMEBUFFER,Ge,x.RENDERBUFFER,Re)}t.bindFramebuffer(x.FRAMEBUFFER,null)}function Et(Z,V,_e){const Ge=n.get(Z);V!==void 0&&Se(Ge.__webglFramebuffer,Z,Z.texture,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,0),_e!==void 0&&qe(Z)}function Tt(Z){const V=Z.texture,_e=n.get(Z),Ge=n.get(V);Z.addEventListener("dispose",R);const Re=Z.textures,Ve=Z.isWebGLCubeRenderTarget===!0,_t=Re.length>1;if(_t||(Ge.__webglTexture===void 0&&(Ge.__webglTexture=x.createTexture()),Ge.__version=V.version,a.memory.textures++),Ve){_e.__webglFramebuffer=[];for(let Ce=0;Ce<6;Ce++)if(V.mipmaps&&V.mipmaps.length>0){_e.__webglFramebuffer[Ce]=[];for(let pt=0;pt<V.mipmaps.length;pt++)_e.__webglFramebuffer[Ce][pt]=x.createFramebuffer()}else _e.__webglFramebuffer[Ce]=x.createFramebuffer()}else{if(V.mipmaps&&V.mipmaps.length>0){_e.__webglFramebuffer=[];for(let Ce=0;Ce<V.mipmaps.length;Ce++)_e.__webglFramebuffer[Ce]=x.createFramebuffer()}else _e.__webglFramebuffer=x.createFramebuffer();if(_t)for(let Ce=0,pt=Re.length;Ce<pt;Ce++){const et=n.get(Re[Ce]);et.__webglTexture===void 0&&(et.__webglTexture=x.createTexture(),a.memory.textures++)}if(Z.samples>0&&Ue(Z)===!1){_e.__webglMultisampledFramebuffer=x.createFramebuffer(),_e.__webglColorRenderbuffer=[],t.bindFramebuffer(x.FRAMEBUFFER,_e.__webglMultisampledFramebuffer);for(let Ce=0;Ce<Re.length;Ce++){const pt=Re[Ce];_e.__webglColorRenderbuffer[Ce]=x.createRenderbuffer(),x.bindRenderbuffer(x.RENDERBUFFER,_e.__webglColorRenderbuffer[Ce]);const et=r.convert(pt.format,pt.colorSpace),tt=r.convert(pt.type),gt=T(pt.internalFormat,et,tt,pt.colorSpace,Z.isXRRenderTarget===!0),i0=at(Z);x.renderbufferStorageMultisample(x.RENDERBUFFER,i0,gt,Z.width,Z.height),x.framebufferRenderbuffer(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0+Ce,x.RENDERBUFFER,_e.__webglColorRenderbuffer[Ce])}x.bindRenderbuffer(x.RENDERBUFFER,null),Z.depthBuffer&&(_e.__webglDepthRenderbuffer=x.createRenderbuffer(),Fe(_e.__webglDepthRenderbuffer,Z,!0)),t.bindFramebuffer(x.FRAMEBUFFER,null)}}if(Ve){t.bindTexture(x.TEXTURE_CUBE_MAP,Ge.__webglTexture),se(x.TEXTURE_CUBE_MAP,V);for(let Ce=0;Ce<6;Ce++)if(V.mipmaps&&V.mipmaps.length>0)for(let pt=0;pt<V.mipmaps.length;pt++)Se(_e.__webglFramebuffer[Ce][pt],Z,V,x.COLOR_ATTACHMENT0,x.TEXTURE_CUBE_MAP_POSITIVE_X+Ce,pt);else Se(_e.__webglFramebuffer[Ce],Z,V,x.COLOR_ATTACHMENT0,x.TEXTURE_CUBE_MAP_POSITIVE_X+Ce,0);v(V)&&b(x.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(_t){for(let Ce=0,pt=Re.length;Ce<pt;Ce++){const et=Re[Ce],tt=n.get(et);t.bindTexture(x.TEXTURE_2D,tt.__webglTexture),se(x.TEXTURE_2D,et),Se(_e.__webglFramebuffer,Z,et,x.COLOR_ATTACHMENT0+Ce,x.TEXTURE_2D,0),v(et)&&b(x.TEXTURE_2D)}t.unbindTexture()}else{let Ce=x.TEXTURE_2D;if((Z.isWebGL3DRenderTarget||Z.isWebGLArrayRenderTarget)&&(Ce=Z.isWebGL3DRenderTarget?x.TEXTURE_3D:x.TEXTURE_2D_ARRAY),t.bindTexture(Ce,Ge.__webglTexture),se(Ce,V),V.mipmaps&&V.mipmaps.length>0)for(let pt=0;pt<V.mipmaps.length;pt++)Se(_e.__webglFramebuffer[pt],Z,V,x.COLOR_ATTACHMENT0,Ce,pt);else Se(_e.__webglFramebuffer,Z,V,x.COLOR_ATTACHMENT0,Ce,0);v(V)&&b(Ce),t.unbindTexture()}Z.depthBuffer&&qe(Z)}function Bt(Z){const V=Z.textures;for(let _e=0,Ge=V.length;_e<Ge;_e++){const Re=V[_e];if(v(Re)){const Ve=Z.isWebGLCubeRenderTarget?x.TEXTURE_CUBE_MAP:x.TEXTURE_2D,_t=n.get(Re).__webglTexture;t.bindTexture(Ve,_t),b(Ve),t.unbindTexture()}}}const Q=[],rt=[];function He(Z){if(Z.samples>0){if(Ue(Z)===!1){const V=Z.textures,_e=Z.width,Ge=Z.height;let Re=x.COLOR_BUFFER_BIT;const Ve=Z.stencilBuffer?x.DEPTH_STENCIL_ATTACHMENT:x.DEPTH_ATTACHMENT,_t=n.get(Z),Ce=V.length>1;if(Ce)for(let pt=0;pt<V.length;pt++)t.bindFramebuffer(x.FRAMEBUFFER,_t.__webglMultisampledFramebuffer),x.framebufferRenderbuffer(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0+pt,x.RENDERBUFFER,null),t.bindFramebuffer(x.FRAMEBUFFER,_t.__webglFramebuffer),x.framebufferTexture2D(x.DRAW_FRAMEBUFFER,x.COLOR_ATTACHMENT0+pt,x.TEXTURE_2D,null,0);t.bindFramebuffer(x.READ_FRAMEBUFFER,_t.__webglMultisampledFramebuffer),t.bindFramebuffer(x.DRAW_FRAMEBUFFER,_t.__webglFramebuffer);for(let pt=0;pt<V.length;pt++){if(Z.resolveDepthBuffer&&(Z.depthBuffer&&(Re|=x.DEPTH_BUFFER_BIT),Z.stencilBuffer&&Z.resolveStencilBuffer&&(Re|=x.STENCIL_BUFFER_BIT)),Ce){x.framebufferRenderbuffer(x.READ_FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.RENDERBUFFER,_t.__webglColorRenderbuffer[pt]);const et=n.get(V[pt]).__webglTexture;x.framebufferTexture2D(x.DRAW_FRAMEBUFFER,x.COLOR_ATTACHMENT0,x.TEXTURE_2D,et,0)}x.blitFramebuffer(0,0,_e,Ge,0,0,_e,Ge,Re,x.NEAREST),l===!0&&(Q.length=0,rt.length=0,Q.push(x.COLOR_ATTACHMENT0+pt),Z.depthBuffer&&Z.resolveDepthBuffer===!1&&(Q.push(Ve),rt.push(Ve),x.invalidateFramebuffer(x.DRAW_FRAMEBUFFER,rt)),x.invalidateFramebuffer(x.READ_FRAMEBUFFER,Q))}if(t.bindFramebuffer(x.READ_FRAMEBUFFER,null),t.bindFramebuffer(x.DRAW_FRAMEBUFFER,null),Ce)for(let pt=0;pt<V.length;pt++){t.bindFramebuffer(x.FRAMEBUFFER,_t.__webglMultisampledFramebuffer),x.framebufferRenderbuffer(x.FRAMEBUFFER,x.COLOR_ATTACHMENT0+pt,x.RENDERBUFFER,_t.__webglColorRenderbuffer[pt]);const et=n.get(V[pt]).__webglTexture;t.bindFramebuffer(x.FRAMEBUFFER,_t.__webglFramebuffer),x.framebufferTexture2D(x.DRAW_FRAMEBUFFER,x.COLOR_ATTACHMENT0+pt,x.TEXTURE_2D,et,0)}t.bindFramebuffer(x.DRAW_FRAMEBUFFER,_t.__webglMultisampledFramebuffer)}else if(Z.depthBuffer&&Z.resolveDepthBuffer===!1&&l){const V=Z.stencilBuffer?x.DEPTH_STENCIL_ATTACHMENT:x.DEPTH_ATTACHMENT;x.invalidateFramebuffer(x.DRAW_FRAMEBUFFER,[V])}}}function at(Z){return Math.min(i.maxSamples,Z.samples)}function Ue(Z){const V=n.get(Z);return Z.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&V.__useRenderToTexture!==!1}function bt(Z){const V=a.render.frame;h.get(Z)!==V&&(h.set(Z,V),Z.update())}function ht(Z,V){const _e=Z.colorSpace,Ge=Z.format,Re=Z.type;return Z.isCompressedTexture===!0||Z.isVideoTexture===!0||_e!==pl&&_e!==z2&&(J0.getTransfer(_e)===Ex?(Ge!==Ka||Re!==zo)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",_e)),V}function dt(Z){return typeof HTMLImageElement<"u"&&Z instanceof HTMLImageElement?(c.width=Z.naturalWidth||Z.width,c.height=Z.naturalHeight||Z.height):typeof VideoFrame<"u"&&Z instanceof VideoFrame?(c.width=Z.displayWidth,c.height=Z.displayHeight):(c.width=Z.width,c.height=Z.height),c}this.allocateTextureUnit=te,this.resetTextureUnits=G,this.setTexture2D=xe,this.setTexture2DArray=ae,this.setTexture3D=H,this.setTextureCube=re,this.rebindTextures=Et,this.setupRenderTarget=Tt,this.updateRenderTargetMipmap=Bt,this.updateMultisampleRenderTarget=He,this.setupDepthRenderbuffer=qe,this.setupFrameBufferTexture=Se,this.useMultisampledRTT=Ue}function Hae(x,e){function t(n,i=z2){let r;const a=J0.getTransfer(i);if(n===zo)return x.UNSIGNED_BYTE;if(n===AM)return x.UNSIGNED_SHORT_4_4_4_4;if(n===EM)return x.UNSIGNED_SHORT_5_5_5_1;if(n===eL)return x.UNSIGNED_INT_5_9_9_9_REV;if(n===jB)return x.BYTE;if(n===qB)return x.SHORT;if(n===ep)return x.UNSIGNED_SHORT;if(n===wM)return x.INT;if(n===Cc)return x.UNSIGNED_INT;if(n===Oo)return x.FLOAT;if(n===Np)return x.HALF_FLOAT;if(n===tL)return x.ALPHA;if(n===xL)return x.RGB;if(n===Ka)return x.RGBA;if(n===nL)return x.LUMINANCE;if(n===iL)return x.LUMINANCE_ALPHA;if(n===fh)return x.DEPTH_COMPONENT;if(n===Gh)return x.DEPTH_STENCIL;if(n===rL)return x.RED;if(n===MM)return x.RED_INTEGER;if(n===aL)return x.RG;if(n===RM)return x.RG_INTEGER;if(n===CM)return x.RGBA_INTEGER;if(n===l1||n===c1||n===u1||n===h1)if(a===Ex)if(r=e.get("WEBGL_compressed_texture_s3tc_srgb"),r!==null){if(n===l1)return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(n===c1)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(n===u1)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(n===h1)return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(r=e.get("WEBGL_compressed_texture_s3tc"),r!==null){if(n===l1)return r.COMPRESSED_RGB_S3TC_DXT1_EXT;if(n===c1)return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(n===u1)return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(n===h1)return r.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(n===rw||n===aw||n===sw||n===ow)if(r=e.get("WEBGL_compressed_texture_pvrtc"),r!==null){if(n===rw)return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(n===aw)return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(n===sw)return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(n===ow)return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(n===lw||n===cw||n===uw)if(r=e.get("WEBGL_compressed_texture_etc"),r!==null){if(n===lw||n===cw)return a===Ex?r.COMPRESSED_SRGB8_ETC2:r.COMPRESSED_RGB8_ETC2;if(n===uw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:r.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(n===hw||n===dw||n===fw||n===pw||n===mw||n===yw||n===gw||n===vw||n===bw||n===_w||n===Sw||n===Tw||n===ww||n===Aw)if(r=e.get("WEBGL_compressed_texture_astc"),r!==null){if(n===hw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:r.COMPRESSED_RGBA_ASTC_4x4_KHR;if(n===dw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:r.COMPRESSED_RGBA_ASTC_5x4_KHR;if(n===fw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:r.COMPRESSED_RGBA_ASTC_5x5_KHR;if(n===pw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:r.COMPRESSED_RGBA_ASTC_6x5_KHR;if(n===mw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:r.COMPRESSED_RGBA_ASTC_6x6_KHR;if(n===yw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:r.COMPRESSED_RGBA_ASTC_8x5_KHR;if(n===gw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:r.COMPRESSED_RGBA_ASTC_8x6_KHR;if(n===vw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:r.COMPRESSED_RGBA_ASTC_8x8_KHR;if(n===bw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:r.COMPRESSED_RGBA_ASTC_10x5_KHR;if(n===_w)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:r.COMPRESSED_RGBA_ASTC_10x6_KHR;if(n===Sw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:r.COMPRESSED_RGBA_ASTC_10x8_KHR;if(n===Tw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:r.COMPRESSED_RGBA_ASTC_10x10_KHR;if(n===ww)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:r.COMPRESSED_RGBA_ASTC_12x10_KHR;if(n===Aw)return a===Ex?r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:r.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(n===d1||n===Ew||n===Mw)if(r=e.get("EXT_texture_compression_bptc"),r!==null){if(n===d1)return a===Ex?r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:r.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(n===Ew)return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(n===Mw)return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(n===sL||n===Rw||n===Cw||n===Nw)if(r=e.get("EXT_texture_compression_rgtc"),r!==null){if(n===d1)return r.COMPRESSED_RED_RGTC1_EXT;if(n===Rw)return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(n===Cw)return r.COMPRESSED_RED_GREEN_RGTC2_EXT;if(n===Nw)return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return n===Hh?x.UNSIGNED_INT_24_8:x[n]!==void 0?x[n]:null}return{convert:t}}class Gae extends Cr{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}let vy=class extends Xo{constructor(){super(),this.isGroup=!0,this.type="Group"}};const Wae={type:"move"};class fS{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new vy,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new vy,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Be,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Be),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new vy,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Be,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Be),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const n of e.hand.values())this._getHandJoint(t,n)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,n){let i=null,r=null,a=null;const s=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){a=!0;for(const _ of e.hand.values()){const v=t.getJointPose(_,n),b=this._getHandJoint(c,_);v!==null&&(b.matrix.fromArray(v.transform.matrix),b.matrix.decompose(b.position,b.rotation,b.scale),b.matrixWorldNeedsUpdate=!0,b.jointRadius=v.radius),b.visible=v!==null}const h=c.joints["index-finger-tip"],d=c.joints["thumb-tip"],p=h.position.distanceTo(d.position),m=.02,g=.005;c.inputState.pinching&&p>m+g?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&p<=m-g&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,n),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));s!==null&&(i=t.getPose(e.targetRaySpace,n),i===null&&r!==null&&(i=r),i!==null&&(s.matrix.fromArray(i.transform.matrix),s.matrix.decompose(s.position,s.rotation,s.scale),s.matrixWorldNeedsUpdate=!0,i.linearVelocity?(s.hasLinearVelocity=!0,s.linearVelocity.copy(i.linearVelocity)):s.hasLinearVelocity=!1,i.angularVelocity?(s.hasAngularVelocity=!0,s.angularVelocity.copy(i.angularVelocity)):s.hasAngularVelocity=!1,this.dispatchEvent(Wae)))}return s!==null&&(s.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=a!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const n=new vy;n.matrixAutoUpdate=!1,n.visible=!1,e.joints[t.jointName]=n,e.add(n)}return e.joints[t.jointName]}}const Xae=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,Yae=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Kae{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t,n){if(this.texture===null){const i=new ns,r=e.properties.get(i);r.__webglTexture=t.texture,(t.depthNear!=n.depthNear||t.depthFar!=n.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=i}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,n=new rl({vertexShader:Xae,fragmentShader:Yae,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new ws(new pv(20,20),n)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class $ae extends hd{constructor(e,t){super();const n=this;let i=null,r=1,a=null,s="local-floor",l=1,c=null,h=null,d=null,p=null,m=null,g=null;const _=new Kae,v=t.getContextAttributes();let b=null,T=null;const E=[],A=[],M=new fx;let R=null;const C=new Cr;C.layers.enable(1),C.viewport=new ui;const k=new Cr;k.layers.enable(2),k.viewport=new ui;const P=[C,k],N=new Gae;N.layers.enable(1),N.layers.enable(2);let G=null,te=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(le){let Se=E[le];return Se===void 0&&(Se=new fS,E[le]=Se),Se.getTargetRaySpace()},this.getControllerGrip=function(le){let Se=E[le];return Se===void 0&&(Se=new fS,E[le]=Se),Se.getGripSpace()},this.getHand=function(le){let Se=E[le];return Se===void 0&&(Se=new fS,E[le]=Se),Se.getHandSpace()};function j(le){const Se=A.indexOf(le.inputSource);if(Se===-1)return;const Fe=E[Se];Fe!==void 0&&(Fe.update(le.inputSource,le.frame,c||a),Fe.dispatchEvent({type:le.type,data:le.inputSource}))}function xe(){i.removeEventListener("select",j),i.removeEventListener("selectstart",j),i.removeEventListener("selectend",j),i.removeEventListener("squeeze",j),i.removeEventListener("squeezestart",j),i.removeEventListener("squeezeend",j),i.removeEventListener("end",xe),i.removeEventListener("inputsourceschange",ae);for(let le=0;le<E.length;le++){const Se=A[le];Se!==null&&(A[le]=null,E[le].disconnect(Se))}G=null,te=null,_.reset(),e.setRenderTarget(b),m=null,p=null,d=null,i=null,T=null,Me.stop(),n.isPresenting=!1,e.setPixelRatio(R),e.setSize(M.width,M.height,!1),n.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(le){r=le,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(le){s=le,n.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||a},this.setReferenceSpace=function(le){c=le},this.getBaseLayer=function(){return p!==null?p:m},this.getBinding=function(){return d},this.getFrame=function(){return g},this.getSession=function(){return i},this.setSession=async function(le){if(i=le,i!==null){if(b=e.getRenderTarget(),i.addEventListener("select",j),i.addEventListener("selectstart",j),i.addEventListener("selectend",j),i.addEventListener("squeeze",j),i.addEventListener("squeezestart",j),i.addEventListener("squeezeend",j),i.addEventListener("end",xe),i.addEventListener("inputsourceschange",ae),v.xrCompatible!==!0&&await t.makeXRCompatible(),R=e.getPixelRatio(),e.getSize(M),i.renderState.layers===void 0){const Se={antialias:v.antialias,alpha:!0,depth:v.depth,stencil:v.stencil,framebufferScaleFactor:r};m=new XRWebGLLayer(i,t,Se),i.updateRenderState({baseLayer:m}),e.setPixelRatio(1),e.setSize(m.framebufferWidth,m.framebufferHeight,!1),T=new Ic(m.framebufferWidth,m.framebufferHeight,{format:Ka,type:zo,colorSpace:e.outputColorSpace,stencilBuffer:v.stencil})}else{let Se=null,Fe=null,Qe=null;v.depth&&(Qe=v.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,Se=v.stencil?Gh:fh,Fe=v.stencil?Hh:Cc);const qe={colorFormat:t.RGBA8,depthFormat:Qe,scaleFactor:r};d=new XRWebGLBinding(i,t),p=d.createProjectionLayer(qe),i.updateRenderState({layers:[p]}),e.setPixelRatio(1),e.setSize(p.textureWidth,p.textureHeight,!1),T=new Ic(p.textureWidth,p.textureHeight,{format:Ka,type:zo,depthTexture:new CL(p.textureWidth,p.textureHeight,Fe,void 0,void 0,void 0,void 0,void 0,void 0,Se),stencilBuffer:v.stencil,colorSpace:e.outputColorSpace,samples:v.antialias?4:0,resolveDepthBuffer:p.ignoreDepthValues===!1})}T.isXRRenderTarget=!0,this.setFoveation(l),c=null,a=await i.requestReferenceSpace(s),Me.setContext(i),Me.start(),n.isPresenting=!0,n.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return _.getDepthTexture()};function ae(le){for(let Se=0;Se<le.removed.length;Se++){const Fe=le.removed[Se],Qe=A.indexOf(Fe);Qe>=0&&(A[Qe]=null,E[Qe].disconnect(Fe))}for(let Se=0;Se<le.added.length;Se++){const Fe=le.added[Se];let Qe=A.indexOf(Fe);if(Qe===-1){for(let Et=0;Et<E.length;Et++)if(Et>=A.length){A.push(Fe),Qe=Et;break}else if(A[Et]===null){A[Et]=Fe,Qe=Et;break}if(Qe===-1)break}const qe=E[Qe];qe&&qe.connect(Fe)}}const H=new Be,re=new Be;function q(le,Se,Fe){H.setFromMatrixPosition(Se.matrixWorld),re.setFromMatrixPosition(Fe.matrixWorld);const Qe=H.distanceTo(re),qe=Se.projectionMatrix.elements,Et=Fe.projectionMatrix.elements,Tt=qe[14]/(qe[10]-1),Bt=qe[14]/(qe[10]+1),Q=(qe[9]+1)/qe[5],rt=(qe[9]-1)/qe[5],He=(qe[8]-1)/qe[0],at=(Et[8]+1)/Et[0],Ue=Tt*He,bt=Tt*at,ht=Qe/(-He+at),dt=ht*-He;if(Se.matrixWorld.decompose(le.position,le.quaternion,le.scale),le.translateX(dt),le.translateZ(ht),le.matrixWorld.compose(le.position,le.quaternion,le.scale),le.matrixWorldInverse.copy(le.matrixWorld).invert(),qe[10]===-1)le.projectionMatrix.copy(Se.projectionMatrix),le.projectionMatrixInverse.copy(Se.projectionMatrixInverse);else{const Z=Tt+ht,V=Bt+ht,_e=Ue-dt,Ge=bt+(Qe-dt),Re=Q*Bt/V*Z,Ve=rt*Bt/V*Z;le.projectionMatrix.makePerspective(_e,Ge,Re,Ve,Z,V),le.projectionMatrixInverse.copy(le.projectionMatrix).invert()}}function be(le,Se){Se===null?le.matrixWorld.copy(le.matrix):le.matrixWorld.multiplyMatrices(Se.matrixWorld,le.matrix),le.matrixWorldInverse.copy(le.matrixWorld).invert()}this.updateCamera=function(le){if(i===null)return;let Se=le.near,Fe=le.far;_.texture!==null&&(_.depthNear>0&&(Se=_.depthNear),_.depthFar>0&&(Fe=_.depthFar)),N.near=k.near=C.near=Se,N.far=k.far=C.far=Fe,(G!==N.near||te!==N.far)&&(i.updateRenderState({depthNear:N.near,depthFar:N.far}),G=N.near,te=N.far);const Qe=le.parent,qe=N.cameras;be(N,Qe);for(let Et=0;Et<qe.length;Et++)be(qe[Et],Qe);qe.length===2?q(N,C,k):N.projectionMatrix.copy(C.projectionMatrix),K(le,N,Qe)};function K(le,Se,Fe){Fe===null?le.matrix.copy(Se.matrixWorld):(le.matrix.copy(Fe.matrixWorld),le.matrix.invert(),le.matrix.multiply(Se.matrixWorld)),le.matrix.decompose(le.position,le.quaternion,le.scale),le.updateMatrixWorld(!0),le.projectionMatrix.copy(Se.projectionMatrix),le.projectionMatrixInverse.copy(Se.projectionMatrixInverse),le.isPerspectiveCamera&&(le.fov=Iw*2*Math.atan(1/le.projectionMatrix.elements[5]),le.zoom=1)}this.getCamera=function(){return N},this.getFoveation=function(){if(!(p===null&&m===null))return l},this.setFoveation=function(le){l=le,p!==null&&(p.fixedFoveation=le),m!==null&&m.fixedFoveation!==void 0&&(m.fixedFoveation=le)},this.hasDepthSensing=function(){return _.texture!==null},this.getDepthSensingMesh=function(){return _.getMesh(N)};let se=null;function ge(le,Se){if(h=Se.getViewerPose(c||a),g=Se,h!==null){const Fe=h.views;m!==null&&(e.setRenderTargetFramebuffer(T,m.framebuffer),e.setRenderTarget(T));let Qe=!1;Fe.length!==N.cameras.length&&(N.cameras.length=0,Qe=!0);for(let Et=0;Et<Fe.length;Et++){const Tt=Fe[Et];let Bt=null;if(m!==null)Bt=m.getViewport(Tt);else{const rt=d.getViewSubImage(p,Tt);Bt=rt.viewport,Et===0&&(e.setRenderTargetTextures(T,rt.colorTexture,p.ignoreDepthValues?void 0:rt.depthStencilTexture),e.setRenderTarget(T))}let Q=P[Et];Q===void 0&&(Q=new Cr,Q.layers.enable(Et),Q.viewport=new ui,P[Et]=Q),Q.matrix.fromArray(Tt.transform.matrix),Q.matrix.decompose(Q.position,Q.quaternion,Q.scale),Q.projectionMatrix.fromArray(Tt.projectionMatrix),Q.projectionMatrixInverse.copy(Q.projectionMatrix).invert(),Q.viewport.set(Bt.x,Bt.y,Bt.width,Bt.height),Et===0&&(N.matrix.copy(Q.matrix),N.matrix.decompose(N.position,N.quaternion,N.scale)),Qe===!0&&N.cameras.push(Q)}const qe=i.enabledFeatures;if(qe&&qe.includes("depth-sensing")){const Et=d.getDepthInformation(Fe[0]);Et&&Et.isValid&&Et.texture&&_.init(e,Et,i.renderState)}}for(let Fe=0;Fe<E.length;Fe++){const Qe=A[Fe],qe=E[Fe];Qe!==null&&qe!==void 0&&qe.update(Qe,Se,c||a)}se&&se(le,Se),Se.detectedPlanes&&n.dispatchEvent({type:"planesdetected",data:Se}),g=null}const Me=new fL;Me.setAnimationLoop(ge),this.setAnimationLoop=function(le){se=le},this.dispose=function(){}}}const Wl=new Nc,Qae=new Hn;function Zae(x,e){function t(v,b){v.matrixAutoUpdate===!0&&v.updateMatrix(),b.value.copy(v.matrix)}function n(v,b){b.color.getRGB(v.fogColor.value,SL(x)),b.isFog?(v.fogNear.value=b.near,v.fogFar.value=b.far):b.isFogExp2&&(v.fogDensity.value=b.density)}function i(v,b,T,E,A){b.isMeshBasicMaterial||b.isMeshLambertMaterial?r(v,b):b.isMeshToonMaterial?(r(v,b),d(v,b)):b.isMeshPhongMaterial?(r(v,b),h(v,b)):b.isMeshStandardMaterial?(r(v,b),p(v,b),b.isMeshPhysicalMaterial&&m(v,b,A)):b.isMeshMatcapMaterial?(r(v,b),g(v,b)):b.isMeshDepthMaterial?r(v,b):b.isMeshDistanceMaterial?(r(v,b),_(v,b)):b.isMeshNormalMaterial?r(v,b):b.isLineBasicMaterial?(a(v,b),b.isLineDashedMaterial&&s(v,b)):b.isPointsMaterial?l(v,b,T,E):b.isSpriteMaterial?c(v,b):b.isShadowMaterial?(v.color.value.copy(b.color),v.opacity.value=b.opacity):b.isShaderMaterial&&(b.uniformsNeedUpdate=!1)}function r(v,b){v.opacity.value=b.opacity,b.color&&v.diffuse.value.copy(b.color),b.emissive&&v.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity),b.map&&(v.map.value=b.map,t(b.map,v.mapTransform)),b.alphaMap&&(v.alphaMap.value=b.alphaMap,t(b.alphaMap,v.alphaMapTransform)),b.bumpMap&&(v.bumpMap.value=b.bumpMap,t(b.bumpMap,v.bumpMapTransform),v.bumpScale.value=b.bumpScale,b.side===er&&(v.bumpScale.value*=-1)),b.normalMap&&(v.normalMap.value=b.normalMap,t(b.normalMap,v.normalMapTransform),v.normalScale.value.copy(b.normalScale),b.side===er&&v.normalScale.value.negate()),b.displacementMap&&(v.displacementMap.value=b.displacementMap,t(b.displacementMap,v.displacementMapTransform),v.displacementScale.value=b.displacementScale,v.displacementBias.value=b.displacementBias),b.emissiveMap&&(v.emissiveMap.value=b.emissiveMap,t(b.emissiveMap,v.emissiveMapTransform)),b.specularMap&&(v.specularMap.value=b.specularMap,t(b.specularMap,v.specularMapTransform)),b.alphaTest>0&&(v.alphaTest.value=b.alphaTest);const T=e.get(b),E=T.envMap,A=T.envMapRotation;E&&(v.envMap.value=E,Wl.copy(A),Wl.x*=-1,Wl.y*=-1,Wl.z*=-1,E.isCubeTexture&&E.isRenderTargetTexture===!1&&(Wl.y*=-1,Wl.z*=-1),v.envMapRotation.value.setFromMatrix4(Qae.makeRotationFromEuler(Wl)),v.flipEnvMap.value=E.isCubeTexture&&E.isRenderTargetTexture===!1?-1:1,v.reflectivity.value=b.reflectivity,v.ior.value=b.ior,v.refractionRatio.value=b.refractionRatio),b.lightMap&&(v.lightMap.value=b.lightMap,v.lightMapIntensity.value=b.lightMapIntensity,t(b.lightMap,v.lightMapTransform)),b.aoMap&&(v.aoMap.value=b.aoMap,v.aoMapIntensity.value=b.aoMapIntensity,t(b.aoMap,v.aoMapTransform))}function a(v,b){v.diffuse.value.copy(b.color),v.opacity.value=b.opacity,b.map&&(v.map.value=b.map,t(b.map,v.mapTransform))}function s(v,b){v.dashSize.value=b.dashSize,v.totalSize.value=b.dashSize+b.gapSize,v.scale.value=b.scale}function l(v,b,T,E){v.diffuse.value.copy(b.color),v.opacity.value=b.opacity,v.size.value=b.size*T,v.scale.value=E*.5,b.map&&(v.map.value=b.map,t(b.map,v.uvTransform)),b.alphaMap&&(v.alphaMap.value=b.alphaMap,t(b.alphaMap,v.alphaMapTransform)),b.alphaTest>0&&(v.alphaTest.value=b.alphaTest)}function c(v,b){v.diffuse.value.copy(b.color),v.opacity.value=b.opacity,v.rotation.value=b.rotation,b.map&&(v.map.value=b.map,t(b.map,v.mapTransform)),b.alphaMap&&(v.alphaMap.value=b.alphaMap,t(b.alphaMap,v.alphaMapTransform)),b.alphaTest>0&&(v.alphaTest.value=b.alphaTest)}function h(v,b){v.specular.value.copy(b.specular),v.shininess.value=Math.max(b.shininess,1e-4)}function d(v,b){b.gradientMap&&(v.gradientMap.value=b.gradientMap)}function p(v,b){v.metalness.value=b.metalness,b.metalnessMap&&(v.metalnessMap.value=b.metalnessMap,t(b.metalnessMap,v.metalnessMapTransform)),v.roughness.value=b.roughness,b.roughnessMap&&(v.roughnessMap.value=b.roughnessMap,t(b.roughnessMap,v.roughnessMapTransform)),b.envMap&&(v.envMapIntensity.value=b.envMapIntensity)}function m(v,b,T){v.ior.value=b.ior,b.sheen>0&&(v.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen),v.sheenRoughness.value=b.sheenRoughness,b.sheenColorMap&&(v.sheenColorMap.value=b.sheenColorMap,t(b.sheenColorMap,v.sheenColorMapTransform)),b.sheenRoughnessMap&&(v.sheenRoughnessMap.value=b.sheenRoughnessMap,t(b.sheenRoughnessMap,v.sheenRoughnessMapTransform))),b.clearcoat>0&&(v.clearcoat.value=b.clearcoat,v.clearcoatRoughness.value=b.clearcoatRoughness,b.clearcoatMap&&(v.clearcoatMap.value=b.clearcoatMap,t(b.clearcoatMap,v.clearcoatMapTransform)),b.clearcoatRoughnessMap&&(v.clearcoatRoughnessMap.value=b.clearcoatRoughnessMap,t(b.clearcoatRoughnessMap,v.clearcoatRoughnessMapTransform)),b.clearcoatNormalMap&&(v.clearcoatNormalMap.value=b.clearcoatNormalMap,t(b.clearcoatNormalMap,v.clearcoatNormalMapTransform),v.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),b.side===er&&v.clearcoatNormalScale.value.negate())),b.dispersion>0&&(v.dispersion.value=b.dispersion),b.iridescence>0&&(v.iridescence.value=b.iridescence,v.iridescenceIOR.value=b.iridescenceIOR,v.iridescenceThicknessMinimum.value=b.iridescenceThicknessRange[0],v.iridescenceThicknessMaximum.value=b.iridescenceThicknessRange[1],b.iridescenceMap&&(v.iridescenceMap.value=b.iridescenceMap,t(b.iridescenceMap,v.iridescenceMapTransform)),b.iridescenceThicknessMap&&(v.iridescenceThicknessMap.value=b.iridescenceThicknessMap,t(b.iridescenceThicknessMap,v.iridescenceThicknessMapTransform))),b.transmission>0&&(v.transmission.value=b.transmission,v.transmissionSamplerMap.value=T.texture,v.transmissionSamplerSize.value.set(T.width,T.height),b.transmissionMap&&(v.transmissionMap.value=b.transmissionMap,t(b.transmissionMap,v.transmissionMapTransform)),v.thickness.value=b.thickness,b.thicknessMap&&(v.thicknessMap.value=b.thicknessMap,t(b.thicknessMap,v.thicknessMapTransform)),v.attenuationDistance.value=b.attenuationDistance,v.attenuationColor.value.copy(b.attenuationColor)),b.anisotropy>0&&(v.anisotropyVector.value.set(b.anisotropy*Math.cos(b.anisotropyRotation),b.anisotropy*Math.sin(b.anisotropyRotation)),b.anisotropyMap&&(v.anisotropyMap.value=b.anisotropyMap,t(b.anisotropyMap,v.anisotropyMapTransform))),v.specularIntensity.value=b.specularIntensity,v.specularColor.value.copy(b.specularColor),b.specularColorMap&&(v.specularColorMap.value=b.specularColorMap,t(b.specularColorMap,v.specularColorMapTransform)),b.specularIntensityMap&&(v.specularIntensityMap.value=b.specularIntensityMap,t(b.specularIntensityMap,v.specularIntensityMapTransform))}function g(v,b){b.matcap&&(v.matcap.value=b.matcap)}function _(v,b){const T=e.get(b).light;v.referencePosition.value.setFromMatrixPosition(T.matrixWorld),v.nearDistance.value=T.shadow.camera.near,v.farDistance.value=T.shadow.camera.far}return{refreshFogUniforms:n,refreshMaterialUniforms:i}}function Jae(x,e,t,n){let i={},r={},a=[];const s=x.getParameter(x.MAX_UNIFORM_BUFFER_BINDINGS);function l(T,E){const A=E.program;n.uniformBlockBinding(T,A)}function c(T,E){let A=i[T.id];A===void 0&&(g(T),A=h(T),i[T.id]=A,T.addEventListener("dispose",v));const M=E.program;n.updateUBOMapping(T,M);const R=e.render.frame;r[T.id]!==R&&(p(T),r[T.id]=R)}function h(T){const E=d();T.__bindingPointIndex=E;const A=x.createBuffer(),M=T.__size,R=T.usage;return x.bindBuffer(x.UNIFORM_BUFFER,A),x.bufferData(x.UNIFORM_BUFFER,M,R),x.bindBuffer(x.UNIFORM_BUFFER,null),x.bindBufferBase(x.UNIFORM_BUFFER,E,A),A}function d(){for(let T=0;T<s;T++)if(a.indexOf(T)===-1)return a.push(T),T;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function p(T){const E=i[T.id],A=T.uniforms,M=T.__cache;x.bindBuffer(x.UNIFORM_BUFFER,E);for(let R=0,C=A.length;R<C;R++){const k=Array.isArray(A[R])?A[R]:[A[R]];for(let P=0,N=k.length;P<N;P++){const G=k[P];if(m(G,R,P,M)===!0){const te=G.__offset,j=Array.isArray(G.value)?G.value:[G.value];let xe=0;for(let ae=0;ae<j.length;ae++){const H=j[ae],re=_(H);typeof H=="number"||typeof H=="boolean"?(G.__data[0]=H,x.bufferSubData(x.UNIFORM_BUFFER,te+xe,G.__data)):H.isMatrix3?(G.__data[0]=H.elements[0],G.__data[1]=H.elements[1],G.__data[2]=H.elements[2],G.__data[3]=0,G.__data[4]=H.elements[3],G.__data[5]=H.elements[4],G.__data[6]=H.elements[5],G.__data[7]=0,G.__data[8]=H.elements[6],G.__data[9]=H.elements[7],G.__data[10]=H.elements[8],G.__data[11]=0):(H.toArray(G.__data,xe),xe+=re.storage/Float32Array.BYTES_PER_ELEMENT)}x.bufferSubData(x.UNIFORM_BUFFER,te,G.__data)}}}x.bindBuffer(x.UNIFORM_BUFFER,null)}function m(T,E,A,M){const R=T.value,C=E+"_"+A;if(M[C]===void 0)return typeof R=="number"||typeof R=="boolean"?M[C]=R:M[C]=R.clone(),!0;{const k=M[C];if(typeof R=="number"||typeof R=="boolean"){if(k!==R)return M[C]=R,!0}else if(k.equals(R)===!1)return k.copy(R),!0}return!1}function g(T){const E=T.uniforms;let A=0;const M=16;for(let C=0,k=E.length;C<k;C++){const P=Array.isArray(E[C])?E[C]:[E[C]];for(let N=0,G=P.length;N<G;N++){const te=P[N],j=Array.isArray(te.value)?te.value:[te.value];for(let xe=0,ae=j.length;xe<ae;xe++){const H=j[xe],re=_(H),q=A%M,be=q%re.boundary,K=q+be;A+=be,K!==0&&M-K<re.storage&&(A+=M-K),te.__data=new Float32Array(re.storage/Float32Array.BYTES_PER_ELEMENT),te.__offset=A,A+=re.storage}}}const R=A%M;return R>0&&(A+=M-R),T.__size=A,T.__cache={},this}function _(T){const E={boundary:0,storage:0};return typeof T=="number"||typeof T=="boolean"?(E.boundary=4,E.storage=4):T.isVector2?(E.boundary=8,E.storage=8):T.isVector3||T.isColor?(E.boundary=16,E.storage=12):T.isVector4?(E.boundary=16,E.storage=16):T.isMatrix3?(E.boundary=48,E.storage=48):T.isMatrix4?(E.boundary=64,E.storage=64):T.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",T),E}function v(T){const E=T.target;E.removeEventListener("dispose",v);const A=a.indexOf(E.__bindingPointIndex);a.splice(A,1),x.deleteBuffer(i[E.id]),delete i[E.id],delete r[E.id]}function b(){for(const T in i)x.deleteBuffer(i[T]);a=[],i={},r={}}return{bind:l,update:c,dispose:b}}class jae{constructor(e={}){const{canvas:t=$0e(),context:n=null,depth:i=!0,stencil:r=!1,alpha:a=!1,antialias:s=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:h="default",failIfMajorPerformanceCaveat:d=!1}=e;this.isWebGLRenderer=!0;let p;if(n!==null){if(typeof WebGLRenderingContext<"u"&&n instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");p=n.getContextAttributes().alpha}else p=a;const m=new Uint32Array(4),g=new Int32Array(4);let _=null,v=null;const b=[],T=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=La,this.toneMapping=Z2,this.toneMappingExposure=1;const E=this;let A=!1,M=0,R=0,C=null,k=-1,P=null;const N=new ui,G=new ui;let te=null;const j=new dx(0);let xe=0,ae=t.width,H=t.height,re=1,q=null,be=null;const K=new ui(0,0,ae,H),se=new ui(0,0,ae,H);let ge=!1;const Me=new hL;let le=!1,Se=!1;const Fe=new Hn,Qe=new Be,qe=new ui,Et={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Tt=!1;function Bt(){return C===null?re:1}let Q=n;function rt(Y,ce){return t.getContext(Y,ce)}try{const Y={alpha:!0,depth:i,stencil:r,antialias:s,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:h,failIfMajorPerformanceCaveat:d};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Wte}`),t.addEventListener("webglcontextlost",Xe,!1),t.addEventListener("webglcontextrestored",Ze,!1),t.addEventListener("webglcontextcreationerror",lt,!1),Q===null){const ce="webgl2";if(Q=rt(ce,Y),Q===null)throw rt(ce)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(Y){throw console.error("THREE.WebGLRenderer: "+Y.message),Y}let He,at,Ue,bt,ht,dt,Z,V,_e,Ge,Re,Ve,_t,Ce,pt,et,tt,gt,i0,Ht,St,Ut,t0,p0;function de(){He=new nre(Q),He.init(),Ut=new Hae(Q,He),at=new Xie(Q,He,e,Ut),Ue=new Lae(Q),bt=new are(Q),ht=new Aae,dt=new Vae(Q,He,Ue,ht,at,Ut,bt),Z=new qie(E),V=new xre(E),_e=new K0e(Q),t0=new Gie(Q,_e),Ge=new ire(Q,_e,bt,t0),Re=new ore(Q,Ge,_e,bt),i0=new sre(Q,at,dt),et=new Yie(ht),Ve=new wae(E,Z,V,He,at,t0,et),_t=new Zae(E,ht),Ce=new Mae,pt=new Dae(He),gt=new Hie(E,Z,V,Ue,Re,p,l),tt=new Bae(E,Re,at),p0=new Jae(Q,bt,at,Ue),Ht=new Wie(Q,He,bt),St=new rre(Q,He,bt),bt.programs=Ve.programs,E.capabilities=at,E.extensions=He,E.properties=ht,E.renderLists=Ce,E.shadowMap=tt,E.state=Ue,E.info=bt}de();const ft=new $ae(E,Q);this.xr=ft,this.getContext=function(){return Q},this.getContextAttributes=function(){return Q.getContextAttributes()},this.forceContextLoss=function(){const Y=He.get("WEBGL_lose_context");Y&&Y.loseContext()},this.forceContextRestore=function(){const Y=He.get("WEBGL_lose_context");Y&&Y.restoreContext()},this.getPixelRatio=function(){return re},this.setPixelRatio=function(Y){Y!==void 0&&(re=Y,this.setSize(ae,H,!1))},this.getSize=function(Y){return Y.set(ae,H)},this.setSize=function(Y,ce,Ne=!0){if(ft.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}ae=Y,H=ce,t.width=Math.floor(Y*re),t.height=Math.floor(ce*re),Ne===!0&&(t.style.width=Y+"px",t.style.height=ce+"px"),this.setViewport(0,0,Y,ce)},this.getDrawingBufferSize=function(Y){return Y.set(ae*re,H*re).floor()},this.setDrawingBufferSize=function(Y,ce,Ne){ae=Y,H=ce,re=Ne,t.width=Math.floor(Y*Ne),t.height=Math.floor(ce*Ne),this.setViewport(0,0,Y,ce)},this.getCurrentViewport=function(Y){return Y.copy(N)},this.getViewport=function(Y){return Y.copy(K)},this.setViewport=function(Y,ce,Ne,Ie){Y.isVector4?K.set(Y.x,Y.y,Y.z,Y.w):K.set(Y,ce,Ne,Ie),Ue.viewport(N.copy(K).multiplyScalar(re).round())},this.getScissor=function(Y){return Y.copy(se)},this.setScissor=function(Y,ce,Ne,Ie){Y.isVector4?se.set(Y.x,Y.y,Y.z,Y.w):se.set(Y,ce,Ne,Ie),Ue.scissor(G.copy(se).multiplyScalar(re).round())},this.getScissorTest=function(){return ge},this.setScissorTest=function(Y){Ue.setScissorTest(ge=Y)},this.setOpaqueSort=function(Y){q=Y},this.setTransparentSort=function(Y){be=Y},this.getClearColor=function(Y){return Y.copy(gt.getClearColor())},this.setClearColor=function(){gt.setClearColor.apply(gt,arguments)},this.getClearAlpha=function(){return gt.getClearAlpha()},this.setClearAlpha=function(){gt.setClearAlpha.apply(gt,arguments)},this.clear=function(Y=!0,ce=!0,Ne=!0){let Ie=0;if(Y){let fe=!1;if(C!==null){const ct=C.texture.format;fe=ct===CM||ct===RM||ct===MM}if(fe){const ct=C.texture.type,wt=ct===zo||ct===Cc||ct===ep||ct===Hh||ct===AM||ct===EM,It=gt.getClearColor(),Ct=gt.getClearAlpha(),Kt=It.r,Ft=It.g,Dt=It.b;wt?(m[0]=Kt,m[1]=Ft,m[2]=Dt,m[3]=Ct,Q.clearBufferuiv(Q.COLOR,0,m)):(g[0]=Kt,g[1]=Ft,g[2]=Dt,g[3]=Ct,Q.clearBufferiv(Q.COLOR,0,g))}else Ie|=Q.COLOR_BUFFER_BIT}ce&&(Ie|=Q.DEPTH_BUFFER_BIT),Ne&&(Ie|=Q.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),Q.clear(Ie)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Xe,!1),t.removeEventListener("webglcontextrestored",Ze,!1),t.removeEventListener("webglcontextcreationerror",lt,!1),Ce.dispose(),pt.dispose(),ht.dispose(),Z.dispose(),V.dispose(),Re.dispose(),t0.dispose(),p0.dispose(),Ve.dispose(),ft.dispose(),ft.removeEventListener("sessionstart",Cx),ft.removeEventListener("sessionend",ax),L0.stop()};function Xe(Y){Y.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),A=!0}function Ze(){console.log("THREE.WebGLRenderer: Context Restored."),A=!1;const Y=bt.autoReset,ce=tt.enabled,Ne=tt.autoUpdate,Ie=tt.needsUpdate,fe=tt.type;de(),bt.autoReset=Y,tt.enabled=ce,tt.autoUpdate=Ne,tt.needsUpdate=Ie,tt.type=fe}function lt(Y){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",Y.statusMessage)}function Wt(Y){const ce=Y.target;ce.removeEventListener("dispose",Wt),Qt(ce)}function Qt(Y){D0(Y),ht.remove(Y)}function D0(Y){const ce=ht.get(Y).programs;ce!==void 0&&(ce.forEach(function(Ne){Ve.releaseProgram(Ne)}),Y.isShaderMaterial&&Ve.releaseShaderCache(Y))}this.renderBufferDirect=function(Y,ce,Ne,Ie,fe,ct){ce===null&&(ce=Et);const wt=fe.isMesh&&fe.matrixWorld.determinant()<0,It=Ii(Y,ce,Ne,Ie,fe);Ue.setMaterial(Ie,wt);let Ct=Ne.index,Kt=1;if(Ie.wireframe===!0){if(Ct=Ge.getWireframeAttribute(Ne),Ct===void 0)return;Kt=2}const Ft=Ne.drawRange,Dt=Ne.attributes.position;let Zt=Ft.start*Kt,v0=(Ft.start+Ft.count)*Kt;ct!==null&&(Zt=Math.max(Zt,ct.start*Kt),v0=Math.min(v0,(ct.start+ct.count)*Kt)),Ct!==null?(Zt=Math.max(Zt,0),v0=Math.min(v0,Ct.count)):Dt!=null&&(Zt=Math.max(Zt,0),v0=Math.min(v0,Dt.count));const h0=v0-Zt;if(h0<0||h0===1/0)return;t0.setup(fe,Ie,It,Ne,Ct);let sx,d0=Ht;if(Ct!==null&&(sx=_e.get(Ct),d0=St,d0.setIndex(sx)),fe.isMesh)Ie.wireframe===!0?(Ue.setLineWidth(Ie.wireframeLinewidth*Bt()),d0.setMode(Q.LINES)):d0.setMode(Q.TRIANGLES);else if(fe.isLine){let Ot=Ie.linewidth;Ot===void 0&&(Ot=1),Ue.setLineWidth(Ot*Bt()),fe.isLineSegments?d0.setMode(Q.LINES):fe.isLineLoop?d0.setMode(Q.LINE_LOOP):d0.setMode(Q.LINE_STRIP)}else fe.isPoints?d0.setMode(Q.POINTS):fe.isSprite&&d0.setMode(Q.TRIANGLES);if(fe.isBatchedMesh)if(fe._multiDrawInstances!==null)d0.renderMultiDrawInstances(fe._multiDrawStarts,fe._multiDrawCounts,fe._multiDrawCount,fe._multiDrawInstances);else if(He.get("WEBGL_multi_draw"))d0.renderMultiDraw(fe._multiDrawStarts,fe._multiDrawCounts,fe._multiDrawCount);else{const Ot=fe._multiDrawStarts,$0=fe._multiDrawCounts,y0=fe._multiDrawCount,U0=Ct?_e.get(Ct).bytesPerElement:1,gi=ht.get(Ie).currentProgram.getUniforms();for(let Bx=0;Bx<y0;Bx++)gi.setValue(Q,"_gl_DrawID",Bx),d0.render(Ot[Bx]/U0,$0[Bx])}else if(fe.isInstancedMesh)d0.renderInstances(Zt,h0,fe.count);else if(Ne.isInstancedBufferGeometry){const Ot=Ne._maxInstanceCount!==void 0?Ne._maxInstanceCount:1/0,$0=Math.min(Ne.instanceCount,Ot);d0.renderInstances(Zt,h0,$0)}else d0.render(Zt,h0)};function P0(Y,ce,Ne){Y.transparent===!0&&Y.side===Mo&&Y.forceSinglePass===!1?(Y.side=er,Y.needsUpdate=!0,mi(Y,ce,Ne),Y.side=il,Y.needsUpdate=!0,mi(Y,ce,Ne),Y.side=Mo):mi(Y,ce,Ne)}this.compile=function(Y,ce,Ne=null){Ne===null&&(Ne=Y),v=pt.get(Ne),v.init(ce),T.push(v),Ne.traverseVisible(function(fe){fe.isLight&&fe.layers.test(ce.layers)&&(v.pushLight(fe),fe.castShadow&&v.pushShadow(fe))}),Y!==Ne&&Y.traverseVisible(function(fe){fe.isLight&&fe.layers.test(ce.layers)&&(v.pushLight(fe),fe.castShadow&&v.pushShadow(fe))}),v.setupLights();const Ie=new Set;return Y.traverse(function(fe){const ct=fe.material;if(ct)if(Array.isArray(ct))for(let wt=0;wt<ct.length;wt++){const It=ct[wt];P0(It,Ne,fe),Ie.add(It)}else P0(ct,Ne,fe),Ie.add(ct)}),T.pop(),v=null,Ie},this.compileAsync=function(Y,ce,Ne=null){const Ie=this.compile(Y,ce,Ne);return new Promise(fe=>{function ct(){if(Ie.forEach(function(wt){ht.get(wt).currentProgram.isReady()&&Ie.delete(wt)}),Ie.size===0){fe(Y);return}setTimeout(ct,10)}He.get("KHR_parallel_shader_compile")!==null?ct():setTimeout(ct,10)})};let s0=null;function rn(Y){s0&&s0(Y)}function Cx(){L0.stop()}function ax(){L0.start()}const L0=new fL;L0.setAnimationLoop(rn),typeof self<"u"&&L0.setContext(self),this.setAnimationLoop=function(Y){s0=Y,ft.setAnimationLoop(Y),Y===null?L0.stop():L0.start()},ft.addEventListener("sessionstart",Cx),ft.addEventListener("sessionend",ax),this.render=function(Y,ce){if(ce!==void 0&&ce.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(A===!0)return;if(Y.matrixWorldAutoUpdate===!0&&Y.updateMatrixWorld(),ce.parent===null&&ce.matrixWorldAutoUpdate===!0&&ce.updateMatrixWorld(),ft.enabled===!0&&ft.isPresenting===!0&&(ft.cameraAutoUpdate===!0&&ft.updateCamera(ce),ce=ft.getCamera()),Y.isScene===!0&&Y.onBeforeRender(E,Y,ce,C),v=pt.get(Y,T.length),v.init(ce),T.push(v),Fe.multiplyMatrices(ce.projectionMatrix,ce.matrixWorldInverse),Me.setFromProjectionMatrix(Fe),Se=this.localClippingEnabled,le=et.init(this.clippingPlanes,Se),_=Ce.get(Y,b.length),_.init(),b.push(_),ft.enabled===!0&&ft.isPresenting===!0){const ct=E.xr.getDepthSensingMesh();ct!==null&&R0(ct,ce,-1/0,E.sortObjects)}R0(Y,ce,0,E.sortObjects),_.finish(),E.sortObjects===!0&&_.sort(q,be),Tt=ft.enabled===!1||ft.isPresenting===!1||ft.hasDepthSensing()===!1,Tt&&gt.addToRenderList(_,Y),this.info.render.frame++,le===!0&&et.beginShadows();const Ne=v.state.shadowsArray;tt.render(Ne,Y,ce),le===!0&&et.endShadows(),this.info.autoReset===!0&&this.info.reset();const Ie=_.opaque,fe=_.transmissive;if(v.setupLights(),ce.isArrayCamera){const ct=ce.cameras;if(fe.length>0)for(let wt=0,It=ct.length;wt<It;wt++){const Ct=ct[wt];q0(Ie,fe,Y,Ct)}Tt&&gt.render(Y);for(let wt=0,It=ct.length;wt<It;wt++){const Ct=ct[wt];Wn(_,Y,Ct,Ct.viewport)}}else fe.length>0&&q0(Ie,fe,Y,ce),Tt&&gt.render(Y),Wn(_,Y,ce);C!==null&&(dt.updateMultisampleRenderTarget(C),dt.updateRenderTargetMipmap(C)),Y.isScene===!0&&Y.onAfterRender(E,Y,ce),t0.resetDefaultState(),k=-1,P=null,T.pop(),T.length>0?(v=T[T.length-1],le===!0&&et.setGlobalState(E.clippingPlanes,v.state.camera)):v=null,b.pop(),b.length>0?_=b[b.length-1]:_=null};function R0(Y,ce,Ne,Ie){if(Y.visible===!1)return;if(Y.layers.test(ce.layers)){if(Y.isGroup)Ne=Y.renderOrder;else if(Y.isLOD)Y.autoUpdate===!0&&Y.update(ce);else if(Y.isLight)v.pushLight(Y),Y.castShadow&&v.pushShadow(Y);else if(Y.isSprite){if(!Y.frustumCulled||Me.intersectsSprite(Y)){Ie&&qe.setFromMatrixPosition(Y.matrixWorld).applyMatrix4(Fe);const wt=Re.update(Y),It=Y.material;It.visible&&_.push(Y,wt,It,Ne,qe.z,null)}}else if((Y.isMesh||Y.isLine||Y.isPoints)&&(!Y.frustumCulled||Me.intersectsObject(Y))){const wt=Re.update(Y),It=Y.material;if(Ie&&(Y.boundingSphere!==void 0?(Y.boundingSphere===null&&Y.computeBoundingSphere(),qe.copy(Y.boundingSphere.center)):(wt.boundingSphere===null&&wt.computeBoundingSphere(),qe.copy(wt.boundingSphere.center)),qe.applyMatrix4(Y.matrixWorld).applyMatrix4(Fe)),Array.isArray(It)){const Ct=wt.groups;for(let Kt=0,Ft=Ct.length;Kt<Ft;Kt++){const Dt=Ct[Kt],Zt=It[Dt.materialIndex];Zt&&Zt.visible&&_.push(Y,wt,Zt,Ne,qe.z,Dt)}}else It.visible&&_.push(Y,wt,It,Ne,qe.z,null)}}const ct=Y.children;for(let wt=0,It=ct.length;wt<It;wt++)R0(ct[wt],ce,Ne,Ie)}function Wn(Y,ce,Ne,Ie){const fe=Y.opaque,ct=Y.transmissive,wt=Y.transparent;v.setupLightsView(Ne),le===!0&&et.setGlobalState(E.clippingPlanes,Ne),Ie&&Ue.viewport(N.copy(Ie)),fe.length>0&&Fx(fe,ce,Ne),ct.length>0&&Fx(ct,ce,Ne),wt.length>0&&Fx(wt,ce,Ne),Ue.buffers.depth.setTest(!0),Ue.buffers.depth.setMask(!0),Ue.buffers.color.setMask(!0),Ue.setPolygonOffset(!1)}function q0(Y,ce,Ne,Ie){if((Ne.isScene===!0?Ne.overrideMaterial:null)!==null)return;v.state.transmissionRenderTarget[Ie.id]===void 0&&(v.state.transmissionRenderTarget[Ie.id]=new Ic(1,1,{generateMipmaps:!0,type:He.has("EXT_color_buffer_half_float")||He.has("EXT_color_buffer_float")?Np:zo,minFilter:cc,samples:4,stencilBuffer:r,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:J0.workingColorSpace}));const ct=v.state.transmissionRenderTarget[Ie.id],wt=Ie.viewport||N;ct.setSize(wt.z,wt.w);const It=E.getRenderTarget();E.setRenderTarget(ct),E.getClearColor(j),xe=E.getClearAlpha(),xe<1&&E.setClearColor(16777215,.5),E.clear(),Tt&&gt.render(Ne);const Ct=E.toneMapping;E.toneMapping=Z2;const Kt=Ie.viewport;if(Ie.viewport!==void 0&&(Ie.viewport=void 0),v.setupLightsView(Ie),le===!0&&et.setGlobalState(E.clippingPlanes,Ie),Fx(Y,Ne,Ie),dt.updateMultisampleRenderTarget(ct),dt.updateRenderTargetMipmap(ct),He.has("WEBGL_multisampled_render_to_texture")===!1){let Ft=!1;for(let Dt=0,Zt=ce.length;Dt<Zt;Dt++){const v0=ce[Dt],h0=v0.object,sx=v0.geometry,d0=v0.material,Ot=v0.group;if(d0.side===Mo&&h0.layers.test(Ie.layers)){const $0=d0.side;d0.side=er,d0.needsUpdate=!0,gn(h0,Ne,Ie,sx,d0,Ot),d0.side=$0,d0.needsUpdate=!0,Ft=!0}}Ft===!0&&(dt.updateMultisampleRenderTarget(ct),dt.updateRenderTargetMipmap(ct))}E.setRenderTarget(It),E.setClearColor(j,xe),Kt!==void 0&&(Ie.viewport=Kt),E.toneMapping=Ct}function Fx(Y,ce,Ne){const Ie=ce.isScene===!0?ce.overrideMaterial:null;for(let fe=0,ct=Y.length;fe<ct;fe++){const wt=Y[fe],It=wt.object,Ct=wt.geometry,Kt=Ie===null?wt.material:Ie,Ft=wt.group;It.layers.test(Ne.layers)&&gn(It,ce,Ne,Ct,Kt,Ft)}}function gn(Y,ce,Ne,Ie,fe,ct){Y.onBeforeRender(E,ce,Ne,Ie,fe,ct),Y.modelViewMatrix.multiplyMatrices(Ne.matrixWorldInverse,Y.matrixWorld),Y.normalMatrix.getNormalMatrix(Y.modelViewMatrix),fe.onBeforeRender(E,ce,Ne,Ie,Y,ct),fe.transparent===!0&&fe.side===Mo&&fe.forceSinglePass===!1?(fe.side=er,fe.needsUpdate=!0,E.renderBufferDirect(Ne,ce,Ie,fe,Y,ct),fe.side=il,fe.needsUpdate=!0,E.renderBufferDirect(Ne,ce,Ie,fe,Y,ct),fe.side=Mo):E.renderBufferDirect(Ne,ce,Ie,fe,Y,ct),Y.onAfterRender(E,ce,Ne,Ie,fe,ct)}function mi(Y,ce,Ne){ce.isScene!==!0&&(ce=Et);const Ie=ht.get(Y),fe=v.state.lights,ct=v.state.shadowsArray,wt=fe.state.version,It=Ve.getParameters(Y,fe.state,ct,ce,Ne),Ct=Ve.getProgramCacheKey(It);let Kt=Ie.programs;Ie.environment=Y.isMeshStandardMaterial?ce.environment:null,Ie.fog=ce.fog,Ie.envMap=(Y.isMeshStandardMaterial?V:Z).get(Y.envMap||Ie.environment),Ie.envMapRotation=Ie.environment!==null&&Y.envMap===null?ce.environmentRotation:Y.envMapRotation,Kt===void 0&&(Y.addEventListener("dispose",Wt),Kt=new Map,Ie.programs=Kt);let Ft=Kt.get(Ct);if(Ft!==void 0){if(Ie.currentProgram===Ft&&Ie.lightsStateVersion===wt)return Gr(Y,It),Ft}else It.uniforms=Ve.getUniforms(Y),Y.onBeforeCompile(It,E),Ft=Ve.acquireProgram(It,Ct),Kt.set(Ct,Ft),Ie.uniforms=It.uniforms;const Dt=Ie.uniforms;return(!Y.isShaderMaterial&&!Y.isRawShaderMaterial||Y.clipping===!0)&&(Dt.clippingPlanes=et.uniform),Gr(Y,It),Ie.needsLights=vn(Y),Ie.lightsStateVersion=wt,Ie.needsLights&&(Dt.ambientLightColor.value=fe.state.ambient,Dt.lightProbe.value=fe.state.probe,Dt.directionalLights.value=fe.state.directional,Dt.directionalLightShadows.value=fe.state.directionalShadow,Dt.spotLights.value=fe.state.spot,Dt.spotLightShadows.value=fe.state.spotShadow,Dt.rectAreaLights.value=fe.state.rectArea,Dt.ltc_1.value=fe.state.rectAreaLTC1,Dt.ltc_2.value=fe.state.rectAreaLTC2,Dt.pointLights.value=fe.state.point,Dt.pointLightShadows.value=fe.state.pointShadow,Dt.hemisphereLights.value=fe.state.hemi,Dt.directionalShadowMap.value=fe.state.directionalShadowMap,Dt.directionalShadowMatrix.value=fe.state.directionalShadowMatrix,Dt.spotShadowMap.value=fe.state.spotShadowMap,Dt.spotLightMatrix.value=fe.state.spotLightMatrix,Dt.spotLightMap.value=fe.state.spotLightMap,Dt.pointShadowMap.value=fe.state.pointShadowMap,Dt.pointShadowMatrix.value=fe.state.pointShadowMatrix),Ie.currentProgram=Ft,Ie.uniformsList=null,Ft}function yi(Y){if(Y.uniformsList===null){const ce=Y.currentProgram.getUniforms();Y.uniformsList=m1.seqWithValue(ce.seq,Y.uniforms)}return Y.uniformsList}function Gr(Y,ce){const Ne=ht.get(Y);Ne.outputColorSpace=ce.outputColorSpace,Ne.batching=ce.batching,Ne.batchingColor=ce.batchingColor,Ne.instancing=ce.instancing,Ne.instancingColor=ce.instancingColor,Ne.instancingMorph=ce.instancingMorph,Ne.skinning=ce.skinning,Ne.morphTargets=ce.morphTargets,Ne.morphNormals=ce.morphNormals,Ne.morphColors=ce.morphColors,Ne.morphTargetsCount=ce.morphTargetsCount,Ne.numClippingPlanes=ce.numClippingPlanes,Ne.numIntersection=ce.numClipIntersection,Ne.vertexAlphas=ce.vertexAlphas,Ne.vertexTangents=ce.vertexTangents,Ne.toneMapping=ce.toneMapping}function Ii(Y,ce,Ne,Ie,fe){ce.isScene!==!0&&(ce=Et),dt.resetTextureUnits();const ct=ce.fog,wt=Ie.isMeshStandardMaterial?ce.environment:null,It=C===null?E.outputColorSpace:C.isXRRenderTarget===!0?C.texture.colorSpace:pl,Ct=(Ie.isMeshStandardMaterial?V:Z).get(Ie.envMap||wt),Kt=Ie.vertexColors===!0&&!!Ne.attributes.color&&Ne.attributes.color.itemSize===4,Ft=!!Ne.attributes.tangent&&(!!Ie.normalMap||Ie.anisotropy>0),Dt=!!Ne.morphAttributes.position,Zt=!!Ne.morphAttributes.normal,v0=!!Ne.morphAttributes.color;let h0=Z2;Ie.toneMapped&&(C===null||C.isXRRenderTarget===!0)&&(h0=E.toneMapping);const sx=Ne.morphAttributes.position||Ne.morphAttributes.normal||Ne.morphAttributes.color,d0=sx!==void 0?sx.length:0,Ot=ht.get(Ie),$0=v.state.lights;if(le===!0&&(Se===!0||Y!==P)){const T0=Y===P&&Ie.id===k;et.setState(Ie,Y,T0)}let y0=!1;Ie.version===Ot.__version?(Ot.needsLights&&Ot.lightsStateVersion!==$0.state.version||Ot.outputColorSpace!==It||fe.isBatchedMesh&&Ot.batching===!1||!fe.isBatchedMesh&&Ot.batching===!0||fe.isBatchedMesh&&Ot.batchingColor===!0&&fe.colorTexture===null||fe.isBatchedMesh&&Ot.batchingColor===!1&&fe.colorTexture!==null||fe.isInstancedMesh&&Ot.instancing===!1||!fe.isInstancedMesh&&Ot.instancing===!0||fe.isSkinnedMesh&&Ot.skinning===!1||!fe.isSkinnedMesh&&Ot.skinning===!0||fe.isInstancedMesh&&Ot.instancingColor===!0&&fe.instanceColor===null||fe.isInstancedMesh&&Ot.instancingColor===!1&&fe.instanceColor!==null||fe.isInstancedMesh&&Ot.instancingMorph===!0&&fe.morphTexture===null||fe.isInstancedMesh&&Ot.instancingMorph===!1&&fe.morphTexture!==null||Ot.envMap!==Ct||Ie.fog===!0&&Ot.fog!==ct||Ot.numClippingPlanes!==void 0&&(Ot.numClippingPlanes!==et.numPlanes||Ot.numIntersection!==et.numIntersection)||Ot.vertexAlphas!==Kt||Ot.vertexTangents!==Ft||Ot.morphTargets!==Dt||Ot.morphNormals!==Zt||Ot.morphColors!==v0||Ot.toneMapping!==h0||Ot.morphTargetsCount!==d0)&&(y0=!0):(y0=!0,Ot.__version=Ie.version);let U0=Ot.currentProgram;y0===!0&&(U0=mi(Ie,ce,fe));let gi=!1,Bx=!1,Di=!1;const Q0=U0.getUniforms(),bn=Ot.uniforms;if(Ue.useProgram(U0.program)&&(gi=!0,Bx=!0,Di=!0),Ie.id!==k&&(k=Ie.id,Bx=!0),gi||P!==Y){Q0.setValue(Q,"projectionMatrix",Y.projectionMatrix),Q0.setValue(Q,"viewMatrix",Y.matrixWorldInverse);const T0=Q0.map.cameraPosition;T0!==void 0&&T0.setValue(Q,Qe.setFromMatrixPosition(Y.matrixWorld)),at.logarithmicDepthBuffer&&Q0.setValue(Q,"logDepthBufFC",2/(Math.log(Y.far+1)/Math.LN2)),(Ie.isMeshPhongMaterial||Ie.isMeshToonMaterial||Ie.isMeshLambertMaterial||Ie.isMeshBasicMaterial||Ie.isMeshStandardMaterial||Ie.isShaderMaterial)&&Q0.setValue(Q,"isOrthographic",Y.isOrthographicCamera===!0),P!==Y&&(P=Y,Bx=!0,Di=!0)}if(fe.isSkinnedMesh){Q0.setOptional(Q,fe,"bindMatrix"),Q0.setOptional(Q,fe,"bindMatrixInverse");const T0=fe.skeleton;T0&&(T0.boneTexture===null&&T0.computeBoneTexture(),Q0.setValue(Q,"boneTexture",T0.boneTexture,dt))}fe.isBatchedMesh&&(Q0.setOptional(Q,fe,"batchingTexture"),Q0.setValue(Q,"batchingTexture",fe._matricesTexture,dt),Q0.setOptional(Q,fe,"batchingIdTexture"),Q0.setValue(Q,"batchingIdTexture",fe._indirectTexture,dt),Q0.setOptional(Q,fe,"batchingColorTexture"),fe._colorsTexture!==null&&Q0.setValue(Q,"batchingColorTexture",fe._colorsTexture,dt));const vi=Ne.morphAttributes;if((vi.position!==void 0||vi.normal!==void 0||vi.color!==void 0)&&i0.update(fe,Ne,U0),(Bx||Ot.receiveShadow!==fe.receiveShadow)&&(Ot.receiveShadow=fe.receiveShadow,Q0.setValue(Q,"receiveShadow",fe.receiveShadow)),Ie.isMeshGouraudMaterial&&Ie.envMap!==null&&(bn.envMap.value=Ct,bn.flipEnvMap.value=Ct.isCubeTexture&&Ct.isRenderTargetTexture===!1?-1:1),Ie.isMeshStandardMaterial&&Ie.envMap===null&&ce.environment!==null&&(bn.envMapIntensity.value=ce.environmentIntensity),Bx&&(Q0.setValue(Q,"toneMappingExposure",E.toneMappingExposure),Ot.needsLights&&Oi(bn,Di),ct&&Ie.fog===!0&&_t.refreshFogUniforms(bn,ct),_t.refreshMaterialUniforms(bn,Ie,re,H,v.state.transmissionRenderTarget[Y.id]),m1.upload(Q,yi(Ot),bn,dt)),Ie.isShaderMaterial&&Ie.uniformsNeedUpdate===!0&&(m1.upload(Q,yi(Ot),bn,dt),Ie.uniformsNeedUpdate=!1),Ie.isSpriteMaterial&&Q0.setValue(Q,"center",fe.center),Q0.setValue(Q,"modelViewMatrix",fe.modelViewMatrix),Q0.setValue(Q,"normalMatrix",fe.normalMatrix),Q0.setValue(Q,"modelMatrix",fe.matrixWorld),Ie.isShaderMaterial||Ie.isRawShaderMaterial){const T0=Ie.uniformsGroups;for(let Xn=0,Nx=T0.length;Xn<Nx;Xn++){const Pi=T0[Xn];p0.update(Pi,U0),p0.bind(Pi,U0)}}return U0}function Oi(Y,ce){Y.ambientLightColor.needsUpdate=ce,Y.lightProbe.needsUpdate=ce,Y.directionalLights.needsUpdate=ce,Y.directionalLightShadows.needsUpdate=ce,Y.pointLights.needsUpdate=ce,Y.pointLightShadows.needsUpdate=ce,Y.spotLights.needsUpdate=ce,Y.spotLightShadows.needsUpdate=ce,Y.rectAreaLights.needsUpdate=ce,Y.hemisphereLights.needsUpdate=ce}function vn(Y){return Y.isMeshLambertMaterial||Y.isMeshToonMaterial||Y.isMeshPhongMaterial||Y.isMeshStandardMaterial||Y.isShadowMaterial||Y.isShaderMaterial&&Y.lights===!0}this.getActiveCubeFace=function(){return M},this.getActiveMipmapLevel=function(){return R},this.getRenderTarget=function(){return C},this.setRenderTargetTextures=function(Y,ce,Ne){ht.get(Y.texture).__webglTexture=ce,ht.get(Y.depthTexture).__webglTexture=Ne;const Ie=ht.get(Y);Ie.__hasExternalTextures=!0,Ie.__autoAllocateDepthBuffer=Ne===void 0,Ie.__autoAllocateDepthBuffer||He.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),Ie.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(Y,ce){const Ne=ht.get(Y);Ne.__webglFramebuffer=ce,Ne.__useDefaultFramebuffer=ce===void 0},this.setRenderTarget=function(Y,ce=0,Ne=0){C=Y,M=ce,R=Ne;let Ie=!0,fe=null,ct=!1,wt=!1;if(Y){const Ct=ht.get(Y);if(Ct.__useDefaultFramebuffer!==void 0)Ue.bindFramebuffer(Q.FRAMEBUFFER,null),Ie=!1;else if(Ct.__webglFramebuffer===void 0)dt.setupRenderTarget(Y);else if(Ct.__hasExternalTextures)dt.rebindTextures(Y,ht.get(Y.texture).__webglTexture,ht.get(Y.depthTexture).__webglTexture);else if(Y.depthBuffer){const Dt=Y.depthTexture;if(Ct.__boundDepthTexture!==Dt){if(Dt!==null&&ht.has(Dt)&&(Y.width!==Dt.image.width||Y.height!==Dt.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");dt.setupDepthRenderbuffer(Y)}}const Kt=Y.texture;(Kt.isData3DTexture||Kt.isDataArrayTexture||Kt.isCompressedArrayTexture)&&(wt=!0);const Ft=ht.get(Y).__webglFramebuffer;Y.isWebGLCubeRenderTarget?(Array.isArray(Ft[ce])?fe=Ft[ce][Ne]:fe=Ft[ce],ct=!0):Y.samples>0&&dt.useMultisampledRTT(Y)===!1?fe=ht.get(Y).__webglMultisampledFramebuffer:Array.isArray(Ft)?fe=Ft[Ne]:fe=Ft,N.copy(Y.viewport),G.copy(Y.scissor),te=Y.scissorTest}else N.copy(K).multiplyScalar(re).floor(),G.copy(se).multiplyScalar(re).floor(),te=ge;if(Ue.bindFramebuffer(Q.FRAMEBUFFER,fe)&&Ie&&Ue.drawBuffers(Y,fe),Ue.viewport(N),Ue.scissor(G),Ue.setScissorTest(te),ct){const Ct=ht.get(Y.texture);Q.framebufferTexture2D(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0,Q.TEXTURE_CUBE_MAP_POSITIVE_X+ce,Ct.__webglTexture,Ne)}else if(wt){const Ct=ht.get(Y.texture),Kt=ce||0;Q.framebufferTextureLayer(Q.FRAMEBUFFER,Q.COLOR_ATTACHMENT0,Ct.__webglTexture,Ne||0,Kt)}k=-1},this.readRenderTargetPixels=function(Y,ce,Ne,Ie,fe,ct,wt){if(!(Y&&Y.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let It=ht.get(Y).__webglFramebuffer;if(Y.isWebGLCubeRenderTarget&&wt!==void 0&&(It=It[wt]),It){Ue.bindFramebuffer(Q.FRAMEBUFFER,It);try{const Ct=Y.texture,Kt=Ct.format,Ft=Ct.type;if(!at.textureFormatReadable(Kt)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!at.textureTypeReadable(Ft)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ce>=0&&ce<=Y.width-Ie&&Ne>=0&&Ne<=Y.height-fe&&Q.readPixels(ce,Ne,Ie,fe,Ut.convert(Kt),Ut.convert(Ft),ct)}finally{const Ct=C!==null?ht.get(C).__webglFramebuffer:null;Ue.bindFramebuffer(Q.FRAMEBUFFER,Ct)}}},this.readRenderTargetPixelsAsync=async function(Y,ce,Ne,Ie,fe,ct,wt){if(!(Y&&Y.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let It=ht.get(Y).__webglFramebuffer;if(Y.isWebGLCubeRenderTarget&&wt!==void 0&&(It=It[wt]),It){Ue.bindFramebuffer(Q.FRAMEBUFFER,It);try{const Ct=Y.texture,Kt=Ct.format,Ft=Ct.type;if(!at.textureFormatReadable(Kt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!at.textureTypeReadable(Ft))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(ce>=0&&ce<=Y.width-Ie&&Ne>=0&&Ne<=Y.height-fe){const Dt=Q.createBuffer();Q.bindBuffer(Q.PIXEL_PACK_BUFFER,Dt),Q.bufferData(Q.PIXEL_PACK_BUFFER,ct.byteLength,Q.STREAM_READ),Q.readPixels(ce,Ne,Ie,fe,Ut.convert(Kt),Ut.convert(Ft),0),Q.flush();const Zt=Q.fenceSync(Q.SYNC_GPU_COMMANDS_COMPLETE,0);await Q0e(Q,Zt,4);try{Q.bindBuffer(Q.PIXEL_PACK_BUFFER,Dt),Q.getBufferSubData(Q.PIXEL_PACK_BUFFER,0,ct)}finally{Q.deleteBuffer(Dt),Q.deleteSync(Zt)}return ct}}finally{const Ct=C!==null?ht.get(C).__webglFramebuffer:null;Ue.bindFramebuffer(Q.FRAMEBUFFER,Ct)}}},this.copyFramebufferToTexture=function(Y,ce=null,Ne=0){Y.isTexture!==!0&&(Ff("WebGLRenderer: copyFramebufferToTexture function signature has changed."),ce=arguments[0]||null,Y=arguments[1]);const Ie=Math.pow(2,-Ne),fe=Math.floor(Y.image.width*Ie),ct=Math.floor(Y.image.height*Ie),wt=ce!==null?ce.x:0,It=ce!==null?ce.y:0;dt.setTexture2D(Y,0),Q.copyTexSubImage2D(Q.TEXTURE_2D,Ne,0,0,wt,It,fe,ct),Ue.unbindTexture()},this.copyTextureToTexture=function(Y,ce,Ne=null,Ie=null,fe=0){Y.isTexture!==!0&&(Ff("WebGLRenderer: copyTextureToTexture function signature has changed."),Ie=arguments[0]||null,Y=arguments[1],ce=arguments[2],fe=arguments[3]||0,Ne=null);let ct,wt,It,Ct,Kt,Ft;Ne!==null?(ct=Ne.max.x-Ne.min.x,wt=Ne.max.y-Ne.min.y,It=Ne.min.x,Ct=Ne.min.y):(ct=Y.image.width,wt=Y.image.height,It=0,Ct=0),Ie!==null?(Kt=Ie.x,Ft=Ie.y):(Kt=0,Ft=0);const Dt=Ut.convert(ce.format),Zt=Ut.convert(ce.type);dt.setTexture2D(ce,0),Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL,ce.flipY),Q.pixelStorei(Q.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ce.premultiplyAlpha),Q.pixelStorei(Q.UNPACK_ALIGNMENT,ce.unpackAlignment);const v0=Q.getParameter(Q.UNPACK_ROW_LENGTH),h0=Q.getParameter(Q.UNPACK_IMAGE_HEIGHT),sx=Q.getParameter(Q.UNPACK_SKIP_PIXELS),d0=Q.getParameter(Q.UNPACK_SKIP_ROWS),Ot=Q.getParameter(Q.UNPACK_SKIP_IMAGES),$0=Y.isCompressedTexture?Y.mipmaps[fe]:Y.image;Q.pixelStorei(Q.UNPACK_ROW_LENGTH,$0.width),Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT,$0.height),Q.pixelStorei(Q.UNPACK_SKIP_PIXELS,It),Q.pixelStorei(Q.UNPACK_SKIP_ROWS,Ct),Y.isDataTexture?Q.texSubImage2D(Q.TEXTURE_2D,fe,Kt,Ft,ct,wt,Dt,Zt,$0.data):Y.isCompressedTexture?Q.compressedTexSubImage2D(Q.TEXTURE_2D,fe,Kt,Ft,$0.width,$0.height,Dt,$0.data):Q.texSubImage2D(Q.TEXTURE_2D,fe,Kt,Ft,ct,wt,Dt,Zt,$0),Q.pixelStorei(Q.UNPACK_ROW_LENGTH,v0),Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT,h0),Q.pixelStorei(Q.UNPACK_SKIP_PIXELS,sx),Q.pixelStorei(Q.UNPACK_SKIP_ROWS,d0),Q.pixelStorei(Q.UNPACK_SKIP_IMAGES,Ot),fe===0&&ce.generateMipmaps&&Q.generateMipmap(Q.TEXTURE_2D),Ue.unbindTexture()},this.copyTextureToTexture3D=function(Y,ce,Ne=null,Ie=null,fe=0){Y.isTexture!==!0&&(Ff("WebGLRenderer: copyTextureToTexture3D function signature has changed."),Ne=arguments[0]||null,Ie=arguments[1]||null,Y=arguments[2],ce=arguments[3],fe=arguments[4]||0);let ct,wt,It,Ct,Kt,Ft,Dt,Zt,v0;const h0=Y.isCompressedTexture?Y.mipmaps[fe]:Y.image;Ne!==null?(ct=Ne.max.x-Ne.min.x,wt=Ne.max.y-Ne.min.y,It=Ne.max.z-Ne.min.z,Ct=Ne.min.x,Kt=Ne.min.y,Ft=Ne.min.z):(ct=h0.width,wt=h0.height,It=h0.depth,Ct=0,Kt=0,Ft=0),Ie!==null?(Dt=Ie.x,Zt=Ie.y,v0=Ie.z):(Dt=0,Zt=0,v0=0);const sx=Ut.convert(ce.format),d0=Ut.convert(ce.type);let Ot;if(ce.isData3DTexture)dt.setTexture3D(ce,0),Ot=Q.TEXTURE_3D;else if(ce.isDataArrayTexture||ce.isCompressedArrayTexture)dt.setTexture2DArray(ce,0),Ot=Q.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}Q.pixelStorei(Q.UNPACK_FLIP_Y_WEBGL,ce.flipY),Q.pixelStorei(Q.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ce.premultiplyAlpha),Q.pixelStorei(Q.UNPACK_ALIGNMENT,ce.unpackAlignment);const $0=Q.getParameter(Q.UNPACK_ROW_LENGTH),y0=Q.getParameter(Q.UNPACK_IMAGE_HEIGHT),U0=Q.getParameter(Q.UNPACK_SKIP_PIXELS),gi=Q.getParameter(Q.UNPACK_SKIP_ROWS),Bx=Q.getParameter(Q.UNPACK_SKIP_IMAGES);Q.pixelStorei(Q.UNPACK_ROW_LENGTH,h0.width),Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT,h0.height),Q.pixelStorei(Q.UNPACK_SKIP_PIXELS,Ct),Q.pixelStorei(Q.UNPACK_SKIP_ROWS,Kt),Q.pixelStorei(Q.UNPACK_SKIP_IMAGES,Ft),Y.isDataTexture||Y.isData3DTexture?Q.texSubImage3D(Ot,fe,Dt,Zt,v0,ct,wt,It,sx,d0,h0.data):ce.isCompressedArrayTexture?Q.compressedTexSubImage3D(Ot,fe,Dt,Zt,v0,ct,wt,It,sx,h0.data):Q.texSubImage3D(Ot,fe,Dt,Zt,v0,ct,wt,It,sx,d0,h0),Q.pixelStorei(Q.UNPACK_ROW_LENGTH,$0),Q.pixelStorei(Q.UNPACK_IMAGE_HEIGHT,y0),Q.pixelStorei(Q.UNPACK_SKIP_PIXELS,U0),Q.pixelStorei(Q.UNPACK_SKIP_ROWS,gi),Q.pixelStorei(Q.UNPACK_SKIP_IMAGES,Bx),fe===0&&ce.generateMipmaps&&Q.generateMipmap(Ot),Ue.unbindTexture()},this.initRenderTarget=function(Y){ht.get(Y).__webglFramebuffer===void 0&&dt.setupRenderTarget(Y)},this.initTexture=function(Y){Y.isCubeTexture?dt.setTextureCube(Y,0):Y.isData3DTexture?dt.setTexture3D(Y,0):Y.isDataArrayTexture||Y.isCompressedArrayTexture?dt.setTexture2DArray(Y,0):dt.setTexture2D(Y,0),Ue.unbindTexture()},this.resetState=function(){M=0,R=0,C=null,Ue.reset(),t0.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Do}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===NM?"display-p3":"srgb",t.unpackColorSpace=J0.workingColorSpace===fv?"display-p3":"srgb"}}class qae extends Xo{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Nc,this.environmentIntensity=1,this.environmentRotation=new Nc,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const PL="168",ng=0,ese=1,tse=2,BD=1,LD=100,zD=204,VD=205,HD=3,xse=0,GD="attached",nse="detached",kL=300,ise=303,tp=1e3,uc=1001,Pw=1002,kw=1003,rse=1004,ase=1005,J2=1006,sse=1007,yv=1008,ose=1009,mh=1015,by=1016,UL=1023,lse=1028,xp=2300,np=2301,pS=2302,WD=2400,XD=2401,YD=2402,cse=2500,use=0,FL=1,Uw=2,hse=0,BL="",Er="srgb",kr="srgb-linear",dse="display-p3",LL="display-p3-linear",Fw="linear",KD="srgb",$D="rec709",QD="p3",ku=7680,ZD=519,Bw=35044,hc=2e3,Lw=2001;class gv{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const n=this._listeners;n[e]===void 0&&(n[e]=[]),n[e].indexOf(t)===-1&&n[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const n=this._listeners;return n[e]!==void 0&&n[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const n=this._listeners[e.type];if(n!==void 0){e.target=this;const i=n.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,e);e.target=null}}}const ai=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let JD=1234567;const Bf=Math.PI/180,ip=180/Math.PI;function va(){const x=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,n=Math.random()*4294967295|0;return(ai[x&255]+ai[x>>8&255]+ai[x>>16&255]+ai[x>>24&255]+"-"+ai[e&255]+ai[e>>8&255]+"-"+ai[e>>16&15|64]+ai[e>>24&255]+"-"+ai[t&63|128]+ai[t>>8&255]+"-"+ai[t>>16&255]+ai[t>>24&255]+ai[n&255]+ai[n>>8&255]+ai[n>>16&255]+ai[n>>24&255]).toLowerCase()}function hn(x,e,t){return Math.max(e,Math.min(t,x))}function DM(x,e){return(x%e+e)%e}function fse(x,e,t,n,i){return n+(x-e)*(i-n)/(t-e)}function pse(x,e,t){return x!==e?(t-x)/(e-x):0}function Lf(x,e,t){return(1-t)*x+t*e}function mse(x,e,t,n){return Lf(x,e,1-Math.exp(-t*n))}function yse(x,e=1){return e-Math.abs(DM(x,e*2)-e)}function gse(x,e,t){return x<=e?0:x>=t?1:(x=(x-e)/(t-e),x*x*(3-2*x))}function vse(x,e,t){return x<=e?0:x>=t?1:(x=(x-e)/(t-e),x*x*x*(x*(x*6-15)+10))}function bse(x,e){return x+Math.floor(Math.random()*(e-x+1))}function _se(x,e){return x+Math.random()*(e-x)}function Sse(x){return x*(.5-Math.random())}function Tse(x){x!==void 0&&(JD=x);let e=JD+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function wse(x){return x*Bf}function Ase(x){return x*ip}function Ese(x){return(x&x-1)===0&&x!==0}function Mse(x){return Math.pow(2,Math.ceil(Math.log(x)/Math.LN2))}function Rse(x){return Math.pow(2,Math.floor(Math.log(x)/Math.LN2))}function Cse(x,e,t,n,i){const r=Math.cos,a=Math.sin,s=r(t/2),l=a(t/2),c=r((e+n)/2),h=a((e+n)/2),d=r((e-n)/2),p=a((e-n)/2),m=r((n-e)/2),g=a((n-e)/2);switch(i){case"XYX":x.set(s*h,l*d,l*p,s*c);break;case"YZY":x.set(l*p,s*h,l*d,s*c);break;case"ZXZ":x.set(l*d,l*p,s*h,s*c);break;case"XZX":x.set(s*h,l*g,l*m,s*c);break;case"YXY":x.set(l*m,s*h,l*g,s*c);break;case"ZYZ":x.set(l*g,l*m,s*h,s*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Wa(x,e){switch(e.constructor){case Float32Array:return x;case Uint32Array:return x/4294967295;case Uint16Array:return x/65535;case Uint8Array:return x/255;case Int32Array:return Math.max(x/2147483647,-1);case Int16Array:return Math.max(x/32767,-1);case Int8Array:return Math.max(x/127,-1);default:throw new Error("Invalid component type.")}}function nx(x,e){switch(e.constructor){case Float32Array:return x;case Uint32Array:return Math.round(x*4294967295);case Uint16Array:return Math.round(x*65535);case Uint8Array:return Math.round(x*255);case Int32Array:return Math.round(x*2147483647);case Int16Array:return Math.round(x*32767);case Int8Array:return Math.round(x*127);default:throw new Error("Invalid component type.")}}const Nse={DEG2RAD:Bf,RAD2DEG:ip,generateUUID:va,clamp:hn,euclideanModulo:DM,mapLinear:fse,inverseLerp:pse,lerp:Lf,damp:mse,pingpong:yse,smoothstep:gse,smootherstep:vse,randInt:bse,randFloat:_se,randFloatSpread:Sse,seededRandom:Tse,degToRad:wse,radToDeg:Ase,isPowerOfTwo:Ese,ceilPowerOfTwo:Mse,floorPowerOfTwo:Rse,setQuaternionFromProperEuler:Cse,normalize:nx,denormalize:Wa};class Pt{constructor(e=0,t=0){Pt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,n=this.y,i=e.elements;return this.x=i[0]*t+i[3]*n+i[6],this.y=i[1]*t+i[4]*n+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(hn(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y;return t*t+n*n}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const n=Math.cos(t),i=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*n-a*i+e.x,this.y=r*i+a*n+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Yo{constructor(e,t,n,i,r,a,s,l,c){Yo.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,n,i,r,a,s,l,c)}set(e,t,n,i,r,a,s,l,c){const h=this.elements;return h[0]=e,h[1]=i,h[2]=s,h[3]=t,h[4]=r,h[5]=l,h[6]=n,h[7]=a,h[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],this}extractBasis(e,t,n){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),n.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],s=n[3],l=n[6],c=n[1],h=n[4],d=n[7],p=n[2],m=n[5],g=n[8],_=i[0],v=i[3],b=i[6],T=i[1],E=i[4],A=i[7],M=i[2],R=i[5],C=i[8];return r[0]=a*_+s*T+l*M,r[3]=a*v+s*E+l*R,r[6]=a*b+s*A+l*C,r[1]=c*_+h*T+d*M,r[4]=c*v+h*E+d*R,r[7]=c*b+h*A+d*C,r[2]=p*_+m*T+g*M,r[5]=p*v+m*E+g*R,r[8]=p*b+m*A+g*C,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],s=e[5],l=e[6],c=e[7],h=e[8];return t*a*h-t*s*c-n*r*h+n*s*l+i*r*c-i*a*l}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],s=e[5],l=e[6],c=e[7],h=e[8],d=h*a-s*c,p=s*l-h*r,m=c*r-a*l,g=t*d+n*p+i*m;if(g===0)return this.set(0,0,0,0,0,0,0,0,0);const _=1/g;return e[0]=d*_,e[1]=(i*c-h*n)*_,e[2]=(s*n-i*a)*_,e[3]=p*_,e[4]=(h*t-i*l)*_,e[5]=(i*r-s*t)*_,e[6]=m*_,e[7]=(n*l-c*t)*_,e[8]=(a*t-n*r)*_,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,n,i,r,a,s){const l=Math.cos(r),c=Math.sin(r);return this.set(n*l,n*c,-n*(l*a+c*s)+a+e,-i*c,i*l,-i*(-c*a+l*s)+s+t,0,0,1),this}scale(e,t){return this.premultiply(mS.makeScale(e,t)),this}rotate(e){return this.premultiply(mS.makeRotation(-e)),this}translate(e,t){return this.premultiply(mS.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,n,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<9;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<9;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const mS=new Yo;function Ise(x){for(let e=x.length-1;e>=0;--e)if(x[e]>=65535)return!0;return!1}function zw(x){return document.createElementNS("http://www.w3.org/1999/xhtml",x)}const jD={};function zL(x){x in jD||(jD[x]=!0,console.warn(x))}const qD=new Yo().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),eP=new Yo().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),pf={[kr]:{transfer:Fw,primaries:$D,luminanceCoefficients:[.2126,.7152,.0722],toReference:x=>x,fromReference:x=>x},[Er]:{transfer:KD,primaries:$D,luminanceCoefficients:[.2126,.7152,.0722],toReference:x=>x.convertSRGBToLinear(),fromReference:x=>x.convertLinearToSRGB()},[LL]:{transfer:Fw,primaries:QD,luminanceCoefficients:[.2289,.6917,.0793],toReference:x=>x.applyMatrix3(eP),fromReference:x=>x.applyMatrix3(qD)},[dse]:{transfer:KD,primaries:QD,luminanceCoefficients:[.2289,.6917,.0793],toReference:x=>x.convertSRGBToLinear().applyMatrix3(eP),fromReference:x=>x.applyMatrix3(qD).convertLinearToSRGB()}},Ose=new Set([kr,LL]),Tr={enabled:!0,_workingColorSpace:kr,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(x){if(!Ose.has(x))throw new Error(`Unsupported working color space, "${x}".`);this._workingColorSpace=x},convert:function(x,e,t){if(this.enabled===!1||e===t||!e||!t)return x;const n=pf[e].toReference,i=pf[t].fromReference;return i(n(x))},fromWorkingColorSpace:function(x,e){return this.convert(x,this._workingColorSpace,e)},toWorkingColorSpace:function(x,e){return this.convert(x,e,this._workingColorSpace)},getPrimaries:function(x){return pf[x].primaries},getTransfer:function(x){return x===BL?Fw:pf[x].transfer},getLuminanceCoefficients:function(x,e=this._workingColorSpace){return x.fromArray(pf[e].luminanceCoefficients)}};function yh(x){return x<.04045?x*.0773993808:Math.pow(x*.9478672986+.0521327014,2.4)}function yS(x){return x<.0031308?x*12.92:1.055*Math.pow(x,.41666)-.055}let Uu;class Dse{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Uu===void 0&&(Uu=zw("canvas")),Uu.width=e.width,Uu.height=e.height;const n=Uu.getContext("2d");e instanceof ImageData?n.putImageData(e,0,0):n.drawImage(e,0,0,e.width,e.height),t=Uu}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=zw("canvas");t.width=e.width,t.height=e.height;const n=t.getContext("2d");n.drawImage(e,0,0,e.width,e.height);const i=n.getImageData(0,0,e.width,e.height),r=i.data;for(let a=0;a<r.length;a++)r[a]=yh(r[a]/255)*255;return n.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let n=0;n<t.length;n++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[n]=Math.floor(yh(t[n]/255)*255):t[n]=yh(t[n]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let Pse=0;class kse{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Pse++}),this.uuid=va(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const n={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let a=0,s=i.length;a<s;a++)i[a].isDataTexture?r.push(gS(i[a].image)):r.push(gS(i[a]))}else r=gS(i);n.url=r}return t||(e.images[this.uuid]=n),n}}function gS(x){return typeof HTMLImageElement<"u"&&x instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&x instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&x instanceof ImageBitmap?Dse.getDataURL(x):x.data?{data:Array.from(x.data),width:x.width,height:x.height,type:x.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Use=0;class Qa extends gv{constructor(e=Qa.DEFAULT_IMAGE,t=Qa.DEFAULT_MAPPING,n=uc,i=uc,r=J2,a=yv,s=UL,l=ose,c=Qa.DEFAULT_ANISOTROPY,h=BL){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Use++}),this.uuid=va(),this.name="",this.source=new kse(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=n,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=c,this.format=s,this.internalFormat=null,this.type=l,this.offset=new Pt(0,0),this.repeat=new Pt(1,1),this.center=new Pt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Yo,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=h,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const n={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(n.userData=this.userData),t||(e.textures[this.uuid]=n),n}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==kL)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case tp:e.x=e.x-Math.floor(e.x);break;case uc:e.x=e.x<0?0:1;break;case Pw:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case tp:e.y=e.y-Math.floor(e.y);break;case uc:e.y=e.y<0?0:1;break;case Pw:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}Qa.DEFAULT_IMAGE=null;Qa.DEFAULT_MAPPING=kL;Qa.DEFAULT_ANISOTROPY=1;class fa{constructor(e=0,t=0,n=0,i=1){fa.prototype.isVector4=!0,this.x=e,this.y=t,this.z=n,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,n,i){return this.x=e,this.y=t,this.z=n,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*n+a[8]*i+a[12]*r,this.y=a[1]*t+a[5]*n+a[9]*i+a[13]*r,this.z=a[2]*t+a[6]*n+a[10]*i+a[14]*r,this.w=a[3]*t+a[7]*n+a[11]*i+a[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,n,i,r;const l=e.elements,c=l[0],h=l[4],d=l[8],p=l[1],m=l[5],g=l[9],_=l[2],v=l[6],b=l[10];if(Math.abs(h-p)<.01&&Math.abs(d-_)<.01&&Math.abs(g-v)<.01){if(Math.abs(h+p)<.1&&Math.abs(d+_)<.1&&Math.abs(g+v)<.1&&Math.abs(c+m+b-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const E=(c+1)/2,A=(m+1)/2,M=(b+1)/2,R=(h+p)/4,C=(d+_)/4,k=(g+v)/4;return E>A&&E>M?E<.01?(n=0,i=.707106781,r=.707106781):(n=Math.sqrt(E),i=R/n,r=C/n):A>M?A<.01?(n=.707106781,i=0,r=.707106781):(i=Math.sqrt(A),n=R/i,r=k/i):M<.01?(n=.707106781,i=.707106781,r=0):(r=Math.sqrt(M),n=C/r,i=k/r),this.set(n,i,r,t),this}let T=Math.sqrt((v-g)*(v-g)+(d-_)*(d-_)+(p-h)*(p-h));return Math.abs(T)<.001&&(T=1),this.x=(v-g)/T,this.y=(d-_)/T,this.z=(p-h)/T,this.w=Math.acos((c+m+b-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this.w=e.w+(t.w-e.w)*n,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class Ns{constructor(e=0,t=0,n=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=n,this._w=i}static slerpFlat(e,t,n,i,r,a,s){let l=n[i+0],c=n[i+1],h=n[i+2],d=n[i+3];const p=r[a+0],m=r[a+1],g=r[a+2],_=r[a+3];if(s===0){e[t+0]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d;return}if(s===1){e[t+0]=p,e[t+1]=m,e[t+2]=g,e[t+3]=_;return}if(d!==_||l!==p||c!==m||h!==g){let v=1-s;const b=l*p+c*m+h*g+d*_,T=b>=0?1:-1,E=1-b*b;if(E>Number.EPSILON){const M=Math.sqrt(E),R=Math.atan2(M,b*T);v=Math.sin(v*R)/M,s=Math.sin(s*R)/M}const A=s*T;if(l=l*v+p*A,c=c*v+m*A,h=h*v+g*A,d=d*v+_*A,v===1-s){const M=1/Math.sqrt(l*l+c*c+h*h+d*d);l*=M,c*=M,h*=M,d*=M}}e[t]=l,e[t+1]=c,e[t+2]=h,e[t+3]=d}static multiplyQuaternionsFlat(e,t,n,i,r,a){const s=n[i],l=n[i+1],c=n[i+2],h=n[i+3],d=r[a],p=r[a+1],m=r[a+2],g=r[a+3];return e[t]=s*g+h*d+l*m-c*p,e[t+1]=l*g+h*p+c*d-s*m,e[t+2]=c*g+h*m+s*p-l*d,e[t+3]=h*g-s*d-l*p-c*m,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,n,i){return this._x=e,this._y=t,this._z=n,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const n=e._x,i=e._y,r=e._z,a=e._order,s=Math.cos,l=Math.sin,c=s(n/2),h=s(i/2),d=s(r/2),p=l(n/2),m=l(i/2),g=l(r/2);switch(a){case"XYZ":this._x=p*h*d+c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d-p*m*g;break;case"YXZ":this._x=p*h*d+c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d+p*m*g;break;case"ZXY":this._x=p*h*d-c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d-p*m*g;break;case"ZYX":this._x=p*h*d-c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d+p*m*g;break;case"YZX":this._x=p*h*d+c*m*g,this._y=c*m*d+p*h*g,this._z=c*h*g-p*m*d,this._w=c*h*d-p*m*g;break;case"XZY":this._x=p*h*d-c*m*g,this._y=c*m*d-p*h*g,this._z=c*h*g+p*m*d,this._w=c*h*d+p*m*g;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const n=t/2,i=Math.sin(n);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(n),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,n=t[0],i=t[4],r=t[8],a=t[1],s=t[5],l=t[9],c=t[2],h=t[6],d=t[10],p=n+s+d;if(p>0){const m=.5/Math.sqrt(p+1);this._w=.25/m,this._x=(h-l)*m,this._y=(r-c)*m,this._z=(a-i)*m}else if(n>s&&n>d){const m=2*Math.sqrt(1+n-s-d);this._w=(h-l)/m,this._x=.25*m,this._y=(i+a)/m,this._z=(r+c)/m}else if(s>d){const m=2*Math.sqrt(1+s-n-d);this._w=(r-c)/m,this._x=(i+a)/m,this._y=.25*m,this._z=(l+h)/m}else{const m=2*Math.sqrt(1+d-n-s);this._w=(a-i)/m,this._x=(r+c)/m,this._y=(l+h)/m,this._z=.25*m}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let n=e.dot(t)+1;return n<Number.EPSILON?(n=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=n):(this._x=0,this._y=-e.z,this._z=e.y,this._w=n)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=n),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(hn(this.dot(e),-1,1)))}rotateTowards(e,t){const n=this.angleTo(e);if(n===0)return this;const i=Math.min(1,t/n);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const n=e._x,i=e._y,r=e._z,a=e._w,s=t._x,l=t._y,c=t._z,h=t._w;return this._x=n*h+a*s+i*c-r*l,this._y=i*h+a*l+r*s-n*c,this._z=r*h+a*c+n*l-i*s,this._w=a*h-n*s-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const n=this._x,i=this._y,r=this._z,a=this._w;let s=a*e._w+n*e._x+i*e._y+r*e._z;if(s<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,s=-s):this.copy(e),s>=1)return this._w=a,this._x=n,this._y=i,this._z=r,this;const l=1-s*s;if(l<=Number.EPSILON){const m=1-t;return this._w=m*a+t*this._w,this._x=m*n+t*this._x,this._y=m*i+t*this._y,this._z=m*r+t*this._z,this.normalize(),this}const c=Math.sqrt(l),h=Math.atan2(c,s),d=Math.sin((1-t)*h)/c,p=Math.sin(t*h)/c;return this._w=a*d+this._w*p,this._x=n*d+this._x*p,this._y=i*d+this._y*p,this._z=r*d+this._z*p,this._onChangeCallback(),this}slerpQuaternions(e,t,n){return this.copy(e).slerp(t,n)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),n=Math.random(),i=Math.sqrt(1-n),r=Math.sqrt(n);return this.set(i*Math.sin(e),i*Math.cos(e),r*Math.sin(t),r*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ee{constructor(e=0,t=0,n=0){ee.prototype.isVector3=!0,this.x=e,this.y=t,this.z=n}set(e,t,n){return n===void 0&&(n=this.z),this.x=e,this.y=t,this.z=n,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(tP.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(tP.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*n+r[6]*i,this.y=r[1]*t+r[4]*n+r[7]*i,this.z=r[2]*t+r[5]*n+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,n=this.y,i=this.z,r=e.elements,a=1/(r[3]*t+r[7]*n+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*n+r[8]*i+r[12])*a,this.y=(r[1]*t+r[5]*n+r[9]*i+r[13])*a,this.z=(r[2]*t+r[6]*n+r[10]*i+r[14])*a,this}applyQuaternion(e){const t=this.x,n=this.y,i=this.z,r=e.x,a=e.y,s=e.z,l=e.w,c=2*(a*i-s*n),h=2*(s*t-r*i),d=2*(r*n-a*t);return this.x=t+l*c+a*d-s*h,this.y=n+l*h+s*c-r*d,this.z=i+l*d+r*h-a*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,n=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*n+r[8]*i,this.y=r[1]*t+r[5]*n+r[9]*i,this.z=r[2]*t+r[6]*n+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const n=this.length();return this.divideScalar(n||1).multiplyScalar(Math.max(e,Math.min(t,n)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,n){return this.x=e.x+(t.x-e.x)*n,this.y=e.y+(t.y-e.y)*n,this.z=e.z+(t.z-e.z)*n,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const n=e.x,i=e.y,r=e.z,a=t.x,s=t.y,l=t.z;return this.x=i*l-r*s,this.y=r*a-n*l,this.z=n*s-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const n=e.dot(this)/t;return this.copy(e).multiplyScalar(n)}projectOnPlane(e){return vS.copy(this).projectOnVector(e),this.sub(vS)}reflect(e){return this.sub(vS.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const n=this.dot(e)/t;return Math.acos(hn(n,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,n=this.y-e.y,i=this.z-e.z;return t*t+n*n+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,n){const i=Math.sin(t)*e;return this.x=i*Math.sin(n),this.y=Math.cos(t)*e,this.z=i*Math.cos(n),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,n){return this.x=e*Math.sin(t),this.y=n,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),n=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=n,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,n=Math.sqrt(1-t*t);return this.x=n*Math.cos(e),this.y=t,this.z=n*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const vS=new ee,tP=new Ns;class pi{constructor(e=new ee(1/0,1/0,1/0),t=new ee(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t+=3)this.expandByPoint(Pa.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,n=e.count;t<n;t++)this.expandByPoint(Pa.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,n=e.length;t<n;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const n=Pa.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(n),this.max.copy(e).add(n),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const n=e.geometry;if(n!==void 0){const r=n.getAttribute("position");if(t===!0&&r!==void 0&&e.isInstancedMesh!==!0)for(let a=0,s=r.count;a<s;a++)e.isMesh===!0?e.getVertexPosition(a,Pa):Pa.fromBufferAttribute(r,a),Pa.applyMatrix4(e.matrixWorld),this.expandByPoint(Pa);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),_y.copy(e.boundingBox)):(n.boundingBox===null&&n.computeBoundingBox(),_y.copy(n.boundingBox)),_y.applyMatrix4(e.matrixWorld),this.union(_y)}const i=e.children;for(let r=0,a=i.length;r<a;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,Pa),Pa.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,n;return e.normal.x>0?(t=e.normal.x*this.min.x,n=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,n=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,n+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,n+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,n+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,n+=e.normal.z*this.min.z),t<=-e.constant&&n>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(mf),Sy.subVectors(this.max,mf),Fu.subVectors(e.a,mf),Bu.subVectors(e.b,mf),Lu.subVectors(e.c,mf),C2.subVectors(Bu,Fu),N2.subVectors(Lu,Bu),Xl.subVectors(Fu,Lu);let t=[0,-C2.z,C2.y,0,-N2.z,N2.y,0,-Xl.z,Xl.y,C2.z,0,-C2.x,N2.z,0,-N2.x,Xl.z,0,-Xl.x,-C2.y,C2.x,0,-N2.y,N2.x,0,-Xl.y,Xl.x,0];return!bS(t,Fu,Bu,Lu,Sy)||(t=[1,0,0,0,1,0,0,0,1],!bS(t,Fu,Bu,Lu,Sy))?!1:(Ty.crossVectors(C2,N2),t=[Ty.x,Ty.y,Ty.z],bS(t,Fu,Bu,Lu,Sy))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Pa).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Pa).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(co[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),co[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),co[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),co[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),co[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),co[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),co[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),co[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(co),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const co=[new ee,new ee,new ee,new ee,new ee,new ee,new ee,new ee],Pa=new ee,_y=new pi,Fu=new ee,Bu=new ee,Lu=new ee,C2=new ee,N2=new ee,Xl=new ee,mf=new ee,Sy=new ee,Ty=new ee,Yl=new ee;function bS(x,e,t,n,i){for(let r=0,a=x.length-3;r<=a;r+=3){Yl.fromArray(x,r);const s=i.x*Math.abs(Yl.x)+i.y*Math.abs(Yl.y)+i.z*Math.abs(Yl.z),l=e.dot(Yl),c=t.dot(Yl),h=n.dot(Yl);if(Math.max(-Math.max(l,c,h),Math.min(l,c,h))>s)return!1}return!0}const Fse=new pi,yf=new ee,_S=new ee;class is{constructor(e=new ee,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const n=this.center;t!==void 0?n.copy(t):Fse.setFromPoints(e).getCenter(n);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,n.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const n=this.center.distanceToSquared(e);return t.copy(e),n>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;yf.subVectors(e,this.center);const t=yf.lengthSq();if(t>this.radius*this.radius){const n=Math.sqrt(t),i=(n-this.radius)*.5;this.center.addScaledVector(yf,i/n),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(_S.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(yf.copy(e.center).add(_S)),this.expandByPoint(yf.copy(e.center).sub(_S))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const uo=new ee,SS=new ee,wy=new ee,I2=new ee,TS=new ee,Ay=new ee,wS=new ee;class vv{constructor(e=new ee,t=new ee(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,uo)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const n=t.dot(this.direction);return n<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,n)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=uo.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(uo.copy(this.origin).addScaledVector(this.direction,t),uo.distanceToSquared(e))}distanceSqToSegment(e,t,n,i){SS.copy(e).add(t).multiplyScalar(.5),wy.copy(t).sub(e).normalize(),I2.copy(this.origin).sub(SS);const r=e.distanceTo(t)*.5,a=-this.direction.dot(wy),s=I2.dot(this.direction),l=-I2.dot(wy),c=I2.lengthSq(),h=Math.abs(1-a*a);let d,p,m,g;if(h>0)if(d=a*l-s,p=a*s-l,g=r*h,d>=0)if(p>=-g)if(p<=g){const _=1/h;d*=_,p*=_,m=d*(d+a*p+2*s)+p*(a*d+p+2*l)+c}else p=r,d=Math.max(0,-(a*p+s)),m=-d*d+p*(p+2*l)+c;else p=-r,d=Math.max(0,-(a*p+s)),m=-d*d+p*(p+2*l)+c;else p<=-g?(d=Math.max(0,-(-a*r+s)),p=d>0?-r:Math.min(Math.max(-r,-l),r),m=-d*d+p*(p+2*l)+c):p<=g?(d=0,p=Math.min(Math.max(-r,-l),r),m=p*(p+2*l)+c):(d=Math.max(0,-(a*r+s)),p=d>0?r:Math.min(Math.max(-r,-l),r),m=-d*d+p*(p+2*l)+c);else p=a>0?-r:r,d=Math.max(0,-(a*p+s)),m=-d*d+p*(p+2*l)+c;return n&&n.copy(this.origin).addScaledVector(this.direction,d),i&&i.copy(SS).addScaledVector(wy,p),m}intersectSphere(e,t){uo.subVectors(e.center,this.origin);const n=uo.dot(this.direction),i=uo.dot(uo)-n*n,r=e.radius*e.radius;if(i>r)return null;const a=Math.sqrt(r-i),s=n-a,l=n+a;return l<0?null:s<0?this.at(l,t):this.at(s,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const n=-(this.origin.dot(e.normal)+e.constant)/t;return n>=0?n:null}intersectPlane(e,t){const n=this.distanceToPlane(e);return n===null?null:this.at(n,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let n,i,r,a,s,l;const c=1/this.direction.x,h=1/this.direction.y,d=1/this.direction.z,p=this.origin;return c>=0?(n=(e.min.x-p.x)*c,i=(e.max.x-p.x)*c):(n=(e.max.x-p.x)*c,i=(e.min.x-p.x)*c),h>=0?(r=(e.min.y-p.y)*h,a=(e.max.y-p.y)*h):(r=(e.max.y-p.y)*h,a=(e.min.y-p.y)*h),n>a||r>i||((r>n||isNaN(n))&&(n=r),(a<i||isNaN(i))&&(i=a),d>=0?(s=(e.min.z-p.z)*d,l=(e.max.z-p.z)*d):(s=(e.max.z-p.z)*d,l=(e.min.z-p.z)*d),n>l||s>i)||((s>n||n!==n)&&(n=s),(l<i||i!==i)&&(i=l),i<0)?null:this.at(n>=0?n:i,t)}intersectsBox(e){return this.intersectBox(e,uo)!==null}intersectTriangle(e,t,n,i,r){TS.subVectors(t,e),Ay.subVectors(n,e),wS.crossVectors(TS,Ay);let a=this.direction.dot(wS),s;if(a>0){if(i)return null;s=1}else if(a<0)s=-1,a=-a;else return null;I2.subVectors(this.origin,e);const l=s*this.direction.dot(Ay.crossVectors(I2,Ay));if(l<0)return null;const c=s*this.direction.dot(TS.cross(I2));if(c<0||l+c>a)return null;const h=-s*I2.dot(wS);return h<0?null:this.at(h/a,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class f0{constructor(e,t,n,i,r,a,s,l,c,h,d,p,m,g,_,v){f0.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,n,i,r,a,s,l,c,h,d,p,m,g,_,v)}set(e,t,n,i,r,a,s,l,c,h,d,p,m,g,_,v){const b=this.elements;return b[0]=e,b[4]=t,b[8]=n,b[12]=i,b[1]=r,b[5]=a,b[9]=s,b[13]=l,b[2]=c,b[6]=h,b[10]=d,b[14]=p,b[3]=m,b[7]=g,b[11]=_,b[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new f0().fromArray(this.elements)}copy(e){const t=this.elements,n=e.elements;return t[0]=n[0],t[1]=n[1],t[2]=n[2],t[3]=n[3],t[4]=n[4],t[5]=n[5],t[6]=n[6],t[7]=n[7],t[8]=n[8],t[9]=n[9],t[10]=n[10],t[11]=n[11],t[12]=n[12],t[13]=n[13],t[14]=n[14],t[15]=n[15],this}copyPosition(e){const t=this.elements,n=e.elements;return t[12]=n[12],t[13]=n[13],t[14]=n[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,n){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),n.setFromMatrixColumn(this,2),this}makeBasis(e,t,n){return this.set(e.x,t.x,n.x,0,e.y,t.y,n.y,0,e.z,t.z,n.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,n=e.elements,i=1/zu.setFromMatrixColumn(e,0).length(),r=1/zu.setFromMatrixColumn(e,1).length(),a=1/zu.setFromMatrixColumn(e,2).length();return t[0]=n[0]*i,t[1]=n[1]*i,t[2]=n[2]*i,t[3]=0,t[4]=n[4]*r,t[5]=n[5]*r,t[6]=n[6]*r,t[7]=0,t[8]=n[8]*a,t[9]=n[9]*a,t[10]=n[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,n=e.x,i=e.y,r=e.z,a=Math.cos(n),s=Math.sin(n),l=Math.cos(i),c=Math.sin(i),h=Math.cos(r),d=Math.sin(r);if(e.order==="XYZ"){const p=a*h,m=a*d,g=s*h,_=s*d;t[0]=l*h,t[4]=-l*d,t[8]=c,t[1]=m+g*c,t[5]=p-_*c,t[9]=-s*l,t[2]=_-p*c,t[6]=g+m*c,t[10]=a*l}else if(e.order==="YXZ"){const p=l*h,m=l*d,g=c*h,_=c*d;t[0]=p+_*s,t[4]=g*s-m,t[8]=a*c,t[1]=a*d,t[5]=a*h,t[9]=-s,t[2]=m*s-g,t[6]=_+p*s,t[10]=a*l}else if(e.order==="ZXY"){const p=l*h,m=l*d,g=c*h,_=c*d;t[0]=p-_*s,t[4]=-a*d,t[8]=g+m*s,t[1]=m+g*s,t[5]=a*h,t[9]=_-p*s,t[2]=-a*c,t[6]=s,t[10]=a*l}else if(e.order==="ZYX"){const p=a*h,m=a*d,g=s*h,_=s*d;t[0]=l*h,t[4]=g*c-m,t[8]=p*c+_,t[1]=l*d,t[5]=_*c+p,t[9]=m*c-g,t[2]=-c,t[6]=s*l,t[10]=a*l}else if(e.order==="YZX"){const p=a*l,m=a*c,g=s*l,_=s*c;t[0]=l*h,t[4]=_-p*d,t[8]=g*d+m,t[1]=d,t[5]=a*h,t[9]=-s*h,t[2]=-c*h,t[6]=m*d+g,t[10]=p-_*d}else if(e.order==="XZY"){const p=a*l,m=a*c,g=s*l,_=s*c;t[0]=l*h,t[4]=-d,t[8]=c*h,t[1]=p*d+_,t[5]=a*h,t[9]=m*d-g,t[2]=g*d-m,t[6]=s*h,t[10]=_*d+p}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Bse,e,Lse)}lookAt(e,t,n){const i=this.elements;return _r.subVectors(e,t),_r.lengthSq()===0&&(_r.z=1),_r.normalize(),O2.crossVectors(n,_r),O2.lengthSq()===0&&(Math.abs(n.z)===1?_r.x+=1e-4:_r.z+=1e-4,_r.normalize(),O2.crossVectors(n,_r)),O2.normalize(),Ey.crossVectors(_r,O2),i[0]=O2.x,i[4]=Ey.x,i[8]=_r.x,i[1]=O2.y,i[5]=Ey.y,i[9]=_r.y,i[2]=O2.z,i[6]=Ey.z,i[10]=_r.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const n=e.elements,i=t.elements,r=this.elements,a=n[0],s=n[4],l=n[8],c=n[12],h=n[1],d=n[5],p=n[9],m=n[13],g=n[2],_=n[6],v=n[10],b=n[14],T=n[3],E=n[7],A=n[11],M=n[15],R=i[0],C=i[4],k=i[8],P=i[12],N=i[1],G=i[5],te=i[9],j=i[13],xe=i[2],ae=i[6],H=i[10],re=i[14],q=i[3],be=i[7],K=i[11],se=i[15];return r[0]=a*R+s*N+l*xe+c*q,r[4]=a*C+s*G+l*ae+c*be,r[8]=a*k+s*te+l*H+c*K,r[12]=a*P+s*j+l*re+c*se,r[1]=h*R+d*N+p*xe+m*q,r[5]=h*C+d*G+p*ae+m*be,r[9]=h*k+d*te+p*H+m*K,r[13]=h*P+d*j+p*re+m*se,r[2]=g*R+_*N+v*xe+b*q,r[6]=g*C+_*G+v*ae+b*be,r[10]=g*k+_*te+v*H+b*K,r[14]=g*P+_*j+v*re+b*se,r[3]=T*R+E*N+A*xe+M*q,r[7]=T*C+E*G+A*ae+M*be,r[11]=T*k+E*te+A*H+M*K,r[15]=T*P+E*j+A*re+M*se,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],n=e[4],i=e[8],r=e[12],a=e[1],s=e[5],l=e[9],c=e[13],h=e[2],d=e[6],p=e[10],m=e[14],g=e[3],_=e[7],v=e[11],b=e[15];return g*(+r*l*d-i*c*d-r*s*p+n*c*p+i*s*m-n*l*m)+_*(+t*l*m-t*c*p+r*a*p-i*a*m+i*c*h-r*l*h)+v*(+t*c*d-t*s*m-r*a*d+n*a*m+r*s*h-n*c*h)+b*(-i*s*h-t*l*d+t*s*p+i*a*d-n*a*p+n*l*h)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,n){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=n),this}invert(){const e=this.elements,t=e[0],n=e[1],i=e[2],r=e[3],a=e[4],s=e[5],l=e[6],c=e[7],h=e[8],d=e[9],p=e[10],m=e[11],g=e[12],_=e[13],v=e[14],b=e[15],T=d*v*c-_*p*c+_*l*m-s*v*m-d*l*b+s*p*b,E=g*p*c-h*v*c-g*l*m+a*v*m+h*l*b-a*p*b,A=h*_*c-g*d*c+g*s*m-a*_*m-h*s*b+a*d*b,M=g*d*l-h*_*l-g*s*p+a*_*p+h*s*v-a*d*v,R=t*T+n*E+i*A+r*M;if(R===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const C=1/R;return e[0]=T*C,e[1]=(_*p*r-d*v*r-_*i*m+n*v*m+d*i*b-n*p*b)*C,e[2]=(s*v*r-_*l*r+_*i*c-n*v*c-s*i*b+n*l*b)*C,e[3]=(d*l*r-s*p*r-d*i*c+n*p*c+s*i*m-n*l*m)*C,e[4]=E*C,e[5]=(h*v*r-g*p*r+g*i*m-t*v*m-h*i*b+t*p*b)*C,e[6]=(g*l*r-a*v*r-g*i*c+t*v*c+a*i*b-t*l*b)*C,e[7]=(a*p*r-h*l*r+h*i*c-t*p*c-a*i*m+t*l*m)*C,e[8]=A*C,e[9]=(g*d*r-h*_*r-g*n*m+t*_*m+h*n*b-t*d*b)*C,e[10]=(a*_*r-g*s*r+g*n*c-t*_*c-a*n*b+t*s*b)*C,e[11]=(h*s*r-a*d*r-h*n*c+t*d*c+a*n*m-t*s*m)*C,e[12]=M*C,e[13]=(h*_*i-g*d*i+g*n*p-t*_*p-h*n*v+t*d*v)*C,e[14]=(g*s*i-a*_*i-g*n*l+t*_*l+a*n*v-t*s*v)*C,e[15]=(a*d*i-h*s*i+h*n*l-t*d*l-a*n*p+t*s*p)*C,this}scale(e){const t=this.elements,n=e.x,i=e.y,r=e.z;return t[0]*=n,t[4]*=i,t[8]*=r,t[1]*=n,t[5]*=i,t[9]*=r,t[2]*=n,t[6]*=i,t[10]*=r,t[3]*=n,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,n,i))}makeTranslation(e,t,n){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,n,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),n=Math.sin(e);return this.set(1,0,0,0,0,t,-n,0,0,n,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,0,n,0,0,1,0,0,-n,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),n=Math.sin(e);return this.set(t,-n,0,0,n,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const n=Math.cos(t),i=Math.sin(t),r=1-n,a=e.x,s=e.y,l=e.z,c=r*a,h=r*s;return this.set(c*a+n,c*s-i*l,c*l+i*s,0,c*s+i*l,h*s+n,h*l-i*a,0,c*l-i*s,h*l+i*a,r*l*l+n,0,0,0,0,1),this}makeScale(e,t,n){return this.set(e,0,0,0,0,t,0,0,0,0,n,0,0,0,0,1),this}makeShear(e,t,n,i,r,a){return this.set(1,n,r,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,n){const i=this.elements,r=t._x,a=t._y,s=t._z,l=t._w,c=r+r,h=a+a,d=s+s,p=r*c,m=r*h,g=r*d,_=a*h,v=a*d,b=s*d,T=l*c,E=l*h,A=l*d,M=n.x,R=n.y,C=n.z;return i[0]=(1-(_+b))*M,i[1]=(m+A)*M,i[2]=(g-E)*M,i[3]=0,i[4]=(m-A)*R,i[5]=(1-(p+b))*R,i[6]=(v+T)*R,i[7]=0,i[8]=(g+E)*C,i[9]=(v-T)*C,i[10]=(1-(p+_))*C,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,n){const i=this.elements;let r=zu.set(i[0],i[1],i[2]).length();const a=zu.set(i[4],i[5],i[6]).length(),s=zu.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],ka.copy(this);const c=1/r,h=1/a,d=1/s;return ka.elements[0]*=c,ka.elements[1]*=c,ka.elements[2]*=c,ka.elements[4]*=h,ka.elements[5]*=h,ka.elements[6]*=h,ka.elements[8]*=d,ka.elements[9]*=d,ka.elements[10]*=d,t.setFromRotationMatrix(ka),n.x=r,n.y=a,n.z=s,this}makePerspective(e,t,n,i,r,a,s=hc){const l=this.elements,c=2*r/(t-e),h=2*r/(n-i),d=(t+e)/(t-e),p=(n+i)/(n-i);let m,g;if(s===hc)m=-(a+r)/(a-r),g=-2*a*r/(a-r);else if(s===Lw)m=-a/(a-r),g=-a*r/(a-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+s);return l[0]=c,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=h,l[9]=p,l[13]=0,l[2]=0,l[6]=0,l[10]=m,l[14]=g,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,n,i,r,a,s=hc){const l=this.elements,c=1/(t-e),h=1/(n-i),d=1/(a-r),p=(t+e)*c,m=(n+i)*h;let g,_;if(s===hc)g=(a+r)*d,_=-2*d;else if(s===Lw)g=r*d,_=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+s);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-p,l[1]=0,l[5]=2*h,l[9]=0,l[13]=-m,l[2]=0,l[6]=0,l[10]=_,l[14]=-g,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,n=e.elements;for(let i=0;i<16;i++)if(t[i]!==n[i])return!1;return!0}fromArray(e,t=0){for(let n=0;n<16;n++)this.elements[n]=e[n+t];return this}toArray(e=[],t=0){const n=this.elements;return e[t]=n[0],e[t+1]=n[1],e[t+2]=n[2],e[t+3]=n[3],e[t+4]=n[4],e[t+5]=n[5],e[t+6]=n[6],e[t+7]=n[7],e[t+8]=n[8],e[t+9]=n[9],e[t+10]=n[10],e[t+11]=n[11],e[t+12]=n[12],e[t+13]=n[13],e[t+14]=n[14],e[t+15]=n[15],e}}const zu=new ee,ka=new f0,Bse=new ee(0,0,0),Lse=new ee(1,1,1),O2=new ee,Ey=new ee,_r=new ee,xP=new f0,nP=new Ns;class pd{constructor(e=0,t=0,n=0,i=pd.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=n,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,n,i=this._order){return this._x=e,this._y=t,this._z=n,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,n=!0){const i=e.elements,r=i[0],a=i[4],s=i[8],l=i[1],c=i[5],h=i[9],d=i[2],p=i[6],m=i[10];switch(t){case"XYZ":this._y=Math.asin(hn(s,-1,1)),Math.abs(s)<.9999999?(this._x=Math.atan2(-h,m),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(p,c),this._z=0);break;case"YXZ":this._x=Math.asin(-hn(h,-1,1)),Math.abs(h)<.9999999?(this._y=Math.atan2(s,m),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-d,r),this._z=0);break;case"ZXY":this._x=Math.asin(hn(p,-1,1)),Math.abs(p)<.9999999?(this._y=Math.atan2(-d,m),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-hn(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(p,m),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(hn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-h,c),this._y=Math.atan2(-d,r)):(this._x=0,this._y=Math.atan2(s,m));break;case"XZY":this._z=Math.asin(-hn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(p,c),this._y=Math.atan2(s,r)):(this._x=Math.atan2(-h,m),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,n===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,n){return xP.makeRotationFromQuaternion(e),this.setFromRotationMatrix(xP,t,n)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return nP.setFromEuler(this),this.setFromQuaternion(nP,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}pd.DEFAULT_ORDER="XYZ";class zse{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let Vse=0;const iP=new ee,Vu=new Ns,ho=new f0,My=new ee,gf=new ee,Hse=new ee,Gse=new Ns,rP=new ee(1,0,0),aP=new ee(0,1,0),sP=new ee(0,0,1),oP={type:"added"},Wse={type:"removed"},Hu={type:"childadded",child:null},AS={type:"childremoved",child:null};class en extends gv{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Vse++}),this.uuid=va(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=en.DEFAULT_UP.clone();const e=new ee,t=new pd,n=new Ns,i=new ee(1,1,1);function r(){n.setFromEuler(t,!1)}function a(){t.setFromQuaternion(n,void 0,!1)}t._onChange(r),n._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:n},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new f0},normalMatrix:{value:new Yo}}),this.matrix=new f0,this.matrixWorld=new f0,this.matrixAutoUpdate=en.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=en.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new zse,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return Vu.setFromAxisAngle(e,t),this.quaternion.multiply(Vu),this}rotateOnWorldAxis(e,t){return Vu.setFromAxisAngle(e,t),this.quaternion.premultiply(Vu),this}rotateX(e){return this.rotateOnAxis(rP,e)}rotateY(e){return this.rotateOnAxis(aP,e)}rotateZ(e){return this.rotateOnAxis(sP,e)}translateOnAxis(e,t){return iP.copy(e).applyQuaternion(this.quaternion),this.position.add(iP.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(rP,e)}translateY(e){return this.translateOnAxis(aP,e)}translateZ(e){return this.translateOnAxis(sP,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(ho.copy(this.matrixWorld).invert())}lookAt(e,t,n){e.isVector3?My.copy(e):My.set(e,t,n);const i=this.parent;this.updateWorldMatrix(!0,!1),gf.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?ho.lookAt(gf,My,this.up):ho.lookAt(My,gf,this.up),this.quaternion.setFromRotationMatrix(ho),i&&(ho.extractRotation(i.matrixWorld),Vu.setFromRotationMatrix(ho),this.quaternion.premultiply(Vu.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(oP),Hu.child=e,this.dispatchEvent(Hu),Hu.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.remove(arguments[n]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Wse),AS.child=e,this.dispatchEvent(AS),AS.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),ho.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),ho.multiply(e.parent.matrixWorld)),e.applyMatrix4(ho),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(oP),Hu.child=e,this.dispatchEvent(Hu),Hu.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let n=0,i=this.children.length;n<i;n++){const a=this.children[n].getObjectByProperty(e,t);if(a!==void 0)return a}}getObjectsByProperty(e,t,n=[]){this[e]===t&&n.push(this);const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].getObjectsByProperty(e,t,n);return n}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(gf,e,Hse),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(gf,Gse,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let n=0,i=t.length;n<i;n++)t[n].updateMatrixWorld(e)}updateWorldMatrix(e,t){const n=this.parent;if(e===!0&&n!==null&&n.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++)i[r].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",n={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},n.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(s=>({boxInitialized:s.boxInitialized,boxMin:s.box.min.toArray(),boxMax:s.box.max.toArray(),sphereInitialized:s.sphereInitialized,sphereRadius:s.sphere.radius,sphereCenter:s.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function r(s,l){return s[l.uuid]===void 0&&(s[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const s=this.geometry.parameters;if(s!==void 0&&s.shapes!==void 0){const l=s.shapes;if(Array.isArray(l))for(let c=0,h=l.length;c<h;c++){const d=l[c];r(e.shapes,d)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const s=[];for(let l=0,c=this.material.length;l<c;l++)s.push(r(e.materials,this.material[l]));i.material=s}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let s=0;s<this.children.length;s++)i.children.push(this.children[s].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let s=0;s<this.animations.length;s++){const l=this.animations[s];i.animations.push(r(e.animations,l))}}if(t){const s=a(e.geometries),l=a(e.materials),c=a(e.textures),h=a(e.images),d=a(e.shapes),p=a(e.skeletons),m=a(e.animations),g=a(e.nodes);s.length>0&&(n.geometries=s),l.length>0&&(n.materials=l),c.length>0&&(n.textures=c),h.length>0&&(n.images=h),d.length>0&&(n.shapes=d),p.length>0&&(n.skeletons=p),m.length>0&&(n.animations=m),g.length>0&&(n.nodes=g)}return n.object=i,n;function a(s){const l=[];for(const c in s){const h=s[c];delete h.metadata,l.push(h)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let n=0;n<e.children.length;n++){const i=e.children[n];this.add(i.clone())}return this}}en.DEFAULT_UP=new ee(0,1,0);en.DEFAULT_MATRIX_AUTO_UPDATE=!0;en.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Ua=new ee,fo=new ee,ES=new ee,po=new ee,Gu=new ee,Wu=new ee,lP=new ee,MS=new ee,RS=new ee,CS=new ee;class Xa{constructor(e=new ee,t=new ee,n=new ee){this.a=e,this.b=t,this.c=n}static getNormal(e,t,n,i){i.subVectors(n,t),Ua.subVectors(e,t),i.cross(Ua);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,n,i,r){Ua.subVectors(i,t),fo.subVectors(n,t),ES.subVectors(e,t);const a=Ua.dot(Ua),s=Ua.dot(fo),l=Ua.dot(ES),c=fo.dot(fo),h=fo.dot(ES),d=a*c-s*s;if(d===0)return r.set(0,0,0),null;const p=1/d,m=(c*l-s*h)*p,g=(a*h-s*l)*p;return r.set(1-m-g,g,m)}static containsPoint(e,t,n,i){return this.getBarycoord(e,t,n,i,po)===null?!1:po.x>=0&&po.y>=0&&po.x+po.y<=1}static getInterpolation(e,t,n,i,r,a,s,l){return this.getBarycoord(e,t,n,i,po)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(r,po.x),l.addScaledVector(a,po.y),l.addScaledVector(s,po.z),l)}static isFrontFacing(e,t,n,i){return Ua.subVectors(n,t),fo.subVectors(e,t),Ua.cross(fo).dot(i)<0}set(e,t,n){return this.a.copy(e),this.b.copy(t),this.c.copy(n),this}setFromPointsAndIndices(e,t,n,i){return this.a.copy(e[t]),this.b.copy(e[n]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,n,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,n),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Ua.subVectors(this.c,this.b),fo.subVectors(this.a,this.b),Ua.cross(fo).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Xa.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Xa.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,n,i,r){return Xa.getInterpolation(e,this.a,this.b,this.c,t,n,i,r)}containsPoint(e){return Xa.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Xa.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const n=this.a,i=this.b,r=this.c;let a,s;Gu.subVectors(i,n),Wu.subVectors(r,n),MS.subVectors(e,n);const l=Gu.dot(MS),c=Wu.dot(MS);if(l<=0&&c<=0)return t.copy(n);RS.subVectors(e,i);const h=Gu.dot(RS),d=Wu.dot(RS);if(h>=0&&d<=h)return t.copy(i);const p=l*d-h*c;if(p<=0&&l>=0&&h<=0)return a=l/(l-h),t.copy(n).addScaledVector(Gu,a);CS.subVectors(e,r);const m=Gu.dot(CS),g=Wu.dot(CS);if(g>=0&&m<=g)return t.copy(r);const _=m*c-l*g;if(_<=0&&c>=0&&g<=0)return s=c/(c-g),t.copy(n).addScaledVector(Wu,s);const v=h*g-m*d;if(v<=0&&d-h>=0&&m-g>=0)return lP.subVectors(r,i),s=(d-h)/(d-h+(m-g)),t.copy(i).addScaledVector(lP,s);const b=1/(v+_+p);return a=_*b,s=p*b,t.copy(n).addScaledVector(Gu,a).addScaledVector(Wu,s)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const VL={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},D2={h:0,s:0,l:0},Ry={h:0,s:0,l:0};function NS(x,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?x+(e-x)*6*t:t<1/2?e:t<2/3?x+(e-x)*6*(2/3-t):x}class yn{constructor(e,t,n){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,n)}set(e,t,n){if(t===void 0&&n===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,n);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Er){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Tr.toWorkingColorSpace(this,t),this}setRGB(e,t,n,i=Tr.workingColorSpace){return this.r=e,this.g=t,this.b=n,Tr.toWorkingColorSpace(this,i),this}setHSL(e,t,n,i=Tr.workingColorSpace){if(e=DM(e,1),t=hn(t,0,1),n=hn(n,0,1),t===0)this.r=this.g=this.b=n;else{const r=n<=.5?n*(1+t):n+t-n*t,a=2*n-r;this.r=NS(a,r,e+1/3),this.g=NS(a,r,e),this.b=NS(a,r,e-1/3)}return Tr.toWorkingColorSpace(this,i),this}setStyle(e,t=Er){function n(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const a=i[1],s=i[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(s))return n(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],a=r.length;if(a===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(a===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=Er){const n=VL[e.toLowerCase()];return n!==void 0?this.setHex(n,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=yh(e.r),this.g=yh(e.g),this.b=yh(e.b),this}copyLinearToSRGB(e){return this.r=yS(e.r),this.g=yS(e.g),this.b=yS(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Er){return Tr.fromWorkingColorSpace(si.copy(this),e),Math.round(hn(si.r*255,0,255))*65536+Math.round(hn(si.g*255,0,255))*256+Math.round(hn(si.b*255,0,255))}getHexString(e=Er){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Tr.workingColorSpace){Tr.fromWorkingColorSpace(si.copy(this),t);const n=si.r,i=si.g,r=si.b,a=Math.max(n,i,r),s=Math.min(n,i,r);let l,c;const h=(s+a)/2;if(s===a)l=0,c=0;else{const d=a-s;switch(c=h<=.5?d/(a+s):d/(2-a-s),a){case n:l=(i-r)/d+(i<r?6:0);break;case i:l=(r-n)/d+2;break;case r:l=(n-i)/d+4;break}l/=6}return e.h=l,e.s=c,e.l=h,e}getRGB(e,t=Tr.workingColorSpace){return Tr.fromWorkingColorSpace(si.copy(this),t),e.r=si.r,e.g=si.g,e.b=si.b,e}getStyle(e=Er){Tr.fromWorkingColorSpace(si.copy(this),e);const t=si.r,n=si.g,i=si.b;return e!==Er?`color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`}offsetHSL(e,t,n){return this.getHSL(D2),this.setHSL(D2.h+e,D2.s+t,D2.l+n)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,n){return this.r=e.r+(t.r-e.r)*n,this.g=e.g+(t.g-e.g)*n,this.b=e.b+(t.b-e.b)*n,this}lerpHSL(e,t){this.getHSL(D2),e.getHSL(Ry);const n=Lf(D2.h,Ry.h,t),i=Lf(D2.s,Ry.s,t),r=Lf(D2.l,Ry.l,t);return this.setHSL(n,i,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,n=this.g,i=this.b,r=e.elements;return this.r=r[0]*t+r[3]*n+r[6]*i,this.g=r[1]*t+r[4]*n+r[7]*i,this.b=r[2]*t+r[5]*n+r[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const si=new yn;yn.NAMES=VL;let Xse=0;class pc extends gv{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Xse++}),this.uuid=va(),this.name="",this.type="Material",this.blending=BD,this.side=ng,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=zD,this.blendDst=VD,this.blendEquation=LD,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new yn(0,0,0),this.blendAlpha=0,this.depthFunc=HD,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=ZD,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=ku,this.stencilZFail=ku,this.stencilZPass=ku,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const n=e[t];if(n===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(n):i&&i.isVector3&&n&&n.isVector3?i.copy(n):this[t]=n}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const n={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};n.uuid=this.uuid,n.type=this.type,this.name!==""&&(n.name=this.name),this.color&&this.color.isColor&&(n.color=this.color.getHex()),this.roughness!==void 0&&(n.roughness=this.roughness),this.metalness!==void 0&&(n.metalness=this.metalness),this.sheen!==void 0&&(n.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(n.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(n.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(n.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(n.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(n.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(n.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(n.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(n.shininess=this.shininess),this.clearcoat!==void 0&&(n.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(n.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(n.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(n.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(n.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,n.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(n.dispersion=this.dispersion),this.iridescence!==void 0&&(n.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(n.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(n.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(n.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(n.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(n.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(n.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(n.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(n.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(n.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(n.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(n.lightMap=this.lightMap.toJSON(e).uuid,n.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(n.aoMap=this.aoMap.toJSON(e).uuid,n.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(n.bumpMap=this.bumpMap.toJSON(e).uuid,n.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(n.normalMap=this.normalMap.toJSON(e).uuid,n.normalMapType=this.normalMapType,n.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(n.displacementMap=this.displacementMap.toJSON(e).uuid,n.displacementScale=this.displacementScale,n.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(n.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(n.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(n.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(n.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(n.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(n.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(n.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(n.combine=this.combine)),this.envMapRotation!==void 0&&(n.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(n.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(n.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(n.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(n.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(n.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(n.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(n.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(n.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(n.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(n.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(n.size=this.size),this.shadowSide!==null&&(n.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(n.sizeAttenuation=this.sizeAttenuation),this.blending!==BD&&(n.blending=this.blending),this.side!==ng&&(n.side=this.side),this.vertexColors===!0&&(n.vertexColors=!0),this.opacity<1&&(n.opacity=this.opacity),this.transparent===!0&&(n.transparent=!0),this.blendSrc!==zD&&(n.blendSrc=this.blendSrc),this.blendDst!==VD&&(n.blendDst=this.blendDst),this.blendEquation!==LD&&(n.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(n.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(n.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(n.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(n.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(n.blendAlpha=this.blendAlpha),this.depthFunc!==HD&&(n.depthFunc=this.depthFunc),this.depthTest===!1&&(n.depthTest=this.depthTest),this.depthWrite===!1&&(n.depthWrite=this.depthWrite),this.colorWrite===!1&&(n.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(n.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==ZD&&(n.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(n.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(n.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==ku&&(n.stencilFail=this.stencilFail),this.stencilZFail!==ku&&(n.stencilZFail=this.stencilZFail),this.stencilZPass!==ku&&(n.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(n.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(n.rotation=this.rotation),this.polygonOffset===!0&&(n.polygonOffset=!0),this.polygonOffsetFactor!==0&&(n.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(n.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(n.linewidth=this.linewidth),this.dashSize!==void 0&&(n.dashSize=this.dashSize),this.gapSize!==void 0&&(n.gapSize=this.gapSize),this.scale!==void 0&&(n.scale=this.scale),this.dithering===!0&&(n.dithering=!0),this.alphaTest>0&&(n.alphaTest=this.alphaTest),this.alphaHash===!0&&(n.alphaHash=!0),this.alphaToCoverage===!0&&(n.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(n.premultipliedAlpha=!0),this.forceSinglePass===!0&&(n.forceSinglePass=!0),this.wireframe===!0&&(n.wireframe=!0),this.wireframeLinewidth>1&&(n.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(n.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(n.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(n.flatShading=!0),this.visible===!1&&(n.visible=!1),this.toneMapped===!1&&(n.toneMapped=!1),this.fog===!1&&(n.fog=!1),Object.keys(this.userData).length>0&&(n.userData=this.userData);function i(r){const a=[];for(const s in r){const l=r[s];delete l.metadata,a.push(l)}return a}if(t){const r=i(e.textures),a=i(e.images);r.length>0&&(n.textures=r),a.length>0&&(n.images=a)}return n}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let n=null;if(t!==null){const i=t.length;n=new Array(i);for(let r=0;r!==i;++r)n[r]=t[r].clone()}return this.clippingPlanes=n,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class nh extends pc{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new yn(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pd,this.combine=xse,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Ro=Yse();function Yse(){const x=new ArrayBuffer(4),e=new Float32Array(x),t=new Uint32Array(x),n=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(n[l]=0,n[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(n[l]=1024>>-c-14,n[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(n[l]=c+15<<10,n[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(n[l]=31744,n[l|256]=64512,i[l]=24,i[l|256]=24):(n[l]=31744,n[l|256]=64512,i[l]=13,i[l|256]=13)}const r=new Uint32Array(2048),a=new Uint32Array(64),s=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,h=0;for(;(c&8388608)===0;)c<<=1,h-=8388608;c&=-8388609,h+=947912704,r[l]=c|h}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)a[l]=l<<23;a[31]=1199570944,a[32]=2147483648;for(let l=33;l<63;++l)a[l]=2147483648+(l-32<<23);a[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(s[l]=1024);return{floatView:e,uint32View:t,baseTable:n,shiftTable:i,mantissaTable:r,exponentTable:a,offsetTable:s}}function Kse(x){Math.abs(x)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),x=hn(x,-65504,65504),Ro.floatView[0]=x;const e=Ro.uint32View[0],t=e>>23&511;return Ro.baseTable[t]+((e&8388607)>>Ro.shiftTable[t])}function $se(x){const e=x>>10;return Ro.uint32View[0]=Ro.mantissaTable[Ro.offsetTable[e]+(x&1023)]+Ro.exponentTable[e],Ro.floatView[0]}const Cy={toHalfFloat:Kse,fromHalfFloat:$se},un=new ee,Ny=new Pt;class Za{constructor(e,t,n=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=n,this.usage=Bw,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=mh,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return zL("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,n){e*=this.itemSize,n*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[n+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,n=this.count;t<n;t++)Ny.fromBufferAttribute(this,t),Ny.applyMatrix3(e),this.setXY(t,Ny.x,Ny.y);else if(this.itemSize===3)for(let t=0,n=this.count;t<n;t++)un.fromBufferAttribute(this,t),un.applyMatrix3(e),this.setXYZ(t,un.x,un.y,un.z);return this}applyMatrix4(e){for(let t=0,n=this.count;t<n;t++)un.fromBufferAttribute(this,t),un.applyMatrix4(e),this.setXYZ(t,un.x,un.y,un.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)un.fromBufferAttribute(this,t),un.applyNormalMatrix(e),this.setXYZ(t,un.x,un.y,un.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)un.fromBufferAttribute(this,t),un.transformDirection(e),this.setXYZ(t,un.x,un.y,un.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let n=this.array[e*this.itemSize+t];return this.normalized&&(n=Wa(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=nx(n,this.array)),this.array[e*this.itemSize+t]=n,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Wa(t,this.array)),t}setX(e,t){return this.normalized&&(t=nx(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Wa(t,this.array)),t}setY(e,t){return this.normalized&&(t=nx(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Wa(t,this.array)),t}setZ(e,t){return this.normalized&&(t=nx(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Wa(t,this.array)),t}setW(e,t){return this.normalized&&(t=nx(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,n){return e*=this.itemSize,this.normalized&&(t=nx(t,this.array),n=nx(n,this.array)),this.array[e+0]=t,this.array[e+1]=n,this}setXYZ(e,t,n,i){return e*=this.itemSize,this.normalized&&(t=nx(t,this.array),n=nx(n,this.array),i=nx(i,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e*=this.itemSize,this.normalized&&(t=nx(t,this.array),n=nx(n,this.array),i=nx(i,this.array),r=nx(r,this.array)),this.array[e+0]=t,this.array[e+1]=n,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Bw&&(e.usage=this.usage),e}}class Qse extends Za{constructor(e,t,n){super(new Uint16Array(e),t,n)}}class Zse extends Za{constructor(e,t,n){super(new Uint32Array(e),t,n)}}class rp extends Za{constructor(e,t,n){super(new Float32Array(e),t,n)}}let Jse=0;const sa=new f0,IS=new en,Xu=new ee,Sr=new pi,vf=new pi,Fn=new ee;class Lc extends gv{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:Jse++}),this.uuid=va(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(Ise(e)?Zse:Qse)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,n=0){this.groups.push({start:e,count:t,materialIndex:n})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const n=this.attributes.normal;if(n!==void 0){const r=new Yo().getNormalMatrix(e);n.applyNormalMatrix(r),n.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return sa.makeRotationFromQuaternion(e),this.applyMatrix4(sa),this}rotateX(e){return sa.makeRotationX(e),this.applyMatrix4(sa),this}rotateY(e){return sa.makeRotationY(e),this.applyMatrix4(sa),this}rotateZ(e){return sa.makeRotationZ(e),this.applyMatrix4(sa),this}translate(e,t,n){return sa.makeTranslation(e,t,n),this.applyMatrix4(sa),this}scale(e,t,n){return sa.makeScale(e,t,n),this.applyMatrix4(sa),this}lookAt(e){return IS.lookAt(e),IS.updateMatrix(),this.applyMatrix4(IS.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(Xu).negate(),this.translate(Xu.x,Xu.y,Xu.z),this}setFromPoints(e){const t=[];for(let n=0,i=e.length;n<i;n++){const r=e[n];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new rp(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new pi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new ee(-1/0,-1/0,-1/0),new ee(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let n=0,i=t.length;n<i;n++){const r=t[n];Sr.setFromBufferAttribute(r),this.morphTargetsRelative?(Fn.addVectors(this.boundingBox.min,Sr.min),this.boundingBox.expandByPoint(Fn),Fn.addVectors(this.boundingBox.max,Sr.max),this.boundingBox.expandByPoint(Fn)):(this.boundingBox.expandByPoint(Sr.min),this.boundingBox.expandByPoint(Sr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new is);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new ee,1/0);return}if(e){const n=this.boundingSphere.center;if(Sr.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){const s=t[r];vf.setFromBufferAttribute(s),this.morphTargetsRelative?(Fn.addVectors(Sr.min,vf.min),Sr.expandByPoint(Fn),Fn.addVectors(Sr.max,vf.max),Sr.expandByPoint(Fn)):(Sr.expandByPoint(vf.min),Sr.expandByPoint(vf.max))}Sr.getCenter(n);let i=0;for(let r=0,a=e.count;r<a;r++)Fn.fromBufferAttribute(e,r),i=Math.max(i,n.distanceToSquared(Fn));if(t)for(let r=0,a=t.length;r<a;r++){const s=t[r],l=this.morphTargetsRelative;for(let c=0,h=s.count;c<h;c++)Fn.fromBufferAttribute(s,c),l&&(Xu.fromBufferAttribute(e,c),Fn.add(Xu)),i=Math.max(i,n.distanceToSquared(Fn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const n=t.position,i=t.normal,r=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Za(new Float32Array(4*n.count),4));const a=this.getAttribute("tangent"),s=[],l=[];for(let k=0;k<n.count;k++)s[k]=new ee,l[k]=new ee;const c=new ee,h=new ee,d=new ee,p=new Pt,m=new Pt,g=new Pt,_=new ee,v=new ee;function b(k,P,N){c.fromBufferAttribute(n,k),h.fromBufferAttribute(n,P),d.fromBufferAttribute(n,N),p.fromBufferAttribute(r,k),m.fromBufferAttribute(r,P),g.fromBufferAttribute(r,N),h.sub(c),d.sub(c),m.sub(p),g.sub(p);const G=1/(m.x*g.y-g.x*m.y);isFinite(G)&&(_.copy(h).multiplyScalar(g.y).addScaledVector(d,-m.y).multiplyScalar(G),v.copy(d).multiplyScalar(m.x).addScaledVector(h,-g.x).multiplyScalar(G),s[k].add(_),s[P].add(_),s[N].add(_),l[k].add(v),l[P].add(v),l[N].add(v))}let T=this.groups;T.length===0&&(T=[{start:0,count:e.count}]);for(let k=0,P=T.length;k<P;++k){const N=T[k],G=N.start,te=N.count;for(let j=G,xe=G+te;j<xe;j+=3)b(e.getX(j+0),e.getX(j+1),e.getX(j+2))}const E=new ee,A=new ee,M=new ee,R=new ee;function C(k){M.fromBufferAttribute(i,k),R.copy(M);const P=s[k];E.copy(P),E.sub(M.multiplyScalar(M.dot(P))).normalize(),A.crossVectors(R,P);const G=A.dot(l[k])<0?-1:1;a.setXYZW(k,E.x,E.y,E.z,G)}for(let k=0,P=T.length;k<P;++k){const N=T[k],G=N.start,te=N.count;for(let j=G,xe=G+te;j<xe;j+=3)C(e.getX(j+0)),C(e.getX(j+1)),C(e.getX(j+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let n=this.getAttribute("normal");if(n===void 0)n=new Za(new Float32Array(t.count*3),3),this.setAttribute("normal",n);else for(let p=0,m=n.count;p<m;p++)n.setXYZ(p,0,0,0);const i=new ee,r=new ee,a=new ee,s=new ee,l=new ee,c=new ee,h=new ee,d=new ee;if(e)for(let p=0,m=e.count;p<m;p+=3){const g=e.getX(p+0),_=e.getX(p+1),v=e.getX(p+2);i.fromBufferAttribute(t,g),r.fromBufferAttribute(t,_),a.fromBufferAttribute(t,v),h.subVectors(a,r),d.subVectors(i,r),h.cross(d),s.fromBufferAttribute(n,g),l.fromBufferAttribute(n,_),c.fromBufferAttribute(n,v),s.add(h),l.add(h),c.add(h),n.setXYZ(g,s.x,s.y,s.z),n.setXYZ(_,l.x,l.y,l.z),n.setXYZ(v,c.x,c.y,c.z)}else for(let p=0,m=t.count;p<m;p+=3)i.fromBufferAttribute(t,p+0),r.fromBufferAttribute(t,p+1),a.fromBufferAttribute(t,p+2),h.subVectors(a,r),d.subVectors(i,r),h.cross(d),n.setXYZ(p+0,h.x,h.y,h.z),n.setXYZ(p+1,h.x,h.y,h.z),n.setXYZ(p+2,h.x,h.y,h.z);this.normalizeNormals(),n.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,n=e.count;t<n;t++)Fn.fromBufferAttribute(e,t),Fn.normalize(),e.setXYZ(t,Fn.x,Fn.y,Fn.z)}toNonIndexed(){function e(s,l){const c=s.array,h=s.itemSize,d=s.normalized,p=new c.constructor(l.length*h);let m=0,g=0;for(let _=0,v=l.length;_<v;_++){s.isInterleavedBufferAttribute?m=l[_]*s.data.stride+s.offset:m=l[_]*h;for(let b=0;b<h;b++)p[g++]=c[m++]}return new Za(p,h,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Lc,n=this.index.array,i=this.attributes;for(const s in i){const l=i[s],c=e(l,n);t.setAttribute(s,c)}const r=this.morphAttributes;for(const s in r){const l=[],c=r[s];for(let h=0,d=c.length;h<d;h++){const p=c[h],m=e(p,n);l.push(m)}t.morphAttributes[s]=l}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let s=0,l=a.length;s<l;s++){const c=a[s];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const n=this.attributes;for(const l in n){const c=n[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],h=[];for(let d=0,p=c.length;d<p;d++){const m=c[d];h.push(m.toJSON(e.data))}h.length>0&&(i[l]=h,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const s=this.boundingSphere;return s!==null&&(e.data.boundingSphere={center:s.center.toArray(),radius:s.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const n=e.index;n!==null&&this.setIndex(n.clone(t));const i=e.attributes;for(const c in i){const h=i[c];this.setAttribute(c,h.clone(t))}const r=e.morphAttributes;for(const c in r){const h=[],d=r[c];for(let p=0,m=d.length;p<m;p++)h.push(d[p].clone(t));this.morphAttributes[c]=h}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let c=0,h=a.length;c<h;c++){const d=a[c];this.addGroup(d.start,d.count,d.materialIndex)}const s=e.boundingBox;s!==null&&(this.boundingBox=s.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const cP=new f0,Kl=new vv,Iy=new is,uP=new ee,Yu=new ee,Ku=new ee,$u=new ee,OS=new ee,Oy=new ee,Dy=new Pt,Py=new Pt,ky=new Pt,hP=new ee,dP=new ee,fP=new ee,Uy=new ee,Fy=new ee;class md extends en{constructor(e=new Lc,t=new nh){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const s=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=r}}}}getVertexPosition(e,t){const n=this.geometry,i=n.attributes.position,r=n.morphAttributes.position,a=n.morphTargetsRelative;t.fromBufferAttribute(i,e);const s=this.morphTargetInfluences;if(r&&s){Oy.set(0,0,0);for(let l=0,c=r.length;l<c;l++){const h=s[l],d=r[l];h!==0&&(OS.fromBufferAttribute(d,e),a?Oy.addScaledVector(OS,h):Oy.addScaledVector(OS.sub(t),h))}t.add(Oy)}return t}raycast(e,t){const n=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(n.boundingSphere===null&&n.computeBoundingSphere(),Iy.copy(n.boundingSphere),Iy.applyMatrix4(r),Kl.copy(e.ray).recast(e.near),!(Iy.containsPoint(Kl.origin)===!1&&(Kl.intersectSphere(Iy,uP)===null||Kl.origin.distanceToSquared(uP)>(e.far-e.near)**2))&&(cP.copy(r).invert(),Kl.copy(e.ray).applyMatrix4(cP),!(n.boundingBox!==null&&Kl.intersectsBox(n.boundingBox)===!1)&&this._computeIntersections(e,t,Kl)))}_computeIntersections(e,t,n){let i;const r=this.geometry,a=this.material,s=r.index,l=r.attributes.position,c=r.attributes.uv,h=r.attributes.uv1,d=r.attributes.normal,p=r.groups,m=r.drawRange;if(s!==null)if(Array.isArray(a))for(let g=0,_=p.length;g<_;g++){const v=p[g],b=a[v.materialIndex],T=Math.max(v.start,m.start),E=Math.min(s.count,Math.min(v.start+v.count,m.start+m.count));for(let A=T,M=E;A<M;A+=3){const R=s.getX(A),C=s.getX(A+1),k=s.getX(A+2);i=By(this,b,e,n,c,h,d,R,C,k),i&&(i.faceIndex=Math.floor(A/3),i.face.materialIndex=v.materialIndex,t.push(i))}}else{const g=Math.max(0,m.start),_=Math.min(s.count,m.start+m.count);for(let v=g,b=_;v<b;v+=3){const T=s.getX(v),E=s.getX(v+1),A=s.getX(v+2);i=By(this,a,e,n,c,h,d,T,E,A),i&&(i.faceIndex=Math.floor(v/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(a))for(let g=0,_=p.length;g<_;g++){const v=p[g],b=a[v.materialIndex],T=Math.max(v.start,m.start),E=Math.min(l.count,Math.min(v.start+v.count,m.start+m.count));for(let A=T,M=E;A<M;A+=3){const R=A,C=A+1,k=A+2;i=By(this,b,e,n,c,h,d,R,C,k),i&&(i.faceIndex=Math.floor(A/3),i.face.materialIndex=v.materialIndex,t.push(i))}}else{const g=Math.max(0,m.start),_=Math.min(l.count,m.start+m.count);for(let v=g,b=_;v<b;v+=3){const T=v,E=v+1,A=v+2;i=By(this,a,e,n,c,h,d,T,E,A),i&&(i.faceIndex=Math.floor(v/3),t.push(i))}}}}function jse(x,e,t,n,i,r,a,s){let l;if(e.side===ese?l=n.intersectTriangle(a,r,i,!0,s):l=n.intersectTriangle(i,r,a,e.side===ng,s),l===null)return null;Fy.copy(s),Fy.applyMatrix4(x.matrixWorld);const c=t.ray.origin.distanceTo(Fy);return c<t.near||c>t.far?null:{distance:c,point:Fy.clone(),object:x}}function By(x,e,t,n,i,r,a,s,l,c){x.getVertexPosition(s,Yu),x.getVertexPosition(l,Ku),x.getVertexPosition(c,$u);const h=jse(x,e,t,n,Yu,Ku,$u,Uy);if(h){i&&(Dy.fromBufferAttribute(i,s),Py.fromBufferAttribute(i,l),ky.fromBufferAttribute(i,c),h.uv=Xa.getInterpolation(Uy,Yu,Ku,$u,Dy,Py,ky,new Pt)),r&&(Dy.fromBufferAttribute(r,s),Py.fromBufferAttribute(r,l),ky.fromBufferAttribute(r,c),h.uv1=Xa.getInterpolation(Uy,Yu,Ku,$u,Dy,Py,ky,new Pt)),a&&(hP.fromBufferAttribute(a,s),dP.fromBufferAttribute(a,l),fP.fromBufferAttribute(a,c),h.normal=Xa.getInterpolation(Uy,Yu,Ku,$u,hP,dP,fP,new ee),h.normal.dot(n.direction)>0&&h.normal.multiplyScalar(-1));const d={a:s,b:l,c,normal:new ee,materialIndex:0};Xa.getNormal(Yu,Ku,$u,d.normal),h.face=d}return h}class HL extends en{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new f0,this.projectionMatrix=new f0,this.projectionMatrixInverse=new f0,this.coordinateSystem=hc}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const P2=new ee,pP=new Pt,mP=new Pt;class PM extends HL{constructor(e=50,t=1,n=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=n,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=ip*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Bf*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return ip*2*Math.atan(Math.tan(Bf*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,n){P2.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(P2.x,P2.y).multiplyScalar(-e/P2.z),P2.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(P2.x,P2.y).multiplyScalar(-e/P2.z)}getViewSize(e,t){return this.getViewBounds(e,pP,mP),t.subVectors(mP,pP)}setViewOffset(e,t,n,i,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(Bf*.5*this.fov)/this.zoom,n=2*t,i=this.aspect*n,r=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,c=a.fullHeight;r+=a.offsetX*i/l,t-=a.offsetY*n/c,i*=a.width/l,n*=a.height/c}const s=this.filmOffset;s!==0&&(r+=e*s/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-n,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const DS=new ee,qse=new ee,eoe=new Yo;class F2{constructor(e=new ee(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,n,i){return this.normal.set(e,t,n),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,n){const i=DS.subVectors(n,t).cross(qse.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const n=e.delta(DS),i=this.normal.dot(n);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(e.start).addScaledVector(n,r)}intersectsLine(e){const t=this.distanceToPoint(e.start),n=this.distanceToPoint(e.end);return t<0&&n>0||n<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const n=t||eoe.getNormalMatrix(e),i=this.coplanarPoint(DS).applyMatrix4(e),r=this.normal.applyMatrix3(n).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const $l=new is,Ly=new ee;class toe{constructor(e=new F2,t=new F2,n=new F2,i=new F2,r=new F2,a=new F2){this.planes=[e,t,n,i,r,a]}set(e,t,n,i,r,a){const s=this.planes;return s[0].copy(e),s[1].copy(t),s[2].copy(n),s[3].copy(i),s[4].copy(r),s[5].copy(a),this}copy(e){const t=this.planes;for(let n=0;n<6;n++)t[n].copy(e.planes[n]);return this}setFromProjectionMatrix(e,t=hc){const n=this.planes,i=e.elements,r=i[0],a=i[1],s=i[2],l=i[3],c=i[4],h=i[5],d=i[6],p=i[7],m=i[8],g=i[9],_=i[10],v=i[11],b=i[12],T=i[13],E=i[14],A=i[15];if(n[0].setComponents(l-r,p-c,v-m,A-b).normalize(),n[1].setComponents(l+r,p+c,v+m,A+b).normalize(),n[2].setComponents(l+a,p+h,v+g,A+T).normalize(),n[3].setComponents(l-a,p-h,v-g,A-T).normalize(),n[4].setComponents(l-s,p-d,v-_,A-E).normalize(),t===hc)n[5].setComponents(l+s,p+d,v+_,A+E).normalize();else if(t===Lw)n[5].setComponents(s,d,_,E).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),$l.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),$l.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere($l)}intersectsSprite(e){return $l.center.set(0,0,0),$l.radius=.7071067811865476,$l.applyMatrix4(e.matrixWorld),this.intersectsSphere($l)}intersectsSphere(e){const t=this.planes,n=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(n)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let n=0;n<6;n++){const i=t[n];if(Ly.x=i.normal.x>0?e.max.x:e.min.x,Ly.y=i.normal.y>0?e.max.y:e.min.y,Ly.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Ly)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let n=0;n<6;n++)if(t[n].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}class GL extends HL{constructor(e=-1,t=1,n=1,i=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=n,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,n,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=n,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),n=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=n-e,a=n+e,s=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,h=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,a=r+c*this.view.width,s-=h*this.view.offsetY,l=s-h*this.view.height}this.projectionMatrix.makeOrthographic(r,a,s,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}class y1 extends en{constructor(){super(),this.isGroup=!0,this.type="Group"}}class xoe{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Bw,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=va()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return zL("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,n){e*=this.stride,n*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[n+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=va()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),n=new this.constructor(t,this.stride);return n.setUsage(this.usage),n}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=va()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const wi=new ee;class kM{constructor(e,t,n,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=n,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,n=this.data.count;t<n;t++)wi.fromBufferAttribute(this,t),wi.applyMatrix4(e),this.setXYZ(t,wi.x,wi.y,wi.z);return this}applyNormalMatrix(e){for(let t=0,n=this.count;t<n;t++)wi.fromBufferAttribute(this,t),wi.applyNormalMatrix(e),this.setXYZ(t,wi.x,wi.y,wi.z);return this}transformDirection(e){for(let t=0,n=this.count;t<n;t++)wi.fromBufferAttribute(this,t),wi.transformDirection(e),this.setXYZ(t,wi.x,wi.y,wi.z);return this}getComponent(e,t){let n=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(n=Wa(n,this.array)),n}setComponent(e,t,n){return this.normalized&&(n=nx(n,this.array)),this.data.array[e*this.data.stride+this.offset+t]=n,this}setX(e,t){return this.normalized&&(t=nx(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=nx(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=nx(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=nx(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Wa(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Wa(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Wa(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Wa(t,this.array)),t}setXY(e,t,n){return e=e*this.data.stride+this.offset,this.normalized&&(t=nx(t,this.array),n=nx(n,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this}setXYZ(e,t,n,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=nx(t,this.array),n=nx(n,this.array),i=nx(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this}setXYZW(e,t,n,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=nx(t,this.array),n=nx(n,this.array),i=nx(i,this.array),r=nx(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=n,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Za(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new kM(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let n=0;n<this.count;n++){const i=n*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const yP=new ee,gP=new fa,vP=new fa,noe=new ee,bP=new f0,zy=new ee,PS=new is,_P=new f0,kS=new vv;class WL extends md{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=GD,this.bindMatrix=new f0,this.bindMatrixInverse=new f0,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new pi),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,zy),this.boundingBox.expandByPoint(zy)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new is),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let n=0;n<t.count;n++)this.getVertexPosition(n,zy),this.boundingSphere.expandByPoint(zy)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const n=this.material,i=this.matrixWorld;n!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),PS.copy(this.boundingSphere),PS.applyMatrix4(i),e.ray.intersectsSphere(PS)!==!1&&(_P.copy(i).invert(),kS.copy(e.ray).applyMatrix4(_P),!(this.boundingBox!==null&&kS.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,kS)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new fa,t=this.geometry.attributes.skinWeight;for(let n=0,i=t.count;n<i;n++){e.fromBufferAttribute(t,n);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(n,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===GD?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===nse?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const n=this.skeleton,i=this.geometry;gP.fromBufferAttribute(i.attributes.skinIndex,e),vP.fromBufferAttribute(i.attributes.skinWeight,e),yP.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const a=vP.getComponent(r);if(a!==0){const s=gP.getComponent(r);bP.multiplyMatrices(n.bones[s].matrixWorld,n.boneInverses[s]),t.addScaledVector(noe.copy(yP).applyMatrix4(bP),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}class UM extends en{constructor(){super(),this.isBone=!0,this.type="Bone"}}class FM extends Qa{constructor(e=null,t=1,n=1,i,r,a,s,l,c=kw,h=kw,d,p){super(null,a,s,l,c,h,i,r,d,p),this.isDataTexture=!0,this.image={data:e,width:t,height:n},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const SP=new f0,ioe=new f0;class BM{constructor(e=[],t=[]){this.uuid=va(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let n=0,i=this.bones.length;n<i;n++)this.boneInverses.push(new f0)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const n=new f0;this.bones[e]&&n.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(n)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&n.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const n=this.bones[e];n&&(n.parent&&n.parent.isBone?(n.matrix.copy(n.parent.matrixWorld).invert(),n.matrix.multiply(n.matrixWorld)):n.matrix.copy(n.matrixWorld),n.matrix.decompose(n.position,n.quaternion,n.scale))}}update(){const e=this.bones,t=this.boneInverses,n=this.boneMatrices,i=this.boneTexture;for(let r=0,a=e.length;r<a;r++){const s=e[r]?e[r].matrixWorld:ioe;SP.multiplyMatrices(s,t[r]),SP.toArray(n,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new BM(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const n=new FM(t,e,e,UL,mh);return n.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=n,this}getBoneByName(e){for(let t=0,n=this.bones.length;t<n;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let n=0,i=e.bones.length;n<i;n++){const r=e.bones[n];let a=t[r];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new UM),this.bones.push(a),this.boneInverses.push(new f0().fromArray(e.boneInverses[n]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,n=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const a=t[i];e.bones.push(a.uuid);const s=n[i];e.boneInverses.push(s.toArray())}return e}}class Vw extends Za{constructor(e,t,n,i=1){super(e,t,n),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Qu=new f0,TP=new f0,Vy=[],wP=new pi,roe=new f0,bf=new md,_f=new is;class aoe extends md{constructor(e,t,n){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Vw(new Float32Array(n*16),16),this.instanceColor=null,this.morphTexture=null,this.count=n,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<n;i++)this.setMatrixAt(i,roe)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new pi),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,Qu),wP.copy(e.boundingBox).applyMatrix4(Qu),this.boundingBox.union(wP)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new is),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let n=0;n<t;n++)this.getMatrixAt(n,Qu),_f.copy(e.boundingSphere).applyMatrix4(Qu),this.boundingSphere.union(_f)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const n=t.morphTargetInfluences,i=this.morphTexture.source.data.data,r=n.length+1,a=e*r+1;for(let s=0;s<n.length;s++)n[s]=i[a+s]}raycast(e,t){const n=this.matrixWorld,i=this.count;if(bf.geometry=this.geometry,bf.material=this.material,bf.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),_f.copy(this.boundingSphere),_f.applyMatrix4(n),e.ray.intersectsSphere(_f)!==!1))for(let r=0;r<i;r++){this.getMatrixAt(r,Qu),TP.multiplyMatrices(n,Qu),bf.matrixWorld=TP,bf.raycast(e,Vy);for(let a=0,s=Vy.length;a<s;a++){const l=Vy[a];l.instanceId=r,l.object=this,t.push(l)}Vy.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Vw(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const n=t.morphTargetInfluences,i=n.length+1;this.morphTexture===null&&(this.morphTexture=new FM(new Float32Array(i*this.count),i,this.count,lse,mh));const r=this.morphTexture.source.data.data;let a=0;for(let c=0;c<n.length;c++)a+=n[c];const s=this.geometry.morphTargetsRelative?1:1-a,l=i*e;r[l]=s,r.set(n,l+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}class XL extends pc{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new yn(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const ig=new ee,rg=new ee,AP=new f0,Sf=new vv,Hy=new is,US=new ee,EP=new ee;class LM extends en{constructor(e=new Lc,t=new XL){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[0];for(let i=1,r=t.count;i<r;i++)ig.fromBufferAttribute(t,i-1),rg.fromBufferAttribute(t,i),n[i]=n[i-1],n[i]+=ig.distanceTo(rg);e.setAttribute("lineDistance",new rp(n,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Hy.copy(n.boundingSphere),Hy.applyMatrix4(i),Hy.radius+=r,e.ray.intersectsSphere(Hy)===!1)return;AP.copy(i).invert(),Sf.copy(e.ray).applyMatrix4(AP);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=s*s,c=this.isLineSegments?2:1,h=n.index,p=n.attributes.position;if(h!==null){const m=Math.max(0,a.start),g=Math.min(h.count,a.start+a.count);for(let _=m,v=g-1;_<v;_+=c){const b=h.getX(_),T=h.getX(_+1),E=Gy(this,e,Sf,l,b,T);E&&t.push(E)}if(this.isLineLoop){const _=h.getX(g-1),v=h.getX(m),b=Gy(this,e,Sf,l,_,v);b&&t.push(b)}}else{const m=Math.max(0,a.start),g=Math.min(p.count,a.start+a.count);for(let _=m,v=g-1;_<v;_+=c){const b=Gy(this,e,Sf,l,_,_+1);b&&t.push(b)}if(this.isLineLoop){const _=Gy(this,e,Sf,l,g-1,m);_&&t.push(_)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const s=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=r}}}}}function Gy(x,e,t,n,i,r){const a=x.geometry.attributes.position;if(ig.fromBufferAttribute(a,i),rg.fromBufferAttribute(a,r),t.distanceSqToSegment(ig,rg,US,EP)>n)return;US.applyMatrix4(x.matrixWorld);const l=e.ray.origin.distanceTo(US);if(!(l<e.near||l>e.far))return{distance:l,point:EP.clone().applyMatrix4(x.matrixWorld),index:i,face:null,faceIndex:null,object:x}}const MP=new ee,RP=new ee;class soe extends LM{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,n=[];for(let i=0,r=t.count;i<r;i+=2)MP.fromBufferAttribute(t,i),RP.fromBufferAttribute(t,i+1),n[i]=i===0?0:n[i-1],n[i+1]=n[i]+MP.distanceTo(RP);e.setAttribute("lineDistance",new rp(n,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class ooe extends LM{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class YL extends pc{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new yn(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const CP=new f0,Hw=new vv,Wy=new is,Xy=new ee;class loe extends en{constructor(e=new Lc,t=new YL){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const n=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,a=n.drawRange;if(n.boundingSphere===null&&n.computeBoundingSphere(),Wy.copy(n.boundingSphere),Wy.applyMatrix4(i),Wy.radius+=r,e.ray.intersectsSphere(Wy)===!1)return;CP.copy(i).invert(),Hw.copy(e.ray).applyMatrix4(CP);const s=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=s*s,c=n.index,d=n.attributes.position;if(c!==null){const p=Math.max(0,a.start),m=Math.min(c.count,a.start+a.count);for(let g=p,_=m;g<_;g++){const v=c.getX(g);Xy.fromBufferAttribute(d,v),NP(Xy,v,l,i,e,t,this)}}else{const p=Math.max(0,a.start),m=Math.min(d.count,a.start+a.count);for(let g=p,_=m;g<_;g++)Xy.fromBufferAttribute(d,g),NP(Xy,g,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,n=Object.keys(t);if(n.length>0){const i=t[n[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const s=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[s]=r}}}}}function NP(x,e,t,n,i,r,a){const s=Hw.distanceSqToPoint(x);if(s<t){const l=new ee;Hw.closestPointToPoint(x,l),l.applyMatrix4(n);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(s),point:l,index:e,face:null,object:a})}}class Ps{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const n=this.getUtoTmapping(e);return this.getPoint(n,t)}getPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return t}getSpacedPoints(e=5){const t=[];for(let n=0;n<=e;n++)t.push(this.getPointAt(n/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let n,i=this.getPoint(0),r=0;t.push(0);for(let a=1;a<=e;a++)n=this.getPoint(a/e),r+=n.distanceTo(i),t.push(r),i=n;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const n=this.getLengths();let i=0;const r=n.length;let a;t?a=t:a=e*n[r-1];let s=0,l=r-1,c;for(;s<=l;)if(i=Math.floor(s+(l-s)/2),c=n[i]-a,c<0)s=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,n[i]===a)return i/(r-1);const h=n[i],p=n[i+1]-h,m=(a-h)/p;return(i+m)/(r-1)}getTangent(e,t){let i=e-1e-4,r=e+1e-4;i<0&&(i=0),r>1&&(r=1);const a=this.getPoint(i),s=this.getPoint(r),l=t||(a.isVector2?new Pt:new ee);return l.copy(s).sub(a).normalize(),l}getTangentAt(e,t){const n=this.getUtoTmapping(e);return this.getTangent(n,t)}computeFrenetFrames(e,t){const n=new ee,i=[],r=[],a=[],s=new ee,l=new f0;for(let m=0;m<=e;m++){const g=m/e;i[m]=this.getTangentAt(g,new ee)}r[0]=new ee,a[0]=new ee;let c=Number.MAX_VALUE;const h=Math.abs(i[0].x),d=Math.abs(i[0].y),p=Math.abs(i[0].z);h<=c&&(c=h,n.set(1,0,0)),d<=c&&(c=d,n.set(0,1,0)),p<=c&&n.set(0,0,1),s.crossVectors(i[0],n).normalize(),r[0].crossVectors(i[0],s),a[0].crossVectors(i[0],r[0]);for(let m=1;m<=e;m++){if(r[m]=r[m-1].clone(),a[m]=a[m-1].clone(),s.crossVectors(i[m-1],i[m]),s.length()>Number.EPSILON){s.normalize();const g=Math.acos(hn(i[m-1].dot(i[m]),-1,1));r[m].applyMatrix4(l.makeRotationAxis(s,g))}a[m].crossVectors(i[m],r[m])}if(t===!0){let m=Math.acos(hn(r[0].dot(r[e]),-1,1));m/=e,i[0].dot(s.crossVectors(r[0],r[e]))>0&&(m=-m);for(let g=1;g<=e;g++)r[g].applyMatrix4(l.makeRotationAxis(i[g],m*g)),a[g].crossVectors(i[g],r[g])}return{tangents:i,normals:r,binormals:a}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class zM extends Ps{constructor(e=0,t=0,n=1,i=1,r=0,a=Math.PI*2,s=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=n,this.yRadius=i,this.aStartAngle=r,this.aEndAngle=a,this.aClockwise=s,this.aRotation=l}getPoint(e,t=new Pt){const n=t,i=Math.PI*2;let r=this.aEndAngle-this.aStartAngle;const a=Math.abs(r)<Number.EPSILON;for(;r<0;)r+=i;for(;r>i;)r-=i;r<Number.EPSILON&&(a?r=0:r=i),this.aClockwise===!0&&!a&&(r===i?r=-i:r=r-i);const s=this.aStartAngle+e*r;let l=this.aX+this.xRadius*Math.cos(s),c=this.aY+this.yRadius*Math.sin(s);if(this.aRotation!==0){const h=Math.cos(this.aRotation),d=Math.sin(this.aRotation),p=l-this.aX,m=c-this.aY;l=p*h-m*d+this.aX,c=p*d+m*h+this.aY}return n.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class coe extends zM{constructor(e,t,n,i,r,a){super(e,t,n,n,i,r,a),this.isArcCurve=!0,this.type="ArcCurve"}}function VM(){let x=0,e=0,t=0,n=0;function i(r,a,s,l){x=r,e=s,t=-3*r+3*a-2*s-l,n=2*r-2*a+s+l}return{initCatmullRom:function(r,a,s,l,c){i(a,s,c*(s-r),c*(l-a))},initNonuniformCatmullRom:function(r,a,s,l,c,h,d){let p=(a-r)/c-(s-r)/(c+h)+(s-a)/h,m=(s-a)/h-(l-a)/(h+d)+(l-s)/d;p*=h,m*=h,i(a,s,p,m)},calc:function(r){const a=r*r,s=a*r;return x+e*r+t*a+n*s}}}const Yy=new ee,FS=new VM,BS=new VM,LS=new VM;class uoe extends Ps{constructor(e=[],t=!1,n="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=n,this.tension=i}getPoint(e,t=new ee){const n=t,i=this.points,r=i.length,a=(r-(this.closed?0:1))*e;let s=Math.floor(a),l=a-s;this.closed?s+=s>0?0:(Math.floor(Math.abs(s)/r)+1)*r:l===0&&s===r-1&&(s=r-2,l=1);let c,h;this.closed||s>0?c=i[(s-1)%r]:(Yy.subVectors(i[0],i[1]).add(i[0]),c=Yy);const d=i[s%r],p=i[(s+1)%r];if(this.closed||s+2<r?h=i[(s+2)%r]:(Yy.subVectors(i[r-1],i[r-2]).add(i[r-1]),h=Yy),this.curveType==="centripetal"||this.curveType==="chordal"){const m=this.curveType==="chordal"?.5:.25;let g=Math.pow(c.distanceToSquared(d),m),_=Math.pow(d.distanceToSquared(p),m),v=Math.pow(p.distanceToSquared(h),m);_<1e-4&&(_=1),g<1e-4&&(g=_),v<1e-4&&(v=_),FS.initNonuniformCatmullRom(c.x,d.x,p.x,h.x,g,_,v),BS.initNonuniformCatmullRom(c.y,d.y,p.y,h.y,g,_,v),LS.initNonuniformCatmullRom(c.z,d.z,p.z,h.z,g,_,v)}else this.curveType==="catmullrom"&&(FS.initCatmullRom(c.x,d.x,p.x,h.x,this.tension),BS.initCatmullRom(c.y,d.y,p.y,h.y,this.tension),LS.initCatmullRom(c.z,d.z,p.z,h.z,this.tension));return n.set(FS.calc(l),BS.calc(l),LS.calc(l)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new ee().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function IP(x,e,t,n,i){const r=(n-e)*.5,a=(i-t)*.5,s=x*x,l=x*s;return(2*t-2*n+r+a)*l+(-3*t+3*n-2*r-a)*s+r*x+t}function hoe(x,e){const t=1-x;return t*t*e}function doe(x,e){return 2*(1-x)*x*e}function foe(x,e){return x*x*e}function zf(x,e,t,n){return hoe(x,e)+doe(x,t)+foe(x,n)}function poe(x,e){const t=1-x;return t*t*t*e}function moe(x,e){const t=1-x;return 3*t*t*x*e}function yoe(x,e){return 3*(1-x)*x*x*e}function goe(x,e){return x*x*x*e}function Vf(x,e,t,n,i){return poe(x,e)+moe(x,t)+yoe(x,n)+goe(x,i)}class KL extends Ps{constructor(e=new Pt,t=new Pt,n=new Pt,i=new Pt){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new Pt){const n=t,i=this.v0,r=this.v1,a=this.v2,s=this.v3;return n.set(Vf(e,i.x,r.x,a.x,s.x),Vf(e,i.y,r.y,a.y,s.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class voe extends Ps{constructor(e=new ee,t=new ee,n=new ee,i=new ee){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=n,this.v3=i}getPoint(e,t=new ee){const n=t,i=this.v0,r=this.v1,a=this.v2,s=this.v3;return n.set(Vf(e,i.x,r.x,a.x,s.x),Vf(e,i.y,r.y,a.y,s.y),Vf(e,i.z,r.z,a.z,s.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class $L extends Ps{constructor(e=new Pt,t=new Pt){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new Pt){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new Pt){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class boe extends Ps{constructor(e=new ee,t=new ee){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=t}getPoint(e,t=new ee){const n=t;return e===1?n.copy(this.v2):(n.copy(this.v2).sub(this.v1),n.multiplyScalar(e).add(this.v1)),n}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t=new ee){return t.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,t){return this.getTangent(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class QL extends Ps{constructor(e=new Pt,t=new Pt,n=new Pt){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new Pt){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(zf(e,i.x,r.x,a.x),zf(e,i.y,r.y,a.y)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class _oe extends Ps{constructor(e=new ee,t=new ee,n=new ee){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=n}getPoint(e,t=new ee){const n=t,i=this.v0,r=this.v1,a=this.v2;return n.set(zf(e,i.x,r.x,a.x),zf(e,i.y,r.y,a.y),zf(e,i.z,r.z,a.z)),n}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class ZL extends Ps{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,t=new Pt){const n=t,i=this.points,r=(i.length-1)*e,a=Math.floor(r),s=r-a,l=i[a===0?a:a-1],c=i[a],h=i[a>i.length-2?i.length-1:a+1],d=i[a>i.length-3?i.length-1:a+2];return n.set(IP(s,l.x,c.x,h.x,d.x),IP(s,l.y,c.y,h.y,d.y)),n}copy(e){super.copy(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,n=this.points.length;t<n;t++){const i=this.points[t];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,n=e.points.length;t<n;t++){const i=e.points[t];this.points.push(new Pt().fromArray(i))}return this}}var Gw=Object.freeze({__proto__:null,ArcCurve:coe,CatmullRomCurve3:uoe,CubicBezierCurve:KL,CubicBezierCurve3:voe,EllipseCurve:zM,LineCurve:$L,LineCurve3:boe,QuadraticBezierCurve:QL,QuadraticBezierCurve3:_oe,SplineCurve:ZL});class Soe extends Ps{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(t)){const n=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new Gw[n](t,e))}return this}getPoint(e,t){const n=e*this.getLength(),i=this.getCurveLengths();let r=0;for(;r<i.length;){if(i[r]>=n){const a=i[r]-n,s=this.curves[r],l=s.getLength(),c=l===0?0:1-a/l;return s.getPointAt(c,t)}r++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let n=0,i=this.curves.length;n<i;n++)t+=this.curves[n].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let n=0;n<=e;n++)t.push(this.getPoint(n/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let n;for(let i=0,r=this.curves;i<r.length;i++){const a=r[i],s=a.isEllipseCurve?e*2:a.isLineCurve||a.isLineCurve3?1:a.isSplineCurve?e*a.points.length:e,l=a.getPoints(s);for(let c=0;c<l.length;c++){const h=l[c];n&&n.equals(h)||(t.push(h),n=h)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,n=this.curves.length;t<n;t++){const i=this.curves[t];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,n=e.curves.length;t<n;t++){const i=e.curves[t];this.curves.push(new Gw[i.type]().fromJSON(i))}return this}}class Ww extends Soe{constructor(e){super(),this.type="Path",this.currentPoint=new Pt,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,n=e.length;t<n;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const n=new $L(this.currentPoint.clone(),new Pt(e,t));return this.curves.push(n),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,n,i){const r=new QL(this.currentPoint.clone(),new Pt(e,t),new Pt(n,i));return this.curves.push(r),this.currentPoint.set(n,i),this}bezierCurveTo(e,t,n,i,r,a){const s=new KL(this.currentPoint.clone(),new Pt(e,t),new Pt(n,i),new Pt(r,a));return this.curves.push(s),this.currentPoint.set(r,a),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),n=new ZL(t);return this.curves.push(n),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,n,i,r,a){const s=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+s,t+l,n,i,r,a),this}absarc(e,t,n,i,r,a){return this.absellipse(e,t,n,n,i,r,a),this}ellipse(e,t,n,i,r,a,s,l){const c=this.currentPoint.x,h=this.currentPoint.y;return this.absellipse(e+c,t+h,n,i,r,a,s,l),this}absellipse(e,t,n,i,r,a,s,l){const c=new zM(e,t,n,i,r,a,s,l);if(this.curves.length>0){const d=c.getPoint(0);d.equals(this.currentPoint)||this.lineTo(d.x,d.y)}this.curves.push(c);const h=c.getPoint(1);return this.currentPoint.copy(h),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class g1 extends Ww{constructor(e){super(e),this.uuid=va(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let n=0,i=this.holes.length;n<i;n++)t[n]=this.holes[n].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,n=this.holes.length;t<n;t++){const i=this.holes[t];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,n=e.holes.length;t<n;t++){const i=e.holes[t];this.holes.push(new Ww().fromJSON(i))}return this}}const Toe={triangulate:function(x,e,t=2){const n=e&&e.length,i=n?e[0]*t:x.length;let r=JL(x,0,i,t,!0);const a=[];if(!r||r.next===r.prev)return a;let s,l,c,h,d,p,m;if(n&&(r=Roe(x,e,r,t)),x.length>80*t){s=c=x[0],l=h=x[1];for(let g=t;g<i;g+=t)d=x[g],p=x[g+1],d<s&&(s=d),p<l&&(l=p),d>c&&(c=d),p>h&&(h=p);m=Math.max(c-s,h-l),m=m!==0?32767/m:0}return ap(r,a,t,s,l,m,0),a}};function JL(x,e,t,n,i){let r,a;if(i===Loe(x,e,t,n)>0)for(r=e;r<t;r+=n)a=OP(r,x[r],x[r+1],a);else for(r=t-n;r>=e;r-=n)a=OP(r,x[r],x[r+1],a);return a&&bv(a,a.next)&&(op(a),a=a.next),a}function Oc(x,e){if(!x)return x;e||(e=x);let t=x,n;do if(n=!1,!t.steiner&&(bv(t,t.next)||Gx(t.prev,t,t.next)===0)){if(op(t),t=e=t.prev,t===t.next)break;n=!0}else t=t.next;while(n||t!==e);return e}function ap(x,e,t,n,i,r,a){if(!x)return;!a&&r&&Doe(x,n,i,r);let s=x,l,c;for(;x.prev!==x.next;){if(l=x.prev,c=x.next,r?Aoe(x,n,i,r):woe(x)){e.push(l.i/t|0),e.push(x.i/t|0),e.push(c.i/t|0),op(x),x=c.next,s=c.next;continue}if(x=c,x===s){a?a===1?(x=Eoe(Oc(x),e,t),ap(x,e,t,n,i,r,2)):a===2&&Moe(x,e,t,n,i,r):ap(Oc(x),e,t,n,i,r,1);break}}}function woe(x){const e=x.prev,t=x,n=x.next;if(Gx(e,t,n)>=0)return!1;const i=e.x,r=t.x,a=n.x,s=e.y,l=t.y,c=n.y,h=i<r?i<a?i:a:r<a?r:a,d=s<l?s<c?s:c:l<c?l:c,p=i>r?i>a?i:a:r>a?r:a,m=s>l?s>c?s:c:l>c?l:c;let g=n.next;for(;g!==e;){if(g.x>=h&&g.x<=p&&g.y>=d&&g.y<=m&&ih(i,s,r,l,a,c,g.x,g.y)&&Gx(g.prev,g,g.next)>=0)return!1;g=g.next}return!0}function Aoe(x,e,t,n){const i=x.prev,r=x,a=x.next;if(Gx(i,r,a)>=0)return!1;const s=i.x,l=r.x,c=a.x,h=i.y,d=r.y,p=a.y,m=s<l?s<c?s:c:l<c?l:c,g=h<d?h<p?h:p:d<p?d:p,_=s>l?s>c?s:c:l>c?l:c,v=h>d?h>p?h:p:d>p?d:p,b=Xw(m,g,e,t,n),T=Xw(_,v,e,t,n);let E=x.prevZ,A=x.nextZ;for(;E&&E.z>=b&&A&&A.z<=T;){if(E.x>=m&&E.x<=_&&E.y>=g&&E.y<=v&&E!==i&&E!==a&&ih(s,h,l,d,c,p,E.x,E.y)&&Gx(E.prev,E,E.next)>=0||(E=E.prevZ,A.x>=m&&A.x<=_&&A.y>=g&&A.y<=v&&A!==i&&A!==a&&ih(s,h,l,d,c,p,A.x,A.y)&&Gx(A.prev,A,A.next)>=0))return!1;A=A.nextZ}for(;E&&E.z>=b;){if(E.x>=m&&E.x<=_&&E.y>=g&&E.y<=v&&E!==i&&E!==a&&ih(s,h,l,d,c,p,E.x,E.y)&&Gx(E.prev,E,E.next)>=0)return!1;E=E.prevZ}for(;A&&A.z<=T;){if(A.x>=m&&A.x<=_&&A.y>=g&&A.y<=v&&A!==i&&A!==a&&ih(s,h,l,d,c,p,A.x,A.y)&&Gx(A.prev,A,A.next)>=0)return!1;A=A.nextZ}return!0}function Eoe(x,e,t){let n=x;do{const i=n.prev,r=n.next.next;!bv(i,r)&&jL(i,n,n.next,r)&&sp(i,r)&&sp(r,i)&&(e.push(i.i/t|0),e.push(n.i/t|0),e.push(r.i/t|0),op(n),op(n.next),n=x=r),n=n.next}while(n!==x);return Oc(n)}function Moe(x,e,t,n,i,r){let a=x;do{let s=a.next.next;for(;s!==a.prev;){if(a.i!==s.i&&Uoe(a,s)){let l=qL(a,s);a=Oc(a,a.next),l=Oc(l,l.next),ap(a,e,t,n,i,r,0),ap(l,e,t,n,i,r,0);return}s=s.next}a=a.next}while(a!==x)}function Roe(x,e,t,n){const i=[];let r,a,s,l,c;for(r=0,a=e.length;r<a;r++)s=e[r]*n,l=r<a-1?e[r+1]*n:x.length,c=JL(x,s,l,n,!1),c===c.next&&(c.steiner=!0),i.push(koe(c));for(i.sort(Coe),r=0;r<i.length;r++)t=Noe(i[r],t);return t}function Coe(x,e){return x.x-e.x}function Noe(x,e){const t=Ioe(x,e);if(!t)return e;const n=qL(t,x);return Oc(n,n.next),Oc(t,t.next)}function Ioe(x,e){let t=e,n=-1/0,i;const r=x.x,a=x.y;do{if(a<=t.y&&a>=t.next.y&&t.next.y!==t.y){const p=t.x+(a-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(p<=r&&p>n&&(n=p,i=t.x<t.next.x?t:t.next,p===r))return i}t=t.next}while(t!==e);if(!i)return null;const s=i,l=i.x,c=i.y;let h=1/0,d;t=i;do r>=t.x&&t.x>=l&&r!==t.x&&ih(a<c?r:n,a,l,c,a<c?n:r,a,t.x,t.y)&&(d=Math.abs(a-t.y)/(r-t.x),sp(t,x)&&(d<h||d===h&&(t.x>i.x||t.x===i.x&&Ooe(i,t)))&&(i=t,h=d)),t=t.next;while(t!==s);return i}function Ooe(x,e){return Gx(x.prev,x,e.prev)<0&&Gx(e.next,x,x.next)<0}function Doe(x,e,t,n){let i=x;do i.z===0&&(i.z=Xw(i.x,i.y,e,t,n)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==x);i.prevZ.nextZ=null,i.prevZ=null,Poe(i)}function Poe(x){let e,t,n,i,r,a,s,l,c=1;do{for(t=x,x=null,r=null,a=0;t;){for(a++,n=t,s=0,e=0;e<c&&(s++,n=n.nextZ,!!n);e++);for(l=c;s>0||l>0&&n;)s!==0&&(l===0||!n||t.z<=n.z)?(i=t,t=t.nextZ,s--):(i=n,n=n.nextZ,l--),r?r.nextZ=i:x=i,i.prevZ=r,r=i;t=n}r.nextZ=null,c*=2}while(a>1);return x}function Xw(x,e,t,n,i){return x=(x-t)*i|0,e=(e-n)*i|0,x=(x|x<<8)&16711935,x=(x|x<<4)&252645135,x=(x|x<<2)&858993459,x=(x|x<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,x|e<<1}function koe(x){let e=x,t=x;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==x);return t}function ih(x,e,t,n,i,r,a,s){return(i-a)*(e-s)>=(x-a)*(r-s)&&(x-a)*(n-s)>=(t-a)*(e-s)&&(t-a)*(r-s)>=(i-a)*(n-s)}function Uoe(x,e){return x.next.i!==e.i&&x.prev.i!==e.i&&!Foe(x,e)&&(sp(x,e)&&sp(e,x)&&Boe(x,e)&&(Gx(x.prev,x,e.prev)||Gx(x,e.prev,e))||bv(x,e)&&Gx(x.prev,x,x.next)>0&&Gx(e.prev,e,e.next)>0)}function Gx(x,e,t){return(e.y-x.y)*(t.x-e.x)-(e.x-x.x)*(t.y-e.y)}function bv(x,e){return x.x===e.x&&x.y===e.y}function jL(x,e,t,n){const i=$y(Gx(x,e,t)),r=$y(Gx(x,e,n)),a=$y(Gx(t,n,x)),s=$y(Gx(t,n,e));return!!(i!==r&&a!==s||i===0&&Ky(x,t,e)||r===0&&Ky(x,n,e)||a===0&&Ky(t,x,n)||s===0&&Ky(t,e,n))}function Ky(x,e,t){return e.x<=Math.max(x.x,t.x)&&e.x>=Math.min(x.x,t.x)&&e.y<=Math.max(x.y,t.y)&&e.y>=Math.min(x.y,t.y)}function $y(x){return x>0?1:x<0?-1:0}function Foe(x,e){let t=x;do{if(t.i!==x.i&&t.next.i!==x.i&&t.i!==e.i&&t.next.i!==e.i&&jL(t,t.next,x,e))return!0;t=t.next}while(t!==x);return!1}function sp(x,e){return Gx(x.prev,x,x.next)<0?Gx(x,e,x.next)>=0&&Gx(x,x.prev,e)>=0:Gx(x,e,x.prev)<0||Gx(x,x.next,e)<0}function Boe(x,e){let t=x,n=!1;const i=(x.x+e.x)/2,r=(x.y+e.y)/2;do t.y>r!=t.next.y>r&&t.next.y!==t.y&&i<(t.next.x-t.x)*(r-t.y)/(t.next.y-t.y)+t.x&&(n=!n),t=t.next;while(t!==x);return n}function qL(x,e){const t=new Yw(x.i,x.x,x.y),n=new Yw(e.i,e.x,e.y),i=x.next,r=e.prev;return x.next=e,e.prev=x,t.next=i,i.prev=t,n.next=t,t.prev=n,r.next=n,n.prev=r,n}function OP(x,e,t,n){const i=new Yw(x,e,t);return n?(i.next=n.next,i.prev=n,n.next.prev=i,n.next=i):(i.prev=i,i.next=i),i}function op(x){x.next.prev=x.prev,x.prev.next=x.next,x.prevZ&&(x.prevZ.nextZ=x.nextZ),x.nextZ&&(x.nextZ.prevZ=x.prevZ)}function Yw(x,e,t){this.i=x,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function Loe(x,e,t,n){let i=0;for(let r=e,a=t-n;r<t;r+=n)i+=(x[a]-x[r])*(x[r+1]+x[a+1]),a=r;return i}class gh{static area(e){const t=e.length;let n=0;for(let i=t-1,r=0;r<t;i=r++)n+=e[i].x*e[r].y-e[r].x*e[i].y;return n*.5}static isClockWise(e){return gh.area(e)<0}static triangulateShape(e,t){const n=[],i=[],r=[];DP(e),PP(n,e);let a=e.length;t.forEach(DP);for(let l=0;l<t.length;l++)i.push(a),a+=t[l].length,PP(n,t[l]);const s=Toe.triangulate(n,i);for(let l=0;l<s.length;l+=3)r.push(s.slice(l,l+3));return r}}function DP(x){const e=x.length;e>2&&x[e-1].equals(x[0])&&x.pop()}function PP(x,e){for(let t=0;t<e.length;t++)x.push(e[t].x),x.push(e[t].y)}class HM extends Lc{constructor(e=new g1([new Pt(.5,.5),new Pt(-.5,.5),new Pt(-.5,-.5),new Pt(.5,-.5)]),t={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const n=this,i=[],r=[];for(let s=0,l=e.length;s<l;s++){const c=e[s];a(c)}this.setAttribute("position",new rp(i,3)),this.setAttribute("uv",new rp(r,2)),this.computeVertexNormals();function a(s){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,h=t.steps!==void 0?t.steps:1,d=t.depth!==void 0?t.depth:1;let p=t.bevelEnabled!==void 0?t.bevelEnabled:!0,m=t.bevelThickness!==void 0?t.bevelThickness:.2,g=t.bevelSize!==void 0?t.bevelSize:m-.1,_=t.bevelOffset!==void 0?t.bevelOffset:0,v=t.bevelSegments!==void 0?t.bevelSegments:3;const b=t.extrudePath,T=t.UVGenerator!==void 0?t.UVGenerator:zoe;let E,A=!1,M,R,C,k;b&&(E=b.getSpacedPoints(h),A=!0,p=!1,M=b.computeFrenetFrames(h,!1),R=new ee,C=new ee,k=new ee),p||(v=0,m=0,g=0,_=0);const P=s.extractPoints(c);let N=P.shape;const G=P.holes;if(!gh.isClockWise(N)){N=N.reverse();for(let Q=0,rt=G.length;Q<rt;Q++){const He=G[Q];gh.isClockWise(He)&&(G[Q]=He.reverse())}}const j=gh.triangulateShape(N,G),xe=N;for(let Q=0,rt=G.length;Q<rt;Q++){const He=G[Q];N=N.concat(He)}function ae(Q,rt,He){return rt||console.error("THREE.ExtrudeGeometry: vec does not exist"),Q.clone().addScaledVector(rt,He)}const H=N.length,re=j.length;function q(Q,rt,He){let at,Ue,bt;const ht=Q.x-rt.x,dt=Q.y-rt.y,Z=He.x-Q.x,V=He.y-Q.y,_e=ht*ht+dt*dt,Ge=ht*V-dt*Z;if(Math.abs(Ge)>Number.EPSILON){const Re=Math.sqrt(_e),Ve=Math.sqrt(Z*Z+V*V),_t=rt.x-dt/Re,Ce=rt.y+ht/Re,pt=He.x-V/Ve,et=He.y+Z/Ve,tt=((pt-_t)*V-(et-Ce)*Z)/(ht*V-dt*Z);at=_t+ht*tt-Q.x,Ue=Ce+dt*tt-Q.y;const gt=at*at+Ue*Ue;if(gt<=2)return new Pt(at,Ue);bt=Math.sqrt(gt/2)}else{let Re=!1;ht>Number.EPSILON?Z>Number.EPSILON&&(Re=!0):ht<-Number.EPSILON?Z<-Number.EPSILON&&(Re=!0):Math.sign(dt)===Math.sign(V)&&(Re=!0),Re?(at=-dt,Ue=ht,bt=Math.sqrt(_e)):(at=ht,Ue=dt,bt=Math.sqrt(_e/2))}return new Pt(at/bt,Ue/bt)}const be=[];for(let Q=0,rt=xe.length,He=rt-1,at=Q+1;Q<rt;Q++,He++,at++)He===rt&&(He=0),at===rt&&(at=0),be[Q]=q(xe[Q],xe[He],xe[at]);const K=[];let se,ge=be.concat();for(let Q=0,rt=G.length;Q<rt;Q++){const He=G[Q];se=[];for(let at=0,Ue=He.length,bt=Ue-1,ht=at+1;at<Ue;at++,bt++,ht++)bt===Ue&&(bt=0),ht===Ue&&(ht=0),se[at]=q(He[at],He[bt],He[ht]);K.push(se),ge=ge.concat(se)}for(let Q=0;Q<v;Q++){const rt=Q/v,He=m*Math.cos(rt*Math.PI/2),at=g*Math.sin(rt*Math.PI/2)+_;for(let Ue=0,bt=xe.length;Ue<bt;Ue++){const ht=ae(xe[Ue],be[Ue],at);Qe(ht.x,ht.y,-He)}for(let Ue=0,bt=G.length;Ue<bt;Ue++){const ht=G[Ue];se=K[Ue];for(let dt=0,Z=ht.length;dt<Z;dt++){const V=ae(ht[dt],se[dt],at);Qe(V.x,V.y,-He)}}}const Me=g+_;for(let Q=0;Q<H;Q++){const rt=p?ae(N[Q],ge[Q],Me):N[Q];A?(C.copy(M.normals[0]).multiplyScalar(rt.x),R.copy(M.binormals[0]).multiplyScalar(rt.y),k.copy(E[0]).add(C).add(R),Qe(k.x,k.y,k.z)):Qe(rt.x,rt.y,0)}for(let Q=1;Q<=h;Q++)for(let rt=0;rt<H;rt++){const He=p?ae(N[rt],ge[rt],Me):N[rt];A?(C.copy(M.normals[Q]).multiplyScalar(He.x),R.copy(M.binormals[Q]).multiplyScalar(He.y),k.copy(E[Q]).add(C).add(R),Qe(k.x,k.y,k.z)):Qe(He.x,He.y,d/h*Q)}for(let Q=v-1;Q>=0;Q--){const rt=Q/v,He=m*Math.cos(rt*Math.PI/2),at=g*Math.sin(rt*Math.PI/2)+_;for(let Ue=0,bt=xe.length;Ue<bt;Ue++){const ht=ae(xe[Ue],be[Ue],at);Qe(ht.x,ht.y,d+He)}for(let Ue=0,bt=G.length;Ue<bt;Ue++){const ht=G[Ue];se=K[Ue];for(let dt=0,Z=ht.length;dt<Z;dt++){const V=ae(ht[dt],se[dt],at);A?Qe(V.x,V.y+E[h-1].y,E[h-1].x+He):Qe(V.x,V.y,d+He)}}}le(),Se();function le(){const Q=i.length/3;if(p){let rt=0,He=H*rt;for(let at=0;at<re;at++){const Ue=j[at];qe(Ue[2]+He,Ue[1]+He,Ue[0]+He)}rt=h+v*2,He=H*rt;for(let at=0;at<re;at++){const Ue=j[at];qe(Ue[0]+He,Ue[1]+He,Ue[2]+He)}}else{for(let rt=0;rt<re;rt++){const He=j[rt];qe(He[2],He[1],He[0])}for(let rt=0;rt<re;rt++){const He=j[rt];qe(He[0]+H*h,He[1]+H*h,He[2]+H*h)}}n.addGroup(Q,i.length/3-Q,0)}function Se(){const Q=i.length/3;let rt=0;Fe(xe,rt),rt+=xe.length;for(let He=0,at=G.length;He<at;He++){const Ue=G[He];Fe(Ue,rt),rt+=Ue.length}n.addGroup(Q,i.length/3-Q,1)}function Fe(Q,rt){let He=Q.length;for(;--He>=0;){const at=He;let Ue=He-1;Ue<0&&(Ue=Q.length-1);for(let bt=0,ht=h+v*2;bt<ht;bt++){const dt=H*bt,Z=H*(bt+1),V=rt+at+dt,_e=rt+Ue+dt,Ge=rt+Ue+Z,Re=rt+at+Z;Et(V,_e,Ge,Re)}}}function Qe(Q,rt,He){l.push(Q),l.push(rt),l.push(He)}function qe(Q,rt,He){Tt(Q),Tt(rt),Tt(He);const at=i.length/3,Ue=T.generateTopUV(n,i,at-3,at-2,at-1);Bt(Ue[0]),Bt(Ue[1]),Bt(Ue[2])}function Et(Q,rt,He,at){Tt(Q),Tt(rt),Tt(at),Tt(rt),Tt(He),Tt(at);const Ue=i.length/3,bt=T.generateSideWallUV(n,i,Ue-6,Ue-3,Ue-2,Ue-1);Bt(bt[0]),Bt(bt[1]),Bt(bt[3]),Bt(bt[1]),Bt(bt[2]),Bt(bt[3])}function Tt(Q){i.push(l[Q*3+0]),i.push(l[Q*3+1]),i.push(l[Q*3+2])}function Bt(Q){r.push(Q.x),r.push(Q.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,n=this.parameters.options;return Voe(t,n,e)}static fromJSON(e,t){const n=[];for(let r=0,a=e.shapes.length;r<a;r++){const s=t[e.shapes[r]];n.push(s)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new Gw[i.type]().fromJSON(i)),new HM(n,e.options)}}const zoe={generateTopUV:function(x,e,t,n,i){const r=e[t*3],a=e[t*3+1],s=e[n*3],l=e[n*3+1],c=e[i*3],h=e[i*3+1];return[new Pt(r,a),new Pt(s,l),new Pt(c,h)]},generateSideWallUV:function(x,e,t,n,i,r){const a=e[t*3],s=e[t*3+1],l=e[t*3+2],c=e[n*3],h=e[n*3+1],d=e[n*3+2],p=e[i*3],m=e[i*3+1],g=e[i*3+2],_=e[r*3],v=e[r*3+1],b=e[r*3+2];return Math.abs(s-h)<Math.abs(a-c)?[new Pt(a,1-l),new Pt(c,1-d),new Pt(p,1-g),new Pt(_,1-b)]:[new Pt(s,1-l),new Pt(h,1-d),new Pt(m,1-g),new Pt(v,1-b)]}};function Voe(x,e,t){if(t.shapes=[],Array.isArray(x))for(let n=0,i=x.length;n<i;n++){const r=x[n];t.shapes.push(r.uuid)}else t.shapes.push(x.uuid);return t.options=Object.assign({},e),e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class lp extends pc{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new yn(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new yn(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=hse,this.normalScale=new Pt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new pd,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class ks extends lp{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Pt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return hn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new yn(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new yn(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new yn(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}function Qy(x,e,t){return!x||!t&&x.constructor===e?x:typeof e.BYTES_PER_ELEMENT=="number"?new e(x):Array.prototype.slice.call(x)}function Hoe(x){return ArrayBuffer.isView(x)&&!(x instanceof DataView)}function Goe(x){function e(i,r){return x[i]-x[r]}const t=x.length,n=new Array(t);for(let i=0;i!==t;++i)n[i]=i;return n.sort(e),n}function kP(x,e,t){const n=x.length,i=new x.constructor(n);for(let r=0,a=0;a!==n;++r){const s=t[r]*e;for(let l=0;l!==e;++l)i[a++]=x[s+l]}return i}function ez(x,e,t,n){let i=1,r=x[0];for(;r!==void 0&&r[n]===void 0;)r=x[i++];if(r===void 0)return;let a=r[n];if(a!==void 0)if(Array.isArray(a))do a=r[n],a!==void 0&&(e.push(r.time),t.push.apply(t,a)),r=x[i++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[n],a!==void 0&&(e.push(r.time),a.toArray(t,t.length)),r=x[i++];while(r!==void 0);else do a=r[n],a!==void 0&&(e.push(r.time),t.push(a)),r=x[i++];while(r!==void 0)}class Pp{constructor(e,t,n,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(n),this.sampleValues=t,this.valueSize=n,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let n=this._cachedIndex,i=t[n],r=t[n-1];e:{t:{let a;x:{n:if(!(e<i)){for(let s=n+2;;){if(i===void 0){if(e<r)break n;return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}if(n===s)break;if(r=i,i=t[++n],e<i)break t}a=t.length;break x}if(!(e>=r)){const s=t[1];e<s&&(n=2,r=s);for(let l=n-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(n===l)break;if(i=r,r=t[--n-1],e>=r)break t}a=n,n=0;break x}break e}for(;n<a;){const s=n+a>>>1;e<t[s]?a=s:n=s+1}if(i=t[n],r=t[n-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return n=t.length,this._cachedIndex=n,this.copySampleValue_(n-1)}this._cachedIndex=n,this.intervalChanged_(n,r,i)}return this.interpolate_(n,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i;for(let a=0;a!==i;++a)t[a]=n[r+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class Woe extends Pp{constructor(e,t,n,i){super(e,t,n,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:WD,endingEnd:WD}}intervalChanged_(e,t,n){const i=this.parameterPositions;let r=e-2,a=e+1,s=i[r],l=i[a];if(s===void 0)switch(this.getSettings_().endingStart){case XD:r=e,s=2*t-n;break;case YD:r=i.length-2,s=t+i[r]-i[r+1];break;default:r=e,s=n}if(l===void 0)switch(this.getSettings_().endingEnd){case XD:a=e,l=2*n-t;break;case YD:a=1,l=n+i[1]-i[0];break;default:a=e-1,l=t}const c=(n-t)*.5,h=this.valueSize;this._weightPrev=c/(t-s),this._weightNext=c/(l-n),this._offsetPrev=r*h,this._offsetNext=a*h}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,s=this.valueSize,l=e*s,c=l-s,h=this._offsetPrev,d=this._offsetNext,p=this._weightPrev,m=this._weightNext,g=(n-t)/(i-t),_=g*g,v=_*g,b=-p*v+2*p*_-p*g,T=(1+p)*v+(-1.5-2*p)*_+(-.5+p)*g+1,E=(-1-m)*v+(1.5+m)*_+.5*g,A=m*v-m*_;for(let M=0;M!==s;++M)r[M]=b*a[h+M]+T*a[c+M]+E*a[l+M]+A*a[d+M];return r}}class Xoe extends Pp{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,s=this.valueSize,l=e*s,c=l-s,h=(n-t)/(i-t),d=1-h;for(let p=0;p!==s;++p)r[p]=a[c+p]*d+a[l+p]*h;return r}}class Yoe extends Pp{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Us{constructor(e,t,n,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Qy(t,this.TimeBufferType),this.values=Qy(n,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let n;if(t.toJSON!==this.toJSON)n=t.toJSON(e);else{n={name:e.name,times:Qy(e.times,Array),values:Qy(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(n.interpolation=i)}return n.type=e.ValueTypeName,n}InterpolantFactoryMethodDiscrete(e){return new Yoe(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Xoe(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new Woe(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case xp:t=this.InterpolantFactoryMethodDiscrete;break;case np:t=this.InterpolantFactoryMethodLinear;break;case pS:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const n="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(n);return console.warn("THREE.KeyframeTrack:",n),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return xp;case this.InterpolantFactoryMethodLinear:return np;case this.InterpolantFactoryMethodSmooth:return pS}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let n=0,i=t.length;n!==i;++n)t[n]*=e}return this}trim(e,t){const n=this.times,i=n.length;let r=0,a=i-1;for(;r!==i&&n[r]<e;)++r;for(;a!==-1&&n[a]>t;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const s=this.getValueSize();this.times=n.slice(r,a),this.values=this.values.slice(r*s,a*s)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const n=this.times,i=this.values,r=n.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let s=0;s!==r;s++){const l=n[s];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,s,l),e=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,s,l,a),e=!1;break}a=l}if(i!==void 0&&Hoe(i))for(let s=0,l=i.length;s!==l;++s){const c=i[s];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,s,c),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),n=this.getValueSize(),i=this.getInterpolation()===pS,r=e.length-1;let a=1;for(let s=1;s<r;++s){let l=!1;const c=e[s],h=e[s+1];if(c!==h&&(s!==1||c!==e[0]))if(i)l=!0;else{const d=s*n,p=d-n,m=d+n;for(let g=0;g!==n;++g){const _=t[d+g];if(_!==t[p+g]||_!==t[m+g]){l=!0;break}}}if(l){if(s!==a){e[a]=e[s];const d=s*n,p=a*n;for(let m=0;m!==n;++m)t[p+m]=t[d+m]}++a}}if(r>0){e[a]=e[r];for(let s=r*n,l=a*n,c=0;c!==n;++c)t[l+c]=t[s+c];++a}return a!==e.length?(this.times=e.slice(0,a),this.values=t.slice(0,a*n)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),n=this.constructor,i=new n(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}Us.prototype.TimeBufferType=Float32Array;Us.prototype.ValueBufferType=Float32Array;Us.prototype.DefaultInterpolation=np;class yd extends Us{constructor(e,t,n){super(e,t,n)}}yd.prototype.ValueTypeName="bool";yd.prototype.ValueBufferType=Array;yd.prototype.DefaultInterpolation=xp;yd.prototype.InterpolantFactoryMethodLinear=void 0;yd.prototype.InterpolantFactoryMethodSmooth=void 0;class tz extends Us{}tz.prototype.ValueTypeName="color";class Yh extends Us{}Yh.prototype.ValueTypeName="number";class Koe extends Pp{constructor(e,t,n,i){super(e,t,n,i)}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,s=this.valueSize,l=(n-t)/(i-t);let c=e*s;for(let h=c+s;c!==h;c+=4)Ns.slerpFlat(r,0,a,c-s,a,c,l);return r}}class Kh extends Us{InterpolantFactoryMethodLinear(e){return new Koe(this.times,this.values,this.getValueSize(),e)}}Kh.prototype.ValueTypeName="quaternion";Kh.prototype.InterpolantFactoryMethodSmooth=void 0;class gd extends Us{constructor(e,t,n){super(e,t,n)}}gd.prototype.ValueTypeName="string";gd.prototype.ValueBufferType=Array;gd.prototype.DefaultInterpolation=xp;gd.prototype.InterpolantFactoryMethodLinear=void 0;gd.prototype.InterpolantFactoryMethodSmooth=void 0;class $h extends Us{}$h.prototype.ValueTypeName="vector";class $oe{constructor(e="",t=-1,n=[],i=cse){this.name=e,this.tracks=n,this.duration=t,this.blendMode=i,this.uuid=va(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],n=e.tracks,i=1/(e.fps||1);for(let a=0,s=n.length;a!==s;++a)t.push(Zoe(n[a]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],n=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,a=n.length;r!==a;++r)t.push(Us.toJSON(n[r]));return i}static CreateFromMorphTargetSequence(e,t,n,i){const r=t.length,a=[];for(let s=0;s<r;s++){let l=[],c=[];l.push((s+r-1)%r,s,(s+1)%r),c.push(0,1,0);const h=Goe(l);l=kP(l,1,h),c=kP(c,1,h),!i&&l[0]===0&&(l.push(r),c.push(c[0])),a.push(new Yh(".morphTargetInfluences["+t[s].name+"]",l,c).scale(1/n))}return new this(e,-1,a)}static findByName(e,t){let n=e;if(!Array.isArray(e)){const i=e;n=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<n.length;i++)if(n[i].name===t)return n[i];return null}static CreateClipsFromMorphTargetSequences(e,t,n){const i={},r=/^([\w-]*?)([\d]+)$/;for(let s=0,l=e.length;s<l;s++){const c=e[s],h=c.name.match(r);if(h&&h.length>1){const d=h[1];let p=i[d];p||(i[d]=p=[]),p.push(c)}}const a=[];for(const s in i)a.push(this.CreateFromMorphTargetSequence(s,i[s],t,n));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const n=function(d,p,m,g,_){if(m.length!==0){const v=[],b=[];ez(m,v,b,g),v.length!==0&&_.push(new d(p,v,b))}},i=[],r=e.name||"default",a=e.fps||30,s=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let d=0;d<c.length;d++){const p=c[d].keys;if(!(!p||p.length===0))if(p[0].morphTargets){const m={};let g;for(g=0;g<p.length;g++)if(p[g].morphTargets)for(let _=0;_<p[g].morphTargets.length;_++)m[p[g].morphTargets[_]]=-1;for(const _ in m){const v=[],b=[];for(let T=0;T!==p[g].morphTargets.length;++T){const E=p[g];v.push(E.time),b.push(E.morphTarget===_?1:0)}i.push(new Yh(".morphTargetInfluence["+_+"]",v,b))}l=m.length*a}else{const m=".bones["+t[d].name+"]";n($h,m+".position",p,"pos",i),n(Kh,m+".quaternion",p,"rot",i),n($h,m+".scale",p,"scl",i)}}return i.length===0?null:new this(r,l,i,s)}resetDuration(){const e=this.tracks;let t=0;for(let n=0,i=e.length;n!==i;++n){const r=this.tracks[n];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Qoe(x){switch(x.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Yh;case"vector":case"vector2":case"vector3":case"vector4":return $h;case"color":return tz;case"quaternion":return Kh;case"bool":case"boolean":return yd;case"string":return gd}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+x)}function Zoe(x){if(x.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=Qoe(x.type);if(x.times===void 0){const t=[],n=[];ez(x.keys,t,n,"value"),x.times=t,x.values=n}return e.parse!==void 0?e.parse(x):new e(x.name,x.times,x.values,x.interpolation)}const G2={enabled:!1,files:{},add:function(x,e){this.enabled!==!1&&(this.files[x]=e)},get:function(x){if(this.enabled!==!1)return this.files[x]},remove:function(x){delete this.files[x]},clear:function(){this.files={}}};class Joe{constructor(e,t,n){const i=this;let r=!1,a=0,s=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=n,this.itemStart=function(h){s++,r===!1&&i.onStart!==void 0&&i.onStart(h,a,s),r=!0},this.itemEnd=function(h){a++,i.onProgress!==void 0&&i.onProgress(h,a,s),a===s&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(h){i.onError!==void 0&&i.onError(h)},this.resolveURL=function(h){return l?l(h):h},this.setURLModifier=function(h){return l=h,this},this.addHandler=function(h,d){return c.push(h,d),this},this.removeHandler=function(h){const d=c.indexOf(h);return d!==-1&&c.splice(d,2),this},this.getHandler=function(h){for(let d=0,p=c.length;d<p;d+=2){const m=c[d],g=c[d+1];if(m.global&&(m.lastIndex=0),m.test(h))return g}return null}}}const joe=new Joe;class ml{constructor(e){this.manager=e!==void 0?e:joe,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const n=this;return new Promise(function(i,r){n.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}ml.DEFAULT_MATERIAL_NAME="__DEFAULT";const mo={};class qoe extends Error{constructor(e,t){super(e),this.response=t}}class _v extends ml{constructor(e){super(e)}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=G2.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(mo[e]!==void 0){mo[e].push({onLoad:t,onProgress:n,onError:i});return}mo[e]=[],mo[e].push({onLoad:t,onProgress:n,onError:i});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),s=this.mimeType,l=this.responseType;fetch(a).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const h=mo[e],d=c.body.getReader(),p=c.headers.get("X-File-Size")||c.headers.get("Content-Length"),m=p?parseInt(p):0,g=m!==0;let _=0;const v=new ReadableStream({start(b){T();function T(){d.read().then(({done:E,value:A})=>{if(E)b.close();else{_+=A.byteLength;const M=new ProgressEvent("progress",{lengthComputable:g,loaded:_,total:m});for(let R=0,C=h.length;R<C;R++){const k=h[R];k.onProgress&&k.onProgress(M)}b.enqueue(A),T()}},E=>{b.error(E)})}}});return new Response(v)}else throw new qoe(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(h=>new DOMParser().parseFromString(h,s));case"json":return c.json();default:if(s===void 0)return c.text();{const d=/charset="?([^;"\s]*)"?/i.exec(s),p=d&&d[1]?d[1].toLowerCase():void 0,m=new TextDecoder(p);return c.arrayBuffer().then(g=>m.decode(g))}}}).then(c=>{G2.add(e,c);const h=mo[e];delete mo[e];for(let d=0,p=h.length;d<p;d++){const m=h[d];m.onLoad&&m.onLoad(c)}}).catch(c=>{const h=mo[e];if(h===void 0)throw this.manager.itemError(e),c;delete mo[e];for(let d=0,p=h.length;d<p;d++){const m=h[d];m.onError&&m.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class e2e extends ml{constructor(e){super(e)}load(e,t,n,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=G2.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const s=zw("img");function l(){h(),G2.add(e,this),t&&t(this),r.manager.itemEnd(e)}function c(d){h(),i&&i(d),r.manager.itemError(e),r.manager.itemEnd(e)}function h(){s.removeEventListener("load",l,!1),s.removeEventListener("error",c,!1)}return s.addEventListener("load",l,!1),s.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(s.crossOrigin=this.crossOrigin),r.manager.itemStart(e),s.src=e,s}}class t2e extends ml{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new FM,s=new _v(this.manager);return s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setPath(this.path),s.setWithCredentials(r.withCredentials),s.load(e,function(l){let c;try{c=r.parse(l)}catch(h){if(i!==void 0)i(h);else{console.error(h);return}}c.image!==void 0?a.image=c.image:c.data!==void 0&&(a.image.width=c.width,a.image.height=c.height,a.image.data=c.data),a.wrapS=c.wrapS!==void 0?c.wrapS:uc,a.wrapT=c.wrapT!==void 0?c.wrapT:uc,a.magFilter=c.magFilter!==void 0?c.magFilter:J2,a.minFilter=c.minFilter!==void 0?c.minFilter:J2,a.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0&&(a.colorSpace=c.colorSpace),c.flipY!==void 0&&(a.flipY=c.flipY),c.format!==void 0&&(a.format=c.format),c.type!==void 0&&(a.type=c.type),c.mipmaps!==void 0&&(a.mipmaps=c.mipmaps,a.minFilter=yv),c.mipmapCount===1&&(a.minFilter=J2),c.generateMipmaps!==void 0&&(a.generateMipmaps=c.generateMipmaps),a.needsUpdate=!0,t&&t(a,c)},n,i),a}}class x2e extends ml{constructor(e){super(e)}load(e,t,n,i){const r=new Qa,a=new e2e(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(s){r.image=s,r.needsUpdate=!0,t!==void 0&&t(r)},n,i),r}}class Sv extends en{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new yn(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}const zS=new f0,UP=new ee,FP=new ee;class GM{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Pt(512,512),this.map=null,this.mapPass=null,this.matrix=new f0,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new toe,this._frameExtents=new Pt(1,1),this._viewportCount=1,this._viewports=[new fa(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,n=this.matrix;UP.setFromMatrixPosition(e.matrixWorld),t.position.copy(UP),FP.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(FP),t.updateMatrixWorld(),zS.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(zS),n.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),n.multiply(zS)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class n2e extends GM{constructor(){super(new PM(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,n=ip*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(n!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=n,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class i2e extends Sv{constructor(e,t,n=0,i=Math.PI/3,r=0,a=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(en.DEFAULT_UP),this.updateMatrix(),this.target=new en,this.distance=n,this.angle=i,this.penumbra=r,this.decay=a,this.map=null,this.shadow=new n2e}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const BP=new f0,Tf=new ee,VS=new ee;class r2e extends GM{constructor(){super(new PM(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Pt(4,2),this._viewportCount=6,this._viewports=[new fa(2,1,1,1),new fa(0,1,1,1),new fa(3,1,1,1),new fa(1,1,1,1),new fa(3,0,1,1),new fa(1,0,1,1)],this._cubeDirections=[new ee(1,0,0),new ee(-1,0,0),new ee(0,0,1),new ee(0,0,-1),new ee(0,1,0),new ee(0,-1,0)],this._cubeUps=[new ee(0,1,0),new ee(0,1,0),new ee(0,1,0),new ee(0,1,0),new ee(0,0,1),new ee(0,0,-1)]}updateMatrices(e,t=0){const n=this.camera,i=this.matrix,r=e.distance||n.far;r!==n.far&&(n.far=r,n.updateProjectionMatrix()),Tf.setFromMatrixPosition(e.matrixWorld),n.position.copy(Tf),VS.copy(n.position),VS.add(this._cubeDirections[t]),n.up.copy(this._cubeUps[t]),n.lookAt(VS),n.updateMatrixWorld(),i.makeTranslation(-Tf.x,-Tf.y,-Tf.z),BP.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(BP)}}class xz extends Sv{constructor(e,t,n=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=n,this.decay=i,this.shadow=new r2e}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class a2e extends GM{constructor(){super(new GL(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class s2e extends Sv{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(en.DEFAULT_UP),this.updateMatrix(),this.target=new en,this.shadow=new a2e}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class o2e extends Sv{constructor(e,t){super(e,t),this.isAmbientLight=!0,this.type="AmbientLight"}}class Hf{static decodeText(e){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let n=0,i=e.length;n<i;n++)t+=String.fromCharCode(e[n]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class l2e extends ml{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,n,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=G2.get(e);if(a!==void 0){if(r.manager.itemStart(e),a.then){a.then(c=>{t&&t(c),r.manager.itemEnd(e)}).catch(c=>{i&&i(c)});return}return setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a}const s={};s.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",s.headers=this.requestHeader;const l=fetch(e,s).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(c){return G2.add(e,c),t&&t(c),r.manager.itemEnd(e),c}).catch(function(c){i&&i(c),G2.remove(e),r.manager.itemError(e),r.manager.itemEnd(e)});G2.add(e,l),r.manager.itemStart(e)}}const WM="\\[\\]\\.:\\/",c2e=new RegExp("["+WM+"]","g"),XM="[^"+WM+"]",u2e="[^"+WM.replace("\\.","")+"]",h2e=/((?:WC+[\/:])*)/.source.replace("WC",XM),d2e=/(WCOD+)?/.source.replace("WCOD",u2e),f2e=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",XM),p2e=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",XM),m2e=new RegExp("^"+h2e+d2e+f2e+p2e+"$"),y2e=["material","materials","bones","map"];class g2e{constructor(e,t,n){const i=n||ix.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const n=this._targetGroup.nCachedObjects_,i=this._bindings[n];i!==void 0&&i.getValue(e,t)}setValue(e,t){const n=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=n.length;i!==r;++i)n[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,n=e.length;t!==n;++t)e[t].unbind()}}class ix{constructor(e,t,n){this.path=t,this.parsedPath=n||ix.parseTrackName(t),this.node=ix.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,n){return e&&e.isAnimationObjectGroup?new ix.Composite(e,t,n):new ix(e,t,n)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(c2e,"")}static parseTrackName(e){const t=m2e.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const n={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=n.nodeName&&n.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=n.nodeName.substring(i+1);y2e.indexOf(r)!==-1&&(n.nodeName=n.nodeName.substring(0,i),n.objectName=r)}if(n.propertyName===null||n.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return n}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const n=e.skeleton.getBoneByName(t);if(n!==void 0)return n}if(e.children){const n=function(r){for(let a=0;a<r.length;a++){const s=r[a];if(s.name===t||s.uuid===t)return s;const l=n(s.children);if(l)return l}return null},i=n(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)e[t++]=n[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const n=this.resolvedProperty;for(let i=0,r=n.length;i!==r;++i)n[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,n=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=ix.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(n){let c=t.objectIndex;switch(n){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let h=0;h<e.length;h++)if(e[h].name===c){c=h;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[n]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[n]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const a=e[i];if(a===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let s=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?s=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(s=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][s]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}ix.Composite=g2e;ix.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};ix.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};ix.prototype.GetterByBindingType=[ix.prototype._getValue_direct,ix.prototype._getValue_array,ix.prototype._getValue_arrayElement,ix.prototype._getValue_toArray];ix.prototype.SetterByBindingTypeAndVersioning=[[ix.prototype._setValue_direct,ix.prototype._setValue_direct_setNeedsUpdate,ix.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[ix.prototype._setValue_array,ix.prototype._setValue_array_setNeedsUpdate,ix.prototype._setValue_array_setMatrixWorldNeedsUpdate],[ix.prototype._setValue_arrayElement,ix.prototype._setValue_arrayElement_setNeedsUpdate,ix.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[ix.prototype._setValue_fromArray,ix.prototype._setValue_fromArray_setNeedsUpdate,ix.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];const LP=new ee,Zy=new ee;class To{constructor(e=new ee,t=new ee){this.start=e,this.end=t}set(e,t){return this.start.copy(e),this.end.copy(t),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,t){return this.delta(t).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,t){LP.subVectors(e,this.start),Zy.subVectors(this.end,this.start);const n=Zy.dot(Zy);let r=Zy.dot(LP)/n;return t&&(r=hn(r,0,1)),r}closestPointToPoint(e,t,n){const i=this.closestPointToPointParameter(e,t);return this.delta(n).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}class v2e{constructor(){this.type="ShapePath",this.color=new yn,this.subPaths=[],this.currentPath=null}moveTo(e,t){return this.currentPath=new Ww,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,t),this}lineTo(e,t){return this.currentPath.lineTo(e,t),this}quadraticCurveTo(e,t,n,i){return this.currentPath.quadraticCurveTo(e,t,n,i),this}bezierCurveTo(e,t,n,i,r,a){return this.currentPath.bezierCurveTo(e,t,n,i,r,a),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function t(b){const T=[];for(let E=0,A=b.length;E<A;E++){const M=b[E],R=new g1;R.curves=M.curves,T.push(R)}return T}function n(b,T){const E=T.length;let A=!1;for(let M=E-1,R=0;R<E;M=R++){let C=T[M],k=T[R],P=k.x-C.x,N=k.y-C.y;if(Math.abs(N)>Number.EPSILON){if(N<0&&(C=T[R],P=-P,k=T[M],N=-N),b.y<C.y||b.y>k.y)continue;if(b.y===C.y){if(b.x===C.x)return!0}else{const G=N*(b.x-C.x)-P*(b.y-C.y);if(G===0)return!0;if(G<0)continue;A=!A}}else{if(b.y!==C.y)continue;if(k.x<=b.x&&b.x<=C.x||C.x<=b.x&&b.x<=k.x)return!0}}return A}const i=gh.isClockWise,r=this.subPaths;if(r.length===0)return[];let a,s,l;const c=[];if(r.length===1)return s=r[0],l=new g1,l.curves=s.curves,c.push(l),c;let h=!i(r[0].getPoints());h=e?!h:h;const d=[],p=[];let m=[],g=0,_;p[g]=void 0,m[g]=[];for(let b=0,T=r.length;b<T;b++)s=r[b],_=s.getPoints(),a=i(_),a=e?!a:a,a?(!h&&p[g]&&g++,p[g]={s:new g1,p:_},p[g].s.curves=s.curves,h&&g++,m[g]=[]):m[g].push({h:s,p:_[0]});if(!p[0])return t(r);if(p.length>1){let b=!1,T=0;for(let E=0,A=p.length;E<A;E++)d[E]=[];for(let E=0,A=p.length;E<A;E++){const M=m[E];for(let R=0;R<M.length;R++){const C=M[R];let k=!0;for(let P=0;P<p.length;P++)n(C.p,p[P].p)&&(E!==P&&T++,k?(k=!1,d[P].push(C)):b=!0);k&&d[E].push(C)}}T>0&&b===!1&&(m=d)}let v;for(let b=0,T=p.length;b<T;b++){l=p[b].s,c.push(l),v=m[b];for(let E=0,A=v.length;E<A;E++)l.holes.push(v[E].h)}return c}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:PL}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=PL);var b2e=Object.defineProperty,zP=Object.getOwnPropertySymbols,_2e=Object.prototype.hasOwnProperty,S2e=Object.prototype.propertyIsEnumerable,VP=(x,e,t)=>e in x?b2e(x,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):x[e]=t,T2e=(x,e)=>{for(var t in e||(e={}))_2e.call(e,t)&&VP(x,t,e[t]);if(zP)for(var t of zP(e))S2e.call(e,t)&&VP(x,t,e[t]);return x};class w2e extends XB{constructor(e,t,n,i){super({container:e,mode:t,layerCount:2,mirror:n});const r=this.canvas.layers[1];this.renderer=new jae(T2e({alpha:!0,preserveDrawingBuffer:!0,canvas:r},i)),this.renderer.setClearColor(0,0),this.renderer.setPixelRatio(window.devicePixelRatio),this.renderer.setSize(r.clientWidth,r.clientHeight),this.renderer.outputColorSpace=La,this.canvas.on("resize",()=>{this.renderer.setSize(r.clientWidth,r.clientHeight)}),this.scene=new qae,this.scene.background=null,this.camera=new Cr(this.cameraAngle,1,.02,20)}updateScene(){this.scene&&this.renderer.render(this.scene,this.camera)}setupCamera(e,t){super.setupCamera(e,t),this.camera instanceof Cr&&(this.camera.aspect=this.cameraRatio,this.camera.fov=this.cameraAngle/Math.PI*180,this.camera.updateProjectionMatrix())}setupVideo(e,t){super.setupVideo(e,t),this.camera instanceof ML&&(this.camera.right=this.videoSize.width,this.camera.bottom=this.videoSize.height,this.camera.updateProjectionMatrix())}disposeObject(e){const t=(n,i)=>Array.isArray(n)&&n.every(r=>r instanceof i);e.removeFromParent(),e.traverse(n=>{n instanceof ws&&(n.geometry instanceof dd&&n.geometry.dispose(),n.material instanceof Wh&&n.material.dispose(),t(n.material,Wh)&&n.material.forEach(i=>{i.dispose();for(const r in i){const a=i[r];a instanceof ns&&a.dispose()}}))})}}class A2e extends Bte{}class E2e extends w2e{}class M2e extends A2e{}class R2e extends M2e{constructor(e,t={spineCurve:.5,neckAdjust:.01,headRatio:.32,shouldersD:[0,-.01,.005]}){super(),this.node=e,this.tune=t,this.avatarLength=1,this.alignScore=.9,this.alignVisibility=.9}async load(e){this.loaded||(await super.load(e),this.setNode(this.node))}unload(){this.loaded&&(delete this.node,delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,super.unload())}setNode(e){var t;if(delete this.skeletonNodes,delete this.skeleton,delete this.spineCurve,this.node=e,!this.loaded||!e)return;e.traverse(C=>{!this.skeleton&&C instanceof WL&&(this.skeleton=C.skeleton)});const n=(t=this.skeleton)==null?void 0:t.bones;if(!n)return;const i=C=>n.find(k=>k.name.toLowerCase().endsWith(C)),r={hips:i("hips"),spine:i("spine"),spine1:i("spine1"),spine2:i("spine2"),neck:i("neck"),head:i("head"),headEnd:i("headtop_end"),shoulderL:i("leftshoulder"),shoulderR:i("rightshoulder"),armL:i("leftarm"),armR:i("rightarm"),forearmL:i("leftforearm"),forearmR:i("rightforearm"),handL:i("lefthand"),handR:i("righthand"),uplegL:i("leftupleg"),uplegR:i("rightupleg"),legL:i("leftleg"),legR:i("rightleg"),footL:i("leftfoot"),footR:i("rightfoot"),toeL:i("lefttoebase"),toeR:i("righttoebase")};this.skeletonNodes=r;const a=r.hips.getWorldPosition(new ee),s=r.armL.getWorldPosition(new ee),l=r.armR.getWorldPosition(new ee),c=s.clone().lerp(l,.5).sub(a).length(),h=s.clone().sub(a),d=l.clone().sub(a).clone().cross(h).normalize(),p=r.spine.getWorldPosition(new ee).sub(a),m=p.dot(d),g=p.clone().sub(d.clone().multiplyScalar(m)).length(),_=r.spine1.getWorldPosition(new ee).sub(a),v=_.dot(d),b=_.clone().sub(d.clone().multiplyScalar(v)).length(),T=r.spine2.getWorldPosition(new ee).sub(a),E=T.dot(d),A=T.clone().sub(d.clone().multiplyScalar(E)).length(),M=r.head.getWorldPosition(new ee),R=r.headEnd.getWorldPosition(new ee).clone().sub(M).length();this.avatarLength=c,this.spineCurve={hips:[a.x,a.y],spine:[g/c,m/c],spine1:[b/c,v/c],spine2:[A/c,E/c],head:[R/c,0]},e.traverse(C=>{C.frustumCulled=!1})}async update(e,t){var n,i;const r=(n=e.poses[0])==null?void 0:n.points,{node:a,skeletonNodes:s,spineCurve:l}=this;if(!a)return super.update(e,t);if(!s||!l||!r)return a.visible=!1,super.update(e,t);const c=this.estimateBones(r,l);return a.visible=!0,(i=this.skeleton)==null||i.pose(),this.updateSpine(c),this.updateHandL(c,r),this.updateHandR(c,r),this.updateLegL(c,r),this.updateLegR(c,r),super.update(e,t)}updateSpine(e){var t;const{skeletonNodes:n}=this;if(!n)return;this.alignBone(e.hips,n.hips,!1),this.alignBone(e.spine,n.spine),this.alignBone(e.spine1,n.spine1),this.alignBone(e.spine2,n.spine2),this.alignBone(e.neck,n.neck,!1),this.alignBone(e.head,n.head,!1);const i=(t=this.skeleton)==null?void 0:t.bones.find(r=>r.name.endsWith("HeadEnd"));if(i){const{head:r,headEnd:a}=e,s=a.position.clone().sub(r.position).length();n.head.scale.setScalar(1.05*s/i.position.length())}this.alignBone(e.shoulderL,n.shoulderL,!1),this.alignBone(e.shoulderR,n.shoulderR,!1)}updateHandL(e,t){const{skeletonNodes:n}=this;if(!n)return;const{alignScore:i,alignVisibility:r}=this;this.alignBone(e.armL,n.armL),!(t.elbowL.score<i&&t.elbowL.visibility<r)&&(this.alignBone(e.forearmL,n.forearmL),this.alignBone(e.handL,n.handL),n.handL.scale.setScalar(.95))}updateHandR(e,t){const{skeletonNodes:n}=this;if(!n)return;const{alignScore:i,alignVisibility:r}=this;this.alignBone(e.armR,n.armR),!(t.elbowR.score<i&&t.elbowR.visibility<r)&&(this.alignBone(e.forearmR,n.forearmR),this.alignBone(e.handR,n.handR),n.handR.scale.setScalar(.95))}updateLegL(e,t){const{skeletonNodes:n}=this;if(!n)return;const{alignScore:i,alignVisibility:r}=this;t.hipL.score<i&&t.hipL.visibility<r||(this.alignBone(e.uplegL,n.uplegL,!1),!(t.kneeL.score<i&&t.kneeL.visibility<r)&&(this.alignBone(e.legL,n.legL),!(t.ankleL.score<i&&t.ankleL.visibility<r)&&(this.alignBone(e.footL,n.footL),this.alignBone(e.toeL,n.toeL))))}updateLegR(e,t){const{skeletonNodes:n}=this;if(!n)return;const{alignScore:i,alignVisibility:r}=this;t.hipR.score<i&&t.hipR.visibility<r||(this.alignBone(e.uplegR,n.uplegR,!1),!(t.kneeR.score<i&&t.kneeR.visibility<r)&&(this.alignBone(e.legR,n.legR),!(t.ankleR.score<i&&t.ankleR.visibility<r)&&(this.alignBone(e.footR,n.footR),this.alignBone(e.toeR,n.toeR))))}estimateBones(e,t){var n;const i=new ee(...e.hipL.metric),r=new ee(...e.hipR.metric),a=i.clone().lerp(r,.5),s=i.clone().sub(r).normalize(),l=s.clone().negate(),c=new ee(...e.shoulderL.metric),h=new ee(...e.shoulderR.metric),d=new ee(...e.elbowL.metric),p=new ee(...e.elbowR.metric),m=c.clone().lerp(h,.5),g=c.clone().sub(h).normalize(),_=c.clone().sub(a),v=h.clone().sub(a).clone().cross(_).normalize();if(this.tune.shouldersD){const q0=g.clone().multiplyScalar(this.tune.shouldersD[0]),Fx=m.clone().sub(a).normalize().multiplyScalar(this.tune.shouldersD[1]).add(v.clone().multiplyScalar((n=this.tune)==null?void 0:n.shouldersD[2]));c.add(Fx).add(q0),h.add(Fx).add(q0.clone().negate())}const b=c.clone().lerp(h,.5),T=b.clone().sub(a).normalize(),E=d.clone().sub(c).normalize(),A=p.clone().sub(h).normalize();let M;if(this.tune.neckAdjust){const q0=Math.abs(g.x);M=T.clone().multiplyScalar(q0*(T.dot(E)*-this.tune.neckAdjust+T.dot(A)*-this.tune.neckAdjust)),b.add(M)}const R=b.clone().sub(a).length(),C=this.tune.shoulderOffset||.2,k=b.clone().lerp(c,C),P=b.clone().lerp(h,C),N=new ee(...e.earL.metric),G=new ee(...e.earR.metric),te=N.clone().lerp(G,.5),j=new ee(...e.nose.metric),xe=te.clone().sub(j).normalize(),ae=N.clone().sub(G).normalize(),H=ae.clone().cross(xe).add(xe.clone().multiplyScalar(.05)).normalize(),re=this.tune.headRatio||.32,q=t.head[0]*R,be=te.clone().add(H.clone().cross(ae).multiplyScalar(.025)),K=be.clone().add(H.clone().multiplyScalar(-re*q)),se=be.clone().add(H.clone().multiplyScalar((1-re)*q)),ge=K.clone().lerp(se,2),Me=g.clone().lerp(ae,.5),le=M?c.clone().add(M):c.clone(),Se=M?h.clone().add(M):h.clone(),Fe=i.clone().lerp(le,t.spine[0]),Qe=r.clone().lerp(Se,t.spine[0]),qe=Fe.clone().lerp(Qe,.5),Et=Fe.clone().sub(Qe),Tt=i.clone().lerp(le,t.spine1[0]),Bt=r.clone().lerp(Se,t.spine1[0]),Q=Tt.clone().lerp(Bt,.5),rt=Tt.clone().sub(Bt),He=i.clone().lerp(le,t.spine2[0]),at=r.clone().lerp(Se,t.spine2[0]),Ue=He.clone().lerp(at,.5),bt=Tt.clone().sub(at);if(this.tune.spineCurve){const q0=c.clone().sub(a),Fx=h.clone().sub(a).clone().cross(q0).normalize(),gn=this.tune.spineCurve*R;qe.add(Fx.clone().multiplyScalar(t.spine[1]*gn)),Q.add(Fx.clone().multiplyScalar(t.spine1[1]*gn)),Ue.add(Fx.clone().multiplyScalar(t.spine2[1]*gn))}const ht=new ee(...e.wristL.metric),dt=ht.clone().sub(d).normalize().clone().sub(E).negate(),Z=v.clone(),V=dt.clone().lerp(Z,.5),_e=new ee(...e.indexL.metric),Ge=new ee(...e.pinkyL.metric),Re=_e.clone().lerp(Ge,.5),Ve=Ge.clone().sub(_e),_t=new ee(...e.wristR.metric),Ce=_t.clone().sub(p).normalize().clone().sub(A),pt=v.clone().negate(),et=Ce.clone().lerp(pt,.5),tt=new ee(...e.indexR.metric),gt=new ee(...e.pinkyR.metric),i0=tt.clone().lerp(gt,.5),Ht=tt.clone().sub(gt),St=new ee(...e.kneeL.metric),Ut=new ee(...e.ankleL.metric),t0=new ee(...e.footIndexL.metric),p0=new ee(...e.heelL.metric),de=Ut.clone().sub(St).normalize(),ft=t0.clone().sub(p0).normalize(),Xe=de.clone().cross(ft).normalize(),Ze=p0.clone().lerp(t0,.8),lt=l.clone().lerp(Xe,.2),Wt=l.clone().lerp(Xe,.6),Qt=new ee(...e.kneeR.metric),D0=new ee(...e.ankleR.metric),P0=new ee(...e.footIndexR.metric),s0=new ee(...e.heelR.metric),rn=D0.clone().sub(Qt).normalize(),Cx=P0.clone().sub(s0).normalize(),ax=rn.clone().cross(Cx).normalize(),L0=s0.clone().lerp(P0,.8),R0=l.clone().lerp(ax,.2),Wn=l.clone().lerp(ax,.6);return{hips:this.estimateBone(a,qe,s),spine:this.estimateBone(qe,Q,Et),spine1:this.estimateBone(Q,Ue,rt),spine2:this.estimateBone(Ue,b,bt),neck:this.estimateBone(b,K,Me),head:this.estimateBone(K,se,ae),headEnd:this.estimateBone(se,ge,ae),shoulderL:this.estimateBone(k,c,Z),armL:this.estimateBone(c,d,V),forearmL:this.estimateBone(d,ht,dt),handL:this.estimateBone(ht,Re,Ve),shoulderR:this.estimateBone(P,h,pt),armR:this.estimateBone(h,p,et),forearmR:this.estimateBone(p,_t,Ce),handR:this.estimateBone(_t,i0,Ht),uplegL:this.estimateBone(i,St,lt),legL:this.estimateBone(St,Ut,Wt),footL:this.estimateBone(Ut,Ze,Xe),toeL:this.estimateBone(Ze,t0,Xe),uplegR:this.estimateBone(r,Qt,R0),legR:this.estimateBone(Qt,D0,Wn),footR:this.estimateBone(D0,L0,ax),toeR:this.estimateBone(L0,P0,ax)}}estimateBone(e,t,n){const i=t.clone().sub(e).normalize(),r=n.clone().normalize().cross(i).normalize(),a=i.clone().cross(r);return{position:e.clone(),rotation:new Ns().setFromRotationMatrix(new f0().makeBasis(a,i,r))}}alignBone(e,t,n=!0){let i=e.rotation.clone(),r=e.position.clone();t.parent&&(i=t.parent.getWorldQuaternion(new Ns).invert().multiply(i),r.applyMatrix4(t.parent.matrixWorld.clone().invert()),n&&t.parent instanceof UM&&(t.parent.scale.setScalar(r.length()/t.position.length()),t.parent.updateWorldMatrix(!0,!0),r=e.position.clone().applyMatrix4(t.parent.matrixWorld.clone().invert()))),t.setRotationFromQuaternion(i),t.position.copy(r),t.updateWorldMatrix(!0,!0)}}class C2e extends R2e{constructor(e,t,n={spineCurve:.5,neckAdjust:.01,headRatio:.32,shouldersD:[0,-.01,.005]}){super(e,n),this.outfit=t}setNode(e){super.setNode(e);const{outfit:t,node:n}=this;!t||!n||n.traverse(i=>{if(!(i instanceof md))return;const r=a=>a==null?void 0:a.some(s=>typeof s=="string"?i.name===s:s.test(i.name));if(r(t.occluders)){i.material.colorWrite=!1,i.renderOrder=-1;return}if(r(t.hidden)){i.visible=!1;return}})}setOutfit(e,t){this.outfit=t,this.setNode(e)}}var HP;(x=>{function e(c,h,d){return{position:c.clone(),rotation:n(h.clone().sub(c),d)}}x.estimateBoneYZ=e;function t(c,h,d){return{position:c.clone(),rotation:i(h.clone().sub(c),d)}}x.estimateBoneYX=t;function n(c,h){const d=c.clone().normalize(),p=d.clone().cross(h).normalize(),m=p.clone().cross(d).normalize();return new Ts().setFromRotationMatrix(new Hn().makeBasis(p,d,m))}x.estimateRotationYZ=n;function i(c,h){const d=c.clone().normalize(),p=h.clone().cross(d).normalize(),m=d.clone().cross(p).normalize();return new Ts().setFromRotationMatrix(new Hn().makeBasis(m,d,p))}x.estimateRotationYX=i;function r(c,h){const d=c.clone().cross(h);return new Ts(d.x,d.y,d.z,Math.sqrt(1+c.dot(h))).normalize()}x.rotationBetween=r;function a(c,h,d=!0){let p=c.position.clone(),m=c.rotation.clone();h.parent&&(m=h.parent.getWorldQuaternion(new Ts).invert().multiply(m),p.applyMatrix4(h.parent.matrixWorld.clone().invert()),d&&(h.parent.scale.setScalar(p.length()/h.position.length()),h.parent.updateWorldMatrix(!0,!0),p=c.position.clone().applyMatrix4(h.parent.matrixWorld.clone().invert()))),h.setRotationFromQuaternion(m),h.position.copy(p),h.updateWorldMatrix(!0,!0)}x.alignBone=a;function s(c,h,d=!0){let p=c.clone();h.parent&&(p.applyMatrix4(h.parent.matrixWorld.clone().invert()),d&&(h.parent.scale.setScalar(p.length()/h.position.length()),h.parent.updateWorldMatrix(!0,!0),p=c.clone().applyMatrix4(h.parent.matrixWorld.clone().invert()))),h.position.copy(p),h.updateWorldMatrix(!0,!0)}x.positionBone=s;function l(c,h){let d=c.clone();h.parent&&(d=h.parent.getWorldQuaternion(new Ts).invert().multiply(d)),h.setRotationFromQuaternion(d),h.updateWorldMatrix(!0,!0)}x.rotateBone=l})(HP||(HP={}));const N2e=32;new Array(N2e).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}));class Fo{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(e,t){let n=1/0,i=-1/0;for(let r=0,a=e.length;r<a;r++){const s=e[r][t];n=s<n?s:n,i=s>i?s:i}this.min=n,this.max=i}setFromPoints(e,t){let n=1/0,i=-1/0;for(let r=0,a=t.length;r<a;r++){const s=t[r],l=e.dot(s);n=l<n?l:n,i=l>i?l:i}this.min=n,this.max=i}isSeparated(e){return this.min>e.max||e.min>this.max}}Fo.prototype.setFromBox=function(){const x=new ee;return function(e,t){const n=t.min,i=t.max;let r=1/0,a=-1/0;for(let s=0;s<=1;s++)for(let l=0;l<=1;l++)for(let c=0;c<=1;c++){x.x=n.x*s+i.x*(1-s),x.y=n.y*l+i.y*(1-l),x.z=n.z*c+i.z*(1-c);const h=e.dot(x);r=Math.min(h,r),a=Math.max(h,a)}this.min=r,this.max=a}}();const I2e=function(){const x=new ee,e=new ee,t=new ee;return function(n,i,r){const a=n.start,s=x,l=i.start,c=e;t.subVectors(a,l),x.subVectors(n.end,n.start),e.subVectors(i.end,i.start);const h=t.dot(c),d=c.dot(s),p=c.dot(c),m=t.dot(s),g=s.dot(s)*p-d*d;let _,v;g!==0?_=(h*d-m*p)/g:_=0,v=(h+_*d)/p,r.x=_,r.y=v}}(),Kw=function(){const x=new Pt,e=new ee,t=new ee;return function(n,i,r,a){I2e(n,i,x);let s=x.x,l=x.y;if(s>=0&&s<=1&&l>=0&&l<=1){n.at(s,r),i.at(l,a);return}else if(s>=0&&s<=1){l<0?i.at(0,a):i.at(1,a),n.closestPointToPoint(a,!0,r);return}else if(l>=0&&l<=1){s<0?n.at(0,r):n.at(1,r),i.closestPointToPoint(r,!0,a);return}else{let c;s<0?c=n.start:c=n.end;let h;l<0?h=i.start:h=i.end;const d=e,p=t;if(n.closestPointToPoint(h,!0,e),i.closestPointToPoint(c,!0,t),d.distanceToSquared(h)<=p.distanceToSquared(c)){r.copy(d),a.copy(h);return}else{r.copy(c),a.copy(p);return}}}}(),O2e=function(){const x=new ee,e=new ee,t=new F2,n=new To;return function(i,r){const{radius:a,center:s}=i,{a:l,b:c,c:h}=r;if(n.start=l,n.end=c,n.closestPointToPoint(s,!0,x).distanceTo(s)<=a||(n.start=l,n.end=h,n.closestPointToPoint(s,!0,x).distanceTo(s)<=a)||(n.start=c,n.end=h,n.closestPointToPoint(s,!0,x).distanceTo(s)<=a))return!0;const d=r.getPlane(t);if(Math.abs(d.distanceToPoint(s))<=a){const p=d.projectPoint(s,e);if(r.containsPoint(p))return!0}return!1}}(),D2e=1e-15;function HS(x){return Math.abs(x)<D2e}class Ya extends Xa{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new ee),this.satBounds=new Array(4).fill().map(()=>new Fo),this.points=[this.a,this.b,this.c],this.sphere=new is,this.plane=new F2,this.needsUpdate=!0}intersectsSphere(e){return O2e(e,this)}update(){const e=this.a,t=this.b,n=this.c,i=this.points,r=this.satAxes,a=this.satBounds,s=r[0],l=a[0];this.getNormal(s),l.setFromPoints(s,i);const c=r[1],h=a[1];c.subVectors(e,t),h.setFromPoints(c,i);const d=r[2],p=a[2];d.subVectors(t,n),p.setFromPoints(d,i);const m=r[3],g=a[3];m.subVectors(n,e),g.setFromPoints(m,i),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(s,e),this.needsUpdate=!1}}Ya.prototype.closestPointToSegment=function(){const x=new ee,e=new ee,t=new To;return function(n,i=null,r=null){const{start:a,end:s}=n,l=this.points;let c,h=1/0;for(let d=0;d<3;d++){const p=(d+1)%3;t.start.copy(l[d]),t.end.copy(l[p]),Kw(t,n,x,e),c=x.distanceToSquared(e),c<h&&(h=c,i&&i.copy(x),r&&r.copy(e))}return this.closestPointToPoint(a,x),c=a.distanceToSquared(x),c<h&&(h=c,i&&i.copy(x),r&&r.copy(a)),this.closestPointToPoint(s,x),c=s.distanceToSquared(x),c<h&&(h=c,i&&i.copy(x),r&&r.copy(s)),Math.sqrt(h)}}(),Ya.prototype.intersectsTriangle=function(){const x=new Ya,e=new Array(3),t=new Array(3),n=new Fo,i=new Fo,r=new ee,a=new ee,s=new ee,l=new ee,c=new ee,h=new To,d=new To,p=new To,m=new ee;function g(_,v,b){const T=_.points;let E=0,A=-1;for(let M=0;M<3;M++){const{start:R,end:C}=h;R.copy(T[M]),C.copy(T[(M+1)%3]),h.delta(a);const k=HS(v.distanceToPoint(R));if(HS(v.normal.dot(a))&&k){b.copy(h),E=2;break}const P=v.intersectLine(h,m);if(!P&&k&&m.copy(R),(P||k)&&!HS(m.distanceTo(C))){if(E<=1)(E===1?b.start:b.end).copy(m),k&&(A=E);else if(E>=2){(A===1?b.start:b.end).copy(m),E=2;break}if(E++,E===2&&A===-1)break}}return E}return function(_,v=null,b=!1){this.needsUpdate&&this.update(),_.isExtendedTriangle?_.needsUpdate&&_.update():(x.copy(_),x.update(),_=x);const T=this.plane,E=_.plane;if(Math.abs(T.normal.dot(E.normal))>1-1e-10){const A=this.satBounds,M=this.satAxes;t[0]=_.a,t[1]=_.b,t[2]=_.c;for(let k=0;k<4;k++){const P=A[k],N=M[k];if(n.setFromPoints(N,t),P.isSeparated(n))return!1}const R=_.satBounds,C=_.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let k=0;k<4;k++){const P=R[k],N=C[k];if(n.setFromPoints(N,e),P.isSeparated(n))return!1}for(let k=0;k<4;k++){const P=M[k];for(let N=0;N<4;N++){const G=C[N];if(r.crossVectors(P,G),n.setFromPoints(r,e),i.setFromPoints(r,t),n.isSeparated(i))return!1}}return v&&(b||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),v.start.set(0,0,0),v.end.set(0,0,0)),!0}else{const A=g(this,E,d);if(A===1&&_.containsPoint(d.end))return v&&(v.start.copy(d.end),v.end.copy(d.end)),!0;if(A!==2)return!1;const M=g(_,T,p);if(M===1&&this.containsPoint(p.end))return v&&(v.start.copy(p.end),v.end.copy(p.end)),!0;if(M!==2)return!1;if(d.delta(s),p.delta(l),s.dot(l)<0){let te=p.start;p.start=p.end,p.end=te}const R=d.start.dot(s),C=d.end.dot(s),k=p.start.dot(s),P=p.end.dot(s),N=C<k,G=R<P;return R!==P&&k!==C&&N===G?!1:(v&&(c.subVectors(d.start,p.start),c.dot(s)>0?v.start.copy(d.start):v.start.copy(p.start),c.subVectors(d.end,p.end),c.dot(s)<0?v.end.copy(d.end):v.end.copy(p.end)),!0)}}}(),Ya.prototype.distanceToPoint=function(){const x=new ee;return function(e){return this.closestPointToPoint(e,x),e.distanceTo(x)}}(),Ya.prototype.distanceToTriangle=function(){const x=new ee,e=new ee,t=["a","b","c"],n=new To,i=new To;return function(r,a=null,s=null){const l=a||s?n:null;if(this.intersectsTriangle(r,l))return(a||s)&&(a&&l.getCenter(a),s&&l.getCenter(s)),0;let c=1/0;for(let h=0;h<3;h++){let d;const p=t[h],m=r[p];this.closestPointToPoint(m,x),d=m.distanceToSquared(x),d<c&&(c=d,a&&a.copy(x),s&&s.copy(m));const g=this[p];r.closestPointToPoint(g,x),d=g.distanceToSquared(x),d<c&&(c=d,a&&a.copy(g),s&&s.copy(x))}for(let h=0;h<3;h++){const d=t[h],p=t[(h+1)%3];n.set(this[d],this[p]);for(let m=0;m<3;m++){const g=t[m],_=t[(m+1)%3];i.set(r[g],r[_]),Kw(n,i,x,e);const v=x.distanceToSquared(e);v<c&&(c=v,a&&a.copy(x),s&&s.copy(e))}}return Math.sqrt(c)}}();class Ei{constructor(e,t,n){this.isOrientedBox=!0,this.min=new ee,this.max=new ee,this.matrix=new f0,this.invMatrix=new f0,this.points=new Array(8).fill().map(()=>new ee),this.satAxes=new Array(3).fill().map(()=>new ee),this.satBounds=new Array(3).fill().map(()=>new Fo),this.alignedSatBounds=new Array(3).fill().map(()=>new Fo),this.needsUpdate=!1,e&&this.min.copy(e),t&&this.max.copy(t),n&&this.matrix.copy(n)}set(e,t,n){this.min.copy(e),this.max.copy(t),this.matrix.copy(n),this.needsUpdate=!0}copy(e){this.min.copy(e.min),this.max.copy(e.max),this.matrix.copy(e.matrix),this.needsUpdate=!0}}Ei.prototype.update=function(){return function(){const x=this.matrix,e=this.min,t=this.max,n=this.points;for(let l=0;l<=1;l++)for(let c=0;c<=1;c++)for(let h=0;h<=1;h++){const d=1*l|2*c|4*h,p=n[d];p.x=l?t.x:e.x,p.y=c?t.y:e.y,p.z=h?t.z:e.z,p.applyMatrix4(x)}const i=this.satBounds,r=this.satAxes,a=n[0];for(let l=0;l<3;l++){const c=r[l],h=i[l],d=1<<l,p=n[d];c.subVectors(a,p),h.setFromPoints(c,n)}const s=this.alignedSatBounds;s[0].setFromPointsField(n,"x"),s[1].setFromPointsField(n,"y"),s[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),Ei.prototype.intersectsBox=function(){const x=new Fo;return function(e){this.needsUpdate&&this.update();const t=e.min,n=e.max,i=this.satBounds,r=this.satAxes,a=this.alignedSatBounds;if(x.min=t.x,x.max=n.x,a[0].isSeparated(x)||(x.min=t.y,x.max=n.y,a[1].isSeparated(x))||(x.min=t.z,x.max=n.z,a[2].isSeparated(x)))return!1;for(let s=0;s<3;s++){const l=r[s],c=i[s];if(x.setFromBox(l,e),c.isSeparated(x))return!1}return!0}}(),Ei.prototype.intersectsTriangle=function(){const x=new Ya,e=new Array(3),t=new Fo,n=new Fo,i=new ee;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(x.copy(r),x.update(),r=x);const a=this.satBounds,s=this.satAxes;e[0]=r.a,e[1]=r.b,e[2]=r.c;for(let d=0;d<3;d++){const p=a[d],m=s[d];if(t.setFromPoints(m,e),p.isSeparated(t))return!1}const l=r.satBounds,c=r.satAxes,h=this.points;for(let d=0;d<3;d++){const p=l[d],m=c[d];if(t.setFromPoints(m,h),p.isSeparated(t))return!1}for(let d=0;d<3;d++){const p=s[d];for(let m=0;m<4;m++){const g=c[m];if(i.crossVectors(p,g),t.setFromPoints(i,e),n.setFromPoints(i,h),t.isSeparated(n))return!1}}return!0}}(),Ei.prototype.closestPointToPoint=function(){return function(x,e){return this.needsUpdate&&this.update(),e.copy(x).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),Ei.prototype.distanceToPoint=function(){const x=new ee;return function(e){return this.closestPointToPoint(e,x),e.distanceTo(x)}}(),Ei.prototype.distanceToBox=function(){const x=["x","y","z"],e=new Array(12).fill().map(()=>new To),t=new Array(12).fill().map(()=>new To),n=new ee,i=new ee;return function(r,a=0,s=null,l=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(s||l)&&(r.getCenter(i),this.closestPointToPoint(i,n),r.closestPointToPoint(n,i),s&&s.copy(n),l&&l.copy(i)),0;const c=a*a,h=r.min,d=r.max,p=this.points;let m=1/0;for(let _=0;_<8;_++){const v=p[_];i.copy(v).clamp(h,d);const b=v.distanceToSquared(i);if(b<m&&(m=b,s&&s.copy(v),l&&l.copy(i),b<c))return Math.sqrt(b)}let g=0;for(let _=0;_<3;_++)for(let v=0;v<=1;v++)for(let b=0;b<=1;b++){const T=(_+1)%3,E=(_+2)%3,A=v<<T|b<<E,M=1<<_|v<<T|b<<E,R=p[A],C=p[M];e[g].set(R,C);const k=x[_],P=x[T],N=x[E],G=t[g],te=G.start,j=G.end;te[k]=h[k],te[P]=v?h[P]:d[P],te[N]=b?h[N]:d[P],j[k]=d[k],j[P]=v?h[P]:d[P],j[N]=b?h[N]:d[P],g++}for(let _=0;_<=1;_++)for(let v=0;v<=1;v++)for(let b=0;b<=1;b++){i.x=_?d.x:h.x,i.y=v?d.y:h.y,i.z=b?d.z:h.z,this.closestPointToPoint(i,n);const T=i.distanceToSquared(n);if(T<m&&(m=T,s&&s.copy(n),l&&l.copy(i),T<c))return Math.sqrt(T)}for(let _=0;_<12;_++){const v=e[_];for(let b=0;b<12;b++){const T=t[b];Kw(v,T,n,i);const E=n.distanceToSquared(i);if(E<m&&(m=E,s&&s.copy(n),l&&l.copy(i),E<c))return Math.sqrt(E)}}return Math.sqrt(m)}}();class P2e{constructor(e){this._getNewPrimitive=e,this._primitives=[]}getPrimitive(){const e=this._primitives;return e.length===0?this._getNewPrimitive():e.pop()}releasePrimitive(e){this._primitives.push(e)}}class k2e extends P2e{constructor(){super(()=>new Ya)}}new k2e;class U2e{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const e=[];let t=null;this.setBuffer=n=>{t&&e.push(t),t=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{t=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,e.length!==0&&this.setBuffer(e.pop())}}}const nz=new U2e;new ee;new ee;new ee;new ee;new ee;new Pt;new Pt;new Pt;new ee;new ee;new ee;new ee;new pi;new Ya;new Ya;new f0;new Ei;new Ei;new f0;new Ei;new Ei;new ee;new ee;new ee;new ee;new pi;new Ya;new Ya;new f0;new Ei;new Ei;new f0;new Ei;new Ei;new ee;new ee;new ee;new ee;new nz.constructor;new nz.constructor;new pi;new pi;new pi;new pi;new Ei;new pi;function GP(x,e){if(e===use)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),x;if(e===Uw||e===FL){let t=x.getIndex();if(t===null){const a=[],s=x.getAttribute("position");if(s!==void 0){for(let l=0;l<s.count;l++)a.push(l);x.setIndex(a),t=x.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),x}const n=t.count-2,i=[];if(e===Uw)for(let a=1;a<=n;a++)i.push(t.getX(0)),i.push(t.getX(a)),i.push(t.getX(a+1));else for(let a=0;a<n;a++)a%2===0?(i.push(t.getX(a)),i.push(t.getX(a+1)),i.push(t.getX(a+2))):(i.push(t.getX(a+2)),i.push(t.getX(a+1)),i.push(t.getX(a)));i.length/3!==n&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=x.clone();return r.setIndex(i),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),x}class F2e extends ml{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new H2e(t)}),this.register(function(t){return new G2e(t)}),this.register(function(t){return new j2e(t)}),this.register(function(t){return new q2e(t)}),this.register(function(t){return new ele(t)}),this.register(function(t){return new X2e(t)}),this.register(function(t){return new Y2e(t)}),this.register(function(t){return new K2e(t)}),this.register(function(t){return new $2e(t)}),this.register(function(t){return new V2e(t)}),this.register(function(t){return new Q2e(t)}),this.register(function(t){return new W2e(t)}),this.register(function(t){return new J2e(t)}),this.register(function(t){return new Z2e(t)}),this.register(function(t){return new L2e(t)}),this.register(function(t){return new tle(t)}),this.register(function(t){return new xle(t)})}load(e,t,n,i){const r=this;let a;if(this.resourcePath!=="")a=this.resourcePath;else if(this.path!==""){const c=Hf.extractUrlBase(e);a=Hf.resolveURL(c,this.path)}else a=Hf.extractUrlBase(e);this.manager.itemStart(e);const s=function(c){i?i(c):console.error(c),r.manager.itemError(e),r.manager.itemEnd(e)},l=new _v(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{r.parse(c,a,function(h){t(h),r.manager.itemEnd(e)},s)}catch(h){s(h)}},n,s)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,i){let r;const a={},s={},l=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.decode(new Uint8Array(e,0,4))===iz){try{a[I0.KHR_BINARY_GLTF]=new nle(e)}catch(d){i&&i(d);return}r=JSON.parse(a[I0.KHR_BINARY_GLTF].content)}else r=JSON.parse(l.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new mle(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const d=this.pluginCallbacks[h](c);d.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),s[d.name]=d,a[d.name]=!0}if(r.extensionsUsed)for(let h=0;h<r.extensionsUsed.length;++h){const d=r.extensionsUsed[h],p=r.extensionsRequired||[];switch(d){case I0.KHR_MATERIALS_UNLIT:a[d]=new z2e;break;case I0.KHR_DRACO_MESH_COMPRESSION:a[d]=new ile(r,this.dracoLoader);break;case I0.KHR_TEXTURE_TRANSFORM:a[d]=new rle;break;case I0.KHR_MESH_QUANTIZATION:a[d]=new ale;break;default:p.indexOf(d)>=0&&s[d]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+d+'".')}}c.setExtensions(a),c.setPlugins(s),c.parse(n,i)}parseAsync(e,t){const n=this;return new Promise(function(i,r){n.parse(e,t,i,r)})}}function B2e(){let x={};return{get:function(e){return x[e]},add:function(e,t){x[e]=t},remove:function(e){delete x[e]},removeAll:function(){x={}}}}const I0={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class L2e{constructor(e){this.parser=e,this.name=I0.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let n=0,i=t.length;n<i;n++){const r=t[n];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,n="light:"+e;let i=t.cache.get(n);if(i)return i;const r=t.json,l=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let c;const h=new yn(16777215);l.color!==void 0&&h.setRGB(l.color[0],l.color[1],l.color[2],kr);const d=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new s2e(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new xz(h),c.distance=d;break;case"spot":c=new i2e(h),c.distance=d,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,vo(c,l),l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),i=Promise.resolve(c),t.cache.add(n,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,n=this.parser,r=n.json.nodes[e],s=(r.extensions&&r.extensions[this.name]||{}).light;return s===void 0?null:this._loadLight(s).then(function(l){return n._getNodeRef(t.cache,s,l)})}}class z2e{constructor(){this.name=I0.KHR_MATERIALS_UNLIT}getMaterialType(){return nh}extendParams(e,t,n){const i=[];e.color=new yn(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const a=r.baseColorFactor;e.color.setRGB(a[0],a[1],a[2],kr),e.opacity=a[3]}r.baseColorTexture!==void 0&&i.push(n.assignTexture(e,"map",r.baseColorTexture,Er))}return Promise.all(i)}}class V2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class H2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(t.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(r.push(n.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const s=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Pt(s,s)}return Promise.all(r)}}class G2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_DISPERSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.dispersion=r.dispersion!==void 0?r.dispersion:0,Promise.resolve()}}class W2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.iridescenceFactor!==void 0&&(t.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(t.iridescenceIOR=a.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&r.push(n.assignTexture(t,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(r)}}class X2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_SHEEN}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new yn(0,0,0),t.sheenRoughness=0,t.sheen=1;const a=i.extensions[this.name];if(a.sheenColorFactor!==void 0){const s=a.sheenColorFactor;t.sheenColor.setRGB(s[0],s[1],s[2],kr)}return a.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&r.push(n.assignTexture(t,"sheenColorMap",a.sheenColorTexture,Er)),a.sheenRoughnessTexture!==void 0&&r.push(n.assignTexture(t,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(r)}}class Y2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(t.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&r.push(n.assignTexture(t,"transmissionMap",a.transmissionTexture)),Promise.all(r)}}class K2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_VOLUME}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];t.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&r.push(n.assignTexture(t,"thicknessMap",a.thicknessTexture)),t.attenuationDistance=a.attenuationDistance||1/0;const s=a.attenuationColor||[1,1,1];return t.attenuationColor=new yn().setRGB(s[0],s[1],s[2],kr),Promise.all(r)}}class $2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_IOR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class Q2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_SPECULAR}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];t.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&r.push(n.assignTexture(t,"specularIntensityMap",a.specularTexture));const s=a.specularColorFactor||[1,1,1];return t.specularColor=new yn().setRGB(s[0],s[1],s[2],kr),a.specularColorTexture!==void 0&&r.push(n.assignTexture(t,"specularColorMap",a.specularColorTexture,Er)),Promise.all(r)}}class Z2e{constructor(e){this.parser=e,this.name=I0.EXT_MATERIALS_BUMP}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return t.bumpScale=a.bumpFactor!==void 0?a.bumpFactor:1,a.bumpTexture!==void 0&&r.push(n.assignTexture(t,"bumpMap",a.bumpTexture)),Promise.all(r)}}class J2e{constructor(e){this.parser=e,this.name=I0.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const n=this.parser.json.materials[e];return!n.extensions||!n.extensions[this.name]?null:ks}extendMaterialParams(e,t){const n=this.parser,i=n.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.anisotropyStrength!==void 0&&(t.anisotropy=a.anisotropyStrength),a.anisotropyRotation!==void 0&&(t.anisotropyRotation=a.anisotropyRotation),a.anisotropyTexture!==void 0&&r.push(n.assignTexture(t,"anisotropyMap",a.anisotropyTexture)),Promise.all(r)}}class j2e{constructor(e){this.parser=e,this.name=I0.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,n=t.json,i=n.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const r=i.extensions[this.name],a=t.options.ktx2Loader;if(!a){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,a)}}class q2e{constructor(e){this.parser=e,this.name=I0.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const a=r.extensions[t],s=i.images[a.source];let l=n.textureLoader;if(s.uri){const c=n.options.manager.getHandler(s.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ele{constructor(e){this.parser=e,this.name=I0.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,n=this.parser,i=n.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const a=r.extensions[t],s=i.images[a.source];let l=n.textureLoader;if(s.uri){const c=n.options.manager.getHandler(s.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return n.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return n.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class tle{constructor(e){this.name=I0.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,n=t.bufferViews[e];if(n.extensions&&n.extensions[this.name]){const i=n.extensions[this.name],r=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(s){const l=i.byteOffset||0,c=i.byteLength||0,h=i.count,d=i.byteStride,p=new Uint8Array(s,l,c);return a.decodeGltfBufferAsync?a.decodeGltfBufferAsync(h,d,p,i.mode,i.filter).then(function(m){return m.buffer}):a.ready.then(function(){const m=new ArrayBuffer(h*d);return a.decodeGltfBuffer(new Uint8Array(m),h,d,p,i.mode,i.filter),m})})}else return null}}class xle{constructor(e){this.name=I0.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,n=t.nodes[e];if(!n.extensions||!n.extensions[this.name]||n.mesh===void 0)return null;const i=t.meshes[n.mesh];for(const c of i.primitives)if(c.mode!==la.TRIANGLES&&c.mode!==la.TRIANGLE_STRIP&&c.mode!==la.TRIANGLE_FAN&&c.mode!==void 0)return null;const a=n.extensions[this.name].attributes,s=[],l={};for(const c in a)s.push(this.parser.getDependency("accessor",a[c]).then(h=>(l[c]=h,l[c])));return s.length<1?null:(s.push(this.parser.createNodeMesh(e)),Promise.all(s).then(c=>{const h=c.pop(),d=h.isGroup?h.children:[h],p=c[0].count,m=[];for(const g of d){const _=new f0,v=new ee,b=new Ns,T=new ee(1,1,1),E=new aoe(g.geometry,g.material,p);for(let A=0;A<p;A++)l.TRANSLATION&&v.fromBufferAttribute(l.TRANSLATION,A),l.ROTATION&&b.fromBufferAttribute(l.ROTATION,A),l.SCALE&&T.fromBufferAttribute(l.SCALE,A),E.setMatrixAt(A,_.compose(v,b,T));for(const A in l)if(A==="_COLOR_0"){const M=l[A];E.instanceColor=new Vw(M.array,M.itemSize,M.normalized)}else A!=="TRANSLATION"&&A!=="ROTATION"&&A!=="SCALE"&&g.geometry.setAttribute(A,l[A]);en.prototype.copy.call(E,g),this.parser.assignFinalMaterial(E),m.push(E)}return h.isGroup?(h.clear(),h.add(...m),h):m[0]}))}}const iz="glTF",wf=12,WP={JSON:1313821514,BIN:5130562};class nle{constructor(e){this.name=I0.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,wf),n=new TextDecoder;if(this.header={magic:n.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==iz)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-wf,r=new DataView(e,wf);let a=0;for(;a<i;){const s=r.getUint32(a,!0);a+=4;const l=r.getUint32(a,!0);if(a+=4,l===WP.JSON){const c=new Uint8Array(e,wf+a,s);this.content=n.decode(c)}else if(l===WP.BIN){const c=wf+a;this.body=e.slice(c,c+s)}a+=s}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class ile{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=I0.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const n=this.json,i=this.dracoLoader,r=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,s={},l={},c={};for(const h in a){const d=$w[h]||h.toLowerCase();s[d]=a[h]}for(const h in e.attributes){const d=$w[h]||h.toLowerCase();if(a[h]!==void 0){const p=n.accessors[e.attributes[h]],m=vh[p.componentType];c[d]=m.name,l[d]=p.normalized===!0}}return t.getDependency("bufferView",r).then(function(h){return new Promise(function(d,p){i.decodeDracoFile(h,function(m){for(const g in m.attributes){const _=m.attributes[g],v=l[g];v!==void 0&&(_.normalized=v)}d(m)},s,c,kr,p)})})}}class rle{constructor(){this.name=I0.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class ale{constructor(){this.name=I0.KHR_MESH_QUANTIZATION}}class rz extends Pp{constructor(e,t,n,i){super(e,t,n,i)}copySampleValue_(e){const t=this.resultBuffer,n=this.sampleValues,i=this.valueSize,r=e*i*3+i;for(let a=0;a!==i;a++)t[a]=n[r+a];return t}interpolate_(e,t,n,i){const r=this.resultBuffer,a=this.sampleValues,s=this.valueSize,l=s*2,c=s*3,h=i-t,d=(n-t)/h,p=d*d,m=p*d,g=e*c,_=g-c,v=-2*m+3*p,b=m-p,T=1-v,E=b-p+d;for(let A=0;A!==s;A++){const M=a[_+A+s],R=a[_+A+l]*h,C=a[g+A+s],k=a[g+A]*h;r[A]=T*M+E*R+v*C+b*k}return r}}const sle=new Ns;class ole extends rz{interpolate_(e,t,n,i){const r=super.interpolate_(e,t,n,i);return sle.fromArray(r).normalize().toArray(r),r}}const la={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},vh={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},XP={9728:kw,9729:J2,9984:rse,9985:sse,9986:ase,9987:yv},YP={33071:uc,33648:Pw,10497:tp},GS={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},$w={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},k2={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},lle={CUBICSPLINE:void 0,LINEAR:np,STEP:xp},WS={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function cle(x){return x.DefaultMaterial===void 0&&(x.DefaultMaterial=new lp({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:ng})),x.DefaultMaterial}function Ql(x,e,t){for(const n in t.extensions)x[n]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[n]=t.extensions[n])}function vo(x,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(x.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function ule(x,e,t){let n=!1,i=!1,r=!1;for(let c=0,h=e.length;c<h;c++){const d=e[c];if(d.POSITION!==void 0&&(n=!0),d.NORMAL!==void 0&&(i=!0),d.COLOR_0!==void 0&&(r=!0),n&&i&&r)break}if(!n&&!i&&!r)return Promise.resolve(x);const a=[],s=[],l=[];for(let c=0,h=e.length;c<h;c++){const d=e[c];if(n){const p=d.POSITION!==void 0?t.getDependency("accessor",d.POSITION):x.attributes.position;a.push(p)}if(i){const p=d.NORMAL!==void 0?t.getDependency("accessor",d.NORMAL):x.attributes.normal;s.push(p)}if(r){const p=d.COLOR_0!==void 0?t.getDependency("accessor",d.COLOR_0):x.attributes.color;l.push(p)}}return Promise.all([Promise.all(a),Promise.all(s),Promise.all(l)]).then(function(c){const h=c[0],d=c[1],p=c[2];return n&&(x.morphAttributes.position=h),i&&(x.morphAttributes.normal=d),r&&(x.morphAttributes.color=p),x.morphTargetsRelative=!0,x})}function hle(x,e){if(x.updateMorphTargets(),e.weights!==void 0)for(let t=0,n=e.weights.length;t<n;t++)x.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(x.morphTargetInfluences.length===t.length){x.morphTargetDictionary={};for(let n=0,i=t.length;n<i;n++)x.morphTargetDictionary[t[n]]=n}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function dle(x){let e;const t=x.extensions&&x.extensions[I0.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+XS(t.attributes):e=x.indices+":"+XS(x.attributes)+":"+x.mode,x.targets!==void 0)for(let n=0,i=x.targets.length;n<i;n++)e+=":"+XS(x.targets[n]);return e}function XS(x){let e="";const t=Object.keys(x).sort();for(let n=0,i=t.length;n<i;n++)e+=t[n]+":"+x[t[n]]+";";return e}function Qw(x){switch(x){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function fle(x){return x.search(/\.jpe?g($|\?)/i)>0||x.search(/^data\:image\/jpeg/)===0?"image/jpeg":x.search(/\.webp($|\?)/i)>0||x.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const ple=new f0;class mle{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new B2e,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let n=!1,i=-1,r=!1,a=-1;if(typeof navigator<"u"){const s=navigator.userAgent;n=/^((?!chrome|android).)*safari/i.test(s)===!0;const l=s.match(/Version\/(\d+)/);i=n&&l?parseInt(l[1],10):-1,r=s.indexOf("Firefox")>-1,a=r?s.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||n&&i<17||r&&a<98?this.textureLoader=new x2e(this.options.manager):this.textureLoader=new l2e(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new _v(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const n=this,i=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([n.getDependencies("scene"),n.getDependencies("animation"),n.getDependencies("camera")])}).then(function(a){const s={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:n,userData:{}};return Ql(r,s,i),vo(s,i),Promise.all(n._invokeAll(function(l){return l.afterRoot&&l.afterRoot(s)})).then(function(){for(const l of s.scenes)l.updateMatrixWorld();e(s)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],n=this.json.meshes||[];for(let i=0,r=t.length;i<r;i++){const a=t[i].joints;for(let s=0,l=a.length;s<l;s++)e[a[s]].isBone=!0}for(let i=0,r=e.length;i<r;i++){const a=e[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(n[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,n){if(e.refs[t]<=1)return n;const i=n.clone(),r=(a,s)=>{const l=this.associations.get(a);l!=null&&this.associations.set(s,l);for(const[c,h]of a.children.entries())r(h,s.children[c])};return r(n,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let n=0;n<t.length;n++){const i=e(t[n]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const n=[];for(let i=0;i<t.length;i++){const r=e(t[i]);r&&n.push(r)}return n}getDependency(e,t){const n=e+":"+t;let i=this.cache.get(n);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":i=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(n,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const n=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(r,a){return n.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],n=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[I0.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(r,a){n.load(Hf.resolveURL(t.uri,i.path),r,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(n){const i=t.byteLength||0,r=t.byteOffset||0;return n.slice(r,r+i)})}loadAccessor(e){const t=this,n=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const a=GS[i.type],s=vh[i.componentType],l=i.normalized===!0,c=new s(i.count*a);return Promise.resolve(new Za(c,a,l))}const r=[];return i.bufferView!==void 0?r.push(this.getDependency("bufferView",i.bufferView)):r.push(null),i.sparse!==void 0&&(r.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(r).then(function(a){const s=a[0],l=GS[i.type],c=vh[i.componentType],h=c.BYTES_PER_ELEMENT,d=h*l,p=i.byteOffset||0,m=i.bufferView!==void 0?n.bufferViews[i.bufferView].byteStride:void 0,g=i.normalized===!0;let _,v;if(m&&m!==d){const b=Math.floor(p/m),T="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+b+":"+i.count;let E=t.cache.get(T);E||(_=new c(s,b*m,i.count*m/h),E=new xoe(_,m/h),t.cache.add(T,E)),v=new kM(E,l,p%m/h,g)}else s===null?_=new c(i.count*l):_=new c(s,p,i.count*l),v=new Za(_,l,g);if(i.sparse!==void 0){const b=GS.SCALAR,T=vh[i.sparse.indices.componentType],E=i.sparse.indices.byteOffset||0,A=i.sparse.values.byteOffset||0,M=new T(a[1],E,i.sparse.count*b),R=new c(a[2],A,i.sparse.count*l);s!==null&&(v=new Za(v.array.slice(),v.itemSize,v.normalized));for(let C=0,k=M.length;C<k;C++){const P=M[C];if(v.setX(P,R[C*l]),l>=2&&v.setY(P,R[C*l+1]),l>=3&&v.setZ(P,R[C*l+2]),l>=4&&v.setW(P,R[C*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(e){const t=this.json,n=this.options,r=t.textures[e].source,a=t.images[r];let s=this.textureLoader;if(a.uri){const l=n.manager.getHandler(a.uri);l!==null&&(s=l)}return this.loadTextureImage(e,r,s)}loadTextureImage(e,t,n){const i=this,r=this.json,a=r.textures[e],s=r.images[t],l=(s.uri||s.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,n).then(function(h){h.flipY=!1,h.name=a.name||s.name||"",h.name===""&&typeof s.uri=="string"&&s.uri.startsWith("data:image/")===!1&&(h.name=s.uri);const p=(r.samplers||{})[a.sampler]||{};return h.magFilter=XP[p.magFilter]||J2,h.minFilter=XP[p.minFilter]||yv,h.wrapS=YP[p.wrapS]||tp,h.wrapT=YP[p.wrapT]||tp,i.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const n=this,i=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(d=>d.clone());const a=i.images[e],s=self.URL||self.webkitURL;let l=a.uri||"",c=!1;if(a.bufferView!==void 0)l=n.getDependency("bufferView",a.bufferView).then(function(d){c=!0;const p=new Blob([d],{type:a.mimeType});return l=s.createObjectURL(p),l});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(l).then(function(d){return new Promise(function(p,m){let g=p;t.isImageBitmapLoader===!0&&(g=function(_){const v=new Qa(_);v.needsUpdate=!0,p(v)}),t.load(Hf.resolveURL(d,r.path),g,void 0,m)})}).then(function(d){return c===!0&&s.revokeObjectURL(l),vo(d,a),d.userData.mimeType=a.mimeType||fle(a.uri),d}).catch(function(d){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),d});return this.sourceCache[e]=h,h}assignTexture(e,t,n,i){const r=this;return this.getDependency("texture",n.index).then(function(a){if(!a)return null;if(n.texCoord!==void 0&&n.texCoord>0&&(a=a.clone(),a.channel=n.texCoord),r.extensions[I0.KHR_TEXTURE_TRANSFORM]){const s=n.extensions!==void 0?n.extensions[I0.KHR_TEXTURE_TRANSFORM]:void 0;if(s){const l=r.associations.get(a);a=r.extensions[I0.KHR_TEXTURE_TRANSFORM].extendTexture(a,s),r.associations.set(a,l)}}return i!==void 0&&(a.colorSpace=i),e[t]=a,a})}assignFinalMaterial(e){const t=e.geometry;let n=e.material;const i=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,a=t.attributes.normal===void 0;if(e.isPoints){const s="PointsMaterial:"+n.uuid;let l=this.cache.get(s);l||(l=new YL,pc.prototype.copy.call(l,n),l.color.copy(n.color),l.map=n.map,l.sizeAttenuation=!1,this.cache.add(s,l)),n=l}else if(e.isLine){const s="LineBasicMaterial:"+n.uuid;let l=this.cache.get(s);l||(l=new XL,pc.prototype.copy.call(l,n),l.color.copy(n.color),l.map=n.map,this.cache.add(s,l)),n=l}if(i||r||a){let s="ClonedMaterial:"+n.uuid+":";i&&(s+="derivative-tangents:"),r&&(s+="vertex-colors:"),a&&(s+="flat-shading:");let l=this.cache.get(s);l||(l=n.clone(),r&&(l.vertexColors=!0),a&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(s,l),this.associations.set(l,this.associations.get(n))),n=l}e.material=n}getMaterialType(){return lp}loadMaterial(e){const t=this,n=this.json,i=this.extensions,r=n.materials[e];let a;const s={},l=r.extensions||{},c=[];if(l[I0.KHR_MATERIALS_UNLIT]){const d=i[I0.KHR_MATERIALS_UNLIT];a=d.getMaterialType(),c.push(d.extendParams(s,r,t))}else{const d=r.pbrMetallicRoughness||{};if(s.color=new yn(1,1,1),s.opacity=1,Array.isArray(d.baseColorFactor)){const p=d.baseColorFactor;s.color.setRGB(p[0],p[1],p[2],kr),s.opacity=p[3]}d.baseColorTexture!==void 0&&c.push(t.assignTexture(s,"map",d.baseColorTexture,Er)),s.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,s.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(s,"metalnessMap",d.metallicRoughnessTexture)),c.push(t.assignTexture(s,"roughnessMap",d.metallicRoughnessTexture))),a=this._invokeOne(function(p){return p.getMaterialType&&p.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(p){return p.extendMaterialParams&&p.extendMaterialParams(e,s)})))}r.doubleSided===!0&&(s.side=tse);const h=r.alphaMode||WS.OPAQUE;if(h===WS.BLEND?(s.transparent=!0,s.depthWrite=!1):(s.transparent=!1,h===WS.MASK&&(s.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&a!==nh&&(c.push(t.assignTexture(s,"normalMap",r.normalTexture)),s.normalScale=new Pt(1,1),r.normalTexture.scale!==void 0)){const d=r.normalTexture.scale;s.normalScale.set(d,d)}if(r.occlusionTexture!==void 0&&a!==nh&&(c.push(t.assignTexture(s,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(s.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&a!==nh){const d=r.emissiveFactor;s.emissive=new yn().setRGB(d[0],d[1],d[2],kr)}return r.emissiveTexture!==void 0&&a!==nh&&c.push(t.assignTexture(s,"emissiveMap",r.emissiveTexture,Er)),Promise.all(c).then(function(){const d=new a(s);return r.name&&(d.name=r.name),vo(d,r),t.associations.set(d,{materials:e}),r.extensions&&Ql(i,d,r),d})}createUniqueName(e){const t=ix.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,n=this.extensions,i=this.primitiveCache;function r(s){return n[I0.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(s,t).then(function(l){return KP(l,s,t)})}const a=[];for(let s=0,l=e.length;s<l;s++){const c=e[s],h=dle(c),d=i[h];if(d)a.push(d.promise);else{let p;c.extensions&&c.extensions[I0.KHR_DRACO_MESH_COMPRESSION]?p=r(c):p=KP(new Lc,c,t),i[h]={primitive:c,promise:p},a.push(p)}}return Promise.all(a)}loadMesh(e){const t=this,n=this.json,i=this.extensions,r=n.meshes[e],a=r.primitives,s=[];for(let l=0,c=a.length;l<c;l++){const h=a[l].material===void 0?cle(this.cache):this.getDependency("material",a[l].material);s.push(h)}return s.push(t.loadGeometries(a)),Promise.all(s).then(function(l){const c=l.slice(0,l.length-1),h=l[l.length-1],d=[];for(let m=0,g=h.length;m<g;m++){const _=h[m],v=a[m];let b;const T=c[m];if(v.mode===la.TRIANGLES||v.mode===la.TRIANGLE_STRIP||v.mode===la.TRIANGLE_FAN||v.mode===void 0)b=r.isSkinnedMesh===!0?new WL(_,T):new md(_,T),b.isSkinnedMesh===!0&&b.normalizeSkinWeights(),v.mode===la.TRIANGLE_STRIP?b.geometry=GP(b.geometry,FL):v.mode===la.TRIANGLE_FAN&&(b.geometry=GP(b.geometry,Uw));else if(v.mode===la.LINES)b=new soe(_,T);else if(v.mode===la.LINE_STRIP)b=new LM(_,T);else if(v.mode===la.LINE_LOOP)b=new ooe(_,T);else if(v.mode===la.POINTS)b=new loe(_,T);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(b.geometry.morphAttributes).length>0&&hle(b,r),b.name=t.createUniqueName(r.name||"mesh_"+e),vo(b,r),v.extensions&&Ql(i,b,v),t.assignFinalMaterial(b),d.push(b)}for(let m=0,g=d.length;m<g;m++)t.associations.set(d[m],{meshes:e,primitives:m});if(d.length===1)return r.extensions&&Ql(i,d[0],r),d[0];const p=new y1;r.extensions&&Ql(i,p,r),t.associations.set(p,{meshes:e});for(let m=0,g=d.length;m<g;m++)p.add(d[m]);return p})}loadCamera(e){let t;const n=this.json.cameras[e],i=n[n.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return n.type==="perspective"?t=new PM(Nse.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):n.type==="orthographic"&&(t=new GL(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),n.name&&(t.name=this.createUniqueName(n.name)),vo(t,n),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],n=[];for(let i=0,r=t.joints.length;i<r;i++)n.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?n.push(this.getDependency("accessor",t.inverseBindMatrices)):n.push(null),Promise.all(n).then(function(i){const r=i.pop(),a=i,s=[],l=[];for(let c=0,h=a.length;c<h;c++){const d=a[c];if(d){s.push(d);const p=new f0;r!==null&&p.fromArray(r.array,c*16),l.push(p)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new BM(s,l)})}loadAnimation(e){const t=this.json,n=this,i=t.animations[e],r=i.name?i.name:"animation_"+e,a=[],s=[],l=[],c=[],h=[];for(let d=0,p=i.channels.length;d<p;d++){const m=i.channels[d],g=i.samplers[m.sampler],_=m.target,v=_.node,b=i.parameters!==void 0?i.parameters[g.input]:g.input,T=i.parameters!==void 0?i.parameters[g.output]:g.output;_.node!==void 0&&(a.push(this.getDependency("node",v)),s.push(this.getDependency("accessor",b)),l.push(this.getDependency("accessor",T)),c.push(g),h.push(_))}return Promise.all([Promise.all(a),Promise.all(s),Promise.all(l),Promise.all(c),Promise.all(h)]).then(function(d){const p=d[0],m=d[1],g=d[2],_=d[3],v=d[4],b=[];for(let T=0,E=p.length;T<E;T++){const A=p[T],M=m[T],R=g[T],C=_[T],k=v[T];if(A===void 0)continue;A.updateMatrix&&A.updateMatrix();const P=n._createAnimationTracks(A,M,R,C,k);if(P)for(let N=0;N<P.length;N++)b.push(P[N])}return new $oe(r,void 0,b)})}createNodeMesh(e){const t=this.json,n=this,i=t.nodes[e];return i.mesh===void 0?null:n.getDependency("mesh",i.mesh).then(function(r){const a=n._getNodeRef(n.meshCache,i.mesh,r);return i.weights!==void 0&&a.traverse(function(s){if(s.isMesh)for(let l=0,c=i.weights.length;l<c;l++)s.morphTargetInfluences[l]=i.weights[l]}),a})}loadNode(e){const t=this.json,n=this,i=t.nodes[e],r=n._loadNodeShallow(e),a=[],s=i.children||[];for(let c=0,h=s.length;c<h;c++)a.push(n.getDependency("node",s[c]));const l=i.skin===void 0?Promise.resolve(null):n.getDependency("skin",i.skin);return Promise.all([r,Promise.all(a),l]).then(function(c){const h=c[0],d=c[1],p=c[2];p!==null&&h.traverse(function(m){m.isSkinnedMesh&&m.bind(p,ple)});for(let m=0,g=d.length;m<g;m++)h.add(d[m]);return h})}_loadNodeShallow(e){const t=this.json,n=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],a=r.name?i.createUniqueName(r.name):"",s=[],l=i._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&s.push(l),r.camera!==void 0&&s.push(i.getDependency("camera",r.camera).then(function(c){return i._getNodeRef(i.cameraCache,r.camera,c)})),i._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){s.push(c)}),this.nodeCache[e]=Promise.all(s).then(function(c){let h;if(r.isBone===!0?h=new UM:c.length>1?h=new y1:c.length===1?h=c[0]:h=new en,h!==c[0])for(let d=0,p=c.length;d<p;d++)h.add(c[d]);if(r.name&&(h.userData.name=r.name,h.name=a),vo(h,r),r.extensions&&Ql(n,h,r),r.matrix!==void 0){const d=new f0;d.fromArray(r.matrix),h.applyMatrix4(d)}else r.translation!==void 0&&h.position.fromArray(r.translation),r.rotation!==void 0&&h.quaternion.fromArray(r.rotation),r.scale!==void 0&&h.scale.fromArray(r.scale);return i.associations.has(h)||i.associations.set(h,{}),i.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,n=this.json.scenes[e],i=this,r=new y1;n.name&&(r.name=i.createUniqueName(n.name)),vo(r,n),n.extensions&&Ql(t,r,n);const a=n.nodes||[],s=[];for(let l=0,c=a.length;l<c;l++)s.push(i.getDependency("node",a[l]));return Promise.all(s).then(function(l){for(let h=0,d=l.length;h<d;h++)r.add(l[h]);const c=h=>{const d=new Map;for(const[p,m]of i.associations)(p instanceof pc||p instanceof Qa)&&d.set(p,m);return h.traverse(p=>{const m=i.associations.get(p);m!=null&&d.set(p,m)}),d};return i.associations=c(r),r})}_createAnimationTracks(e,t,n,i,r){const a=[],s=e.name?e.name:e.uuid,l=[];k2[r.path]===k2.weights?e.traverse(function(p){p.morphTargetInfluences&&l.push(p.name?p.name:p.uuid)}):l.push(s);let c;switch(k2[r.path]){case k2.weights:c=Yh;break;case k2.rotation:c=Kh;break;case k2.position:case k2.scale:c=$h;break;default:switch(n.itemSize){case 1:c=Yh;break;case 2:case 3:default:c=$h;break}break}const h=i.interpolation!==void 0?lle[i.interpolation]:np,d=this._getArrayFromAccessor(n);for(let p=0,m=l.length;p<m;p++){const g=new c(l[p]+"."+k2[r.path],t.array,d,h);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(g),a.push(g)}return a}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const n=Qw(t.constructor),i=new Float32Array(t.length);for(let r=0,a=t.length;r<a;r++)i[r]=t[r]*n;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(n){const i=this instanceof Kh?ole:rz;return new i(this.times,this.values,this.getValueSize()/3,n)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function yle(x,e,t){const n=e.attributes,i=new pi;if(n.POSITION!==void 0){const s=t.json.accessors[n.POSITION],l=s.min,c=s.max;if(l!==void 0&&c!==void 0){if(i.set(new ee(l[0],l[1],l[2]),new ee(c[0],c[1],c[2])),s.normalized){const h=Qw(vh[s.componentType]);i.min.multiplyScalar(h),i.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const s=new ee,l=new ee;for(let c=0,h=r.length;c<h;c++){const d=r[c];if(d.POSITION!==void 0){const p=t.json.accessors[d.POSITION],m=p.min,g=p.max;if(m!==void 0&&g!==void 0){if(l.setX(Math.max(Math.abs(m[0]),Math.abs(g[0]))),l.setY(Math.max(Math.abs(m[1]),Math.abs(g[1]))),l.setZ(Math.max(Math.abs(m[2]),Math.abs(g[2]))),p.normalized){const _=Qw(vh[p.componentType]);l.multiplyScalar(_)}s.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(s)}x.boundingBox=i;const a=new is;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,x.boundingSphere=a}function KP(x,e,t){const n=e.attributes,i=[];function r(a,s){return t.getDependency("accessor",a).then(function(l){x.setAttribute(s,l)})}for(const a in n){const s=$w[a]||a.toLowerCase();s in x.attributes||i.push(r(n[a],s))}if(e.indices!==void 0&&!x.index){const a=t.getDependency("accessor",e.indices).then(function(s){x.setIndex(s)});i.push(a)}return Tr.workingColorSpace!==kr&&"COLOR_0"in n&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Tr.workingColorSpace}" not supported.`),vo(x,e),yle(x,e,t),Promise.all(i).then(function(){return e.targets!==void 0?ule(x,e.targets,t):x})}class gle extends t2e{constructor(e){super(e),this.type=by}parse(e){const a=function(k,P){switch(k){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(P||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(P||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(P||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(P||""))}},h=`
`,d=function(k,P,N){P=P||1024;let te=k.pos,j=-1,xe=0,ae="",H=String.fromCharCode.apply(null,new Uint16Array(k.subarray(te,te+128)));for(;0>(j=H.indexOf(h))&&xe<P&&te<k.byteLength;)ae+=H,xe+=H.length,te+=128,H+=String.fromCharCode.apply(null,new Uint16Array(k.subarray(te,te+128)));return-1<j?(k.pos+=xe+j+1,ae+H.slice(0,j)):!1},p=function(k){const P=/^#\?(\S+)/,N=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,G=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,te=/^\s*FORMAT=(\S+)\s*$/,j=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,xe={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let ae,H;for((k.pos>=k.byteLength||!(ae=d(k)))&&a(1,"no header found"),(H=ae.match(P))||a(3,"bad initial token"),xe.valid|=1,xe.programtype=H[1],xe.string+=ae+`
`;ae=d(k),ae!==!1;){if(xe.string+=ae+`
`,ae.charAt(0)==="#"){xe.comments+=ae+`
`;continue}if((H=ae.match(N))&&(xe.gamma=parseFloat(H[1])),(H=ae.match(G))&&(xe.exposure=parseFloat(H[1])),(H=ae.match(te))&&(xe.valid|=2,xe.format=H[1]),(H=ae.match(j))&&(xe.valid|=4,xe.height=parseInt(H[1],10),xe.width=parseInt(H[2],10)),xe.valid&2&&xe.valid&4)break}return xe.valid&2||a(3,"missing format specifier"),xe.valid&4||a(3,"missing image size specifier"),xe},m=function(k,P,N){const G=P;if(G<8||G>32767||k[0]!==2||k[1]!==2||k[2]&128)return new Uint8Array(k);G!==(k[2]<<8|k[3])&&a(3,"wrong scanline width");const te=new Uint8Array(4*P*N);te.length||a(4,"unable to allocate buffer space");let j=0,xe=0;const ae=4*G,H=new Uint8Array(4),re=new Uint8Array(ae);let q=N;for(;q>0&&xe<k.byteLength;){xe+4>k.byteLength&&a(1),H[0]=k[xe++],H[1]=k[xe++],H[2]=k[xe++],H[3]=k[xe++],(H[0]!=2||H[1]!=2||(H[2]<<8|H[3])!=G)&&a(3,"bad rgbe scanline format");let be=0,K;for(;be<ae&&xe<k.byteLength;){K=k[xe++];const ge=K>128;if(ge&&(K-=128),(K===0||be+K>ae)&&a(3,"bad scanline data"),ge){const Me=k[xe++];for(let le=0;le<K;le++)re[be++]=Me}else re.set(k.subarray(xe,xe+K),be),be+=K,xe+=K}const se=G;for(let ge=0;ge<se;ge++){let Me=0;te[j]=re[ge+Me],Me+=G,te[j+1]=re[ge+Me],Me+=G,te[j+2]=re[ge+Me],Me+=G,te[j+3]=re[ge+Me],j+=4}q--}return te},g=function(k,P,N,G){const te=k[P+3],j=Math.pow(2,te-128)/255;N[G+0]=k[P+0]*j,N[G+1]=k[P+1]*j,N[G+2]=k[P+2]*j,N[G+3]=1},_=function(k,P,N,G){const te=k[P+3],j=Math.pow(2,te-128)/255;N[G+0]=Cy.toHalfFloat(Math.min(k[P+0]*j,65504)),N[G+1]=Cy.toHalfFloat(Math.min(k[P+1]*j,65504)),N[G+2]=Cy.toHalfFloat(Math.min(k[P+2]*j,65504)),N[G+3]=Cy.toHalfFloat(1)},v=new Uint8Array(e);v.pos=0;const b=p(v),T=b.width,E=b.height,A=m(v.subarray(v.pos),T,E);let M,R,C;switch(this.type){case mh:C=A.length/4;const k=new Float32Array(C*4);for(let N=0;N<C;N++)g(A,N*4,k,N*4);M=k,R=mh;break;case by:C=A.length/4;const P=new Uint16Array(C*4);for(let N=0;N<C;N++)_(A,N*4,P,N*4);M=P,R=by;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:T,height:E,data:M,header:b.string,gamma:b.gamma,exposure:b.exposure,type:R}}setDataType(e){return this.type=e,this}load(e,t,n,i){function r(a,s){switch(a.type){case mh:case by:a.colorSpace=kr,a.minFilter=J2,a.magFilter=J2,a.generateMipmaps=!1,a.flipY=!0;break}t&&t(a,s)}return super.load(e,r,n,i)}}class vle extends ml{constructor(e){super(e)}load(e,t,n,i){const r=this,a=new _v(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(s){const l=r.parse(JSON.parse(s));t&&t(l)},n,i)}parse(e){return new ble(e)}}class ble{constructor(e){this.isFont=!0,this.type="Font",this.data=e}generateShapes(e,t=100){const n=[],i=_le(e,t,this.data);for(let r=0,a=i.length;r<a;r++)n.push(...i[r].toShapes());return n}}function _le(x,e,t){const n=Array.from(x),i=e/t.resolution,r=(t.boundingBox.yMax-t.boundingBox.yMin+t.underlineThickness)*i,a=[];let s=0,l=0;for(let c=0;c<n.length;c++){const h=n[c];if(h===`
`)s=0,l-=r;else{const d=Sle(h,i,s,l,t);s+=d.offsetX,a.push(d.path)}}return a}function Sle(x,e,t,n,i){const r=i.glyphs[x]||i.glyphs["?"];if(!r){console.error('THREE.Font: character "'+x+'" does not exists in font family '+i.familyName+".");return}const a=new v2e;let s,l,c,h,d,p,m,g;if(r.o){const _=r._cachedOutline||(r._cachedOutline=r.o.split(" "));for(let v=0,b=_.length;v<b;)switch(_[v++]){case"m":s=_[v++]*e+t,l=_[v++]*e+n,a.moveTo(s,l);break;case"l":s=_[v++]*e+t,l=_[v++]*e+n,a.lineTo(s,l);break;case"q":c=_[v++]*e+t,h=_[v++]*e+n,d=_[v++]*e+t,p=_[v++]*e+n,a.quadraticCurveTo(d,p,c,h);break;case"b":c=_[v++]*e+t,h=_[v++]*e+n,d=_[v++]*e+t,p=_[v++]*e+n,m=_[v++]*e+t,g=_[v++]*e+n,a.bezierCurveTo(d,p,m,g,c,h);break}}return{offsetX:r.ha*e,path:a}}class Tle extends HM{constructor(e,t={}){const n=t.font;if(n===void 0)super();else{const i=n.generateShapes(e,t.size);t.depth===void 0&&t.height!==void 0&&console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead"),t.depth=t.depth!==void 0?t.depth:t.height!==void 0?t.height:50,t.bevelThickness===void 0&&(t.bevelThickness=10),t.bevelSize===void 0&&(t.bevelSize=8),t.bevelEnabled===void 0&&(t.bevelEnabled=!1),super(i,t)}this.type="TextGeometry"}}class wle extends E2e{constructor(e,t,n,i="onesie.glb",r){super(e,t,n),this.url=i,this.outfit=r,this.lightInt=.75,this.ambientInt=1.25,this.handsUp=!1,this.plugin=new C2e(void 0,r),this.addPlugin(this.plugin)}async load(){if(!(this.loaded||!this.scene))return await this.setupScene(this.scene),super.load()}async setupScene(e){var s;await this.setModel(this.url),this.light=new xz(16777215,this.lightInt),this.ambient=new o2e(16777215,this.ambientInt),e.add(this.light),e.add(this.ambient);const t=await new gle().loadAsync("environment.hdr");t.mapping=ise,e.environment=t;const n=await new vle().loadAsync("font.json"),i=new Tle("HOORAY!!!",{font:n,size:5,height:2,bevelSize:.3,bevelThickness:1,bevelSegments:10,bevelEnabled:!0});i.scale(.01,.01,.01),i.computeBoundingBox();const r=i.boundingBox;r&&i.translate(...r.max.sub(r.min).multiplyScalar(-.5).toArray()),i.rotateY(Math.PI);const a=new md(i,[new lp({color:3922843,flatShading:!0}),new lp({color:3922843})]);this.textModel=new y1,this.textModel.visible=!1,this.textModel.add(a),(s=this.scene)==null||s.add(this.textModel)}async setModel(e){return this.setOutfit(e,this.outfit)}async setOutfit(e,t){var i;this.model&&this.disposeObject(this.model),delete this.model,this.url=e,this.outfit=t;const n=await new F2e().loadAsync(e);this.model=n.scene,(i=this.scene)==null||i.add(this.model),this.plugin.setOutfit(this.model,t)}async update(e,t){const n=e.poses[0];if(!n)return this.handsUp=!1,super.update(e,t);const{points:i}=n,r=new ee(...i.hipL.metric),a=new ee(...i.hipR.metric),s=new ee(...i.shoulderL.metric),l=new ee(...i.shoulderR.metric),c=new ee(...i.elbowL.metric),h=new ee(...i.elbowR.metric),d=new ee(...i.wristL.metric),p=new ee(...i.wristR.metric),m=s.clone().sub(r).normalize(),g=l.clone().sub(a).normalize(),_=c.clone().sub(s).normalize(),v=h.clone().sub(l).normalize(),b=d.clone().sub(c).normalize(),T=p.clone().sub(h).normalize(),E=m.dot(_),A=g.dot(v),M=b.dot(_),R=T.dot(v),C=Math.min(E,A,M,R);C>.8&&(this.handsUp=!0),C<.7&&(this.handsUp=!1);const{textModel:k}=this;if(k){const P=d.clone().lerp(p,.5);k.position.copy(P),k.visible=this.handsUp}await super.update(e,t)}}function Ale({wMargin:x=0,hMargin:e=0}){return Jn.useEffect(()=>{const t=new Vte,n=location.hostname==="localhost"?"AVSE9trnGfvPowd3z2f5cQW-FW87bF5t":"HiCltgzsHoEwIl02FxcrdhLy6wdabBmY";let r=new URLSearchParams(window.location.search).has("rear");const a={onesie:{file:"onesie.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Eye/,/Teeth/,/Footwear/]}},jacket:{file:"jacket.glb",avatar:!1,outfit:{occluders:[/Head$/,/Body/],hidden:[/Eye/,/Teeth/,/Bottom/,/Footwear/,/Glasses/]}}};let s="onesie",l=a.onesie.avatar;function c(){const d=document.createElement("div");d.className="boxes",d.id="spinner";for(let p=0;p<4;p++){const m=document.createElement("div");m.className="box";for(let g=0;g<4;g++)m.appendChild(document.createElement("div"));d.appendChild(m)}return d}async function h(){const d=document.getElementById("arview");if(!d)return;const p=new wle(d,"crop",!r,a[s].file,l?void 0:a[s].outfit),m=document.getElementById("camera-switch");m&&(m.onclick=async()=>{m.disabled=!0,r=!r,await t.setup({size:{width:window.innerWidth-x,height:window.innerHeight-e},rear:r}),await t.start(),p.setMirror(!r),m.disabled=!1});const g=document.getElementById("outfit-switch");g.checked=l,g.onchange=async()=>{E.forEach(M=>{M.disabled=!0}),g.disabled=!0;const A=c();document.body.appendChild(A),l=g.checked,await p.setOutfit(a[s].file,l?void 0:a[s].outfit),document.body.removeChild(A),E.forEach(M=>{M.disabled=!1}),g.disabled=!1};const v=navigator.userAgent.indexOf("Safari")>-1&&navigator.userAgent.indexOf("Chrome")<=-1?"mp4":"webm",b=new Lte(p,"video/"+v),T=document.getElementById("record");T&&(T.onclick=()=>{b==null||b.start(),setTimeout(async()=>{const A=await(b==null?void 0:b.stop());if(!A)return;const M=URL.createObjectURL(A),R=document.createElement("a");R.hidden=!0,R.href=M,R.download="capture."+v,R.click(),R.remove(),URL.revokeObjectURL(M)},1e4)});const E=document.getElementsByName("model");E.forEach(A=>{A.onchange=async()=>{if(A.checked&&a[A.value]){E.forEach(R=>{R.disabled=!0}),g.disabled=!0;const M=c();document.body.appendChild(M),s=A.value,l=a[s].avatar,await p.setOutfit(a[s].file,l?void 0:a[s].outfit),g.checked=l,document.body.removeChild(M),E.forEach(R=>{R.disabled=!1}),g.disabled=!1}}}),await Promise.all([t.addRenderer(p),t.init({token:n})]),await t.setup({size:{width:window.innerWidth-x,height:window.innerHeight-e},rear:r}),await t.start()}h()},[]),hx.createElement("div",{id:"arview"})}const Ele="_entryPage_13czy_1",Mle="_content_13czy_6",Rle="_headline_13czy_13",Cle="_tagline_13czy_21",Nle="_leftAbs_13czy_24",Ile="_rightAbs_13czy_25",yo={entryPage:Ele,content:Mle,headline:Rle,tagline:Cle,leftAbs:Nle,rightAbs:Ile},Ole=""+new URL("ytLogo-DDxpBXig.png",import.meta.url).href,Dle=""+new URL("start-C3V2VgPH.png",import.meta.url).href,Ple=""+new URL("membership-BzkQ9aWx.png",import.meta.url).href,kle=""+new URL("bag-DJXCQPYb.png",import.meta.url).href;function Ule({setCurrentState:x}){return hx.createElement("div",{className:yo.entryPage},hx.createElement("div",{className:yo.content,style:{maxWidth:Zl(803)}},hx.createElement("div",{className:yo.mainLogo,style:{width:Zl(803)}},hx.createElement("img",{src:Ole,alt:"atsa"})),hx.createElement("div",{className:yo.text},hx.createElement("div",{className:yo.headline,style:{fontSize:Zu(80)}},hx.createElement("span",{style:{fontSize:Zu(50)}},"Step Into Style with"),hx.createElement("br",null),"YouTube AR Try-On!",hx.createElement("div",{className:yo.leftAbs,style:{width:Zl(88.5),height:"auto",top:Zu(-100),left:Zl(-60)}},hx.createElement("img",{src:Ple,alt:"membership"})),hx.createElement("div",{className:yo.rightAbs,style:{width:Zl(161.3),height:"auto",top:Zu(-120),right:Zl(-60)}},hx.createElement("img",{src:kle,alt:"bag"}))),hx.createElement("div",{className:yo.tagline,style:{fontSize:Zu(47),marginTop:Zu(50)}},"Experience fashion like never before with a virtual try-on.")),hx.createElement("div",{className:yo.action,style:{width:Zl(590),height:"auto"}},hx.createElement("img",{src:Dle,alt:"start",onClick:()=>x(1)}))))}const Fle="_appWrapper_yjspg_1",Ble={appWrapper:Fle};function Zl(x,e=1080){return x/e*100+"vw"}function Zu(x,e=1920){return x/e*100+"vh"}function $P(x,e){const t=window.innerHeight,n=window.innerWidth;if(e==="vh")return x/100*t;if(e==="vw")return x/100*n;console.warn("Invalid unit. Use 'vh' or 'vw'.")}const Lle=()=>{const x=M=>{console.log("Selected outfit:",M)},[e,t]=Jn.useState(0);Jn.useRef(null),Jn.useRef(null),Jn.useRef(null),Jn.useRef(!1);const n=$P(10,"vw"),i=$P(5,"vh"),[r,a]=Jn.useState(""),[s,l]=Jn.useState("top"),[c,h]=Jn.useState(null),[d,p]=Jn.useState("7b5be302-d60c-4381-9328-b3d0c317f278"),[m,g]=Jn.useState(!1),[_,v]=Jn.useState(!1),[b,T]=Jn.useState(null),[E,A]=Jn.useState(!1);return Jn.useEffect(()=>{localStorage.removeItem("genderSelect")},[]),hx.createElement("div",{className:Ble.appWrapper,style:{textAlign:"center",flexDirection:"column",display:"flex",alignItems:"center",justifyContent:"center"}},e===0?hx.createElement(Ule,{setCurrentState:t}):null,e===1?hx.createElement(hx.Fragment,null,hx.createElement(Ale,{wMargin:n,hMargin:i}),hx.createElement(D5,{onOutfitChange:x})):null)},zle=document.getElementById("root"),Vle=O5.createRoot(zle);Vle.render(hx.createElement(Lle,null));
